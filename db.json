{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/avatar.jpg","path":"assets/blogImg/avatar.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/images.jpg","path":"assets/blogImg/images.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/onepiece.png","path":"assets/blogImg/onepiece.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/is_ref2.jpg","path":"assets/blogImg/is_ref2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/reactor.png","path":"assets/blogImg/reactor.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/zend_manage.jpg","path":"assets/blogImg/zend_manage.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/女神.jpg","path":"assets/blogImg/女神.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/女神2.jpg","path":"assets/blogImg/女神2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/终端截图.png","path":"assets/blogImg/终端截图.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/process.pipe.png","path":"assets/blogImg/process.pipe.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/选择主题.png","path":"assets/blogImg/选择主题.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/process.png","path":"assets/blogImg/process.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/thread.corrupt.png","path":"assets/blogImg/thread.corrupt.png","modified":1,"renderable":0},{"_id":"themes/anatole/source/css/blog_basic.css","path":"css/blog_basic.css","modified":1,"renderable":1},{"_id":"themes/anatole/source/css/style.css","path":"css/style.css","modified":1,"renderable":1},{"_id":"themes/anatole/source/css/style.scss","path":"css/style.scss","modified":1,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","path":"fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","path":"fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"source/assets/blogImg/1350027313170.jpg","path":"assets/blogImg/1350027313170.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/p478446624 (1).jpg","path":"assets/blogImg/p478446624 (1).jpg","modified":1,"renderable":0},{"_id":"themes/anatole/source/css/font-awesome.min.css","path":"css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","path":"js/jquery-migrate-1.2.1.min.js","modified":1,"renderable":1},{"_id":"themes/anatole/source/js/jquery.appear.js","path":"js/jquery.appear.js","modified":1,"renderable":1},{"_id":"themes/anatole/source/images/favicon.png","path":"images/favicon.png","modified":1,"renderable":1},{"_id":"themes/anatole/source/images/logo@2x.png","path":"images/logo@2x.png","modified":1,"renderable":1},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","path":"fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"source/assets/blogImg/php.png","path":"assets/blogImg/php.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/Packagist.gif","path":"assets/blogImg/Packagist.gif","modified":1,"renderable":0},{"_id":"source/assets/blogImg/manyporcess.png","path":"assets/blogImg/manyporcess.png","modified":1,"renderable":0},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","path":"fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/assets/blogImg/Graychen-Container.gif","path":"assets/blogImg/Graychen-Container.gif","modified":1,"renderable":0},{"_id":"source/assets/blogImg/631283.jpg","path":"assets/blogImg/631283.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/多窗终端.png","path":"assets/blogImg/多窗终端.png","modified":1,"renderable":0},{"_id":"themes/anatole/source/js/jquery.js","path":"js/jquery.js","modified":1,"renderable":1},{"_id":"source/assets/blogImg/桌面带终端效果图.png","path":"assets/blogImg/桌面带终端效果图.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/anatole/README.md","hash":"88d58e69eda2435ce074bc6cafb1817346089a88","modified":1553668112696},{"_id":"themes/anatole/.gitignore","hash":"9fcbb05b158b5d3ba1ee60d38889e05e8b0f3f2a","modified":1553668112696},{"_id":"themes/anatole/LICENSE","hash":"359cb81298c1fdbccf531548fc097466b0151be4","modified":1553668112696},{"_id":"themes/anatole/_config.sample.yml","hash":"c6bce49d93a37e9ed5f0c4b104decc0bd7832e04","modified":1553668112697},{"_id":"themes/anatole/package.json","hash":"cf731a3ebf3913747fccb6c4c6615eba7d7e88a4","modified":1553668112699},{"_id":"source/_posts/Kubernetes本地实验环境.md","hash":"0d8a5981f683cee90b868875ec6c151d14e452b5","modified":1566451508802},{"_id":"source/_posts/Webpack595错误.md","hash":"bb04a359e7fcf380a45a73723aac914c4dd97ac5","modified":1527415176038},{"_id":"source/_posts/docker中使用supervisor.md","hash":"6c4a858c6006c3624e852b81951b2d92763a18a6","modified":1527415176036},{"_id":"source/_posts/Hprose使用说明.md","hash":"f850c327dd59c33de392749cb929c29fb7745e65","modified":1553693138794},{"_id":"source/_posts/github自动化测试.md","hash":"b4bd459a29c53e5b56a2dd1b8fd71691808e902d","modified":1527415176033},{"_id":"source/_posts/composer包是怎样炼成的.md","hash":"a5c219635e316a9c8a77284ab2301b9116c97afc","modified":1527415176030},{"_id":"source/_posts/github自动化测试.md~","hash":"5dd3009d63f9197e4a87f6a20ecb619d7d123756","modified":1527415176027},{"_id":"source/_posts/elastic语句记录.md","hash":"413b23174097f1c094001c240c4044ed455ea4d7","modified":1576049213049},{"_id":"source/_posts/gitlab-ci由浅入深.md","hash":"e263e6814c0a7031914a95924a5686c845d01842","modified":1527415176026},{"_id":"source/_posts/git使用规范.md","hash":"313f465389fef4159718d82a8679de19c0f0ddc7","modified":1527415176029},{"_id":"source/_posts/helm在k8s上的部署.md","hash":"438d4f34fa46282ad43dd3a5758ca49c977ad777","modified":1576897313533},{"_id":"source/_posts/lnmp源码搭建.md","hash":"35ca9a8664378911a52eb35a18d71383a0dc22dd","modified":1527415176026},{"_id":"source/_posts/mac终端走shadowsocks代理.md","hash":"d45714da390e76ad501d138d49f4339270a67839","modified":1566451922065},{"_id":"source/_posts/mac下配置vscode的xdebug.md","hash":"5b63119ba328fafc53082e01527803b9ca60af90","modified":1566451569383},{"_id":"source/_posts/mysql优化总结.md","hash":"4103af80dcfd7c05fc2fa6a3df4fb369dd3a4b0f","modified":1563884388282},{"_id":"source/_posts/nginx配置优化.md","hash":"df9b44962951127232e3f5d25d467b569ab17aca","modified":1527415176032},{"_id":"source/_posts/php利用puppeteer来抓取西瓜视频.md","hash":"05ee147cc464cd8ea993617be95b3c7936ec7576","modified":1566815956097},{"_id":"source/_posts/php如何正确的统计中文.md","hash":"a286a92bb84da7473891a91060188b5354041b0e","modified":1576049777564},{"_id":"source/_posts/ubuntu下lnmp快速搭建.md","hash":"9cbef1b6c4a35c137ebdd44bb853b262be2f2f40","modified":1527415176035},{"_id":"source/_posts/vichrome像vi一样操作你的chrome浏览器.md","hash":"dafc407767b17d9389ffd8a35c0bcdd7d7ca3214","modified":1527415176029},{"_id":"source/_posts/vi的使用总结.md","hash":"5d15a3c9c535469c9b6d7844a3a52914ada6eb24","modified":1527415176037},{"_id":"source/_posts/websocket结合swoole进行wss访问.md~","hash":"b7f9991df7f5ae02732e6cac8f437b7e389aa917","modified":1527415176031},{"_id":"source/_posts/websocket结合swoole进行wss访问.md","hash":"a628e59a948dc72e3fd8943a59ce1b34f890cf0e","modified":1527415176033},{"_id":"source/_posts/yii2-queue队列的使用说明.md","hash":"2eb2f3df8b6d5e17b575b0097be2becdedb17490","modified":1527415176037},{"_id":"source/_posts/使用Prometheus-Grafana监控.md","hash":"41663d61bd039d625a0f44f57103091651b450ae","modified":1527415176034},{"_id":"source/_posts/使用Prometheus-Grafana监控.md~","hash":"ea9319ac5e034f40d7b1ebe0ddb80a84cfcd7457","modified":1527415176038},{"_id":"source/_posts/关于软件工程师的思考.md","hash":"929876cb0e86c508fafac85455639b65d3a279a2","modified":1571208342393},{"_id":"source/_posts/利用gitlab进行持续部署.md","hash":"d5ba74422934edeb040c18a00eda5579c74efb6a","modified":1527415176027},{"_id":"source/_posts/压力测试，压力山大.md","hash":"063b2d68945137c37f475490b027b2bef80c5993","modified":1527415176030},{"_id":"source/_posts/变身吧！我的linux配置环境.md","hash":"95bf3a0048d0624c2ac28dd94179e9cca7b6e80f","modified":1527415176033},{"_id":"source/_posts/国内环境kubernetes安装.md","hash":"e30eba46add51364849dc20703ef3543156de01c","modified":1576892627457},{"_id":"source/_posts/在k8s上部署dashboard后台管理界面.md","hash":"92f245778a7090f9d5ddc7f95e34607a4115fafd","modified":1576893171800},{"_id":"source/_posts/在minikube部署个node服务.md","hash":"458849b6ceeee58833ce8be318c0efa3748d1a2f","modified":1566472228688},{"_id":"source/_posts/如何编写测试.md","hash":"942f52e2cb16e1744eced69d65df3a129e796282","modified":1527415176037},{"_id":"source/_posts/在程序开发中-i与i-的区别在哪里.md","hash":"6984cfac1b9dc33940e691e7339a0d4c0aca1d91","modified":1573649943291},{"_id":"source/_posts/如何编写测试.md~","hash":"8a4f42980196fcf3face3acc70a744d606060d0c","modified":1527415176035},{"_id":"source/_posts/探索php中的变量zval结构体.md","hash":"7cb2d15eb60e648beb03a9acad38fc64e3bdf344","modified":1527415176028},{"_id":"source/_posts/解析jwt.md","hash":"cd4a99ab511d5ab1b9f9cd0f1e5ca147cf2bd497","modified":1566392987393},{"_id":"source/_posts/探索php中的变量zval结构体二.md","hash":"97298831fcdfa29137804f2e10d25b44e42d2e7f","modified":1527415176027},{"_id":"source/_posts/深入解析php的容器模式.md","hash":"8489ea19652ec00c9c60f1d88ba695257eda18e9","modified":1527415176027},{"_id":"source/_posts/解析php的内存管理.md","hash":"3b9196f6ad1dc8519e2227c1144b0826a4393342","modified":1527415176032},{"_id":"source/_posts/秒杀防止库存超卖的思路.md","hash":"a3696db849ec5ecfe266b42a814e643287734d91","modified":1564042151055},{"_id":"source/_posts/计划虽然不酷，但是很有用.md","hash":"22d6321f9b7158bc2c9144276590ac888f601d6f","modified":1527415176035},{"_id":"source/_posts/记一次mysql容器的异常退出.md","hash":"ec64fd5b3532ccd47d3ab43fdbd2967b6c1f86f5","modified":1576567166398},{"_id":"source/_posts/记一次阿里云ssh登录不上的bug.md","hash":"37b3584fccc0796988a8bec794368ac0ce2ff7d9","modified":1576047978818},{"_id":"source/_posts/谈谈mysql的四种事务隔离级别.md","hash":"efa3556a9c71093fee87db110228e4988dc7ac7c","modified":1571501221859},{"_id":"source/_posts/集中式日志管理elk搭建.md","hash":"9ff012646d43008f879078ca1881083ae6eeb83e","modified":1527415176034},{"_id":"source/_posts/php的并发io.md","hash":"4c378d1632c9ef700a78bc16c787beb04ba79280","modified":1527415176031},{"_id":"source/_posts/记录一次阿里云上docker启动不了的bug.md","hash":"3d9ec740971ac9999676e26e46873731d76db1a5","modified":1570599255872},{"_id":"source/_posts/谈谈进程和线程.md","hash":"3bfb88c54e5bc536a12db6919e3a73428a21648c","modified":1527415176036},{"_id":"source/_posts/集群的nginx配置.md","hash":"7423c715f21d18a8f3ae8390985a23441970d9c9","modified":1527415176028},{"_id":"source/images/avatar.jpg","hash":"f88f6b513f90be947234de853271119eda312d64","modified":1527415176025},{"_id":"themes/anatole/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1553668112687},{"_id":"themes/anatole/.git/config","hash":"831e9fdc6bb9fa56130a1292e248c5ad420f7229","modified":1553668112689},{"_id":"themes/anatole/.git/ORIG_HEAD","hash":"925503d46c26d7a61b09317360241cba55ee3974","modified":1553671116011},{"_id":"themes/anatole/.git/FETCH_HEAD","hash":"e32717fa598a9530b98256ff6c87fbedbea35f6a","modified":1553671115992},{"_id":"themes/anatole/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1553667905235},{"_id":"themes/anatole/.git/index","hash":"38ca3165fc943891631b6ae6f3fd89edfb8fa7b4","modified":1576567335577},{"_id":"themes/anatole/languages/pt-BR.yml","hash":"ac5a0003d7793aade51f70643b2e2a631b6a65c3","modified":1553668112697},{"_id":"themes/anatole/languages/zh-cn.yml","hash":"dab1823e036f4adb3b7ae9efe95a37a15e47bec2","modified":1553668112697},{"_id":"themes/anatole/.git/packed-refs","hash":"1b6b58240cb6ba507347e8f64e18aca873ba8cdd","modified":1553668112685},{"_id":"themes/anatole/layout/archive.pug","hash":"1a161404966000b25a84762f08da3ca60af146bc","modified":1553668112697},{"_id":"themes/anatole/layout/category.pug","hash":"ae894ef4baee4a0c7c8e66641166061e789f1fa7","modified":1553668112697},{"_id":"themes/anatole/layout/index.pug","hash":"53da3cfd498951148acb33de1574df80ae282dc5","modified":1553668112698},{"_id":"themes/anatole/layout/page.pug","hash":"15142c94e5c2247aba8efb64cffd695b3f133670","modified":1553668112698},{"_id":"themes/anatole/layout/mixins.pug","hash":"107bfd2fe10de0d8b110c13bb1168af79e62a37c","modified":1553668112698},{"_id":"themes/anatole/layout/post.pug","hash":"012f8e272cf4713a0f08e3b702dab08ef6593b31","modified":1553668112699},{"_id":"themes/anatole/layout/tag.pug","hash":"7017a8bae4f4a412dafb556772bdcf2cfddeb79f","modified":1553668112699},{"_id":"source/assets/blogImg/.桌面效果图.png.icloud","hash":"2210e2db15d3b8ad19d0dd03b3b42093a129cf7a","modified":1527415176000},{"_id":"source/assets/blogImg/avatar.jpg","hash":"b899370064d7289319e837799a3df29e60d8b72c","modified":1527415176045},{"_id":"source/assets/blogImg/images.jpg","hash":"5ce42d8035ef434ab24089309e1a3233b639fb39","modified":1527415176055},{"_id":"source/assets/blogImg/onepiece.png","hash":"ee8123247a0342cbe097dbad2eef320392bc97ca","modified":1527415176045},{"_id":"source/assets/blogImg/is_ref2.jpg","hash":"4a63cde5a0d53f662b8975ac0802987c7c7747dc","modified":1527415176043},{"_id":"source/assets/blogImg/reactor.png","hash":"04d20800c2ec2bc2c3966a3d3fa9abeef9583655","modified":1527415176039},{"_id":"source/assets/blogImg/zend_manage.jpg","hash":"3922f45adbe6aa941cdd6f9549714aeadcbba7ba","modified":1527415176054},{"_id":"source/assets/blogImg/女神.jpg","hash":"bdcdc004db6bbf439d3695c67c0b27ac6eac705c","modified":1527415176042},{"_id":"source/assets/blogImg/女神2.jpg","hash":"b3c333fca3dec309251423fa2a02180555791271","modified":1527415176043},{"_id":"source/assets/blogImg/终端截图.png","hash":"2dd559ffae900981a00a560119a1e9bb2c14dca8","modified":1527415176041},{"_id":"source/assets/blogImg/process.pipe.png","hash":"7705f38c0a5a22839de67b191f2f8f50397ba6d1","modified":1527415176042},{"_id":"source/assets/blogImg/选择主题.png","hash":"b5d7347639b85bcb7e3063aca3289f49e8e2eaa6","modified":1527415176049},{"_id":"source/assets/blogImg/process.png","hash":"c83f60f8e9d0419c8fcb651c71916eec8b8d097a","modified":1527415176056},{"_id":"source/assets/blogImg/thread.corrupt.png","hash":"98962544fee729ddfe671d051fb619ac26822d14","modified":1527415176040},{"_id":"themes/anatole/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1553667905237},{"_id":"themes/anatole/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1553667905238},{"_id":"themes/anatole/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1553667905240},{"_id":"themes/anatole/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1553667905240},{"_id":"themes/anatole/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1553667905240},{"_id":"themes/anatole/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1553667905236},{"_id":"themes/anatole/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1553667905234},{"_id":"themes/anatole/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1553667905239},{"_id":"themes/anatole/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1553667905239},{"_id":"themes/anatole/.git/logs/HEAD","hash":"1fe1148fe095cea5ec6c172a1e926116f2825053","modified":1553668112688},{"_id":"themes/anatole/source/css/blog_basic.css","hash":"7db88f0873e858b21a4c981c8481708ad9117478","modified":1553668112700},{"_id":"themes/anatole/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1553667905236},{"_id":"themes/anatole/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1553667905237},{"_id":"themes/anatole/source/css/style.css","hash":"871a5c940cbc0ce5488a670f2285f2c3015cf71c","modified":1553668112701},{"_id":"themes/anatole/source/css/style.scss","hash":"175c9237798207f705c62777b5f51509adec6d0a","modified":1553668112701},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.eot","hash":"0183979056f0b87616cd99d5c54a48f3b771eee6","modified":1553668112703},{"_id":"themes/anatole/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1553667905241},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.woff","hash":"7d65e0227d0d7cdc1718119cd2a7dce0638f151c","modified":1553668112708},{"_id":"themes/anatole/source/css/font-awesome.min.css","hash":"95d0b0c4d11105c81be1857b744076a1d2bed918","modified":1553668112701},{"_id":"themes/anatole/source/js/jquery-migrate-1.2.1.min.js","hash":"743052320809514fb788fe1d3df37fc87ce90452","modified":1553668112709},{"_id":"themes/anatole/source/js/jquery.appear.js","hash":"1f8067d7bd4c0bde30785e8016100f239e14394f","modified":1553668112709},{"_id":"source/assets/blogImg/1350027313170.jpg","hash":"837368703355d0cb5561c2cc25b0f8da0780a782","modified":1527415176043},{"_id":"source/assets/blogImg/p478446624 (1).jpg","hash":"806f0fa94f9f3ddf0ef8ac0bf103e0ce8f6a2711","modified":1527415176044},{"_id":"themes/anatole/source/images/favicon.png","hash":"d659236704308954da9d64b101c4f54cc3f3255c","modified":1553668112708},{"_id":"themes/anatole/layout/partial/comments.pug","hash":"fad5bbe7c2a134c892fcb1c731d979463145a49b","modified":1553668112698},{"_id":"themes/anatole/layout/partial/footer.pug","hash":"772f03a2dd9fa4fed422c4eb4d5d1ace84c65580","modified":1553668112698},{"_id":"themes/anatole/layout/partial/head.pug","hash":"3d6126d0b53a889a46ad61eb8cc0ab1b35446c49","modified":1553668112698},{"_id":"themes/anatole/layout/partial/layout.pug","hash":"174050fa9ee919f5bcb2c5426224ec1968db672c","modified":1553668112698},{"_id":"themes/anatole/layout/partial/sidebar.pug","hash":"6721b1e0b1e59e54d031a4978e7f82aece336efc","modified":1553668112699},{"_id":"themes/anatole/layout/partial/nav.pug","hash":"69ea79bdae20a41a948ac1f95a76341d951ed302","modified":1553670303964},{"_id":"themes/anatole/source/images/logo@2x.png","hash":"49c3fa97724abf53861bf11356ea9ba5bcb11576","modified":1553668112709},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.ttf","hash":"6225ccc4ec94d060f19efab97ca42d842845b949","modified":1553668112707},{"_id":"source/assets/blogImg/php.png","hash":"a0d9d3836acd748a53ad3d718a104dc2b9cfb349","modified":1527415176051},{"_id":"themes/anatole/.git/refs/heads/master","hash":"925503d46c26d7a61b09317360241cba55ee3974","modified":1553668112688},{"_id":"themes/anatole/.git/objects/pack/pack-a1978a0c4fdc701078c675218192a7e6c7a709a9.idx","hash":"83fc4a0423ba57a9085d17b2fba48aa398682d8d","modified":1553668112672},{"_id":"source/assets/blogImg/Packagist.gif","hash":"b0744949057774ef4364b195a11b2958003070d7","modified":1527415176054},{"_id":"themes/anatole/.git/logs/refs/heads/master","hash":"1fe1148fe095cea5ec6c172a1e926116f2825053","modified":1553668112688},{"_id":"themes/anatole/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1553668112687},{"_id":"themes/anatole/source/fonts/fontawesome-webfont.svg","hash":"cd980eab6db5fa57db670cb2e4278e67e1a4d6c9","modified":1553668112705},{"_id":"source/assets/blogImg/manyporcess.png","hash":"2cb5c1cc4be9ec117a59c7bd23c956a416b2bb9d","modified":1527415176050},{"_id":"themes/anatole/source/js/jquery.js","hash":"bfc05b695dfa4f23e11d04b84993585da7a764bf","modified":1553668112711},{"_id":"source/assets/blogImg/Graychen-Container.gif","hash":"38bd85eaaa94bafc1857313a5df2c0bb17683b3b","modified":1527415176048},{"_id":"source/assets/blogImg/631283.jpg","hash":"d3439ed0c38b481b6f0caeab3c672c6e1662a66c","modified":1527415176049},{"_id":"source/assets/blogImg/多窗终端.png","hash":"f9b4e6565694fe37667fb36297a6e72b51661236","modified":1527415176040},{"_id":"themes/anatole/.git/logs/refs/remotes/origin/HEAD","hash":"1fe1148fe095cea5ec6c172a1e926116f2825053","modified":1553668112687},{"_id":"source/assets/blogImg/桌面带终端效果图.png","hash":"12e66fac2eb3b201e740f7329996ef51733dd648","modified":1527415176047},{"_id":"themes/anatole/.git/objects/pack/pack-a1978a0c4fdc701078c675218192a7e6c7a709a9.pack","hash":"cc823f2dc8d86c0e30577338c3cc3ea9d580f312","modified":1553668112671}],"Category":[{"name":"错误日志","_id":"ck4f00sjk0013th8lyf31kbhc"},{"name":"技术","_id":"ck4f00sjo0018th8lnj7pfliw"},{"name":"随笔","_id":"ck4f00sk50023th8lh4xlreth"}],"Data":[],"Page":[],"Post":[{"layout":"minikube","title":"Kubernetes本地实验环境","date":"2019-08-22T05:12:59.000Z","_content":"最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，\n所以使用这个minikube来安装.\n我是mac电脑，首先\n``` bash\nbrew install kubernetes-cli\n```\n然后确认是否安装成功\n```\nkubectl version\n```\n接着安装[VitualBox](https://www.virtualbox.org/wiki/Downloads)\n然后安装改版的minikube\n``` bash\ncurl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/\n```\n接着启动\n``` bash\nminikube start --registry-mirror=https://registry.docker-cn.com\n```\n打开Kubernetes控制台\n``` bash\nminikube dashboard\n```\n## 参考资料\n\n+ [Minikube - Kubernetes本地实验环境](https://yq.aliyun.com/articles/221687)\n","source":"_posts/Kubernetes本地实验环境.md","raw":"---\nlayout: minikube\ntitle: Kubernetes本地实验环境\ndate: 2019-08-22 13:12:59\ntags: DevOps\n---\n最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，\n所以使用这个minikube来安装.\n我是mac电脑，首先\n``` bash\nbrew install kubernetes-cli\n```\n然后确认是否安装成功\n```\nkubectl version\n```\n接着安装[VitualBox](https://www.virtualbox.org/wiki/Downloads)\n然后安装改版的minikube\n``` bash\ncurl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 && chmod +x minikube && sudo mv minikube /usr/local/bin/\n```\n接着启动\n``` bash\nminikube start --registry-mirror=https://registry.docker-cn.com\n```\n打开Kubernetes控制台\n``` bash\nminikube dashboard\n```\n## 参考资料\n\n+ [Minikube - Kubernetes本地实验环境](https://yq.aliyun.com/articles/221687)\n","slug":"Kubernetes本地实验环境","published":1,"updated":"2019-08-22T05:25:08.802Z","comments":1,"photos":[],"link":"","_id":"ck4f00shp0000th8lizsk7kpg","content":"<p>最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，<br>所以使用这个minikube来安装.<br>我是mac电脑，首先<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install kubernetes-cli</span><br></pre></td></tr></table></figure></p>\n<p>然后确认是否安装成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl version</span><br></pre></td></tr></table></figure></p>\n<p>接着安装<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">VitualBox</a><br>然后安装改版的minikube<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class=\"built_in\">local</span>/bin/</span><br></pre></td></tr></table></figure></p>\n<p>接着启动<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube start --registry-mirror=https://registry.docker-cn.com</span><br></pre></td></tr></table></figure></p>\n<p>打开Kubernetes控制台<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube dashboard</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://yq.aliyun.com/articles/221687\" target=\"_blank\" rel=\"noopener\">Minikube - Kubernetes本地实验环境</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，<br>所以使用这个minikube来安装.<br>我是mac电脑，首先<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew install kubernetes-cli</span><br></pre></td></tr></table></figure></p>\n<p>然后确认是否安装成功<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl version</span><br></pre></td></tr></table></figure></p>\n<p>接着安装<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">VitualBox</a><br>然后安装改版的minikube<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class=\"built_in\">local</span>/bin/</span><br></pre></td></tr></table></figure></p>\n<p>接着启动<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube start --registry-mirror=https://registry.docker-cn.com</span><br></pre></td></tr></table></figure></p>\n<p>打开Kubernetes控制台<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube dashboard</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://yq.aliyun.com/articles/221687\" target=\"_blank\" rel=\"noopener\">Minikube - Kubernetes本地实验环境</a></li>\n</ul>\n"},{"title":"Webpack595错误","date":"2017-05-13T15:39:40.000Z","_content":"## 错误情况\nMix incompatible with Webpack 2.3.0? #595\n## 错误原因\n这是laravel5.4的错误webpack依赖包兼容问题\n## 解决方法\n在package,json 修改\"aravel-mix\": \"^0.10.0\" 修复这个错误\n<!--more-->\n\n","source":"_posts/Webpack595错误.md","raw":"---\ntitle: Webpack595错误\ndate: 2017-05-13 23:39:40\ncategory: 错误日志\ntag: 错误日志\n\n---\n## 错误情况\nMix incompatible with Webpack 2.3.0? #595\n## 错误原因\n这是laravel5.4的错误webpack依赖包兼容问题\n## 解决方法\n在package,json 修改\"aravel-mix\": \"^0.10.0\" 修复这个错误\n<!--more-->\n\n","slug":"Webpack595错误","published":1,"updated":"2018-05-27T09:59:36.038Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si20001th8lhmxu8dnr","content":"<h2 id=\"错误情况\"><a href=\"#错误情况\" class=\"headerlink\" title=\"错误情况\"></a>错误情况</h2><p>Mix incompatible with Webpack 2.3.0? #595</p>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h2><p>这是laravel5.4的错误webpack依赖包兼容问题</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在package,json 修改”aravel-mix”: “^0.10.0” 修复这个错误<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"错误情况\"><a href=\"#错误情况\" class=\"headerlink\" title=\"错误情况\"></a>错误情况</h2><p>Mix incompatible with Webpack 2.3.0? #595</p>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h2><p>这是laravel5.4的错误webpack依赖包兼容问题</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在package,json 修改”aravel-mix”: “^0.10.0” 修复这个错误<br>","more":"</p>"},{"title":"docker中使用supervisor管理队列","date":"2017-07-25T15:04:46.000Z","_content":"\n## 简介\nSupervisor[链接](http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。\n## 安装\nSupervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor\n 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加\n``` bash\nRUN apk add supervisor\n```\n这样容器就可以安装superviosr\n## 配置\n然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件\n<!--more-->\n#\n``` \n[supervisord]\nnodaemon=true\n[program:mqtt-server]\ndirectory = /var/www/html ;\ncommand = php yii queue/listen\nautostart = true\nstartsecs = 5\nautorestart = true\nstartretries = 10\nredirect_stderr=true\nstdout_logfile = /var/www/html/yii-queue-worker.log\n```\n然后在Dockerfile-web-volumes里面添加\n\n<!--more-->\n```\n- ./services/supervisor:/etc/supervisor/conf.d\n```\n\n以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件\n## 运行\n> 本来我的想法是在Dockerfile里面直接添加`ENTRYPOINT ['/usr/bin/supervisord','-c','/etc/supervisor/conf.d']`,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。`注意，如果队列基于其它driver的可以这样直接运行的`\n\n折中的方案是在.gitlab-ci.yml文件中的**testing-server:**-> **script:**和**staging-server:**->**script:**下分别添加\n```\n- ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &>/dev/null&\"\n```\n\n这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了\n然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/docker中使用supervisor.md","raw":"---\ntitle: docker中使用supervisor管理队列\ndate: 2017-07-25 23:04:46\ntag: php\ncategories: 技术\n\n---\n\n## 简介\nSupervisor[链接](http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。\n## 安装\nSupervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor\n 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加\n``` bash\nRUN apk add supervisor\n```\n这样容器就可以安装superviosr\n## 配置\n然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件\n<!--more-->\n#\n``` \n[supervisord]\nnodaemon=true\n[program:mqtt-server]\ndirectory = /var/www/html ;\ncommand = php yii queue/listen\nautostart = true\nstartsecs = 5\nautorestart = true\nstartretries = 10\nredirect_stderr=true\nstdout_logfile = /var/www/html/yii-queue-worker.log\n```\n然后在Dockerfile-web-volumes里面添加\n\n<!--more-->\n```\n- ./services/supervisor:/etc/supervisor/conf.d\n```\n\n以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件\n## 运行\n> 本来我的想法是在Dockerfile里面直接添加`ENTRYPOINT ['/usr/bin/supervisord','-c','/etc/supervisor/conf.d']`,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。`注意，如果队列基于其它driver的可以这样直接运行的`\n\n折中的方案是在.gitlab-ci.yml文件中的**testing-server:**-> **script:**和**staging-server:**->**script:**下分别添加\n```\n- ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &>/dev/null&\"\n```\n\n这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了\n然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"docker中使用supervisor","published":1,"updated":"2018-05-27T09:59:36.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si30002th8l9pikmgqn","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Supervisor<a href=\"http://supervisord.org\" target=\"_blank\" rel=\"noopener\">链接</a> 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor<br> 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN apk add supervisor</span><br></pre></td></tr></table></figure></p>\n<p>这样容器就可以安装superviosr</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件<br><a id=\"more\"></a><br>#<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[supervisord]</span><br><span class=\"line\">nodaemon=true</span><br><span class=\"line\">[program:mqtt-server]</span><br><span class=\"line\">directory = /var/www/html ;</span><br><span class=\"line\">command = php yii queue/listen</span><br><span class=\"line\">autostart = true</span><br><span class=\"line\">startsecs = 5</span><br><span class=\"line\">autorestart = true</span><br><span class=\"line\">startretries = 10</span><br><span class=\"line\">redirect_stderr=true</span><br><span class=\"line\">stdout_logfile = /var/www/html/yii-queue-worker.log</span><br></pre></td></tr></table></figure></p>\n<p>然后在Dockerfile-web-volumes里面添加</p>\n<!--more-->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- ./services/supervisor:/etc/supervisor/conf.d</span><br></pre></td></tr></table></figure>\n<p>以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><blockquote>\n<p>本来我的想法是在Dockerfile里面直接添加<code>ENTRYPOINT [&#39;/usr/bin/supervisord&#39;,&#39;-c&#39;,&#39;/etc/supervisor/conf.d&#39;]</code>,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。<code>注意，如果队列基于其它driver的可以这样直接运行的</code></p>\n</blockquote>\n<p>折中的方案是在.gitlab-ci.yml文件中的<strong>testing-server:</strong>-&gt; <strong>script:</strong>和<strong>staging-server:</strong>-&gt;<strong>script:</strong>下分别添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &amp;&gt;/dev/null&amp;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了<br>然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Supervisor<a href=\"http://supervisord.org\" target=\"_blank\" rel=\"noopener\">链接</a> 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor<br> 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">RUN apk add supervisor</span><br></pre></td></tr></table></figure></p>\n<p>这样容器就可以安装superviosr</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件<br>","more":"<br>#<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[supervisord]</span><br><span class=\"line\">nodaemon=true</span><br><span class=\"line\">[program:mqtt-server]</span><br><span class=\"line\">directory = /var/www/html ;</span><br><span class=\"line\">command = php yii queue/listen</span><br><span class=\"line\">autostart = true</span><br><span class=\"line\">startsecs = 5</span><br><span class=\"line\">autorestart = true</span><br><span class=\"line\">startretries = 10</span><br><span class=\"line\">redirect_stderr=true</span><br><span class=\"line\">stdout_logfile = /var/www/html/yii-queue-worker.log</span><br></pre></td></tr></table></figure></p>\n<p>然后在Dockerfile-web-volumes里面添加</p>\n<!--more-->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- ./services/supervisor:/etc/supervisor/conf.d</span><br></pre></td></tr></table></figure>\n<p>以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><blockquote>\n<p>本来我的想法是在Dockerfile里面直接添加<code>ENTRYPOINT [&#39;/usr/bin/supervisord&#39;,&#39;-c&#39;,&#39;/etc/supervisor/conf.d&#39;]</code>,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。<code>注意，如果队列基于其它driver的可以这样直接运行的</code></p>\n</blockquote>\n<p>折中的方案是在.gitlab-ci.yml文件中的<strong>testing-server:</strong>-&gt; <strong>script:</strong>和<strong>staging-server:</strong>-&gt;<strong>script:</strong>下分别添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">- ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &amp;&gt;/dev/null&amp;&quot;</span><br></pre></td></tr></table></figure></p>\n<p>这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了<br>然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面</p>"},{"layout":"rpc","title":"Hprose使用说明","date":"2018-05-20T04:37:25.000Z","_content":"# 简介\n\nHprose(High Performance Remote Object Service Engine)\n是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。 你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。\n\n# 使用手册\n\n# 案例(php)\n## 安装\n- 使用`composer require hprose/hprose`\n如果你正在使用 composer 管理你的项目，那么你不需要做任何特别处理。只要在 composer.json 中的 require 段添加了对 hprose/hprose 的引用就可以了。如果你需要 swoole 支持，添加 hprose/hprose-swoole 就可以了。\n然后在代码中这样引用\n\n<!--more-->\n\n### 服务端\n```\n<?php\nuse Hprose\\Swoole\\Http\\Server;\n\n//定义Hello服务\nfunction hello($name) {\n    return \"Hello $name!\";\n}\n\n//发布服务器\n$server = new Server();\n\n//注册hello方法\n$server->addFunction('hello');\n\n$server->start();\n```\n### 客户端\n``` php \nuse Hprose\\Client;\n\n$client=Client::create('http://localhost/',false);\necho $client->hello(\"World\");\n```\n# 案例(go)\n## 安装\n```\ngo get github.com/gorilla/websocket\ngo get github.com/valyala/fasthttp\ngo get github.com/hprose/hprose-golang\n```\n## 使用\n### 服务端\n```\npackage main\n\nimport(\n    \"net/http\"\n    \"github.com/hprose/hprose-golang/rpc\"\n      )\n\nfunc hello(name string) string {\n    return \"Hello\" + name + \"!\"\n}\n\nfunc main() {\n    service := rpc.NewHTTPService()\n    service.AddFunction(\"hello\", hello, rpc.Options{})\n    http.ListenAndServer(\":8080\",service)\n}\n```\n\n\n### 客户端\n``` go \npackage main\n\nimport (\n        \"fmt\"\n        \"github.com/hprose/hprose-golang/rpc\"\n       )\n\ntype Stub struct {\n    Hello func(string) (string, error)\n    AsyncHello func(func(string, error),string) `name:\"hello\"`\n}\n\nfunc main() {\n    client := rpc.NewClient(\"http://127.0.0.1:8080/\")\n    var stub *Stub\n    client.UseService(&stub)\n    stub.AsyncHello(func(result string,err error) {\n            fmt.Println(result, error)\n            },\"async world\")\n            fmt.Println(stub.Hello(\"world\"))\n}\n```\n\n\n\n","source":"_posts/Hprose使用说明.md","raw":"---\nlayout: rpc\ntitle: Hprose使用说明\ndate: 2018-05-20 12:37:25\ntags: 技术\n---\n# 简介\n\nHprose(High Performance Remote Object Service Engine)\n是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。 你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。\n\n# 使用手册\n\n# 案例(php)\n## 安装\n- 使用`composer require hprose/hprose`\n如果你正在使用 composer 管理你的项目，那么你不需要做任何特别处理。只要在 composer.json 中的 require 段添加了对 hprose/hprose 的引用就可以了。如果你需要 swoole 支持，添加 hprose/hprose-swoole 就可以了。\n然后在代码中这样引用\n\n<!--more-->\n\n### 服务端\n```\n<?php\nuse Hprose\\Swoole\\Http\\Server;\n\n//定义Hello服务\nfunction hello($name) {\n    return \"Hello $name!\";\n}\n\n//发布服务器\n$server = new Server();\n\n//注册hello方法\n$server->addFunction('hello');\n\n$server->start();\n```\n### 客户端\n``` php \nuse Hprose\\Client;\n\n$client=Client::create('http://localhost/',false);\necho $client->hello(\"World\");\n```\n# 案例(go)\n## 安装\n```\ngo get github.com/gorilla/websocket\ngo get github.com/valyala/fasthttp\ngo get github.com/hprose/hprose-golang\n```\n## 使用\n### 服务端\n```\npackage main\n\nimport(\n    \"net/http\"\n    \"github.com/hprose/hprose-golang/rpc\"\n      )\n\nfunc hello(name string) string {\n    return \"Hello\" + name + \"!\"\n}\n\nfunc main() {\n    service := rpc.NewHTTPService()\n    service.AddFunction(\"hello\", hello, rpc.Options{})\n    http.ListenAndServer(\":8080\",service)\n}\n```\n\n\n### 客户端\n``` go \npackage main\n\nimport (\n        \"fmt\"\n        \"github.com/hprose/hprose-golang/rpc\"\n       )\n\ntype Stub struct {\n    Hello func(string) (string, error)\n    AsyncHello func(func(string, error),string) `name:\"hello\"`\n}\n\nfunc main() {\n    client := rpc.NewClient(\"http://127.0.0.1:8080/\")\n    var stub *Stub\n    client.UseService(&stub)\n    stub.AsyncHello(func(result string,err error) {\n            fmt.Println(result, error)\n            },\"async world\")\n            fmt.Println(stub.Hello(\"world\"))\n}\n```\n\n\n\n","slug":"Hprose使用说明","published":1,"updated":"2019-03-27T13:25:38.794Z","comments":1,"photos":[],"link":"","_id":"ck4f00si40003th8l8zizjghf","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Hprose(High Performance Remote Object Service Engine)<br>是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。 你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。</p>\n<h1 id=\"使用手册\"><a href=\"#使用手册\" class=\"headerlink\" title=\"使用手册\"></a>使用手册</h1><h1 id=\"案例-php\"><a href=\"#案例-php\" class=\"headerlink\" title=\"案例(php)\"></a>案例(php)</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ul>\n<li>使用<code>composer require hprose/hprose</code><br>如果你正在使用 composer 管理你的项目，那么你不需要做任何特别处理。只要在 composer.json 中的 require 段添加了对 hprose/hprose 的引用就可以了。如果你需要 swoole 支持，添加 hprose/hprose-swoole 就可以了。<br>然后在代码中这样引用</li>\n</ul>\n<a id=\"more\"></a>\n<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">use Hprose\\Swoole\\Http\\Server;</span><br><span class=\"line\"></span><br><span class=\"line\">//定义Hello服务</span><br><span class=\"line\">function hello($name) &#123;</span><br><span class=\"line\">    return &quot;Hello $name!&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//发布服务器</span><br><span class=\"line\">$server = new Server();</span><br><span class=\"line\"></span><br><span class=\"line\">//注册hello方法</span><br><span class=\"line\">$server-&gt;addFunction(&apos;hello&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">$server-&gt;start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Hprose</span>\\<span class=\"title\">Client</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$client=Client::create(<span class=\"string\">'http://localhost/'</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $client-&gt;hello(<span class=\"string\">\"World\"</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"案例-go\"><a href=\"#案例-go\" class=\"headerlink\" title=\"案例(go)\"></a>案例(go)</h1><h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/gorilla/websocket</span><br><span class=\"line\">go get github.com/valyala/fasthttp</span><br><span class=\"line\">go get github.com/hprose/hprose-golang</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"服务端-1\"><a href=\"#服务端-1\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import(</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;github.com/hprose/hprose-golang/rpc&quot;</span><br><span class=\"line\">      )</span><br><span class=\"line\"></span><br><span class=\"line\">func hello(name string) string &#123;</span><br><span class=\"line\">    return &quot;Hello&quot; + name + &quot;!&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    service := rpc.NewHTTPService()</span><br><span class=\"line\">    service.AddFunction(&quot;hello&quot;, hello, rpc.Options&#123;&#125;)</span><br><span class=\"line\">    http.ListenAndServer(&quot;:8080&quot;,service)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">        <span class=\"string\">\"github.com/hprose/hprose-golang/rpc\"</span></span><br><span class=\"line\">       )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stub <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Hello <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">AsyncHello</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">func</span>(<span class=\"keyword\">string</span>, error)</span>,<span class=\"title\">string</span>) `<span class=\"title\">name</span>:\"<span class=\"title\">hello</span>\"`</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    client := rpc.NewClient(<span class=\"string\">\"http://127.0.0.1:8080/\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stub *Stub</span><br><span class=\"line\">    client.UseService(&amp;stub)</span><br><span class=\"line\">    stub.AsyncHello(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(result <span class=\"keyword\">string</span>,err error)</span></span> &#123;</span><br><span class=\"line\">            fmt.Println(result, error)</span><br><span class=\"line\">            &#125;,<span class=\"string\">\"async world\"</span>)</span><br><span class=\"line\">            fmt.Println(stub.Hello(<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>Hprose(High Performance Remote Object Service Engine)<br>是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。 你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。</p>\n<h1 id=\"使用手册\"><a href=\"#使用手册\" class=\"headerlink\" title=\"使用手册\"></a>使用手册</h1><h1 id=\"案例-php\"><a href=\"#案例-php\" class=\"headerlink\" title=\"案例(php)\"></a>案例(php)</h1><h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><ul>\n<li>使用<code>composer require hprose/hprose</code><br>如果你正在使用 composer 管理你的项目，那么你不需要做任何特别处理。只要在 composer.json 中的 require 段添加了对 hprose/hprose 的引用就可以了。如果你需要 swoole 支持，添加 hprose/hprose-swoole 就可以了。<br>然后在代码中这样引用</li>\n</ul>","more":"<h3 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">use Hprose\\Swoole\\Http\\Server;</span><br><span class=\"line\"></span><br><span class=\"line\">//定义Hello服务</span><br><span class=\"line\">function hello($name) &#123;</span><br><span class=\"line\">    return &quot;Hello $name!&quot;;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//发布服务器</span><br><span class=\"line\">$server = new Server();</span><br><span class=\"line\"></span><br><span class=\"line\">//注册hello方法</span><br><span class=\"line\">$server-&gt;addFunction(&apos;hello&apos;);</span><br><span class=\"line\"></span><br><span class=\"line\">$server-&gt;start();</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Hprose</span>\\<span class=\"title\">Client</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$client=Client::create(<span class=\"string\">'http://localhost/'</span>,<span class=\"keyword\">false</span>);</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $client-&gt;hello(<span class=\"string\">\"World\"</span>);</span><br></pre></td></tr></table></figure>\n<h1 id=\"案例-go\"><a href=\"#案例-go\" class=\"headerlink\" title=\"案例(go)\"></a>案例(go)</h1><h2 id=\"安装-1\"><a href=\"#安装-1\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">go get github.com/gorilla/websocket</span><br><span class=\"line\">go get github.com/valyala/fasthttp</span><br><span class=\"line\">go get github.com/hprose/hprose-golang</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h3 id=\"服务端-1\"><a href=\"#服务端-1\" class=\"headerlink\" title=\"服务端\"></a>服务端</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">package main</span><br><span class=\"line\"></span><br><span class=\"line\">import(</span><br><span class=\"line\">    &quot;net/http&quot;</span><br><span class=\"line\">    &quot;github.com/hprose/hprose-golang/rpc&quot;</span><br><span class=\"line\">      )</span><br><span class=\"line\"></span><br><span class=\"line\">func hello(name string) string &#123;</span><br><span class=\"line\">    return &quot;Hello&quot; + name + &quot;!&quot;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">func main() &#123;</span><br><span class=\"line\">    service := rpc.NewHTTPService()</span><br><span class=\"line\">    service.AddFunction(&quot;hello&quot;, hello, rpc.Options&#123;&#125;)</span><br><span class=\"line\">    http.ListenAndServer(&quot;:8080&quot;,service)</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"客户端-1\"><a href=\"#客户端-1\" class=\"headerlink\" title=\"客户端\"></a>客户端</h3><figure class=\"highlight go\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> main</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> (</span><br><span class=\"line\">        <span class=\"string\">\"fmt\"</span></span><br><span class=\"line\">        <span class=\"string\">\"github.com/hprose/hprose-golang/rpc\"</span></span><br><span class=\"line\">       )</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">type</span> Stub <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">    Hello <span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(<span class=\"keyword\">string</span>)</span> <span class=\"params\">(<span class=\"keyword\">string</span>, error)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"title\">AsyncHello</span> <span class=\"title\">func</span><span class=\"params\">(<span class=\"keyword\">func</span>(<span class=\"keyword\">string</span>, error)</span>,<span class=\"title\">string</span>) `<span class=\"title\">name</span>:\"<span class=\"title\">hello</span>\"`</span></span><br><span class=\"line\"><span class=\"function\">&#125;</span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"title\">func</span> <span class=\"title\">main</span><span class=\"params\">()</span></span> &#123;</span><br><span class=\"line\">    client := rpc.NewClient(<span class=\"string\">\"http://127.0.0.1:8080/\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">var</span> stub *Stub</span><br><span class=\"line\">    client.UseService(&amp;stub)</span><br><span class=\"line\">    stub.AsyncHello(<span class=\"function\"><span class=\"keyword\">func</span><span class=\"params\">(result <span class=\"keyword\">string</span>,err error)</span></span> &#123;</span><br><span class=\"line\">            fmt.Println(result, error)</span><br><span class=\"line\">            &#125;,<span class=\"string\">\"async world\"</span>)</span><br><span class=\"line\">            fmt.Println(stub.Hello(<span class=\"string\">\"world\"</span>))</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"github上composer自动化测试","date":"2017-09-27T14:39:54.000Z","_content":"前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，\n使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\n## Style CI(php格式检查)\n在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：\n```\npreset: psr2\n```\n打开 https://styleci.io/ ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，\n每次提交代码，都会看到检测结果\n如果没有找到自己的项目，打开 https://styleci.io/account#repos 点击 Sync With GitHub 同步，就会看到\n## Travis-CI(自动化测试)\n### 配置单元测试\n1先引入phpunit单元测试包,\n```\ncomposer require --dev phpunit/phpunit ^6.2\n```\n2编写配置文件phpunit.xml.dist,放到根根根目录\n白名单是你要测试的目录文件，用于生成代码覆盖率\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"./tests/bootstrap.php\"\n         colors=\"true\"\n         verbose=\"true\"\n         convertErrorsToExceptions=\"true\"\n         convertNoticesToExceptions=\"true\"\n         convertWarningsToExceptions=\"true\"\n         processIsolation=\"false\"\n         stopOnFailure=\"false\">\n    <testsuites>\n        <testsuite name=\"Test Suite\">\n            <directory>./tests</directory>\n        </testsuite>\n    </testsuites>\n    <filter>\n        <whitelist>\n            <directory suffix=\".php\">./src</directory>\n        </whitelist>\n    </filter>\n</phpunit>\n```\n\n<!--more-->\n3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件\n``` php\n<?php\n// ensure we get report on all possible php errors\nerror_reporting(-1);\nrequire_once(__DIR__ . '/../vendor/autoload.php');\n```\n4composerjson.json文件里自动载入,否则找不到tests里面的TestCase\n``` \n \"autoload-dev\": {\n        \"psr-4\": {\n            \"graychen\\\\Test\\\\\": \"tests/\"\n        }\n    },\n```\n\n5编写.travil.yml文件(在https://travis-ci.com/ 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)\n\n``` \n\nphp:\n  - 5.6\n\n  - 7.1\n\n # cache vendor dirs\ncache:\n  directories:\n    - $HOME/.composer/cache\n    - vendor\n\n#安装依赖\ninstall:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --prefer-dist --no-interaction\n\n\nbefore_script:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --no-interaction --prefer-source --dev\n\n#单元测试\nscript:\n\n  - phpunit --coverage-text --coverage-clover=coverage.clover --debug\n\n#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目\nafter_script:\n\n  - wget https://scrutinizer-ci.com/ocular.phar\n\n  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover\n```\n\n\n## Scrutinizer （单元测试覆盖率）\nScrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。\n\n1.Scrutinizer测试以后会有三个指标供我们对代码来改进\n\nCode Quality\n\n   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等. \nCode Coverage\n\n  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行\nBuild Status\n\n  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）\n  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析\n  excluded_dependencies:\n                         - phpunit/php-timer\n                         - or-another/package-name\n  \n2.基本配置文件\n\n   #测试项目根目录创建.scrutinizer.yml文件\n```\n   imports:\n         - php\n    tools:\n        external_code_coverage:\n            timeout: 1800 # Timeout in seconds.\n        # disable copy paste detector and similarity analyzer as they have no real value\n        # and a huge bunch of false-positives\n        php_sim: false\n        php_cpd: false\n```\n参考文档地址https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\n## Codeclimate简介及使用 (漏洞排查)\nCode Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：\n\n重复的代码，它们可能存在于同一个类或不同类中\n不一致或没有标识性的对象、变量或方法命名\n过长的代码段\n让人费解的布尔表达式\n过于复杂的逻辑判断\n对象错误地暴露其内部状态\n遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码\n\n### 使用\n\n首先在项目中添加配置文件 。codeclimate.yml配置如下:\n```\nengines:\n  duplication:\n    enabled: true\n    config:\n      languages:\n      - php\n  eslint:\n    enabled: true\n  fixme:\n    enabled: true\n  phpmd:\n    enabled: true\n    config:\n    checks:\n      UnusedLocalVariable:\n        enabled: false\nratings:\n  paths:\n  - \"**.php\"\nexclude_paths:\n- tests/\n```\n配置分析\n\n引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。\n\nengines:\n  some-engine:\n    enabled: true\n    channel: \"new-hotness\"\nGithub 集成\n1首先登录[climatecode网站]https://codeclimate.com/dashboard \n2 添加仓库 \n3入库\n4显示成功,这些是分析数据\n## github徽章 (测试保证)\n修改README.md 在工具页面找这些徽章\n[![Latest Stable Version](https://poser.pugx.org/graychen/geolocation/version)](https://packagist.org/packages/graychen/geolocation)\n[![Total Downloads](https://poser.pugx.org/graychen/geolocation/downloads)](https://packagist.org/packages/graychen/geolocation)\n[![License](https://poser.pugx.org/graychen/geolocation/license)](https://packagist.org/packages/graychen/geolocation)\n[![StyleCI](https://styleci.io/repos/92368125/shield?branch=master)](https://styleci.io/repos/92368125)\n[![Build Status](https://travis-ci.org/Graychen/yii2-post.svg?branch=master)](https://travis-ci.org/Graychen/yii2-post)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Code Coverage](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Build Status](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master)\n\n\n","source":"_posts/github自动化测试.md","raw":"---\ntitle: github上composer自动化测试\ndate: 2017-09-27 22:39:54\ntags: 技术 php\n\n---\n前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，\n使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\n## Style CI(php格式检查)\n在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：\n```\npreset: psr2\n```\n打开 https://styleci.io/ ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，\n每次提交代码，都会看到检测结果\n如果没有找到自己的项目，打开 https://styleci.io/account#repos 点击 Sync With GitHub 同步，就会看到\n## Travis-CI(自动化测试)\n### 配置单元测试\n1先引入phpunit单元测试包,\n```\ncomposer require --dev phpunit/phpunit ^6.2\n```\n2编写配置文件phpunit.xml.dist,放到根根根目录\n白名单是你要测试的目录文件，用于生成代码覆盖率\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"./tests/bootstrap.php\"\n         colors=\"true\"\n         verbose=\"true\"\n         convertErrorsToExceptions=\"true\"\n         convertNoticesToExceptions=\"true\"\n         convertWarningsToExceptions=\"true\"\n         processIsolation=\"false\"\n         stopOnFailure=\"false\">\n    <testsuites>\n        <testsuite name=\"Test Suite\">\n            <directory>./tests</directory>\n        </testsuite>\n    </testsuites>\n    <filter>\n        <whitelist>\n            <directory suffix=\".php\">./src</directory>\n        </whitelist>\n    </filter>\n</phpunit>\n```\n\n<!--more-->\n3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件\n``` php\n<?php\n// ensure we get report on all possible php errors\nerror_reporting(-1);\nrequire_once(__DIR__ . '/../vendor/autoload.php');\n```\n4composerjson.json文件里自动载入,否则找不到tests里面的TestCase\n``` \n \"autoload-dev\": {\n        \"psr-4\": {\n            \"graychen\\\\Test\\\\\": \"tests/\"\n        }\n    },\n```\n\n5编写.travil.yml文件(在https://travis-ci.com/ 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)\n\n``` \n\nphp:\n  - 5.6\n\n  - 7.1\n\n # cache vendor dirs\ncache:\n  directories:\n    - $HOME/.composer/cache\n    - vendor\n\n#安装依赖\ninstall:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --prefer-dist --no-interaction\n\n\nbefore_script:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --no-interaction --prefer-source --dev\n\n#单元测试\nscript:\n\n  - phpunit --coverage-text --coverage-clover=coverage.clover --debug\n\n#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目\nafter_script:\n\n  - wget https://scrutinizer-ci.com/ocular.phar\n\n  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover\n```\n\n\n## Scrutinizer （单元测试覆盖率）\nScrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。\n\n1.Scrutinizer测试以后会有三个指标供我们对代码来改进\n\nCode Quality\n\n   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等. \nCode Coverage\n\n  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行\nBuild Status\n\n  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）\n  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析\n  excluded_dependencies:\n                         - phpunit/php-timer\n                         - or-another/package-name\n  \n2.基本配置文件\n\n   #测试项目根目录创建.scrutinizer.yml文件\n```\n   imports:\n         - php\n    tools:\n        external_code_coverage:\n            timeout: 1800 # Timeout in seconds.\n        # disable copy paste detector and similarity analyzer as they have no real value\n        # and a huge bunch of false-positives\n        php_sim: false\n        php_cpd: false\n```\n参考文档地址https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\n## Codeclimate简介及使用 (漏洞排查)\nCode Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：\n\n重复的代码，它们可能存在于同一个类或不同类中\n不一致或没有标识性的对象、变量或方法命名\n过长的代码段\n让人费解的布尔表达式\n过于复杂的逻辑判断\n对象错误地暴露其内部状态\n遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码\n\n### 使用\n\n首先在项目中添加配置文件 。codeclimate.yml配置如下:\n```\nengines:\n  duplication:\n    enabled: true\n    config:\n      languages:\n      - php\n  eslint:\n    enabled: true\n  fixme:\n    enabled: true\n  phpmd:\n    enabled: true\n    config:\n    checks:\n      UnusedLocalVariable:\n        enabled: false\nratings:\n  paths:\n  - \"**.php\"\nexclude_paths:\n- tests/\n```\n配置分析\n\n引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。\n\nengines:\n  some-engine:\n    enabled: true\n    channel: \"new-hotness\"\nGithub 集成\n1首先登录[climatecode网站]https://codeclimate.com/dashboard \n2 添加仓库 \n3入库\n4显示成功,这些是分析数据\n## github徽章 (测试保证)\n修改README.md 在工具页面找这些徽章\n[![Latest Stable Version](https://poser.pugx.org/graychen/geolocation/version)](https://packagist.org/packages/graychen/geolocation)\n[![Total Downloads](https://poser.pugx.org/graychen/geolocation/downloads)](https://packagist.org/packages/graychen/geolocation)\n[![License](https://poser.pugx.org/graychen/geolocation/license)](https://packagist.org/packages/graychen/geolocation)\n[![StyleCI](https://styleci.io/repos/92368125/shield?branch=master)](https://styleci.io/repos/92368125)\n[![Build Status](https://travis-ci.org/Graychen/yii2-post.svg?branch=master)](https://travis-ci.org/Graychen/yii2-post)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Code Coverage](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Build Status](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master)\n\n\n","slug":"github自动化测试","published":1,"updated":"2018-05-27T09:59:36.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si50004th8l4kta20mu","content":"<p>前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，<br>使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[<a href=\"https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\" target=\"_blank\" rel=\"noopener\">https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。</a></p>\n<h2 id=\"Style-CI-php格式检查\"><a href=\"#Style-CI-php格式检查\" class=\"headerlink\" title=\"Style CI(php格式检查)\"></a>Style CI(php格式检查)</h2><p>在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preset: psr2</span><br></pre></td></tr></table></figure></p>\n<p>打开 <a href=\"https://styleci.io/\" target=\"_blank\" rel=\"noopener\">https://styleci.io/</a> ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，<br>每次提交代码，都会看到检测结果<br>如果没有找到自己的项目，打开 <a href=\"https://styleci.io/account#repos\" target=\"_blank\" rel=\"noopener\">https://styleci.io/account#repos</a> 点击 Sync With GitHub 同步，就会看到</p>\n<h2 id=\"Travis-CI-自动化测试\"><a href=\"#Travis-CI-自动化测试\" class=\"headerlink\" title=\"Travis-CI(自动化测试)\"></a>Travis-CI(自动化测试)</h2><h3 id=\"配置单元测试\"><a href=\"#配置单元测试\" class=\"headerlink\" title=\"配置单元测试\"></a>配置单元测试</h3><p>1先引入phpunit单元测试包,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require --dev phpunit/phpunit ^6.2</span><br></pre></td></tr></table></figure></p>\n<p>2编写配置文件phpunit.xml.dist,放到根根根目录<br>白名单是你要测试的目录文件，用于生成代码覆盖率<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;phpunit bootstrap=&quot;./tests/bootstrap.php&quot;</span><br><span class=\"line\">         colors=&quot;true&quot;</span><br><span class=\"line\">         verbose=&quot;true&quot;</span><br><span class=\"line\">         convertErrorsToExceptions=&quot;true&quot;</span><br><span class=\"line\">         convertNoticesToExceptions=&quot;true&quot;</span><br><span class=\"line\">         convertWarningsToExceptions=&quot;true&quot;</span><br><span class=\"line\">         processIsolation=&quot;false&quot;</span><br><span class=\"line\">         stopOnFailure=&quot;false&quot;&gt;</span><br><span class=\"line\">    &lt;testsuites&gt;</span><br><span class=\"line\">        &lt;testsuite name=&quot;Test Suite&quot;&gt;</span><br><span class=\"line\">            &lt;directory&gt;./tests&lt;/directory&gt;</span><br><span class=\"line\">        &lt;/testsuite&gt;</span><br><span class=\"line\">    &lt;/testsuites&gt;</span><br><span class=\"line\">    &lt;filter&gt;</span><br><span class=\"line\">        &lt;whitelist&gt;</span><br><span class=\"line\">            &lt;directory suffix=&quot;.php&quot;&gt;./src&lt;/directory&gt;</span><br><span class=\"line\">        &lt;/whitelist&gt;</span><br><span class=\"line\">    &lt;/filter&gt;</span><br><span class=\"line\">&lt;/phpunit&gt;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// ensure we get report on all possible php errors</span></span><br><span class=\"line\">error_reporting(<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"keyword\">__DIR__</span> . <span class=\"string\">'/../vendor/autoload.php'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4composerjson.json文件里自动载入,否则找不到tests里面的TestCase<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;autoload-dev&quot;: &#123;</span><br><span class=\"line\">       &quot;psr-4&quot;: &#123;</span><br><span class=\"line\">           &quot;graychen\\\\Test\\\\&quot;: &quot;tests/&quot;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>5编写.travil.yml文件(在<a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">https://travis-ci.com/</a> 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">php:</span><br><span class=\"line\">  - 5.6</span><br><span class=\"line\"></span><br><span class=\"line\">  - 7.1</span><br><span class=\"line\"></span><br><span class=\"line\"> # cache vendor dirs</span><br><span class=\"line\">cache:</span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - $HOME/.composer/cache</span><br><span class=\"line\">    - vendor</span><br><span class=\"line\"></span><br><span class=\"line\">#安装依赖</span><br><span class=\"line\">install:</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer self-update</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer install --prefer-dist --no-interaction</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">before_script:</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer self-update</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer install --no-interaction --prefer-source --dev</span><br><span class=\"line\"></span><br><span class=\"line\">#单元测试</span><br><span class=\"line\">script:</span><br><span class=\"line\"></span><br><span class=\"line\">  - phpunit --coverage-text --coverage-clover=coverage.clover --debug</span><br><span class=\"line\"></span><br><span class=\"line\">#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目</span><br><span class=\"line\">after_script:</span><br><span class=\"line\"></span><br><span class=\"line\">  - wget https://scrutinizer-ci.com/ocular.phar</span><br><span class=\"line\"></span><br><span class=\"line\">  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover</span><br></pre></td></tr></table></figure>\n<h2 id=\"Scrutinizer-（单元测试覆盖率）\"><a href=\"#Scrutinizer-（单元测试覆盖率）\" class=\"headerlink\" title=\"Scrutinizer （单元测试覆盖率）\"></a>Scrutinizer （单元测试覆盖率）</h2><p>Scrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。</p>\n<p>1.Scrutinizer测试以后会有三个指标供我们对代码来改进</p>\n<p>Code Quality</p>\n<p>   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等.<br>Code Coverage</p>\n<p>  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行<br>Build Status</p>\n<p>  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）<br>  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析<br>  excluded_dependencies:</p>\n<pre><code>- phpunit/php-timer\n- or-another/package-name\n</code></pre><p>2.基本配置文件</p>\n<p>   #测试项目根目录创建.scrutinizer.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imports:</span><br><span class=\"line\">      - php</span><br><span class=\"line\"> tools:</span><br><span class=\"line\">     external_code_coverage:</span><br><span class=\"line\">         timeout: 1800 # Timeout in seconds.</span><br><span class=\"line\">     # disable copy paste detector and similarity analyzer as they have no real value</span><br><span class=\"line\">     # and a huge bunch of false-positives</span><br><span class=\"line\">     php_sim: false</span><br><span class=\"line\">     php_cpd: false</span><br></pre></td></tr></table></figure></p>\n<p>参考文档地址<a href=\"https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\" target=\"_blank\" rel=\"noopener\">https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews</a></p>\n<h2 id=\"Codeclimate简介及使用-漏洞排查\"><a href=\"#Codeclimate简介及使用-漏洞排查\" class=\"headerlink\" title=\"Codeclimate简介及使用 (漏洞排查)\"></a>Codeclimate简介及使用 (漏洞排查)</h2><p>Code Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：</p>\n<p>重复的代码，它们可能存在于同一个类或不同类中<br>不一致或没有标识性的对象、变量或方法命名<br>过长的代码段<br>让人费解的布尔表达式<br>过于复杂的逻辑判断<br>对象错误地暴露其内部状态<br>遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>首先在项目中添加配置文件 。codeclimate.yml配置如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">engines:</span><br><span class=\"line\">  duplication:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      languages:</span><br><span class=\"line\">      - php</span><br><span class=\"line\">  eslint:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">  fixme:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">  phpmd:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    config:</span><br><span class=\"line\">    checks:</span><br><span class=\"line\">      UnusedLocalVariable:</span><br><span class=\"line\">        enabled: false</span><br><span class=\"line\">ratings:</span><br><span class=\"line\">  paths:</span><br><span class=\"line\">  - &quot;**.php&quot;</span><br><span class=\"line\">exclude_paths:</span><br><span class=\"line\">- tests/</span><br></pre></td></tr></table></figure></p>\n<p>配置分析</p>\n<p>引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。</p>\n<p>engines:<br>  some-engine:<br>    enabled: true<br>    channel: “new-hotness”<br>Github 集成<br>1首先登录[climatecode网站]<a href=\"https://codeclimate.com/dashboard\" target=\"_blank\" rel=\"noopener\">https://codeclimate.com/dashboard</a><br>2 添加仓库<br>3入库<br>4显示成功,这些是分析数据</p>\n<h2 id=\"github徽章-测试保证\"><a href=\"#github徽章-测试保证\" class=\"headerlink\" title=\"github徽章 (测试保证)\"></a>github徽章 (测试保证)</h2><p>修改README.md 在工具页面找这些徽章<br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/version\" alt=\"Latest Stable Version\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/downloads\" alt=\"Total Downloads\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/license\" alt=\"License\"></a><br><a href=\"https://styleci.io/repos/92368125\" target=\"_blank\" rel=\"noopener\"><img src=\"https://styleci.io/repos/92368125/shield?branch=master\" alt=\"StyleCI\"></a><br><a href=\"https://travis-ci.org/Graychen/yii2-post\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/Graychen/yii2-post.svg?branch=master\" alt=\"Build Status\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master\" alt=\"Scrutinizer Code Quality\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master\" alt=\"Code Coverage\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master\" alt=\"Build Status\"></a></p>\n","site":{"data":{}},"excerpt":"<p>前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，<br>使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[<a href=\"https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\" target=\"_blank\" rel=\"noopener\">https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。</a></p>\n<h2 id=\"Style-CI-php格式检查\"><a href=\"#Style-CI-php格式检查\" class=\"headerlink\" title=\"Style CI(php格式检查)\"></a>Style CI(php格式检查)</h2><p>在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">preset: psr2</span><br></pre></td></tr></table></figure></p>\n<p>打开 <a href=\"https://styleci.io/\" target=\"_blank\" rel=\"noopener\">https://styleci.io/</a> ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，<br>每次提交代码，都会看到检测结果<br>如果没有找到自己的项目，打开 <a href=\"https://styleci.io/account#repos\" target=\"_blank\" rel=\"noopener\">https://styleci.io/account#repos</a> 点击 Sync With GitHub 同步，就会看到</p>\n<h2 id=\"Travis-CI-自动化测试\"><a href=\"#Travis-CI-自动化测试\" class=\"headerlink\" title=\"Travis-CI(自动化测试)\"></a>Travis-CI(自动化测试)</h2><h3 id=\"配置单元测试\"><a href=\"#配置单元测试\" class=\"headerlink\" title=\"配置单元测试\"></a>配置单元测试</h3><p>1先引入phpunit单元测试包,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require --dev phpunit/phpunit ^6.2</span><br></pre></td></tr></table></figure></p>\n<p>2编写配置文件phpunit.xml.dist,放到根根根目录<br>白名单是你要测试的目录文件，用于生成代码覆盖率<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class=\"line\">&lt;phpunit bootstrap=&quot;./tests/bootstrap.php&quot;</span><br><span class=\"line\">         colors=&quot;true&quot;</span><br><span class=\"line\">         verbose=&quot;true&quot;</span><br><span class=\"line\">         convertErrorsToExceptions=&quot;true&quot;</span><br><span class=\"line\">         convertNoticesToExceptions=&quot;true&quot;</span><br><span class=\"line\">         convertWarningsToExceptions=&quot;true&quot;</span><br><span class=\"line\">         processIsolation=&quot;false&quot;</span><br><span class=\"line\">         stopOnFailure=&quot;false&quot;&gt;</span><br><span class=\"line\">    &lt;testsuites&gt;</span><br><span class=\"line\">        &lt;testsuite name=&quot;Test Suite&quot;&gt;</span><br><span class=\"line\">            &lt;directory&gt;./tests&lt;/directory&gt;</span><br><span class=\"line\">        &lt;/testsuite&gt;</span><br><span class=\"line\">    &lt;/testsuites&gt;</span><br><span class=\"line\">    &lt;filter&gt;</span><br><span class=\"line\">        &lt;whitelist&gt;</span><br><span class=\"line\">            &lt;directory suffix=&quot;.php&quot;&gt;./src&lt;/directory&gt;</span><br><span class=\"line\">        &lt;/whitelist&gt;</span><br><span class=\"line\">    &lt;/filter&gt;</span><br><span class=\"line\">&lt;/phpunit&gt;</span><br></pre></td></tr></table></figure></p>","more":"<p>3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">// ensure we get report on all possible php errors</span></span><br><span class=\"line\">error_reporting(<span class=\"number\">-1</span>);</span><br><span class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"keyword\">__DIR__</span> . <span class=\"string\">'/../vendor/autoload.php'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>4composerjson.json文件里自动载入,否则找不到tests里面的TestCase<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;autoload-dev&quot;: &#123;</span><br><span class=\"line\">       &quot;psr-4&quot;: &#123;</span><br><span class=\"line\">           &quot;graychen\\\\Test\\\\&quot;: &quot;tests/&quot;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">   &#125;,</span><br></pre></td></tr></table></figure></p>\n<p>5编写.travil.yml文件(在<a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">https://travis-ci.com/</a> 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">php:</span><br><span class=\"line\">  - 5.6</span><br><span class=\"line\"></span><br><span class=\"line\">  - 7.1</span><br><span class=\"line\"></span><br><span class=\"line\"> # cache vendor dirs</span><br><span class=\"line\">cache:</span><br><span class=\"line\">  directories:</span><br><span class=\"line\">    - $HOME/.composer/cache</span><br><span class=\"line\">    - vendor</span><br><span class=\"line\"></span><br><span class=\"line\">#安装依赖</span><br><span class=\"line\">install:</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer self-update</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer install --prefer-dist --no-interaction</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">before_script:</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer self-update</span><br><span class=\"line\"></span><br><span class=\"line\">  - travis_retry composer install --no-interaction --prefer-source --dev</span><br><span class=\"line\"></span><br><span class=\"line\">#单元测试</span><br><span class=\"line\">script:</span><br><span class=\"line\"></span><br><span class=\"line\">  - phpunit --coverage-text --coverage-clover=coverage.clover --debug</span><br><span class=\"line\"></span><br><span class=\"line\">#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目</span><br><span class=\"line\">after_script:</span><br><span class=\"line\"></span><br><span class=\"line\">  - wget https://scrutinizer-ci.com/ocular.phar</span><br><span class=\"line\"></span><br><span class=\"line\">  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover</span><br></pre></td></tr></table></figure>\n<h2 id=\"Scrutinizer-（单元测试覆盖率）\"><a href=\"#Scrutinizer-（单元测试覆盖率）\" class=\"headerlink\" title=\"Scrutinizer （单元测试覆盖率）\"></a>Scrutinizer （单元测试覆盖率）</h2><p>Scrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。</p>\n<p>1.Scrutinizer测试以后会有三个指标供我们对代码来改进</p>\n<p>Code Quality</p>\n<p>   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等.<br>Code Coverage</p>\n<p>  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行<br>Build Status</p>\n<p>  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）<br>  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析<br>  excluded_dependencies:</p>\n<pre><code>- phpunit/php-timer\n- or-another/package-name\n</code></pre><p>2.基本配置文件</p>\n<p>   #测试项目根目录创建.scrutinizer.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imports:</span><br><span class=\"line\">      - php</span><br><span class=\"line\"> tools:</span><br><span class=\"line\">     external_code_coverage:</span><br><span class=\"line\">         timeout: 1800 # Timeout in seconds.</span><br><span class=\"line\">     # disable copy paste detector and similarity analyzer as they have no real value</span><br><span class=\"line\">     # and a huge bunch of false-positives</span><br><span class=\"line\">     php_sim: false</span><br><span class=\"line\">     php_cpd: false</span><br></pre></td></tr></table></figure></p>\n<p>参考文档地址<a href=\"https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\" target=\"_blank\" rel=\"noopener\">https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews</a></p>\n<h2 id=\"Codeclimate简介及使用-漏洞排查\"><a href=\"#Codeclimate简介及使用-漏洞排查\" class=\"headerlink\" title=\"Codeclimate简介及使用 (漏洞排查)\"></a>Codeclimate简介及使用 (漏洞排查)</h2><p>Code Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：</p>\n<p>重复的代码，它们可能存在于同一个类或不同类中<br>不一致或没有标识性的对象、变量或方法命名<br>过长的代码段<br>让人费解的布尔表达式<br>过于复杂的逻辑判断<br>对象错误地暴露其内部状态<br>遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>首先在项目中添加配置文件 。codeclimate.yml配置如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">engines:</span><br><span class=\"line\">  duplication:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    config:</span><br><span class=\"line\">      languages:</span><br><span class=\"line\">      - php</span><br><span class=\"line\">  eslint:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">  fixme:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">  phpmd:</span><br><span class=\"line\">    enabled: true</span><br><span class=\"line\">    config:</span><br><span class=\"line\">    checks:</span><br><span class=\"line\">      UnusedLocalVariable:</span><br><span class=\"line\">        enabled: false</span><br><span class=\"line\">ratings:</span><br><span class=\"line\">  paths:</span><br><span class=\"line\">  - &quot;**.php&quot;</span><br><span class=\"line\">exclude_paths:</span><br><span class=\"line\">- tests/</span><br></pre></td></tr></table></figure></p>\n<p>配置分析</p>\n<p>引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。</p>\n<p>engines:<br>  some-engine:<br>    enabled: true<br>    channel: “new-hotness”<br>Github 集成<br>1首先登录[climatecode网站]<a href=\"https://codeclimate.com/dashboard\" target=\"_blank\" rel=\"noopener\">https://codeclimate.com/dashboard</a><br>2 添加仓库<br>3入库<br>4显示成功,这些是分析数据</p>\n<h2 id=\"github徽章-测试保证\"><a href=\"#github徽章-测试保证\" class=\"headerlink\" title=\"github徽章 (测试保证)\"></a>github徽章 (测试保证)</h2><p>修改README.md 在工具页面找这些徽章<br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/version\" alt=\"Latest Stable Version\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/downloads\" alt=\"Total Downloads\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/license\" alt=\"License\"></a><br><a href=\"https://styleci.io/repos/92368125\" target=\"_blank\" rel=\"noopener\"><img src=\"https://styleci.io/repos/92368125/shield?branch=master\" alt=\"StyleCI\"></a><br><a href=\"https://travis-ci.org/Graychen/yii2-post\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/Graychen/yii2-post.svg?branch=master\" alt=\"Build Status\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master\" alt=\"Scrutinizer Code Quality\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master\" alt=\"Code Coverage\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master\" alt=\"Build Status\"></a></p>"},{"title":"elastic语句记录","date":"2019-12-11T07:14:26.000Z","_content":"最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。\n``` shell \nGET /student_app_request/_search\n{\n   \"_source\":[\"student_no\"],\n  \"query\": {\n      \"bool\" : {\n            \"must\" : {\n                \"exists\" : {\n                    \"field\" : \"student_no\"\n                }\n            },\n      \"filter\": [\n        {\"range\":\n          {\n            \"timestamp\":{\n                \"gte\" : \"now-30d/d\",\n                \"lt\" :  \"now/d\"\n          }\n          }\n        }\n      ]\n    }\n  },\n  \"size\": 1000,\n  \"aggs\": {\n    \"student_num\": {\n      \"cardinality\": {\"field\": \"student_no\"}\n    }\n  }\n}\n```\n - _source\n 这相当于mysql语句中的字段选择\n - must\n must中的bool参数表达了student_no这个字段一定要存在\n - filter\n range代表了对时间的筛选，表示了日志中timestamp这个时间戳的30天内的筛选\n - size\n 代表了返回的数据量，如果想要单纯的拿统计数据的话，这个值可以设置为0\n - aggs\n 相当于mysql中的聚合函数，构造一个数值来进行统计，我构造了student_num这个数字，对student_no的数量做了统计，并且使用了cardinlity对该字段做了去重\n\n\n","source":"_posts/elastic语句记录.md","raw":"---\ntitle: elastic语句记录\ndate: 2019-12-11 15:14:26\ntags: 技术\n---\n最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。\n``` shell \nGET /student_app_request/_search\n{\n   \"_source\":[\"student_no\"],\n  \"query\": {\n      \"bool\" : {\n            \"must\" : {\n                \"exists\" : {\n                    \"field\" : \"student_no\"\n                }\n            },\n      \"filter\": [\n        {\"range\":\n          {\n            \"timestamp\":{\n                \"gte\" : \"now-30d/d\",\n                \"lt\" :  \"now/d\"\n          }\n          }\n        }\n      ]\n    }\n  },\n  \"size\": 1000,\n  \"aggs\": {\n    \"student_num\": {\n      \"cardinality\": {\"field\": \"student_no\"}\n    }\n  }\n}\n```\n - _source\n 这相当于mysql语句中的字段选择\n - must\n must中的bool参数表达了student_no这个字段一定要存在\n - filter\n range代表了对时间的筛选，表示了日志中timestamp这个时间戳的30天内的筛选\n - size\n 代表了返回的数据量，如果想要单纯的拿统计数据的话，这个值可以设置为0\n - aggs\n 相当于mysql中的聚合函数，构造一个数值来进行统计，我构造了student_num这个数字，对student_no的数量做了统计，并且使用了cardinlity对该字段做了去重\n\n\n","slug":"elastic语句记录","published":1,"updated":"2019-12-11T07:26:53.049Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si60005th8lzbmdi58p","content":"<p>最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student_app_request/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   \"_source\":[\"student_no\"],</span><br><span class=\"line\">  \"query\": &#123;</span><br><span class=\"line\">      \"bool\" : &#123;</span><br><span class=\"line\">            \"must\" : &#123;</span><br><span class=\"line\">                \"exists\" : &#123;</span><br><span class=\"line\">                    \"field\" : \"student_no\"</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">      \"filter\": [</span><br><span class=\"line\">        &#123;\"range\":</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            \"timestamp\":&#123;</span><br><span class=\"line\">                \"gte\" : \"now-30d/d\",</span><br><span class=\"line\">                \"lt\" :  \"now/d\"</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"size\": 1000,</span><br><span class=\"line\">  \"aggs\": &#123;</span><br><span class=\"line\">    \"student_num\": &#123;</span><br><span class=\"line\">      \"cardinality\": &#123;\"field\": \"student_no\"&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>_source<br>这相当于mysql语句中的字段选择</li>\n<li>must<br>must中的bool参数表达了student_no这个字段一定要存在</li>\n<li>filter<br>range代表了对时间的筛选，表示了日志中timestamp这个时间戳的30天内的筛选</li>\n<li>size<br>代表了返回的数据量，如果想要单纯的拿统计数据的话，这个值可以设置为0</li>\n<li>aggs<br>相当于mysql中的聚合函数，构造一个数值来进行统计，我构造了student_num这个数字，对student_no的数量做了统计，并且使用了cardinlity对该字段做了去重</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET /student_app_request/_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">   \"_source\":[\"student_no\"],</span><br><span class=\"line\">  \"query\": &#123;</span><br><span class=\"line\">      \"bool\" : &#123;</span><br><span class=\"line\">            \"must\" : &#123;</span><br><span class=\"line\">                \"exists\" : &#123;</span><br><span class=\"line\">                    \"field\" : \"student_no\"</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;,</span><br><span class=\"line\">      \"filter\": [</span><br><span class=\"line\">        &#123;\"range\":</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">            \"timestamp\":&#123;</span><br><span class=\"line\">                \"gte\" : \"now-30d/d\",</span><br><span class=\"line\">                \"lt\" :  \"now/d\"</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">      ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;,</span><br><span class=\"line\">  \"size\": 1000,</span><br><span class=\"line\">  \"aggs\": &#123;</span><br><span class=\"line\">    \"student_num\": &#123;</span><br><span class=\"line\">      \"cardinality\": &#123;\"field\": \"student_no\"&#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>_source<br>这相当于mysql语句中的字段选择</li>\n<li>must<br>must中的bool参数表达了student_no这个字段一定要存在</li>\n<li>filter<br>range代表了对时间的筛选，表示了日志中timestamp这个时间戳的30天内的筛选</li>\n<li>size<br>代表了返回的数据量，如果想要单纯的拿统计数据的话，这个值可以设置为0</li>\n<li>aggs<br>相当于mysql中的聚合函数，构造一个数值来进行统计，我构造了student_num这个数字，对student_no的数量做了统计，并且使用了cardinlity对该字段做了去重</li>\n</ul>\n"},{"title":"Composer包是怎样炼成的","date":"2016-10-19T03:20:43.000Z","_content":"\n>**Composer**是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 --[Composer中文网](http://www.phpcomposer.com/)\n\n关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到[packgist](https://packagist.org/)\n\n## 创建组件\n### 产商名称和包名\n在设置命名空间之前，先要确定产商名称和包名，类似于**laravel/framework**,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。\n### 文件系统结构\n- **src**:这个目录用于存放组件的源码   \n- **tests**:这个目录用于存放测试代码   \n- **composer.json**:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   \n- **README.md**:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   \n- **CONTRIBUTING.md**:这个Markdown文件告知别人如何为这个组件做贡献  \n- **LICENSE**：纯文本文件，声明组件的软件许可证\n- **CHANGELOG.md**：Markdown文件，列出组件在每个版本中引入的改动\n\n### 文件系统结构\n我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：\ncomposer init\n\n<!--more-->\n然后在终端会让我们按照提示向导一步步填写composer.json内容：\n最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：\n``` javascript\n{\n    \"name\": \"graychen/container\",\n    \"description\": \"a container for interface and container\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Graychen\",\n            \"email\": \"13780185250@sina.cn\"\n        }\n    ],\n    \"minimum-stability\": \"dev\",\n    \"require\": {},\n    \"require-dev\": {\n            \"phpunit/phpunit\" : \"~4.3\" \n        },\n    \"autoload\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\\" : \"src\"\n        }\n    },\n    \"autoload-dev\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\Tests\\\\\":\"tests/\"\n        }\n    }\n}\n\n```\n我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：\n\n- name：组件的厂商名和包名，也是Packagist中的组件名\n- description：简要说明组件\n- keywords：描述属性的关键字\n- homepage：组件网站URL\n- license：PHP组件采用的软件许可证（更多软件许可证参考：http://choosealicense.com/）\n- authors：作者信息数组\n- support：组件用户获取技术支持的方式\n- require：组件自身依赖的组件\n- require-dev：开发这个组件所需的依赖\n- suggest：建议安装的组件\n- autoload：告诉Composer自动加载器如何自动加载这个组件\n\nREADEME.md\n\n通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：\n- 组件的名称和描述\n- 安装说明\n- 使用说明\n- 测试说明\n- 贡献方式\n- 支持资源\n- 作者信息\n- 软件许可证\n\n实现组件\n\n开始之前我们使用如下命令安装依赖：\n``` php\ncomposer install\n```\n该命令会把依赖组件安装到vendor目录并生成自动加载器。\n安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。\n``` php\n<?php\nnamespace container;\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n    private $_bindings = [];//服务列表\n    private $_instances= [];//已经实例化的服务\n    //获取服务\n    public function get($name,$params=[]){\n        //先从实例化的列表中查找\n        if(isset($this->$_instances[$name])){\n            return $this->$_instances[$name]; \n        }\n        //检测有没有注册该服务\n        if(!isset($this->$_bindings[$name])){\n            return null;\n        }\n        $concrete = $this->$_bindings[$name]['class'];//对象具体注册内容\n        $obj = null;\n        if($concrete instanceof \\Closure){ //匿名函数方式\n            $obj = call_user_func_array($concrete,$params);\n        }elseif(is_string($concrete)){     //字符串方式\n            if(empty($params)){\n                $obj = new $concrete;\n            }else{\n                //带参数的类实例化,使用反射\n                $class = new \\reflectionClass($concrete);\n                $obj = $class->newInstanceArgs($params);\n            }\n        }\n        //如果是共享服务，则写入_instances列表，下次直接取回\n        if($this->_bindings[$name]['shared']==true && $ojb){\n            $this->_instances[$name]=$obj;\n        }\n        return $obj;\n    } \n    //检测是否已经绑定\n    public function has($name){\n        return isset($this->_bindings[$name]) or isset($this->_instances[$name]);\n    }\n    //卸载服务\n    public function remove($name){\n        unset($this->_bindings[$name],$this->_instances[$name]);\n    }\n    //设置服务\n    public function set($name,$class){\n        $this->_registerService($name,$class);\n    }\n    //设置共享服务\n    public function setShared($name,$class){\n        $this->_registerService($name,$class,true);\n    }\n    //注册服务\n    private function _registerService($name,$class,$shared=false){\n        $this->remove($name);\n        if(!($class instanceof \\Closure) && is_object($class)){\n            $this->_instances[$name]=$class;\n        }else{\n            $this->_bindings[$name]=array(\"class\"=>$class,\"shared\"=>$shared); \n        }\n    }\n    //ArrayAccess接口，检测服务是否存在\n    public function offsetExists($offset){\n        return $this->has($offset);\n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetGet($offset){\n       return $this->get($offset); \n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetSet($offset,$value){\n        return $this->set($offset,$value);\n    }\n    //卸载服务\n    public function offsetUnset($offset){\n        return $this->remove($offset);\n    }\n} \n```\n### 提交到packglist\n我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：\n``` git\ngit init\ngit remote add origin https://github.com/nonfu/urlscanner.git\ngit add .\ngit commit -m “urlscanner\"\ngit pull origin master\ngit push origin master\n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/Graychen-Container.gif)\n 然后在Packagist中通过GitHub账户登录，通过https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\n check成功后点击submit即可将组件提交到Packagist：\n ![\"我是傲娇的效果图\"](/assets/blogImg/Packagist.gif)\n## 使用组件\n 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：\n\n composer require graychen/container dev-master\n","source":"_posts/composer包是怎样炼成的.md","raw":"---\ntitle: Composer包是怎样炼成的\ndate: 2016-10-19 11:20:43\ntag: php\ncategories: 技术\n\n---\n\n>**Composer**是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 --[Composer中文网](http://www.phpcomposer.com/)\n\n关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到[packgist](https://packagist.org/)\n\n## 创建组件\n### 产商名称和包名\n在设置命名空间之前，先要确定产商名称和包名，类似于**laravel/framework**,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。\n### 文件系统结构\n- **src**:这个目录用于存放组件的源码   \n- **tests**:这个目录用于存放测试代码   \n- **composer.json**:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   \n- **README.md**:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   \n- **CONTRIBUTING.md**:这个Markdown文件告知别人如何为这个组件做贡献  \n- **LICENSE**：纯文本文件，声明组件的软件许可证\n- **CHANGELOG.md**：Markdown文件，列出组件在每个版本中引入的改动\n\n### 文件系统结构\n我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：\ncomposer init\n\n<!--more-->\n然后在终端会让我们按照提示向导一步步填写composer.json内容：\n最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：\n``` javascript\n{\n    \"name\": \"graychen/container\",\n    \"description\": \"a container for interface and container\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Graychen\",\n            \"email\": \"13780185250@sina.cn\"\n        }\n    ],\n    \"minimum-stability\": \"dev\",\n    \"require\": {},\n    \"require-dev\": {\n            \"phpunit/phpunit\" : \"~4.3\" \n        },\n    \"autoload\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\\" : \"src\"\n        }\n    },\n    \"autoload-dev\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\Tests\\\\\":\"tests/\"\n        }\n    }\n}\n\n```\n我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：\n\n- name：组件的厂商名和包名，也是Packagist中的组件名\n- description：简要说明组件\n- keywords：描述属性的关键字\n- homepage：组件网站URL\n- license：PHP组件采用的软件许可证（更多软件许可证参考：http://choosealicense.com/）\n- authors：作者信息数组\n- support：组件用户获取技术支持的方式\n- require：组件自身依赖的组件\n- require-dev：开发这个组件所需的依赖\n- suggest：建议安装的组件\n- autoload：告诉Composer自动加载器如何自动加载这个组件\n\nREADEME.md\n\n通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：\n- 组件的名称和描述\n- 安装说明\n- 使用说明\n- 测试说明\n- 贡献方式\n- 支持资源\n- 作者信息\n- 软件许可证\n\n实现组件\n\n开始之前我们使用如下命令安装依赖：\n``` php\ncomposer install\n```\n该命令会把依赖组件安装到vendor目录并生成自动加载器。\n安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。\n``` php\n<?php\nnamespace container;\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n    private $_bindings = [];//服务列表\n    private $_instances= [];//已经实例化的服务\n    //获取服务\n    public function get($name,$params=[]){\n        //先从实例化的列表中查找\n        if(isset($this->$_instances[$name])){\n            return $this->$_instances[$name]; \n        }\n        //检测有没有注册该服务\n        if(!isset($this->$_bindings[$name])){\n            return null;\n        }\n        $concrete = $this->$_bindings[$name]['class'];//对象具体注册内容\n        $obj = null;\n        if($concrete instanceof \\Closure){ //匿名函数方式\n            $obj = call_user_func_array($concrete,$params);\n        }elseif(is_string($concrete)){     //字符串方式\n            if(empty($params)){\n                $obj = new $concrete;\n            }else{\n                //带参数的类实例化,使用反射\n                $class = new \\reflectionClass($concrete);\n                $obj = $class->newInstanceArgs($params);\n            }\n        }\n        //如果是共享服务，则写入_instances列表，下次直接取回\n        if($this->_bindings[$name]['shared']==true && $ojb){\n            $this->_instances[$name]=$obj;\n        }\n        return $obj;\n    } \n    //检测是否已经绑定\n    public function has($name){\n        return isset($this->_bindings[$name]) or isset($this->_instances[$name]);\n    }\n    //卸载服务\n    public function remove($name){\n        unset($this->_bindings[$name],$this->_instances[$name]);\n    }\n    //设置服务\n    public function set($name,$class){\n        $this->_registerService($name,$class);\n    }\n    //设置共享服务\n    public function setShared($name,$class){\n        $this->_registerService($name,$class,true);\n    }\n    //注册服务\n    private function _registerService($name,$class,$shared=false){\n        $this->remove($name);\n        if(!($class instanceof \\Closure) && is_object($class)){\n            $this->_instances[$name]=$class;\n        }else{\n            $this->_bindings[$name]=array(\"class\"=>$class,\"shared\"=>$shared); \n        }\n    }\n    //ArrayAccess接口，检测服务是否存在\n    public function offsetExists($offset){\n        return $this->has($offset);\n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetGet($offset){\n       return $this->get($offset); \n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetSet($offset,$value){\n        return $this->set($offset,$value);\n    }\n    //卸载服务\n    public function offsetUnset($offset){\n        return $this->remove($offset);\n    }\n} \n```\n### 提交到packglist\n我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：\n``` git\ngit init\ngit remote add origin https://github.com/nonfu/urlscanner.git\ngit add .\ngit commit -m “urlscanner\"\ngit pull origin master\ngit push origin master\n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/Graychen-Container.gif)\n 然后在Packagist中通过GitHub账户登录，通过https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\n check成功后点击submit即可将组件提交到Packagist：\n ![\"我是傲娇的效果图\"](/assets/blogImg/Packagist.gif)\n## 使用组件\n 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：\n\n composer require graychen/container dev-master\n","slug":"composer包是怎样炼成的","published":1,"updated":"2018-05-27T09:59:36.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si70006th8lvo8czcea","content":"<blockquote>\n<p><strong>Composer</strong>是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 –<a href=\"http://www.phpcomposer.com/\" target=\"_blank\" rel=\"noopener\">Composer中文网</a></p>\n</blockquote>\n<p>关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到<a href=\"https://packagist.org/\" target=\"_blank\" rel=\"noopener\">packgist</a></p>\n<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><h3 id=\"产商名称和包名\"><a href=\"#产商名称和包名\" class=\"headerlink\" title=\"产商名称和包名\"></a>产商名称和包名</h3><p>在设置命名空间之前，先要确定产商名称和包名，类似于<strong>laravel/framework</strong>,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。</p>\n<h3 id=\"文件系统结构\"><a href=\"#文件系统结构\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><ul>\n<li><strong>src</strong>:这个目录用于存放组件的源码   </li>\n<li><strong>tests</strong>:这个目录用于存放测试代码   </li>\n<li><strong>composer.json</strong>:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   </li>\n<li><strong>README.md</strong>:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   </li>\n<li><strong>CONTRIBUTING.md</strong>:这个Markdown文件告知别人如何为这个组件做贡献  </li>\n<li><strong>LICENSE</strong>：纯文本文件，声明组件的软件许可证</li>\n<li><strong>CHANGELOG.md</strong>：Markdown文件，列出组件在每个版本中引入的改动</li>\n</ul>\n<h3 id=\"文件系统结构-1\"><a href=\"#文件系统结构-1\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><p>我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：<br>composer init</p>\n<a id=\"more\"></a>\n<p>然后在终端会让我们按照提示向导一步步填写composer.json内容：<br>最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"graychen/container\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"a container for interface and container\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"license\"</span>: <span class=\"string\">\"MIT\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"authors\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Graychen\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"email\"</span>: <span class=\"string\">\"13780185250@sina.cn\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"minimum-stability\"</span>: <span class=\"string\">\"dev\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"require\"</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"require-dev\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"phpunit/phpunit\"</span> : <span class=\"string\">\"~4.3\"</span> </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"autoload\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\\"</span> : <span class=\"string\">\"src\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"autoload-dev\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\Tests\\\\\"</span>:<span class=\"string\">\"tests/\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：</p>\n<ul>\n<li>name：组件的厂商名和包名，也是Packagist中的组件名</li>\n<li>description：简要说明组件</li>\n<li>keywords：描述属性的关键字</li>\n<li>homepage：组件网站URL</li>\n<li>license：PHP组件采用的软件许可证（更多软件许可证参考：<a href=\"http://choosealicense.com/）\" target=\"_blank\" rel=\"noopener\">http://choosealicense.com/）</a></li>\n<li>authors：作者信息数组</li>\n<li>support：组件用户获取技术支持的方式</li>\n<li>require：组件自身依赖的组件</li>\n<li>require-dev：开发这个组件所需的依赖</li>\n<li>suggest：建议安装的组件</li>\n<li>autoload：告诉Composer自动加载器如何自动加载这个组件</li>\n</ul>\n<p>READEME.md</p>\n<p>通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：</p>\n<ul>\n<li>组件的名称和描述</li>\n<li>安装说明</li>\n<li>使用说明</li>\n<li>测试说明</li>\n<li>贡献方式</li>\n<li>支持资源</li>\n<li>作者信息</li>\n<li>软件许可证</li>\n</ul>\n<p>实现组件</p>\n<p>开始之前我们使用如下命令安装依赖：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer install</span><br></pre></td></tr></table></figure></p>\n<p>该命令会把依赖组件安装到vendor目录并生成自动加载器。<br>安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">container</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> 服务容器</span></span><br><span class=\"line\"><span class=\"comment\">* author Graychen</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $_bindings = [];<span class=\"comment\">//服务列表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></span><br><span class=\"line\">    <span class=\"comment\">//获取服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//先从实例化的列表中查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_instances[$name]))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;$_instances[$name]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//检测有没有注册该服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_bindings[$name]))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $concrete = <span class=\"keyword\">$this</span>-&gt;$_bindings[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></span><br><span class=\"line\">        $obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">            $obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123;     <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">                $obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">                $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">                $obj = $class-&gt;newInstanceArgs($params);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $obj;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">//检测是否已经绑定</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置共享服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注册服务</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;remove($name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_bindings[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"提交到packglist\"><a href=\"#提交到packglist\" class=\"headerlink\" title=\"提交到packglist\"></a>提交到packglist</h3><p>我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin https://github.com/nonfu/urlscanner.git</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “urlscanner&quot;</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/Graychen-Container.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 然后在Packagist中通过GitHub账户登录，通过<a href=\"https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\" target=\"_blank\" rel=\"noopener\">https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：</a><br> check成功后点击submit即可将组件提交到Packagist：<br> <img src=\"/assets/blogImg/Packagist.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"使用组件\"><a href=\"#使用组件\" class=\"headerlink\" title=\"使用组件\"></a>使用组件</h2><p> 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：</p>\n<p> composer require graychen/container dev-master</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>Composer</strong>是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 –<a href=\"http://www.phpcomposer.com/\" target=\"_blank\" rel=\"noopener\">Composer中文网</a></p>\n</blockquote>\n<p>关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到<a href=\"https://packagist.org/\" target=\"_blank\" rel=\"noopener\">packgist</a></p>\n<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><h3 id=\"产商名称和包名\"><a href=\"#产商名称和包名\" class=\"headerlink\" title=\"产商名称和包名\"></a>产商名称和包名</h3><p>在设置命名空间之前，先要确定产商名称和包名，类似于<strong>laravel/framework</strong>,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。</p>\n<h3 id=\"文件系统结构\"><a href=\"#文件系统结构\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><ul>\n<li><strong>src</strong>:这个目录用于存放组件的源码   </li>\n<li><strong>tests</strong>:这个目录用于存放测试代码   </li>\n<li><strong>composer.json</strong>:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   </li>\n<li><strong>README.md</strong>:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   </li>\n<li><strong>CONTRIBUTING.md</strong>:这个Markdown文件告知别人如何为这个组件做贡献  </li>\n<li><strong>LICENSE</strong>：纯文本文件，声明组件的软件许可证</li>\n<li><strong>CHANGELOG.md</strong>：Markdown文件，列出组件在每个版本中引入的改动</li>\n</ul>\n<h3 id=\"文件系统结构-1\"><a href=\"#文件系统结构-1\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><p>我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：<br>composer init</p>","more":"<p>然后在终端会让我们按照提示向导一步步填写composer.json内容：<br>最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"graychen/container\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"a container for interface and container\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"license\"</span>: <span class=\"string\">\"MIT\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"authors\"</span>: [</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Graychen\"</span>,</span><br><span class=\"line\">            <span class=\"string\">\"email\"</span>: <span class=\"string\">\"13780185250@sina.cn\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    <span class=\"string\">\"minimum-stability\"</span>: <span class=\"string\">\"dev\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"require\"</span>: &#123;&#125;,</span><br><span class=\"line\">    <span class=\"string\">\"require-dev\"</span>: &#123;</span><br><span class=\"line\">            <span class=\"string\">\"phpunit/phpunit\"</span> : <span class=\"string\">\"~4.3\"</span> </span><br><span class=\"line\">        &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"autoload\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\\"</span> : <span class=\"string\">\"src\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    <span class=\"string\">\"autoload-dev\"</span>:&#123;</span><br><span class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</span><br><span class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\Tests\\\\\"</span>:<span class=\"string\">\"tests/\"</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：</p>\n<ul>\n<li>name：组件的厂商名和包名，也是Packagist中的组件名</li>\n<li>description：简要说明组件</li>\n<li>keywords：描述属性的关键字</li>\n<li>homepage：组件网站URL</li>\n<li>license：PHP组件采用的软件许可证（更多软件许可证参考：<a href=\"http://choosealicense.com/）\" target=\"_blank\" rel=\"noopener\">http://choosealicense.com/）</a></li>\n<li>authors：作者信息数组</li>\n<li>support：组件用户获取技术支持的方式</li>\n<li>require：组件自身依赖的组件</li>\n<li>require-dev：开发这个组件所需的依赖</li>\n<li>suggest：建议安装的组件</li>\n<li>autoload：告诉Composer自动加载器如何自动加载这个组件</li>\n</ul>\n<p>READEME.md</p>\n<p>通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：</p>\n<ul>\n<li>组件的名称和描述</li>\n<li>安装说明</li>\n<li>使用说明</li>\n<li>测试说明</li>\n<li>贡献方式</li>\n<li>支持资源</li>\n<li>作者信息</li>\n<li>软件许可证</li>\n</ul>\n<p>实现组件</p>\n<p>开始之前我们使用如下命令安装依赖：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer install</span><br></pre></td></tr></table></figure></p>\n<p>该命令会把依赖组件安装到vendor目录并生成自动加载器。<br>安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">container</span>;</span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> 服务容器</span></span><br><span class=\"line\"><span class=\"comment\">* author Graychen</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> $_bindings = [];<span class=\"comment\">//服务列表</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></span><br><span class=\"line\">    <span class=\"comment\">//获取服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//先从实例化的列表中查找</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_instances[$name]))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;$_instances[$name]; </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//检测有没有注册该服务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_bindings[$name]))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $concrete = <span class=\"keyword\">$this</span>-&gt;$_bindings[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></span><br><span class=\"line\">        $obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">            $obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">        &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123;     <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">                $obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">                <span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">                $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">                $obj = $class-&gt;newInstanceArgs($params);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $obj;</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">    <span class=\"comment\">//检测是否已经绑定</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//设置共享服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//注册服务</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;remove($name);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</span><br><span class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_bindings[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared); </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset); </span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"提交到packglist\"><a href=\"#提交到packglist\" class=\"headerlink\" title=\"提交到packglist\"></a>提交到packglist</h3><p>我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">git init</span><br><span class=\"line\">git remote add origin https://github.com/nonfu/urlscanner.git</span><br><span class=\"line\">git add .</span><br><span class=\"line\">git commit -m “urlscanner&quot;</span><br><span class=\"line\">git pull origin master</span><br><span class=\"line\">git push origin master</span><br></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/Graychen-Container.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 然后在Packagist中通过GitHub账户登录，通过<a href=\"https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\" target=\"_blank\" rel=\"noopener\">https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：</a><br> check成功后点击submit即可将组件提交到Packagist：<br> <img src=\"/assets/blogImg/Packagist.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"使用组件\"><a href=\"#使用组件\" class=\"headerlink\" title=\"使用组件\"></a>使用组件</h2><p> 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：</p>\n<p> composer require graychen/container dev-master</p>"},{"title":"gitlab-ci由浅入深","date":"2018-02-11T14:57:07.000Z","_content":"# 概述\n\n持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。\n\n持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.\n\n# 功能\n\n## 持续集成可以实现的功能:\n\n- 代码审核: 自动化代码规范审查, 甚至代码质量检查\n- 自动化测试: 单元测试, 功能测试和验收测试\n- 编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布\n- 构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署\n## 原理\n\nGitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.\nGitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.\nGitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.\n<!--more-->\n在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下\n```\njob-1:\n  script:\n      - echo \"Hello World\"\n```\n      这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\n      script下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n  这样, 一次简单的持续集成已经搞定了.\n\n  如何编写GitLab-CI配置文件\n\n  见文档 如何编写GitLab-CI配置文件\n\n  远程拉取代码\n\n  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新\n\n  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥\n\n  如\n```\n  release-doc:\n      stage: deploy\n          script:\n            - ssh root@$DEPLOY_SERVER \"cd /mnt/data/docker-gollum/wiki && git pull origin master\"\n```\n\n## 关键词\n\n### 根主要关键词一览\n\n|关键词|  含义|    可选 |   备注|\n|--|--|--|--|\n|image  | 声明使用的Docker镜像 |   为空时使用默认镜像 | 该镜像应当满足脚本执行的环境依赖|\n|services   | Docker镜像使用的服务, 通过链接的方式来调用所需服务 | 可空 |   常用于链接数据库|\n|stages  |定义构建阶段  |  为空时, 单纯定义jobs   | 项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务|\n|before_script  | 定义每个job之前执行的脚本  | 可空   | 每个job启动时会先执行该脚本|\n|after_script   | 定义每个job之后执行的脚本  | 可空  |  同上|\n|variables |  定义变量  |  可空  |  同上|\n|cache  | 定义与后续job之间应缓存的文件  | 可空  |  同上|\n### Demo:\n```ci\nimage: aipline\nservices:\n  - mysql\n  - redis\nstages:\n  - build\n  - test\n  - deploy\nbefore_script:\n  - bundle install  \nafter_script:\n  - rm secrets\ncache:\npaths:\n  - binaries/\n  - .config\n```\n## Jobs中的关键词\n### jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\n#### job 这里译为任务\n|关键词 | 含义  |  可选  |  备注|\n|--|--|--|--|\n|image  | 声明任务使用的Docker镜像  |  为空时使用根中的定义  |  该镜像应当满足脚本执行的环境依赖|\n|services   | 任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务  |  可空  |  常用于链接数据库|\n|stage  | 所属构建阶段   | 为空时则不使用stages |   一个任务属于一个构建阶段|\n|before_script  | 定义每个job之前执行的脚本 |  可选  |  如果在job中定义则会覆盖根中的内容|\n|script | 定义每个job执行的脚本  | 必须 |   \n|after_script  |  定义每个job之后执行的脚本 |  可选 |   同上|\n|variables  | 定义任务中使用的变量   | 可选  |  同上|\n|cache  | 定义与后续job之间应缓存的文件 |  可选 |   同上|\n|only   | 指定应用的Git分支 |  可选  | 可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支|\n|except | 排除应用的Git分支 | 可选   | 同上|\n|tags   | 指定执行的GitLab-Runners   | 可选|    通过匹配Runners的标签选定|\n|allow_failure  |  允许失败  |  默认为false 如果允许失败, 本次任务不会影响整个构建的结果|\n|when  |  定义合适执行任务 |   默认为always |   有on_success, on_failure, always or manual可选|\n|dependencies  |  定义合任务所需要的工件|  可空 |   需要首先定义工件|\n|artifacts |  定义工件  |  可空 |   工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压|\n|environment | 定义环境 |   可空 |   在部署任务中, 定义该任务所属的环境|\n\n示例\n``` ci\ninstalling-dependencies:\n  script:\n    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest\n    - composer dump-autoload --optimize\n  artifacts:\n    - name: \"vendor\"\n    - untracked: true\n    - expire_in: 60 mins\n    - paths:\n    - vendor/    \ndeleteocker-build-image:    \n  stage: test\n  only:\n    - master\n  except:\n    - develop\n  tags:\n    - ruby\n    - postgres\n  allow_failure: true\n  dependencies:\n    - installing-dependencies\n  script:        \n    - docker build -t registry.com/mops/image:latest .\n    - docker push registry.com/mops/image:latest \n```\n\n>注意:\njobs的名称不能重名\n同一阶段中的任务, 是并行执行的\n上一阶段所有任务执行完后, 才会进入下一阶段\n定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间\n如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)\n\n###  验证配置文件合法性\n  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证\n##  通过gitlab-ci实现文件的自动部署\n###  实现过程\n  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令\n###  过程\n#### 生成ssh证书\n  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥\n  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys\n#### 添加公钥\n  添加公钥: cat id_rsa.pub >> ~/.ssh/authorized_keys\n  id_rsa.pub为第一步生成的公钥\n  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root\n  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥\n#### 设置CI/CD变量\n  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY\n  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址\n  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令\n  完整代码\n  ```ci\n# 使用alpine镜像, 该镜像很少,只有几兆\nimage: alpine\nstages:\n  - deploy\nbefore_script:\n  # 预先装 ssh-agent\n  - 'which ssh-agent || ( apk update && apk add openssh-client)'\n  # 启动服务\n  - eval $(ssh-agent -s)\n  # 将私钥写入deploy.key 文件\n  - echo \"$SSH_PRIVATE_KEY\" > deploy.key\n  # 配置较低权限\n  - chmod 0600 deploy.key\n  # 注入密钥\n  - ssh-add deploy.key\n  - mkdir -p ~/.ssh    \n  - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n\nrelease-doc:\n  stage: deploy\n  variables:\n    GIT_STRATEGY: none     \n  script:\n    # 连接远程服务器并执行拉取代码的命令\n    - ssh root@$DEPLOY_SERVER \"cd /path/to/wiki && git pull origin master\"\n  only:\n    - master\n  environment:\n    name: production\n    url: http://$DEPLOY_SERVER\n```\n\n\n\n","source":"_posts/gitlab-ci由浅入深.md","raw":"---\ntitle: gitlab-ci由浅入深\ndate: 2018-02-11 22:57:07\ntags:\n---\n# 概述\n\n持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。\n\n持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.\n\n# 功能\n\n## 持续集成可以实现的功能:\n\n- 代码审核: 自动化代码规范审查, 甚至代码质量检查\n- 自动化测试: 单元测试, 功能测试和验收测试\n- 编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布\n- 构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署\n## 原理\n\nGitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.\nGitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.\nGitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.\n<!--more-->\n在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下\n```\njob-1:\n  script:\n      - echo \"Hello World\"\n```\n      这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\n      script下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n  这样, 一次简单的持续集成已经搞定了.\n\n  如何编写GitLab-CI配置文件\n\n  见文档 如何编写GitLab-CI配置文件\n\n  远程拉取代码\n\n  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新\n\n  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥\n\n  如\n```\n  release-doc:\n      stage: deploy\n          script:\n            - ssh root@$DEPLOY_SERVER \"cd /mnt/data/docker-gollum/wiki && git pull origin master\"\n```\n\n## 关键词\n\n### 根主要关键词一览\n\n|关键词|  含义|    可选 |   备注|\n|--|--|--|--|\n|image  | 声明使用的Docker镜像 |   为空时使用默认镜像 | 该镜像应当满足脚本执行的环境依赖|\n|services   | Docker镜像使用的服务, 通过链接的方式来调用所需服务 | 可空 |   常用于链接数据库|\n|stages  |定义构建阶段  |  为空时, 单纯定义jobs   | 项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务|\n|before_script  | 定义每个job之前执行的脚本  | 可空   | 每个job启动时会先执行该脚本|\n|after_script   | 定义每个job之后执行的脚本  | 可空  |  同上|\n|variables |  定义变量  |  可空  |  同上|\n|cache  | 定义与后续job之间应缓存的文件  | 可空  |  同上|\n### Demo:\n```ci\nimage: aipline\nservices:\n  - mysql\n  - redis\nstages:\n  - build\n  - test\n  - deploy\nbefore_script:\n  - bundle install  \nafter_script:\n  - rm secrets\ncache:\npaths:\n  - binaries/\n  - .config\n```\n## Jobs中的关键词\n### jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\n#### job 这里译为任务\n|关键词 | 含义  |  可选  |  备注|\n|--|--|--|--|\n|image  | 声明任务使用的Docker镜像  |  为空时使用根中的定义  |  该镜像应当满足脚本执行的环境依赖|\n|services   | 任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务  |  可空  |  常用于链接数据库|\n|stage  | 所属构建阶段   | 为空时则不使用stages |   一个任务属于一个构建阶段|\n|before_script  | 定义每个job之前执行的脚本 |  可选  |  如果在job中定义则会覆盖根中的内容|\n|script | 定义每个job执行的脚本  | 必须 |   \n|after_script  |  定义每个job之后执行的脚本 |  可选 |   同上|\n|variables  | 定义任务中使用的变量   | 可选  |  同上|\n|cache  | 定义与后续job之间应缓存的文件 |  可选 |   同上|\n|only   | 指定应用的Git分支 |  可选  | 可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支|\n|except | 排除应用的Git分支 | 可选   | 同上|\n|tags   | 指定执行的GitLab-Runners   | 可选|    通过匹配Runners的标签选定|\n|allow_failure  |  允许失败  |  默认为false 如果允许失败, 本次任务不会影响整个构建的结果|\n|when  |  定义合适执行任务 |   默认为always |   有on_success, on_failure, always or manual可选|\n|dependencies  |  定义合任务所需要的工件|  可空 |   需要首先定义工件|\n|artifacts |  定义工件  |  可空 |   工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压|\n|environment | 定义环境 |   可空 |   在部署任务中, 定义该任务所属的环境|\n\n示例\n``` ci\ninstalling-dependencies:\n  script:\n    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest\n    - composer dump-autoload --optimize\n  artifacts:\n    - name: \"vendor\"\n    - untracked: true\n    - expire_in: 60 mins\n    - paths:\n    - vendor/    \ndeleteocker-build-image:    \n  stage: test\n  only:\n    - master\n  except:\n    - develop\n  tags:\n    - ruby\n    - postgres\n  allow_failure: true\n  dependencies:\n    - installing-dependencies\n  script:        \n    - docker build -t registry.com/mops/image:latest .\n    - docker push registry.com/mops/image:latest \n```\n\n>注意:\njobs的名称不能重名\n同一阶段中的任务, 是并行执行的\n上一阶段所有任务执行完后, 才会进入下一阶段\n定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间\n如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)\n\n###  验证配置文件合法性\n  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证\n##  通过gitlab-ci实现文件的自动部署\n###  实现过程\n  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令\n###  过程\n#### 生成ssh证书\n  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥\n  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys\n#### 添加公钥\n  添加公钥: cat id_rsa.pub >> ~/.ssh/authorized_keys\n  id_rsa.pub为第一步生成的公钥\n  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root\n  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥\n#### 设置CI/CD变量\n  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY\n  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址\n  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令\n  完整代码\n  ```ci\n# 使用alpine镜像, 该镜像很少,只有几兆\nimage: alpine\nstages:\n  - deploy\nbefore_script:\n  # 预先装 ssh-agent\n  - 'which ssh-agent || ( apk update && apk add openssh-client)'\n  # 启动服务\n  - eval $(ssh-agent -s)\n  # 将私钥写入deploy.key 文件\n  - echo \"$SSH_PRIVATE_KEY\" > deploy.key\n  # 配置较低权限\n  - chmod 0600 deploy.key\n  # 注入密钥\n  - ssh-add deploy.key\n  - mkdir -p ~/.ssh    \n  - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n\nrelease-doc:\n  stage: deploy\n  variables:\n    GIT_STRATEGY: none     \n  script:\n    # 连接远程服务器并执行拉取代码的命令\n    - ssh root@$DEPLOY_SERVER \"cd /path/to/wiki && git pull origin master\"\n  only:\n    - master\n  environment:\n    name: production\n    url: http://$DEPLOY_SERVER\n```\n\n\n\n","slug":"gitlab-ci由浅入深","published":1,"updated":"2018-05-27T09:59:36.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si70007th8lp6qaar6k","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。</p>\n<p>持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.</p>\n<h1 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h1><h2 id=\"持续集成可以实现的功能\"><a href=\"#持续集成可以实现的功能\" class=\"headerlink\" title=\"持续集成可以实现的功能:\"></a>持续集成可以实现的功能:</h2><ul>\n<li>代码审核: 自动化代码规范审查, 甚至代码质量检查</li>\n<li>自动化测试: 单元测试, 功能测试和验收测试</li>\n<li>编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布</li>\n<li>构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2></li>\n</ul>\n<p>GitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.<br>GitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.<br>GitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.<br><a id=\"more\"></a><br>在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">job-1:</span><br><span class=\"line\">  script:</span><br><span class=\"line\">      - echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p>\n<pre><code>这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\nscript下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n</code></pre><p>  这样, 一次简单的持续集成已经搞定了.</p>\n<p>  如何编写GitLab-CI配置文件</p>\n<p>  见文档 如何编写GitLab-CI配置文件</p>\n<p>  远程拉取代码</p>\n<p>  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新</p>\n<p>  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥</p>\n<p>  如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">release-doc:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">        script:</span><br><span class=\"line\">          - ssh root@$DEPLOY_SERVER &quot;cd /mnt/data/docker-gollum/wiki &amp;&amp; git pull origin master&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h2><h3 id=\"根主要关键词一览\"><a href=\"#根主要关键词一览\" class=\"headerlink\" title=\"根主要关键词一览\"></a>根主要关键词一览</h3><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明使用的Docker镜像</td>\n<td>为空时使用默认镜像</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stages</td>\n<td>定义构建阶段</td>\n<td>为空时, 单纯定义jobs</td>\n<td>项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可空</td>\n<td>每个job启动时会先执行该脚本</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义变量</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo:\"></a>Demo:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image: aipline</span><br><span class=\"line\">services:</span><br><span class=\"line\">  - mysql</span><br><span class=\"line\">  - redis</span><br><span class=\"line\">stages:</span><br><span class=\"line\">  - build</span><br><span class=\"line\">  - test</span><br><span class=\"line\">  - deploy</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">  - bundle install  </span><br><span class=\"line\">after_script:</span><br><span class=\"line\">  - rm secrets</span><br><span class=\"line\">cache:</span><br><span class=\"line\">paths:</span><br><span class=\"line\">  - binaries/</span><br><span class=\"line\">  - .config</span><br></pre></td></tr></table></figure>\n<h2 id=\"Jobs中的关键词\"><a href=\"#Jobs中的关键词\" class=\"headerlink\" title=\"Jobs中的关键词\"></a>Jobs中的关键词</h2><h3 id=\"jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\"><a href=\"#jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\" class=\"headerlink\" title=\"jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\"></a>jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行</h3><h4 id=\"job-这里译为任务\"><a href=\"#job-这里译为任务\" class=\"headerlink\" title=\"job 这里译为任务\"></a>job 这里译为任务</h4><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明任务使用的Docker镜像</td>\n<td>为空时使用根中的定义</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stage</td>\n<td>所属构建阶段</td>\n<td>为空时则不使用stages</td>\n<td>一个任务属于一个构建阶段</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可选</td>\n<td>如果在job中定义则会覆盖根中的内容</td>\n</tr>\n<tr>\n<td>script</td>\n<td>定义每个job执行的脚本</td>\n<td>必须</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义任务中使用的变量</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>only</td>\n<td>指定应用的Git分支</td>\n<td>可选</td>\n<td>可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支</td>\n</tr>\n<tr>\n<td>except</td>\n<td>排除应用的Git分支</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>指定执行的GitLab-Runners</td>\n<td>可选</td>\n<td>通过匹配Runners的标签选定</td>\n</tr>\n<tr>\n<td>allow_failure</td>\n<td>允许失败</td>\n<td>默认为false 如果允许失败, 本次任务不会影响整个构建的结果</td>\n</tr>\n<tr>\n<td>when</td>\n<td>定义合适执行任务</td>\n<td>默认为always</td>\n<td>有on_success, on_failure, always or manual可选</td>\n</tr>\n<tr>\n<td>dependencies</td>\n<td>定义合任务所需要的工件</td>\n<td>可空</td>\n<td>需要首先定义工件</td>\n</tr>\n<tr>\n<td>artifacts</td>\n<td>定义工件</td>\n<td>可空</td>\n<td>工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压</td>\n</tr>\n<tr>\n<td>environment</td>\n<td>定义环境</td>\n<td>可空</td>\n<td>在部署任务中, 定义该任务所属的环境</td>\n</tr>\n</tbody>\n</table>\n<p>示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">installing-dependencies:</span><br><span class=\"line\">  script:</span><br><span class=\"line\">    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest</span><br><span class=\"line\">    - composer dump-autoload --optimize</span><br><span class=\"line\">  artifacts:</span><br><span class=\"line\">    - name: &quot;vendor&quot;</span><br><span class=\"line\">    - untracked: true</span><br><span class=\"line\">    - expire_in: 60 mins</span><br><span class=\"line\">    - paths:</span><br><span class=\"line\">    - vendor/    </span><br><span class=\"line\">deleteocker-build-image:    </span><br><span class=\"line\">  stage: test</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\">  except:</span><br><span class=\"line\">    - develop</span><br><span class=\"line\">  tags:</span><br><span class=\"line\">    - ruby</span><br><span class=\"line\">    - postgres</span><br><span class=\"line\">  allow_failure: true</span><br><span class=\"line\">  dependencies:</span><br><span class=\"line\">    - installing-dependencies</span><br><span class=\"line\">  script:        </span><br><span class=\"line\">    - docker build -t registry.com/mops/image:latest .</span><br><span class=\"line\">    - docker push registry.com/mops/image:latest</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意:<br>jobs的名称不能重名<br>同一阶段中的任务, 是并行执行的<br>上一阶段所有任务执行完后, 才会进入下一阶段<br>定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间<br>如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)</p>\n</blockquote>\n<h3 id=\"验证配置文件合法性\"><a href=\"#验证配置文件合法性\" class=\"headerlink\" title=\"验证配置文件合法性\"></a>验证配置文件合法性</h3><p>  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证</p>\n<h2 id=\"通过gitlab-ci实现文件的自动部署\"><a href=\"#通过gitlab-ci实现文件的自动部署\" class=\"headerlink\" title=\"通过gitlab-ci实现文件的自动部署\"></a>通过gitlab-ci实现文件的自动部署</h2><h3 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h3><p>  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><h4 id=\"生成ssh证书\"><a href=\"#生成ssh证书\" class=\"headerlink\" title=\"生成ssh证书\"></a>生成ssh证书</h4><p>  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥<br>  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys</p>\n<h4 id=\"添加公钥\"><a href=\"#添加公钥\" class=\"headerlink\" title=\"添加公钥\"></a>添加公钥</h4><p>  添加公钥: cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>  id_rsa.pub为第一步生成的公钥<br>  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root<br>  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥</p>\n<h4 id=\"设置CI-CD变量\"><a href=\"#设置CI-CD变量\" class=\"headerlink\" title=\"设置CI/CD变量\"></a>设置CI/CD变量</h4><p>  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY<br>  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址<br>  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令<br>  完整代码<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用alpine镜像, 该镜像很少,只有几兆</span><br><span class=\"line\">image: alpine</span><br><span class=\"line\">stages:</span><br><span class=\"line\">  - deploy</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">  # 预先装 ssh-agent</span><br><span class=\"line\">  - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class=\"line\">  # 启动服务</span><br><span class=\"line\">  - eval $(ssh-agent -s)</span><br><span class=\"line\">  # 将私钥写入deploy.key 文件</span><br><span class=\"line\">  - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; deploy.key</span><br><span class=\"line\">  # 配置较低权限</span><br><span class=\"line\">  - chmod 0600 deploy.key</span><br><span class=\"line\">  # 注入密钥</span><br><span class=\"line\">  - ssh-add deploy.key</span><br><span class=\"line\">  - mkdir -p ~/.ssh    </span><br><span class=\"line\">  - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">release-doc:</span><br><span class=\"line\">  stage: deploy</span><br><span class=\"line\">  variables:</span><br><span class=\"line\">    GIT_STRATEGY: none     </span><br><span class=\"line\">  script:</span><br><span class=\"line\">    # 连接远程服务器并执行拉取代码的命令</span><br><span class=\"line\">    - ssh root@$DEPLOY_SERVER &quot;cd /path/to/wiki &amp;&amp; git pull origin master&quot;</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\">  environment:</span><br><span class=\"line\">    name: production</span><br><span class=\"line\">    url: http://$DEPLOY_SERVER</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。</p>\n<p>持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.</p>\n<h1 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h1><h2 id=\"持续集成可以实现的功能\"><a href=\"#持续集成可以实现的功能\" class=\"headerlink\" title=\"持续集成可以实现的功能:\"></a>持续集成可以实现的功能:</h2><ul>\n<li>代码审核: 自动化代码规范审查, 甚至代码质量检查</li>\n<li>自动化测试: 单元测试, 功能测试和验收测试</li>\n<li>编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布</li>\n<li>构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2></li>\n</ul>\n<p>GitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.<br>GitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.<br>GitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.<br>","more":"<br>在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">job-1:</span><br><span class=\"line\">  script:</span><br><span class=\"line\">      - echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p>\n<pre><code>这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\nscript下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n</code></pre><p>  这样, 一次简单的持续集成已经搞定了.</p>\n<p>  如何编写GitLab-CI配置文件</p>\n<p>  见文档 如何编写GitLab-CI配置文件</p>\n<p>  远程拉取代码</p>\n<p>  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新</p>\n<p>  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥</p>\n<p>  如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">release-doc:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">        script:</span><br><span class=\"line\">          - ssh root@$DEPLOY_SERVER &quot;cd /mnt/data/docker-gollum/wiki &amp;&amp; git pull origin master&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h2><h3 id=\"根主要关键词一览\"><a href=\"#根主要关键词一览\" class=\"headerlink\" title=\"根主要关键词一览\"></a>根主要关键词一览</h3><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明使用的Docker镜像</td>\n<td>为空时使用默认镜像</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stages</td>\n<td>定义构建阶段</td>\n<td>为空时, 单纯定义jobs</td>\n<td>项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可空</td>\n<td>每个job启动时会先执行该脚本</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义变量</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo:\"></a>Demo:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image: aipline</span><br><span class=\"line\">services:</span><br><span class=\"line\">  - mysql</span><br><span class=\"line\">  - redis</span><br><span class=\"line\">stages:</span><br><span class=\"line\">  - build</span><br><span class=\"line\">  - test</span><br><span class=\"line\">  - deploy</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">  - bundle install  </span><br><span class=\"line\">after_script:</span><br><span class=\"line\">  - rm secrets</span><br><span class=\"line\">cache:</span><br><span class=\"line\">paths:</span><br><span class=\"line\">  - binaries/</span><br><span class=\"line\">  - .config</span><br></pre></td></tr></table></figure>\n<h2 id=\"Jobs中的关键词\"><a href=\"#Jobs中的关键词\" class=\"headerlink\" title=\"Jobs中的关键词\"></a>Jobs中的关键词</h2><h3 id=\"jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\"><a href=\"#jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\" class=\"headerlink\" title=\"jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\"></a>jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行</h3><h4 id=\"job-这里译为任务\"><a href=\"#job-这里译为任务\" class=\"headerlink\" title=\"job 这里译为任务\"></a>job 这里译为任务</h4><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明任务使用的Docker镜像</td>\n<td>为空时使用根中的定义</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stage</td>\n<td>所属构建阶段</td>\n<td>为空时则不使用stages</td>\n<td>一个任务属于一个构建阶段</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可选</td>\n<td>如果在job中定义则会覆盖根中的内容</td>\n</tr>\n<tr>\n<td>script</td>\n<td>定义每个job执行的脚本</td>\n<td>必须</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义任务中使用的变量</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>only</td>\n<td>指定应用的Git分支</td>\n<td>可选</td>\n<td>可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支</td>\n</tr>\n<tr>\n<td>except</td>\n<td>排除应用的Git分支</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>指定执行的GitLab-Runners</td>\n<td>可选</td>\n<td>通过匹配Runners的标签选定</td>\n</tr>\n<tr>\n<td>allow_failure</td>\n<td>允许失败</td>\n<td>默认为false 如果允许失败, 本次任务不会影响整个构建的结果</td>\n</tr>\n<tr>\n<td>when</td>\n<td>定义合适执行任务</td>\n<td>默认为always</td>\n<td>有on_success, on_failure, always or manual可选</td>\n</tr>\n<tr>\n<td>dependencies</td>\n<td>定义合任务所需要的工件</td>\n<td>可空</td>\n<td>需要首先定义工件</td>\n</tr>\n<tr>\n<td>artifacts</td>\n<td>定义工件</td>\n<td>可空</td>\n<td>工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压</td>\n</tr>\n<tr>\n<td>environment</td>\n<td>定义环境</td>\n<td>可空</td>\n<td>在部署任务中, 定义该任务所属的环境</td>\n</tr>\n</tbody>\n</table>\n<p>示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">installing-dependencies:</span><br><span class=\"line\">  script:</span><br><span class=\"line\">    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest</span><br><span class=\"line\">    - composer dump-autoload --optimize</span><br><span class=\"line\">  artifacts:</span><br><span class=\"line\">    - name: &quot;vendor&quot;</span><br><span class=\"line\">    - untracked: true</span><br><span class=\"line\">    - expire_in: 60 mins</span><br><span class=\"line\">    - paths:</span><br><span class=\"line\">    - vendor/    </span><br><span class=\"line\">deleteocker-build-image:    </span><br><span class=\"line\">  stage: test</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\">  except:</span><br><span class=\"line\">    - develop</span><br><span class=\"line\">  tags:</span><br><span class=\"line\">    - ruby</span><br><span class=\"line\">    - postgres</span><br><span class=\"line\">  allow_failure: true</span><br><span class=\"line\">  dependencies:</span><br><span class=\"line\">    - installing-dependencies</span><br><span class=\"line\">  script:        </span><br><span class=\"line\">    - docker build -t registry.com/mops/image:latest .</span><br><span class=\"line\">    - docker push registry.com/mops/image:latest</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意:<br>jobs的名称不能重名<br>同一阶段中的任务, 是并行执行的<br>上一阶段所有任务执行完后, 才会进入下一阶段<br>定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间<br>如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)</p>\n</blockquote>\n<h3 id=\"验证配置文件合法性\"><a href=\"#验证配置文件合法性\" class=\"headerlink\" title=\"验证配置文件合法性\"></a>验证配置文件合法性</h3><p>  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证</p>\n<h2 id=\"通过gitlab-ci实现文件的自动部署\"><a href=\"#通过gitlab-ci实现文件的自动部署\" class=\"headerlink\" title=\"通过gitlab-ci实现文件的自动部署\"></a>通过gitlab-ci实现文件的自动部署</h2><h3 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h3><p>  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><h4 id=\"生成ssh证书\"><a href=\"#生成ssh证书\" class=\"headerlink\" title=\"生成ssh证书\"></a>生成ssh证书</h4><p>  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥<br>  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys</p>\n<h4 id=\"添加公钥\"><a href=\"#添加公钥\" class=\"headerlink\" title=\"添加公钥\"></a>添加公钥</h4><p>  添加公钥: cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>  id_rsa.pub为第一步生成的公钥<br>  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root<br>  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥</p>\n<h4 id=\"设置CI-CD变量\"><a href=\"#设置CI-CD变量\" class=\"headerlink\" title=\"设置CI/CD变量\"></a>设置CI/CD变量</h4><p>  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY<br>  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址<br>  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令<br>  完整代码<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># 使用alpine镜像, 该镜像很少,只有几兆</span><br><span class=\"line\">image: alpine</span><br><span class=\"line\">stages:</span><br><span class=\"line\">  - deploy</span><br><span class=\"line\">before_script:</span><br><span class=\"line\">  # 预先装 ssh-agent</span><br><span class=\"line\">  - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class=\"line\">  # 启动服务</span><br><span class=\"line\">  - eval $(ssh-agent -s)</span><br><span class=\"line\">  # 将私钥写入deploy.key 文件</span><br><span class=\"line\">  - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; deploy.key</span><br><span class=\"line\">  # 配置较低权限</span><br><span class=\"line\">  - chmod 0600 deploy.key</span><br><span class=\"line\">  # 注入密钥</span><br><span class=\"line\">  - ssh-add deploy.key</span><br><span class=\"line\">  - mkdir -p ~/.ssh    </span><br><span class=\"line\">  - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">release-doc:</span><br><span class=\"line\">  stage: deploy</span><br><span class=\"line\">  variables:</span><br><span class=\"line\">    GIT_STRATEGY: none     </span><br><span class=\"line\">  script:</span><br><span class=\"line\">    # 连接远程服务器并执行拉取代码的命令</span><br><span class=\"line\">    - ssh root@$DEPLOY_SERVER &quot;cd /path/to/wiki &amp;&amp; git pull origin master&quot;</span><br><span class=\"line\">  only:</span><br><span class=\"line\">    - master</span><br><span class=\"line\">  environment:</span><br><span class=\"line\">    name: production</span><br><span class=\"line\">    url: http://$DEPLOY_SERVER</span><br></pre></td></tr></table></figure></p>"},{"title":"git使用规范","date":"2018-02-11T14:30:54.000Z","_content":"# Git工作流程\n\n## 分支\n\n- master: 用于生产环境部署, 只接受合并请求, 不直接提交\n- testing: 用于测试环境测试\n- develop: 用于日常开发主线, 其他分支只能合并到 develop 分支\n- feature-xxx: 用于增加一个新功能\n- hotfix-xxx: 用于修复一个紧急bug\n每次开发新功能，都应该新建一个单独的分支\n## 工作流\n\n- 如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码\n- Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发\n- 开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息\n- 开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库\n## Commit message 和 Change log 编写指南\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从[ Angular 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n### 安装 Commitizen 来格式化 commit , 使其遵循以上规范\n\n首先注意将package.json和node_modules加入.gitignore文件\n全局安装commitizen: `npm install -g commitizen`\n在项目根目录初始化package.json: `npm init --yes`\n项目根目录运行 `commitizen init cz-conventional-changelog --save --save-exact`\n每次提交代码时, 用 `git cz` 代替` git commit`\n<!-- more -->\n## 自动生成 Change log\n\n安装 `npm install -g conventional-changelog-cli`\n使用`conventional-changelog`生成日志: `conventional-changelog -p angular -i CHANGELOG.md -s -r 0`\n## 版本号使用规范\n\n版本号遵循语义化版本规范.\n\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n\n主版本号：当你做了不兼容的 API 修改，\n次版本号：当你做了向下兼容的功能性新增，\n修订号：当你做了向下兼容的问题修正。\n先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n更多内容参见 [语义化版本](http://semver.org/lang/zh-CN/)\n\n## 参考资料\n\n[Git 使用规范流程](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)\n[Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n[Git commit message 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n","source":"_posts/git使用规范.md","raw":"---\ntitle: git使用规范\ndate: 2018-02-11 22:30:54\ntags: 技术 php\n---\n# Git工作流程\n\n## 分支\n\n- master: 用于生产环境部署, 只接受合并请求, 不直接提交\n- testing: 用于测试环境测试\n- develop: 用于日常开发主线, 其他分支只能合并到 develop 分支\n- feature-xxx: 用于增加一个新功能\n- hotfix-xxx: 用于修复一个紧急bug\n每次开发新功能，都应该新建一个单独的分支\n## 工作流\n\n- 如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码\n- Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发\n- 开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息\n- 开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库\n## Commit message 和 Change log 编写指南\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从[ Angular 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n### 安装 Commitizen 来格式化 commit , 使其遵循以上规范\n\n首先注意将package.json和node_modules加入.gitignore文件\n全局安装commitizen: `npm install -g commitizen`\n在项目根目录初始化package.json: `npm init --yes`\n项目根目录运行 `commitizen init cz-conventional-changelog --save --save-exact`\n每次提交代码时, 用 `git cz` 代替` git commit`\n<!-- more -->\n## 自动生成 Change log\n\n安装 `npm install -g conventional-changelog-cli`\n使用`conventional-changelog`生成日志: `conventional-changelog -p angular -i CHANGELOG.md -s -r 0`\n## 版本号使用规范\n\n版本号遵循语义化版本规范.\n\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n\n主版本号：当你做了不兼容的 API 修改，\n次版本号：当你做了向下兼容的功能性新增，\n修订号：当你做了向下兼容的问题修正。\n先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n更多内容参见 [语义化版本](http://semver.org/lang/zh-CN/)\n\n## 参考资料\n\n[Git 使用规范流程](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)\n[Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n[Git commit message 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n","slug":"git使用规范","published":1,"updated":"2018-05-27T09:59:36.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si80008th8lk6ifrt7l","content":"<h1 id=\"Git工作流程\"><a href=\"#Git工作流程\" class=\"headerlink\" title=\"Git工作流程\"></a>Git工作流程</h1><h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><ul>\n<li>master: 用于生产环境部署, 只接受合并请求, 不直接提交</li>\n<li>testing: 用于测试环境测试</li>\n<li>develop: 用于日常开发主线, 其他分支只能合并到 develop 分支</li>\n<li>feature-xxx: 用于增加一个新功能</li>\n<li><p>hotfix-xxx: 用于修复一个紧急bug<br>每次开发新功能，都应该新建一个单独的分支</p>\n<h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2></li>\n<li><p>如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码</p>\n</li>\n<li>Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发</li>\n<li>开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息</li>\n<li>开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库<h2 id=\"Commit-message-和-Change-log-编写指南\"><a href=\"#Commit-message-和-Change-log-编写指南\" class=\"headerlink\" title=\"Commit message 和 Change log 编写指南\"></a>Commit message 和 Change log 编写指南</h2></li>\n</ul>\n<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从<a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\"> Angular 规范</a></p>\n<h3 id=\"安装-Commitizen-来格式化-commit-使其遵循以上规范\"><a href=\"#安装-Commitizen-来格式化-commit-使其遵循以上规范\" class=\"headerlink\" title=\"安装 Commitizen 来格式化 commit , 使其遵循以上规范\"></a>安装 Commitizen 来格式化 commit , 使其遵循以上规范</h3><p>首先注意将package.json和node_modules加入.gitignore文件<br>全局安装commitizen: <code>npm install -g commitizen</code><br>在项目根目录初始化package.json: <code>npm init --yes</code><br>项目根目录运行 <code>commitizen init cz-conventional-changelog --save --save-exact</code><br>每次提交代码时, 用 <code>git cz</code> 代替<code>git commit</code><br><a id=\"more\"></a></p>\n<h2 id=\"自动生成-Change-log\"><a href=\"#自动生成-Change-log\" class=\"headerlink\" title=\"自动生成 Change log\"></a>自动生成 Change log</h2><p>安装 <code>npm install -g conventional-changelog-cli</code><br>使用<code>conventional-changelog</code>生成日志: <code>conventional-changelog -p angular -i CHANGELOG.md -s -r 0</code></p>\n<h2 id=\"版本号使用规范\"><a href=\"#版本号使用规范\" class=\"headerlink\" title=\"版本号使用规范\"></a>版本号使用规范</h2><p>版本号遵循语义化版本规范.</p>\n<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>\n<p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n<p>更多内容参见 <a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义化版本</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.ruanyifeng.com/blog/2015/08/git-use-process.html\" target=\"_blank\" rel=\"noopener\">Git 使用规范流程</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">Commit message 和 Change log 编写指南</a><br><a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\">Git commit message 规范</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Git工作流程\"><a href=\"#Git工作流程\" class=\"headerlink\" title=\"Git工作流程\"></a>Git工作流程</h1><h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><ul>\n<li>master: 用于生产环境部署, 只接受合并请求, 不直接提交</li>\n<li>testing: 用于测试环境测试</li>\n<li>develop: 用于日常开发主线, 其他分支只能合并到 develop 分支</li>\n<li>feature-xxx: 用于增加一个新功能</li>\n<li><p>hotfix-xxx: 用于修复一个紧急bug<br>每次开发新功能，都应该新建一个单独的分支</p>\n<h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2></li>\n<li><p>如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码</p>\n</li>\n<li>Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发</li>\n<li>开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息</li>\n<li>开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库<h2 id=\"Commit-message-和-Change-log-编写指南\"><a href=\"#Commit-message-和-Change-log-编写指南\" class=\"headerlink\" title=\"Commit message 和 Change log 编写指南\"></a>Commit message 和 Change log 编写指南</h2></li>\n</ul>\n<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从<a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\"> Angular 规范</a></p>\n<h3 id=\"安装-Commitizen-来格式化-commit-使其遵循以上规范\"><a href=\"#安装-Commitizen-来格式化-commit-使其遵循以上规范\" class=\"headerlink\" title=\"安装 Commitizen 来格式化 commit , 使其遵循以上规范\"></a>安装 Commitizen 来格式化 commit , 使其遵循以上规范</h3><p>首先注意将package.json和node_modules加入.gitignore文件<br>全局安装commitizen: <code>npm install -g commitizen</code><br>在项目根目录初始化package.json: <code>npm init --yes</code><br>项目根目录运行 <code>commitizen init cz-conventional-changelog --save --save-exact</code><br>每次提交代码时, 用 <code>git cz</code> 代替<code>git commit</code><br>","more":"</p>\n<h2 id=\"自动生成-Change-log\"><a href=\"#自动生成-Change-log\" class=\"headerlink\" title=\"自动生成 Change log\"></a>自动生成 Change log</h2><p>安装 <code>npm install -g conventional-changelog-cli</code><br>使用<code>conventional-changelog</code>生成日志: <code>conventional-changelog -p angular -i CHANGELOG.md -s -r 0</code></p>\n<h2 id=\"版本号使用规范\"><a href=\"#版本号使用规范\" class=\"headerlink\" title=\"版本号使用规范\"></a>版本号使用规范</h2><p>版本号遵循语义化版本规范.</p>\n<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>\n<p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n<p>更多内容参见 <a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义化版本</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.ruanyifeng.com/blog/2015/08/git-use-process.html\" target=\"_blank\" rel=\"noopener\">Git 使用规范流程</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">Commit message 和 Change log 编写指南</a><br><a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\">Git commit message 规范</a></p>"},{"title":"mac终端走shadowsocks代理","date":"2019-08-22T03:44:23.000Z","_content":"shadowsocks设置为：\n\n打开shadowsocks\n自动代理模式\n服务器（香港阿里云）\n以zsh作为说明\n``` bash\n➜  ~ vim ~/.zshrc\n```\n添加如下代理配置:\n\n# proxy list\n``` bash\nalias proxy='export all_proxy=socks5://127.0.0.1:1080'\nalias unproxy='unset all_proxy'\n:wq保存退出\n➜  ~ source ~/.zshrc\n```\n使用proxy前先查看下当前的ip地址：\n\n``` bash\n➜  ~ curl ip.cn\n当前 IP：112.64.xxx.xx 来自：上海市 联通\n或者\n~ curl cip.cc\nIP\t: 140.206.97.42\n地址\t: 中国  上海\n\n数据二\t: 上海市 | 联通\n\nURL\t: http://www.cip.cc/140.206.97.42\n执行:\n\n➜  ~ proxy\n➜  ~ curl ip.cn\n当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云\n如果ip.cn不能用，可以换个类似的站点查询\n~ curl cip.cc\nIP\t: 45.78.47.19\n地址\t: 美国  加利福尼亚\n\n数据二\t: 美国 | 加利福尼亚州洛杉矶市 IT7 Networks\n\nURL\t: http://www.cip.cc/45.78.47.19\n```\n没问题，终端走了代理，brew update顺畅了- -\n","source":"_posts/mac终端走shadowsocks代理.md","raw":"---\ntitle: mac终端走shadowsocks代理\ndate: 2019-08-22 11:44:23\ntags: 技术\n---\nshadowsocks设置为：\n\n打开shadowsocks\n自动代理模式\n服务器（香港阿里云）\n以zsh作为说明\n``` bash\n➜  ~ vim ~/.zshrc\n```\n添加如下代理配置:\n\n# proxy list\n``` bash\nalias proxy='export all_proxy=socks5://127.0.0.1:1080'\nalias unproxy='unset all_proxy'\n:wq保存退出\n➜  ~ source ~/.zshrc\n```\n使用proxy前先查看下当前的ip地址：\n\n``` bash\n➜  ~ curl ip.cn\n当前 IP：112.64.xxx.xx 来自：上海市 联通\n或者\n~ curl cip.cc\nIP\t: 140.206.97.42\n地址\t: 中国  上海\n\n数据二\t: 上海市 | 联通\n\nURL\t: http://www.cip.cc/140.206.97.42\n执行:\n\n➜  ~ proxy\n➜  ~ curl ip.cn\n当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云\n如果ip.cn不能用，可以换个类似的站点查询\n~ curl cip.cc\nIP\t: 45.78.47.19\n地址\t: 美国  加利福尼亚\n\n数据二\t: 美国 | 加利福尼亚州洛杉矶市 IT7 Networks\n\nURL\t: http://www.cip.cc/45.78.47.19\n```\n没问题，终端走了代理，brew update顺畅了- -\n","slug":"mac终端走shadowsocks代理","published":1,"updated":"2019-08-22T05:32:02.065Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00si90009th8lo45jv2j4","content":"<p>shadowsocks设置为：</p>\n<p>打开shadowsocks<br>自动代理模式<br>服务器（香港阿里云）<br>以zsh作为说明<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ vim ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>添加如下代理配置:</p>\n<h1 id=\"proxy-list\"><a href=\"#proxy-list\" class=\"headerlink\" title=\"proxy list\"></a>proxy list</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> proxy=<span class=\"string\">'export all_proxy=socks5://127.0.0.1:1080'</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> unproxy=<span class=\"string\">'unset all_proxy'</span></span><br><span class=\"line\">:wq保存退出</span><br><span class=\"line\">➜  ~ <span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>使用proxy前先查看下当前的ip地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ curl ip.cn</span><br><span class=\"line\">当前 IP：112.64.xxx.xx 来自：上海市 联通</span><br><span class=\"line\">或者</span><br><span class=\"line\">~ curl cip.cc</span><br><span class=\"line\">IP\t: 140.206.97.42</span><br><span class=\"line\">地址\t: 中国  上海</span><br><span class=\"line\"></span><br><span class=\"line\">数据二\t: 上海市 | 联通</span><br><span class=\"line\"></span><br><span class=\"line\">URL\t: http://www.cip.cc/140.206.97.42</span><br><span class=\"line\">执行:</span><br><span class=\"line\"></span><br><span class=\"line\">➜  ~ proxy</span><br><span class=\"line\">➜  ~ curl ip.cn</span><br><span class=\"line\">当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云</span><br><span class=\"line\">如果ip.cn不能用，可以换个类似的站点查询</span><br><span class=\"line\">~ curl cip.cc</span><br><span class=\"line\">IP\t: 45.78.47.19</span><br><span class=\"line\">地址\t: 美国  加利福尼亚</span><br><span class=\"line\"></span><br><span class=\"line\">数据二\t: 美国 | 加利福尼亚州洛杉矶市 IT7 Networks</span><br><span class=\"line\"></span><br><span class=\"line\">URL\t: http://www.cip.cc/45.78.47.19</span><br></pre></td></tr></table></figure>\n<p>没问题，终端走了代理，brew update顺畅了- -</p>\n","site":{"data":{}},"excerpt":"","more":"<p>shadowsocks设置为：</p>\n<p>打开shadowsocks<br>自动代理模式<br>服务器（香港阿里云）<br>以zsh作为说明<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ vim ~/.zshrc</span><br></pre></td></tr></table></figure></p>\n<p>添加如下代理配置:</p>\n<h1 id=\"proxy-list\"><a href=\"#proxy-list\" class=\"headerlink\" title=\"proxy list\"></a>proxy list</h1><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">alias</span> proxy=<span class=\"string\">'export all_proxy=socks5://127.0.0.1:1080'</span></span><br><span class=\"line\"><span class=\"built_in\">alias</span> unproxy=<span class=\"string\">'unset all_proxy'</span></span><br><span class=\"line\">:wq保存退出</span><br><span class=\"line\">➜  ~ <span class=\"built_in\">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure>\n<p>使用proxy前先查看下当前的ip地址：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">➜  ~ curl ip.cn</span><br><span class=\"line\">当前 IP：112.64.xxx.xx 来自：上海市 联通</span><br><span class=\"line\">或者</span><br><span class=\"line\">~ curl cip.cc</span><br><span class=\"line\">IP\t: 140.206.97.42</span><br><span class=\"line\">地址\t: 中国  上海</span><br><span class=\"line\"></span><br><span class=\"line\">数据二\t: 上海市 | 联通</span><br><span class=\"line\"></span><br><span class=\"line\">URL\t: http://www.cip.cc/140.206.97.42</span><br><span class=\"line\">执行:</span><br><span class=\"line\"></span><br><span class=\"line\">➜  ~ proxy</span><br><span class=\"line\">➜  ~ curl ip.cn</span><br><span class=\"line\">当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云</span><br><span class=\"line\">如果ip.cn不能用，可以换个类似的站点查询</span><br><span class=\"line\">~ curl cip.cc</span><br><span class=\"line\">IP\t: 45.78.47.19</span><br><span class=\"line\">地址\t: 美国  加利福尼亚</span><br><span class=\"line\"></span><br><span class=\"line\">数据二\t: 美国 | 加利福尼亚州洛杉矶市 IT7 Networks</span><br><span class=\"line\"></span><br><span class=\"line\">URL\t: http://www.cip.cc/45.78.47.19</span><br></pre></td></tr></table></figure>\n<p>没问题，终端走了代理，brew update顺畅了- -</p>\n"},{"title":"mac下配置vscode的xdebug","date":"2019-08-21T10:39:44.000Z","_content":"# 最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\n## 首先下载xdebug的扩展\n\n``` php\npecl install xdebug\n```\n### 配置php.ini\n``` php\nzend_extension=\"xdebug.so\"\nxdebug.profiler_enable = on\nxdebug.trace_output_dir = \"/data/logs/xdebug\"\nxdebug.profile_output_dir = \"/data/logs/xdebug\"\nxdebug.remote_enable = 1\nxdebug.remote_autostart = 1\nxdebug.remote_host = \"localhost\"\nxdebug.remote_port = 9000\nxdebug.idekey = \"phpStorm\"\n ```\n### 保存并退出，重启php-fpm \n ``` php\n brew services restart php72\n```\n## 二、VS Code 配置\n1.安装 PHP Debug 扩展\n2.左侧调试按钮 - 左侧顶部调试[Listen for XDebug]，设置\n``` php\n{\n    // 使用 IntelliSense 了解相关属性。 \n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n    {\n        \"name\": \"Listen for Xdebug\",\n        \"type\": \"php\",\n        \"request\": \"launch\",\n        \"port\": 9000\n    },\n    {\n        \"name\": \"Launch currently open script\",\n        \"type\": \"php\",\n        \"request\": \"launch\",\n        \"program\": \"${file}\",\n        \"cwd\": \"${fileDirname}\",\n        \"port\": 9001\n    }\n    ]\n}\n ```\n## 然后就可以利用xdebug调试php了\n","source":"_posts/mac下配置vscode的xdebug.md","raw":"---\ntitle: mac下配置vscode的xdebug\ndate: 2019-08-21 18:39:44\ntags: 技术\n---\n# 最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\n## 首先下载xdebug的扩展\n\n``` php\npecl install xdebug\n```\n### 配置php.ini\n``` php\nzend_extension=\"xdebug.so\"\nxdebug.profiler_enable = on\nxdebug.trace_output_dir = \"/data/logs/xdebug\"\nxdebug.profile_output_dir = \"/data/logs/xdebug\"\nxdebug.remote_enable = 1\nxdebug.remote_autostart = 1\nxdebug.remote_host = \"localhost\"\nxdebug.remote_port = 9000\nxdebug.idekey = \"phpStorm\"\n ```\n### 保存并退出，重启php-fpm \n ``` php\n brew services restart php72\n```\n## 二、VS Code 配置\n1.安装 PHP Debug 扩展\n2.左侧调试按钮 - 左侧顶部调试[Listen for XDebug]，设置\n``` php\n{\n    // 使用 IntelliSense 了解相关属性。 \n    // 悬停以查看现有属性的描述。\n    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387\n    \"version\": \"0.2.0\",\n    \"configurations\": [\n    {\n        \"name\": \"Listen for Xdebug\",\n        \"type\": \"php\",\n        \"request\": \"launch\",\n        \"port\": 9000\n    },\n    {\n        \"name\": \"Launch currently open script\",\n        \"type\": \"php\",\n        \"request\": \"launch\",\n        \"program\": \"${file}\",\n        \"cwd\": \"${fileDirname}\",\n        \"port\": 9001\n    }\n    ]\n}\n ```\n## 然后就可以利用xdebug调试php了\n","slug":"mac下配置vscode的xdebug","published":1,"updated":"2019-08-22T05:26:09.383Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sib000ath8lx7l9gj3r","content":"<h1 id=\"最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\"><a href=\"#最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\" class=\"headerlink\" title=\"最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\"></a>最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路</h1><h2 id=\"首先下载xdebug的扩展\"><a href=\"#首先下载xdebug的扩展\" class=\"headerlink\" title=\"首先下载xdebug的扩展\"></a>首先下载xdebug的扩展</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pecl install xdebug</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置php-ini\"><a href=\"#配置php-ini\" class=\"headerlink\" title=\"配置php.ini\"></a>配置php.ini</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zend_extension=<span class=\"string\">\"xdebug.so\"</span></span><br><span class=\"line\">xdebug.profiler_enable = on</span><br><span class=\"line\">xdebug.trace_output_dir = <span class=\"string\">\"/data/logs/xdebug\"</span></span><br><span class=\"line\">xdebug.profile_output_dir = <span class=\"string\">\"/data/logs/xdebug\"</span></span><br><span class=\"line\">xdebug.remote_enable = <span class=\"number\">1</span></span><br><span class=\"line\">xdebug.remote_autostart = <span class=\"number\">1</span></span><br><span class=\"line\">xdebug.remote_host = <span class=\"string\">\"localhost\"</span></span><br><span class=\"line\">xdebug.remote_port = <span class=\"number\">9000</span></span><br><span class=\"line\">xdebug.idekey = <span class=\"string\">\"phpStorm\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"保存并退出，重启php-fpm\"><a href=\"#保存并退出，重启php-fpm\" class=\"headerlink\" title=\"保存并退出，重启php-fpm\"></a>保存并退出，重启php-fpm</h3> <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew services restart php72</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、VS-Code-配置\"><a href=\"#二、VS-Code-配置\" class=\"headerlink\" title=\"二、VS Code 配置\"></a>二、VS Code 配置</h2><p>1.安装 PHP Debug 扩展<br>2.左侧调试按钮 - 左侧顶部调试[Listen for XDebug]，设置<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class=\"line\">    <span class=\"comment\">// 悬停以查看现有属性的描述。</span></span><br><span class=\"line\">    <span class=\"comment\">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"configurations\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Listen for Xdebug\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"php\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"port\"</span>: <span class=\"number\">9000</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Launch currently open script\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"php\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"program\"</span>: <span class=\"string\">\"$&#123;file&#125;\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"cwd\"</span>: <span class=\"string\">\"$&#123;fileDirname&#125;\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"port\"</span>: <span class=\"number\">9001</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"然后就可以利用xdebug调试php了\"><a href=\"#然后就可以利用xdebug调试php了\" class=\"headerlink\" title=\"然后就可以利用xdebug调试php了\"></a>然后就可以利用xdebug调试php了</h2>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\"><a href=\"#最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\" class=\"headerlink\" title=\"最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路\"></a>最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路</h1><h2 id=\"首先下载xdebug的扩展\"><a href=\"#首先下载xdebug的扩展\" class=\"headerlink\" title=\"首先下载xdebug的扩展\"></a>首先下载xdebug的扩展</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pecl install xdebug</span><br></pre></td></tr></table></figure>\n<h3 id=\"配置php-ini\"><a href=\"#配置php-ini\" class=\"headerlink\" title=\"配置php.ini\"></a>配置php.ini</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zend_extension=<span class=\"string\">\"xdebug.so\"</span></span><br><span class=\"line\">xdebug.profiler_enable = on</span><br><span class=\"line\">xdebug.trace_output_dir = <span class=\"string\">\"/data/logs/xdebug\"</span></span><br><span class=\"line\">xdebug.profile_output_dir = <span class=\"string\">\"/data/logs/xdebug\"</span></span><br><span class=\"line\">xdebug.remote_enable = <span class=\"number\">1</span></span><br><span class=\"line\">xdebug.remote_autostart = <span class=\"number\">1</span></span><br><span class=\"line\">xdebug.remote_host = <span class=\"string\">\"localhost\"</span></span><br><span class=\"line\">xdebug.remote_port = <span class=\"number\">9000</span></span><br><span class=\"line\">xdebug.idekey = <span class=\"string\">\"phpStorm\"</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"保存并退出，重启php-fpm\"><a href=\"#保存并退出，重启php-fpm\" class=\"headerlink\" title=\"保存并退出，重启php-fpm\"></a>保存并退出，重启php-fpm</h3> <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">brew services restart php72</span><br></pre></td></tr></table></figure>\n<h2 id=\"二、VS-Code-配置\"><a href=\"#二、VS-Code-配置\" class=\"headerlink\" title=\"二、VS Code 配置\"></a>二、VS Code 配置</h2><p>1.安装 PHP Debug 扩展<br>2.左侧调试按钮 - 左侧顶部调试[Listen for XDebug]，设置<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class=\"line\">    <span class=\"comment\">// 悬停以查看现有属性的描述。</span></span><br><span class=\"line\">    <span class=\"comment\">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class=\"line\">    <span class=\"string\">\"version\"</span>: <span class=\"string\">\"0.2.0\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"configurations\"</span>: [</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Listen for Xdebug\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"php\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"port\"</span>: <span class=\"number\">9000</span></span><br><span class=\"line\">    &#125;,</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Launch currently open script\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"type\"</span>: <span class=\"string\">\"php\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"request\"</span>: <span class=\"string\">\"launch\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"program\"</span>: <span class=\"string\">\"$&#123;file&#125;\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"cwd\"</span>: <span class=\"string\">\"$&#123;fileDirname&#125;\"</span>,</span><br><span class=\"line\">        <span class=\"string\">\"port\"</span>: <span class=\"number\">9001</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"然后就可以利用xdebug调试php了\"><a href=\"#然后就可以利用xdebug调试php了\" class=\"headerlink\" title=\"然后就可以利用xdebug调试php了\"></a>然后就可以利用xdebug调试php了</h2>"},{"title":"mysql优化总结","date":"2019-04-27T09:00:21.000Z","_content":"\n最近总结下mysql的优化思路，希望接下来能看到这篇文章回忆和参考\n# 优化sql语句\n## 通过show status命令了解各种sql的执行效率\n``` mysql\nmysql> show status like 'Com_%';\n```\n- Com_select:执行select操作的次数，一次查询只增加1\n- Com_insert:执行insert操作的次数，对于批量插入的insert操作，只累加一次\n- Com_update: 执行update操作的次数\n- Com_delete: 执行delete操作的次数\n对InnoDB存储引擎\nInnodb_rows_read: select查询返回的行数\nInnodb_rows_inserted: 执行insert操作的行数\nInnodb_rows_update: 执行update操作更新的行数\nInnodb_rows_delete: 执行delete操作的行数\n了解当前数据以插入更新为主还是以查询为主，各种类型sql的执行比例。对于更新操作的计数，是执行次数的计数。通过com_commit和Com_rollback可以了解事务提交和回滚的情况\n## 定位执行效率较低的sql语句\n- 通过慢查询日志定位那些执行效率低的sql语句，用--log-slow-queries=[filename]\n- 通过show processlist命令查看mysql进行的线程，包括线程的状态，是否锁表\n## 通过explain分析sql的执行计划\n``` php\n mysql> explain select sum(amount) from customer a , payment b where 1=1 a.customer_id = b.customer_id and email = 'JANE.BENNETT@SAKILACUSTOMER.org'\\G\n***************1. row*********************\nid:1\nselect_type:SIMPLE\ntable:a\ntype:ALL\npossible_keys:PRIMARY\nkey:NULL\nkey_len:NULL\nref:NULL\nROWS:583\n***************2. row*********************\nid:2\nselect_type:SIMPLE\ntable:b\ntype: ref\npossible_keys:idx_fk_customer_id\nkey:idx_fk_customer_id\nkey_len:2\nref:sakila.a.customer_id\nROWS:12\n************************************\n```\n>\nslect_type: select的类型\n- SIMPLE(简单表，不使用表连接或者子查询)\n- PRIMARY(主查询:外层的查询)\n- UNION(UNION中的第二个或者后面的查询语句)\n- SUBQUERY(子查询中的第一个SELECT)\ntable:输出结果集的表\ntype:\n- ALL 全表扫描（表里全表来找到匹配的行）\n- index 索引全扫描 (遍历索引来查询匹配的行)\n- range 索引范围扫描 (常见< > <= >= between)\n- ref 非唯一索引扫描表\n- eq_ref 唯一索引扫描表 \n- const/system 最多有一个匹配行\nNULL：不用访问表或者索引","source":"_posts/mysql优化总结.md","raw":"---\ntitle: mysql优化总结\ndate: 2019-04-27 17:00:21\ncategories: 技术\n---\n\n最近总结下mysql的优化思路，希望接下来能看到这篇文章回忆和参考\n# 优化sql语句\n## 通过show status命令了解各种sql的执行效率\n``` mysql\nmysql> show status like 'Com_%';\n```\n- Com_select:执行select操作的次数，一次查询只增加1\n- Com_insert:执行insert操作的次数，对于批量插入的insert操作，只累加一次\n- Com_update: 执行update操作的次数\n- Com_delete: 执行delete操作的次数\n对InnoDB存储引擎\nInnodb_rows_read: select查询返回的行数\nInnodb_rows_inserted: 执行insert操作的行数\nInnodb_rows_update: 执行update操作更新的行数\nInnodb_rows_delete: 执行delete操作的行数\n了解当前数据以插入更新为主还是以查询为主，各种类型sql的执行比例。对于更新操作的计数，是执行次数的计数。通过com_commit和Com_rollback可以了解事务提交和回滚的情况\n## 定位执行效率较低的sql语句\n- 通过慢查询日志定位那些执行效率低的sql语句，用--log-slow-queries=[filename]\n- 通过show processlist命令查看mysql进行的线程，包括线程的状态，是否锁表\n## 通过explain分析sql的执行计划\n``` php\n mysql> explain select sum(amount) from customer a , payment b where 1=1 a.customer_id = b.customer_id and email = 'JANE.BENNETT@SAKILACUSTOMER.org'\\G\n***************1. row*********************\nid:1\nselect_type:SIMPLE\ntable:a\ntype:ALL\npossible_keys:PRIMARY\nkey:NULL\nkey_len:NULL\nref:NULL\nROWS:583\n***************2. row*********************\nid:2\nselect_type:SIMPLE\ntable:b\ntype: ref\npossible_keys:idx_fk_customer_id\nkey:idx_fk_customer_id\nkey_len:2\nref:sakila.a.customer_id\nROWS:12\n************************************\n```\n>\nslect_type: select的类型\n- SIMPLE(简单表，不使用表连接或者子查询)\n- PRIMARY(主查询:外层的查询)\n- UNION(UNION中的第二个或者后面的查询语句)\n- SUBQUERY(子查询中的第一个SELECT)\ntable:输出结果集的表\ntype:\n- ALL 全表扫描（表里全表来找到匹配的行）\n- index 索引全扫描 (遍历索引来查询匹配的行)\n- range 索引范围扫描 (常见< > <= >= between)\n- ref 非唯一索引扫描表\n- eq_ref 唯一索引扫描表 \n- const/system 最多有一个匹配行\nNULL：不用访问表或者索引","slug":"mysql优化总结","published":1,"updated":"2019-07-23T12:19:48.282Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sic000bth8l4vieu049","content":"<p>最近总结下mysql的优化思路，希望接下来能看到这篇文章回忆和参考</p>\n<h1 id=\"优化sql语句\"><a href=\"#优化sql语句\" class=\"headerlink\" title=\"优化sql语句\"></a>优化sql语句</h1><h2 id=\"通过show-status命令了解各种sql的执行效率\"><a href=\"#通过show-status命令了解各种sql的执行效率\" class=\"headerlink\" title=\"通过show status命令了解各种sql的执行效率\"></a>通过show status命令了解各种sql的执行效率</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &apos;Com_%&apos;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Com_select:执行select操作的次数，一次查询只增加1</li>\n<li>Com_insert:执行insert操作的次数，对于批量插入的insert操作，只累加一次</li>\n<li>Com_update: 执行update操作的次数</li>\n<li>Com_delete: 执行delete操作的次数<br>对InnoDB存储引擎<br>Innodb_rows_read: select查询返回的行数<br>Innodb_rows_inserted: 执行insert操作的行数<br>Innodb_rows_update: 执行update操作更新的行数<br>Innodb_rows_delete: 执行delete操作的行数<br>了解当前数据以插入更新为主还是以查询为主，各种类型sql的执行比例。对于更新操作的计数，是执行次数的计数。通过com_commit和Com_rollback可以了解事务提交和回滚的情况<h2 id=\"定位执行效率较低的sql语句\"><a href=\"#定位执行效率较低的sql语句\" class=\"headerlink\" title=\"定位执行效率较低的sql语句\"></a>定位执行效率较低的sql语句</h2></li>\n<li>通过慢查询日志定位那些执行效率低的sql语句，用–log-slow-queries=[filename]</li>\n<li>通过show processlist命令查看mysql进行的线程，包括线程的状态，是否锁表<h2 id=\"通过explain分析sql的执行计划\"><a href=\"#通过explain分析sql的执行计划\" class=\"headerlink\" title=\"通过explain分析sql的执行计划\"></a>通过explain分析sql的执行计划</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> mysql&gt; explain select sum(amount) from customer a , payment b where <span class=\"number\">1</span>=<span class=\"number\">1</span> a.customer_id = b.customer_id <span class=\"keyword\">and</span> email = <span class=\"string\">'JANE.BENNETT@SAKILACUSTOMER.org'</span>\\G</span><br><span class=\"line\">***************<span class=\"number\">1.</span> row*********************</span><br><span class=\"line\">id:<span class=\"number\">1</span></span><br><span class=\"line\">select_type:SIMPLE</span><br><span class=\"line\">table:a</span><br><span class=\"line\">type:ALL</span><br><span class=\"line\">possible_keys:PRIMARY</span><br><span class=\"line\">key:<span class=\"keyword\">NULL</span></span><br><span class=\"line\">key_len:<span class=\"keyword\">NULL</span></span><br><span class=\"line\">ref:<span class=\"keyword\">NULL</span></span><br><span class=\"line\">ROWS:<span class=\"number\">583</span></span><br><span class=\"line\">***************<span class=\"number\">2.</span> row*********************</span><br><span class=\"line\">id:<span class=\"number\">2</span></span><br><span class=\"line\">select_type:SIMPLE</span><br><span class=\"line\">table:b</span><br><span class=\"line\">type: ref</span><br><span class=\"line\">possible_keys:idx_fk_customer_id</span><br><span class=\"line\">key:idx_fk_customer_id</span><br><span class=\"line\">key_len:<span class=\"number\">2</span></span><br><span class=\"line\">ref:sakila.a.customer_id</span><br><span class=\"line\">ROWS:<span class=\"number\">12</span></span><br><span class=\"line\">************************************</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n</blockquote>\n<p>slect_type: select的类型</p>\n<ul>\n<li>SIMPLE(简单表，不使用表连接或者子查询)</li>\n<li>PRIMARY(主查询:外层的查询)</li>\n<li>UNION(UNION中的第二个或者后面的查询语句)</li>\n<li>SUBQUERY(子查询中的第一个SELECT)<br>table:输出结果集的表<br>type:</li>\n<li>ALL 全表扫描（表里全表来找到匹配的行）</li>\n<li>index 索引全扫描 (遍历索引来查询匹配的行)</li>\n<li>range 索引范围扫描 (常见&lt; &gt; &lt;= &gt;= between)</li>\n<li>ref 非唯一索引扫描表</li>\n<li>eq_ref 唯一索引扫描表 </li>\n<li>const/system 最多有一个匹配行<br>NULL：不用访问表或者索引</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>最近总结下mysql的优化思路，希望接下来能看到这篇文章回忆和参考</p>\n<h1 id=\"优化sql语句\"><a href=\"#优化sql语句\" class=\"headerlink\" title=\"优化sql语句\"></a>优化sql语句</h1><h2 id=\"通过show-status命令了解各种sql的执行效率\"><a href=\"#通过show-status命令了解各种sql的执行效率\" class=\"headerlink\" title=\"通过show status命令了解各种sql的执行效率\"></a>通过show status命令了解各种sql的执行效率</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; show status like &apos;Com_%&apos;;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Com_select:执行select操作的次数，一次查询只增加1</li>\n<li>Com_insert:执行insert操作的次数，对于批量插入的insert操作，只累加一次</li>\n<li>Com_update: 执行update操作的次数</li>\n<li>Com_delete: 执行delete操作的次数<br>对InnoDB存储引擎<br>Innodb_rows_read: select查询返回的行数<br>Innodb_rows_inserted: 执行insert操作的行数<br>Innodb_rows_update: 执行update操作更新的行数<br>Innodb_rows_delete: 执行delete操作的行数<br>了解当前数据以插入更新为主还是以查询为主，各种类型sql的执行比例。对于更新操作的计数，是执行次数的计数。通过com_commit和Com_rollback可以了解事务提交和回滚的情况<h2 id=\"定位执行效率较低的sql语句\"><a href=\"#定位执行效率较低的sql语句\" class=\"headerlink\" title=\"定位执行效率较低的sql语句\"></a>定位执行效率较低的sql语句</h2></li>\n<li>通过慢查询日志定位那些执行效率低的sql语句，用–log-slow-queries=[filename]</li>\n<li>通过show processlist命令查看mysql进行的线程，包括线程的状态，是否锁表<h2 id=\"通过explain分析sql的执行计划\"><a href=\"#通过explain分析sql的执行计划\" class=\"headerlink\" title=\"通过explain分析sql的执行计划\"></a>通过explain分析sql的执行计划</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> mysql&gt; explain select sum(amount) from customer a , payment b where <span class=\"number\">1</span>=<span class=\"number\">1</span> a.customer_id = b.customer_id <span class=\"keyword\">and</span> email = <span class=\"string\">'JANE.BENNETT@SAKILACUSTOMER.org'</span>\\G</span><br><span class=\"line\">***************<span class=\"number\">1.</span> row*********************</span><br><span class=\"line\">id:<span class=\"number\">1</span></span><br><span class=\"line\">select_type:SIMPLE</span><br><span class=\"line\">table:a</span><br><span class=\"line\">type:ALL</span><br><span class=\"line\">possible_keys:PRIMARY</span><br><span class=\"line\">key:<span class=\"keyword\">NULL</span></span><br><span class=\"line\">key_len:<span class=\"keyword\">NULL</span></span><br><span class=\"line\">ref:<span class=\"keyword\">NULL</span></span><br><span class=\"line\">ROWS:<span class=\"number\">583</span></span><br><span class=\"line\">***************<span class=\"number\">2.</span> row*********************</span><br><span class=\"line\">id:<span class=\"number\">2</span></span><br><span class=\"line\">select_type:SIMPLE</span><br><span class=\"line\">table:b</span><br><span class=\"line\">type: ref</span><br><span class=\"line\">possible_keys:idx_fk_customer_id</span><br><span class=\"line\">key:idx_fk_customer_id</span><br><span class=\"line\">key_len:<span class=\"number\">2</span></span><br><span class=\"line\">ref:sakila.a.customer_id</span><br><span class=\"line\">ROWS:<span class=\"number\">12</span></span><br><span class=\"line\">************************************</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<blockquote>\n</blockquote>\n<p>slect_type: select的类型</p>\n<ul>\n<li>SIMPLE(简单表，不使用表连接或者子查询)</li>\n<li>PRIMARY(主查询:外层的查询)</li>\n<li>UNION(UNION中的第二个或者后面的查询语句)</li>\n<li>SUBQUERY(子查询中的第一个SELECT)<br>table:输出结果集的表<br>type:</li>\n<li>ALL 全表扫描（表里全表来找到匹配的行）</li>\n<li>index 索引全扫描 (遍历索引来查询匹配的行)</li>\n<li>range 索引范围扫描 (常见&lt; &gt; &lt;= &gt;= between)</li>\n<li>ref 非唯一索引扫描表</li>\n<li>eq_ref 唯一索引扫描表 </li>\n<li>const/system 最多有一个匹配行<br>NULL：不用访问表或者索引</li>\n</ul>\n"},{"title":"php利用puppeteer来抓取西瓜视频","date":"2019-08-26T10:12:44.000Z","_content":"\n最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件\n本来下载puppeteer的时候它会自动下载无头的chrome的,但是由于被墙的原因，这个方案不行，我后面是用了阿里的一个改进版的puppeteer库，但后面发现还是不行，最后我只能在我的docker里面先下chrome的组件了\n下面是我的dockerfile\n``` docker\nFROM graychen/alpine-php7.1:alpine\nWORKDIR /var/www/html\nCOPY supervisord.conf /etc/supervisor/conf.d/\nCOPY . /var/www/html\nENV CHROME_BIN=\"/usr/bin/chromium-browser\"\\\n    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=\"true\"\nRUN set -x \\\n&& apk update \\\n&& apk upgrade \\\n# replacing default repositories with edge ones\n&& echo \"http://dl-cdn.alpinelinux.org/alpine/edge/testing\" > /etc/apk/repositories \\\n&& echo \"http://dl-cdn.alpinelinux.org/alpine/edge/community\" >> /etc/apk/repositories \\\n&& echo \"http://dl-cdn.alpinelinux.org/alpine/edge/main\" >> /etc/apk/repositories && \\\n# Add the packages\napk add --no-cache dumb-init curl make gcc g++ python linux-headers binutils-gold gnupg libstdc++ nss nodejs nodejs-npm \\\n  #alsa-lib \\\n  #at-spi2-atk \\\n  #atk \\\n  cairo \\\n  cups-libs \\\n  dbus-libs \\\n  eudev-libs \\\n  expat \\\n  flac \\\n  gdk-pixbuf \\\n  glib \\\n  libgcc \\\n  libjpeg-turbo \\\n  libpng \\\n  libwebp \\\n  libx11 \\\n  libxcomposite \\\n  libxdamage \\\n  libxext \\\n  libxfixes \\\n  tzdata \\\n  libexif \\\n  udev \\\n  xvfb \\\n  zlib-dev \\\n  chromium \\\n  chromium-chromedriver && \\\nnpm install cnpm -g --registry=https://r.npm.taobao.org && \\\ncnpm install puppeteer@0.13.0  && \\\napk del --no-cache make gcc g++ python binutils-gold gnupg libstdc++ && \\\ndocker-php-ext-install sockets\nENTRYPOINT [\"/usr/bin/supervisord\", \"-n\", \"-c\",  \"/etc/supervisor/conf.d/supervisord.conf\"]%\n```\n因为我本身是用php，所以要下这个使用别人已经封装好的composer包\n``` php\ncomposer require jaeger/querylist-puppeteer\n```\n然后安装Node依赖（与composer一样在项目根目录下执行\n``` nodejs\nnpm install @nesk/puphpeteer\n```\n下面是这个组件的用法\n在QueryList中注册插件\n``` php\nuse QL\\QueryList;\nuse QL\\Ext\\Chrome;\n\n$ql = QueryList::getInstance();\n// 注册插件，默认注册的方法名为: chrome\n$ql->use(Chrome::class);\n// 或者自定义注册的方法名\n$ql->use(Chrome::class,'chrome');\n```\n基本用法\n``` php \n// 抓取的目标页面是使用Vue.js动态渲染的页面\n$text = $ql->chrome('https://www.iviewui.com/components/button')->find('h1')->text();\nprint_r($text);\n// 输出: Button 按钮\n$rules = [\n 'h1' => ['h1','text']\n];\n$ql = $ql->chrome('https://www.iviewui.com/components/button');\n$data = $ql->rules($rules)->queryData();\n```\n后面我优化了一下参数,我将抓取的步骤放到了队列中\n``` \npublic function execute($queue)\n    {\n            $ql = QueryList::getInstance();\n                // 注册插件，默认注册的方法名为: chrome\n                $ql->use(Chrome::class);\n                $ql->use(Chrome::class,'chrome');\n                $url = 'https://www.ixigua.com/'.$this->jumpUrl;\n                $text = $ql->chrome($url,[executablePath => '/usr/bin/chromium-browser', args=> ['--no-sandbox', '--disable-setuid-sandbox','--proxy-server=\"direct://\"',\n                '--proxy-bypass-list=*','–disable-gpu',\n                '–disable-dev-shm-usage',\n                '–disable-setuid-sandbox',\n                '–no-first-run',\n                '–no-zygote',\n                '–single-process']],\n                function ($page,$browser) {\n                    $page->setUserAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36');\n                    // 设置cookie\n                    $page->setCookie([\n                    'name' => 'foo',\n                    'value' => 'xxx',\n                    'url' => $url\n                    ],[\n                    'name' => 'foo2',\n                    'value' => 'yyy',\n                    'url' => $url\n                    ]);\n                    $page->goto($url);\n                    // 等待h1元素出现\n                    $page->waitFor('#vs');\n                    $page->waitFor('xg-poster');\n                    $page->waitForNavigation();\n                    $page->screenshot([\n                        'path' => 'page.png',\n                        'fullPage' => true\n                    ]);\n                    // 获取页面HTML内容\n                    $html = $page->content();\n                    // 关闭浏览器\n                    $browser->close();\n                    // 返回值一定要是页面的HTML内容\n                    return $html;\n                })->getHtml();\n                $img = \"#<xg-poster.*>([^<]*)</xg-poster>#\";\n                preg_match($img, $text, $contentImg);\n                $str = explode(\";\",$contentImg[0]);\n                $strUrl = explode(\"&\",$str[1]);\n                $imgUrl=$strUrl[0];\n                $s = file_get_contents($imgUrl);\n                $moive = new Moive();\n                $dir = \\Yii::getAlias('@frontend') . '/web/uploads/cover/'.date('Ymd');\n                if(!is_dir($dir)) {\n                    mkdir($dir);\n                }\n                $imgShotPath='cover/'.date('Ymd').'/'.time().'.jpg';\n                $imgPath = $dir.'/'.time().'.jpg';\n                file_put_contents($imgPath, $s);\n                $head=\"#<h1>([^<]*)</h1>#\";\n                preg_match($head, $text, $contentHead);\n                $regex = \"/src=\\s*[\\'|\\\"]+?(.*?)[\\'|\\\"]+?/\";\n                $return = preg_match_all($regex, $text, $content);\n                $pathUrl = $content[1][4];\n                $s = file_get_contents($pathUrl);\n                $dir = \\Yii::getAlias('@frontend') . '/web/uploads/video/'.date('Ymd');\n                if(!is_dir($dir)) {\n                    mkdir($dir);\n                }\n                $videoShotPath = 'video/'.date('Ymd').'/'.time().'.mp4';\n                $videoPath = $dir.'/'.time().'.mp4';\n                file_put_contents($videoPath, $s);\n                $contentArray = explode(\"：\", $contentHead[1]);\n                $describe=$contentArray[1];\n                $status = Moive::STATUS_SHOW;\n                $num = 0;\n                $this->saveData($moive, $describe, $status, $num, $imgShotPath, $videoShotPath);\n    }\n```\n其实我现在的代码还有个问题，就是渲染出来的页面有时候没有渲染好就打印出来了，接下来看看怎么优化\n","source":"_posts/php利用puppeteer来抓取西瓜视频.md","raw":"---\ntitle: php利用puppeteer来抓取西瓜视频\ndate: 2019-08-26 18:12:44\ntags: 技术\n---\n\n最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件\n本来下载puppeteer的时候它会自动下载无头的chrome的,但是由于被墙的原因，这个方案不行，我后面是用了阿里的一个改进版的puppeteer库，但后面发现还是不行，最后我只能在我的docker里面先下chrome的组件了\n下面是我的dockerfile\n``` docker\nFROM graychen/alpine-php7.1:alpine\nWORKDIR /var/www/html\nCOPY supervisord.conf /etc/supervisor/conf.d/\nCOPY . /var/www/html\nENV CHROME_BIN=\"/usr/bin/chromium-browser\"\\\n    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=\"true\"\nRUN set -x \\\n&& apk update \\\n&& apk upgrade \\\n# replacing default repositories with edge ones\n&& echo \"http://dl-cdn.alpinelinux.org/alpine/edge/testing\" > /etc/apk/repositories \\\n&& echo \"http://dl-cdn.alpinelinux.org/alpine/edge/community\" >> /etc/apk/repositories \\\n&& echo \"http://dl-cdn.alpinelinux.org/alpine/edge/main\" >> /etc/apk/repositories && \\\n# Add the packages\napk add --no-cache dumb-init curl make gcc g++ python linux-headers binutils-gold gnupg libstdc++ nss nodejs nodejs-npm \\\n  #alsa-lib \\\n  #at-spi2-atk \\\n  #atk \\\n  cairo \\\n  cups-libs \\\n  dbus-libs \\\n  eudev-libs \\\n  expat \\\n  flac \\\n  gdk-pixbuf \\\n  glib \\\n  libgcc \\\n  libjpeg-turbo \\\n  libpng \\\n  libwebp \\\n  libx11 \\\n  libxcomposite \\\n  libxdamage \\\n  libxext \\\n  libxfixes \\\n  tzdata \\\n  libexif \\\n  udev \\\n  xvfb \\\n  zlib-dev \\\n  chromium \\\n  chromium-chromedriver && \\\nnpm install cnpm -g --registry=https://r.npm.taobao.org && \\\ncnpm install puppeteer@0.13.0  && \\\napk del --no-cache make gcc g++ python binutils-gold gnupg libstdc++ && \\\ndocker-php-ext-install sockets\nENTRYPOINT [\"/usr/bin/supervisord\", \"-n\", \"-c\",  \"/etc/supervisor/conf.d/supervisord.conf\"]%\n```\n因为我本身是用php，所以要下这个使用别人已经封装好的composer包\n``` php\ncomposer require jaeger/querylist-puppeteer\n```\n然后安装Node依赖（与composer一样在项目根目录下执行\n``` nodejs\nnpm install @nesk/puphpeteer\n```\n下面是这个组件的用法\n在QueryList中注册插件\n``` php\nuse QL\\QueryList;\nuse QL\\Ext\\Chrome;\n\n$ql = QueryList::getInstance();\n// 注册插件，默认注册的方法名为: chrome\n$ql->use(Chrome::class);\n// 或者自定义注册的方法名\n$ql->use(Chrome::class,'chrome');\n```\n基本用法\n``` php \n// 抓取的目标页面是使用Vue.js动态渲染的页面\n$text = $ql->chrome('https://www.iviewui.com/components/button')->find('h1')->text();\nprint_r($text);\n// 输出: Button 按钮\n$rules = [\n 'h1' => ['h1','text']\n];\n$ql = $ql->chrome('https://www.iviewui.com/components/button');\n$data = $ql->rules($rules)->queryData();\n```\n后面我优化了一下参数,我将抓取的步骤放到了队列中\n``` \npublic function execute($queue)\n    {\n            $ql = QueryList::getInstance();\n                // 注册插件，默认注册的方法名为: chrome\n                $ql->use(Chrome::class);\n                $ql->use(Chrome::class,'chrome');\n                $url = 'https://www.ixigua.com/'.$this->jumpUrl;\n                $text = $ql->chrome($url,[executablePath => '/usr/bin/chromium-browser', args=> ['--no-sandbox', '--disable-setuid-sandbox','--proxy-server=\"direct://\"',\n                '--proxy-bypass-list=*','–disable-gpu',\n                '–disable-dev-shm-usage',\n                '–disable-setuid-sandbox',\n                '–no-first-run',\n                '–no-zygote',\n                '–single-process']],\n                function ($page,$browser) {\n                    $page->setUserAgent('Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36');\n                    // 设置cookie\n                    $page->setCookie([\n                    'name' => 'foo',\n                    'value' => 'xxx',\n                    'url' => $url\n                    ],[\n                    'name' => 'foo2',\n                    'value' => 'yyy',\n                    'url' => $url\n                    ]);\n                    $page->goto($url);\n                    // 等待h1元素出现\n                    $page->waitFor('#vs');\n                    $page->waitFor('xg-poster');\n                    $page->waitForNavigation();\n                    $page->screenshot([\n                        'path' => 'page.png',\n                        'fullPage' => true\n                    ]);\n                    // 获取页面HTML内容\n                    $html = $page->content();\n                    // 关闭浏览器\n                    $browser->close();\n                    // 返回值一定要是页面的HTML内容\n                    return $html;\n                })->getHtml();\n                $img = \"#<xg-poster.*>([^<]*)</xg-poster>#\";\n                preg_match($img, $text, $contentImg);\n                $str = explode(\";\",$contentImg[0]);\n                $strUrl = explode(\"&\",$str[1]);\n                $imgUrl=$strUrl[0];\n                $s = file_get_contents($imgUrl);\n                $moive = new Moive();\n                $dir = \\Yii::getAlias('@frontend') . '/web/uploads/cover/'.date('Ymd');\n                if(!is_dir($dir)) {\n                    mkdir($dir);\n                }\n                $imgShotPath='cover/'.date('Ymd').'/'.time().'.jpg';\n                $imgPath = $dir.'/'.time().'.jpg';\n                file_put_contents($imgPath, $s);\n                $head=\"#<h1>([^<]*)</h1>#\";\n                preg_match($head, $text, $contentHead);\n                $regex = \"/src=\\s*[\\'|\\\"]+?(.*?)[\\'|\\\"]+?/\";\n                $return = preg_match_all($regex, $text, $content);\n                $pathUrl = $content[1][4];\n                $s = file_get_contents($pathUrl);\n                $dir = \\Yii::getAlias('@frontend') . '/web/uploads/video/'.date('Ymd');\n                if(!is_dir($dir)) {\n                    mkdir($dir);\n                }\n                $videoShotPath = 'video/'.date('Ymd').'/'.time().'.mp4';\n                $videoPath = $dir.'/'.time().'.mp4';\n                file_put_contents($videoPath, $s);\n                $contentArray = explode(\"：\", $contentHead[1]);\n                $describe=$contentArray[1];\n                $status = Moive::STATUS_SHOW;\n                $num = 0;\n                $this->saveData($moive, $describe, $status, $num, $imgShotPath, $videoShotPath);\n    }\n```\n其实我现在的代码还有个问题，就是渲染出来的页面有时候没有渲染好就打印出来了，接下来看看怎么优化\n","slug":"php利用puppeteer来抓取西瓜视频","published":1,"updated":"2019-08-26T10:39:16.097Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sic000cth8laniocnd7","content":"<p>最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件<br>本来下载puppeteer的时候它会自动下载无头的chrome的,但是由于被墙的原因，这个方案不行，我后面是用了阿里的一个改进版的puppeteer库，但后面发现还是不行，最后我只能在我的docker里面先下chrome的组件了<br>下面是我的dockerfile<br><figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> graychen/alpine-php7.<span class=\"number\">1</span>:alpine</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /var/www/html</span></span><br><span class=\"line\"><span class=\"bash\">COPY supervisord.conf /etc/supervisor/conf.d/</span></span><br><span class=\"line\"><span class=\"bash\">COPY . /var/www/html</span></span><br><span class=\"line\"><span class=\"bash\">ENV CHROME_BIN=<span class=\"string\">\"/usr/bin/chromium-browser\"</span>\\</span></span><br><span class=\"line\"><span class=\"bash\">    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"bash\">RUN <span class=\"built_in\">set</span> -x \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; apk update \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; apk upgrade \\</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># replacing default repositories with edge ones</span></span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://dl-cdn.alpinelinux.org/alpine/edge/testing\"</span> &gt; /etc/apk/repositories \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://dl-cdn.alpinelinux.org/alpine/edge/community\"</span> &gt;&gt; /etc/apk/repositories \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://dl-cdn.alpinelinux.org/alpine/edge/main\"</span> &gt;&gt; /etc/apk/repositories &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># Add the packages</span></span></span><br><span class=\"line\"><span class=\"bash\">apk add --no-cache dumb-init curl make gcc g++ python linux-headers binutils-gold gnupg libstdc++ nss nodejs nodejs-npm \\</span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"comment\">#alsa-lib \\</span></span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"comment\">#at-spi2-atk \\</span></span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"comment\">#atk \\</span></span></span><br><span class=\"line\"><span class=\"bash\">  cairo \\</span></span><br><span class=\"line\"><span class=\"bash\">  cups-libs \\</span></span><br><span class=\"line\"><span class=\"bash\">  dbus-libs \\</span></span><br><span class=\"line\"><span class=\"bash\">  eudev-libs \\</span></span><br><span class=\"line\"><span class=\"bash\">  expat \\</span></span><br><span class=\"line\"><span class=\"bash\">  flac \\</span></span><br><span class=\"line\"><span class=\"bash\">  gdk-pixbuf \\</span></span><br><span class=\"line\"><span class=\"bash\">  glib \\</span></span><br><span class=\"line\"><span class=\"bash\">  libgcc \\</span></span><br><span class=\"line\"><span class=\"bash\">  libjpeg-turbo \\</span></span><br><span class=\"line\"><span class=\"bash\">  libpng \\</span></span><br><span class=\"line\"><span class=\"bash\">  libwebp \\</span></span><br><span class=\"line\"><span class=\"bash\">  libx11 \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxcomposite \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxdamage \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxext \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxfixes \\</span></span><br><span class=\"line\"><span class=\"bash\">  tzdata \\</span></span><br><span class=\"line\"><span class=\"bash\">  libexif \\</span></span><br><span class=\"line\"><span class=\"bash\">  udev \\</span></span><br><span class=\"line\"><span class=\"bash\">  xvfb \\</span></span><br><span class=\"line\"><span class=\"bash\">  zlib-dev \\</span></span><br><span class=\"line\"><span class=\"bash\">  chromium \\</span></span><br><span class=\"line\"><span class=\"bash\">  chromium-chromedriver &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">npm install cnpm -g --registry=https://r.npm.taobao.org &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">cnpm install puppeteer@0.13.0  &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">apk del --no-cache make gcc g++ python binutils-gold gnupg libstdc++ &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">docker-php-ext-install sockets</span></span><br><span class=\"line\"><span class=\"bash\">ENTRYPOINT [<span class=\"string\">\"/usr/bin/supervisord\"</span>, <span class=\"string\">\"-n\"</span>, <span class=\"string\">\"-c\"</span>,  <span class=\"string\">\"/etc/supervisor/conf.d/supervisord.conf\"</span>]%</span></span><br></pre></td></tr></table></figure></p>\n<p>因为我本身是用php，所以要下这个使用别人已经封装好的composer包<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer <span class=\"keyword\">require</span> jaeger/querylist-puppeteer</span><br></pre></td></tr></table></figure></p>\n<p>然后安装Node依赖（与composer一样在项目根目录下执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nesk/puphpeteer</span><br></pre></td></tr></table></figure></p>\n<p>下面是这个组件的用法<br>在QueryList中注册插件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">QL</span>\\<span class=\"title\">QueryList</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">QL</span>\\<span class=\"title\">Ext</span>\\<span class=\"title\">Chrome</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$ql = QueryList::getInstance();</span><br><span class=\"line\"><span class=\"comment\">// 注册插件，默认注册的方法名为: chrome</span></span><br><span class=\"line\">$ql-&gt;use(Chrome::class);</span><br><span class=\"line\"><span class=\"comment\">// 或者自定义注册的方法名</span></span><br><span class=\"line\">$ql-&gt;use(Chrome::class,<span class=\"string\">'chrome'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>基本用法<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抓取的目标页面是使用Vue.js动态渲染的页面</span></span><br><span class=\"line\">$text = $ql-&gt;chrome(<span class=\"string\">'https://www.iviewui.com/components/button'</span>)-&gt;find(<span class=\"string\">'h1'</span>)-&gt;text();</span><br><span class=\"line\">print_r($text);</span><br><span class=\"line\"><span class=\"comment\">// 输出: Button 按钮</span></span><br><span class=\"line\">$rules = [</span><br><span class=\"line\"> <span class=\"string\">'h1'</span> =&gt; [<span class=\"string\">'h1'</span>,<span class=\"string\">'text'</span>]</span><br><span class=\"line\">];</span><br><span class=\"line\">$ql = $ql-&gt;chrome(<span class=\"string\">'https://www.iviewui.com/components/button'</span>);</span><br><span class=\"line\">$data = $ql-&gt;rules($rules)-&gt;queryData();</span><br></pre></td></tr></table></figure></p>\n<p>后面我优化了一下参数,我将抓取的步骤放到了队列中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public function execute($queue)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">            $ql = QueryList::getInstance();</span><br><span class=\"line\">                // 注册插件，默认注册的方法名为: chrome</span><br><span class=\"line\">                $ql-&gt;use(Chrome::class);</span><br><span class=\"line\">                $ql-&gt;use(Chrome::class,&apos;chrome&apos;);</span><br><span class=\"line\">                $url = &apos;https://www.ixigua.com/&apos;.$this-&gt;jumpUrl;</span><br><span class=\"line\">                $text = $ql-&gt;chrome($url,[executablePath =&gt; &apos;/usr/bin/chromium-browser&apos;, args=&gt; [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;,&apos;--proxy-server=&quot;direct://&quot;&apos;,</span><br><span class=\"line\">                &apos;--proxy-bypass-list=*&apos;,&apos;–disable-gpu&apos;,</span><br><span class=\"line\">                &apos;–disable-dev-shm-usage&apos;,</span><br><span class=\"line\">                &apos;–disable-setuid-sandbox&apos;,</span><br><span class=\"line\">                &apos;–no-first-run&apos;,</span><br><span class=\"line\">                &apos;–no-zygote&apos;,</span><br><span class=\"line\">                &apos;–single-process&apos;]],</span><br><span class=\"line\">                function ($page,$browser) &#123;</span><br><span class=\"line\">                    $page-&gt;setUserAgent(&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&apos;);</span><br><span class=\"line\">                    // 设置cookie</span><br><span class=\"line\">                    $page-&gt;setCookie([</span><br><span class=\"line\">                    &apos;name&apos; =&gt; &apos;foo&apos;,</span><br><span class=\"line\">                    &apos;value&apos; =&gt; &apos;xxx&apos;,</span><br><span class=\"line\">                    &apos;url&apos; =&gt; $url</span><br><span class=\"line\">                    ],[</span><br><span class=\"line\">                    &apos;name&apos; =&gt; &apos;foo2&apos;,</span><br><span class=\"line\">                    &apos;value&apos; =&gt; &apos;yyy&apos;,</span><br><span class=\"line\">                    &apos;url&apos; =&gt; $url</span><br><span class=\"line\">                    ]);</span><br><span class=\"line\">                    $page-&gt;goto($url);</span><br><span class=\"line\">                    // 等待h1元素出现</span><br><span class=\"line\">                    $page-&gt;waitFor(&apos;#vs&apos;);</span><br><span class=\"line\">                    $page-&gt;waitFor(&apos;xg-poster&apos;);</span><br><span class=\"line\">                    $page-&gt;waitForNavigation();</span><br><span class=\"line\">                    $page-&gt;screenshot([</span><br><span class=\"line\">                        &apos;path&apos; =&gt; &apos;page.png&apos;,</span><br><span class=\"line\">                        &apos;fullPage&apos; =&gt; true</span><br><span class=\"line\">                    ]);</span><br><span class=\"line\">                    // 获取页面HTML内容</span><br><span class=\"line\">                    $html = $page-&gt;content();</span><br><span class=\"line\">                    // 关闭浏览器</span><br><span class=\"line\">                    $browser-&gt;close();</span><br><span class=\"line\">                    // 返回值一定要是页面的HTML内容</span><br><span class=\"line\">                    return $html;</span><br><span class=\"line\">                &#125;)-&gt;getHtml();</span><br><span class=\"line\">                $img = &quot;#&lt;xg-poster.*&gt;([^&lt;]*)&lt;/xg-poster&gt;#&quot;;</span><br><span class=\"line\">                preg_match($img, $text, $contentImg);</span><br><span class=\"line\">                $str = explode(&quot;;&quot;,$contentImg[0]);</span><br><span class=\"line\">                $strUrl = explode(&quot;&amp;&quot;,$str[1]);</span><br><span class=\"line\">                $imgUrl=$strUrl[0];</span><br><span class=\"line\">                $s = file_get_contents($imgUrl);</span><br><span class=\"line\">                $moive = new Moive();</span><br><span class=\"line\">                $dir = \\Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/cover/&apos;.date(&apos;Ymd&apos;);</span><br><span class=\"line\">                if(!is_dir($dir)) &#123;</span><br><span class=\"line\">                    mkdir($dir);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                $imgShotPath=&apos;cover/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class=\"line\">                $imgPath = $dir.&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class=\"line\">                file_put_contents($imgPath, $s);</span><br><span class=\"line\">                $head=&quot;#&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;#&quot;;</span><br><span class=\"line\">                preg_match($head, $text, $contentHead);</span><br><span class=\"line\">                $regex = &quot;/src=\\s*[\\&apos;|\\&quot;]+?(.*?)[\\&apos;|\\&quot;]+?/&quot;;</span><br><span class=\"line\">                $return = preg_match_all($regex, $text, $content);</span><br><span class=\"line\">                $pathUrl = $content[1][4];</span><br><span class=\"line\">                $s = file_get_contents($pathUrl);</span><br><span class=\"line\">                $dir = \\Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/video/&apos;.date(&apos;Ymd&apos;);</span><br><span class=\"line\">                if(!is_dir($dir)) &#123;</span><br><span class=\"line\">                    mkdir($dir);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                $videoShotPath = &apos;video/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class=\"line\">                $videoPath = $dir.&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class=\"line\">                file_put_contents($videoPath, $s);</span><br><span class=\"line\">                $contentArray = explode(&quot;：&quot;, $contentHead[1]);</span><br><span class=\"line\">                $describe=$contentArray[1];</span><br><span class=\"line\">                $status = Moive::STATUS_SHOW;</span><br><span class=\"line\">                $num = 0;</span><br><span class=\"line\">                $this-&gt;saveData($moive, $describe, $status, $num, $imgShotPath, $videoShotPath);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实我现在的代码还有个问题，就是渲染出来的页面有时候没有渲染好就打印出来了，接下来看看怎么优化</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件<br>本来下载puppeteer的时候它会自动下载无头的chrome的,但是由于被墙的原因，这个方案不行，我后面是用了阿里的一个改进版的puppeteer库，但后面发现还是不行，最后我只能在我的docker里面先下chrome的组件了<br>下面是我的dockerfile<br><figure class=\"highlight docker\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> graychen/alpine-php7.<span class=\"number\">1</span>:alpine</span><br><span class=\"line\"><span class=\"keyword\">WORKDIR</span><span class=\"bash\"> /var/www/html</span></span><br><span class=\"line\"><span class=\"bash\">COPY supervisord.conf /etc/supervisor/conf.d/</span></span><br><span class=\"line\"><span class=\"bash\">COPY . /var/www/html</span></span><br><span class=\"line\"><span class=\"bash\">ENV CHROME_BIN=<span class=\"string\">\"/usr/bin/chromium-browser\"</span>\\</span></span><br><span class=\"line\"><span class=\"bash\">    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=<span class=\"string\">\"true\"</span></span></span><br><span class=\"line\"><span class=\"bash\">RUN <span class=\"built_in\">set</span> -x \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; apk update \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; apk upgrade \\</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># replacing default repositories with edge ones</span></span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://dl-cdn.alpinelinux.org/alpine/edge/testing\"</span> &gt; /etc/apk/repositories \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://dl-cdn.alpinelinux.org/alpine/edge/community\"</span> &gt;&gt; /etc/apk/repositories \\</span></span><br><span class=\"line\"><span class=\"bash\">&amp;&amp; <span class=\"built_in\">echo</span> <span class=\"string\">\"http://dl-cdn.alpinelinux.org/alpine/edge/main\"</span> &gt;&gt; /etc/apk/repositories &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\"><span class=\"comment\"># Add the packages</span></span></span><br><span class=\"line\"><span class=\"bash\">apk add --no-cache dumb-init curl make gcc g++ python linux-headers binutils-gold gnupg libstdc++ nss nodejs nodejs-npm \\</span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"comment\">#alsa-lib \\</span></span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"comment\">#at-spi2-atk \\</span></span></span><br><span class=\"line\"><span class=\"bash\">  <span class=\"comment\">#atk \\</span></span></span><br><span class=\"line\"><span class=\"bash\">  cairo \\</span></span><br><span class=\"line\"><span class=\"bash\">  cups-libs \\</span></span><br><span class=\"line\"><span class=\"bash\">  dbus-libs \\</span></span><br><span class=\"line\"><span class=\"bash\">  eudev-libs \\</span></span><br><span class=\"line\"><span class=\"bash\">  expat \\</span></span><br><span class=\"line\"><span class=\"bash\">  flac \\</span></span><br><span class=\"line\"><span class=\"bash\">  gdk-pixbuf \\</span></span><br><span class=\"line\"><span class=\"bash\">  glib \\</span></span><br><span class=\"line\"><span class=\"bash\">  libgcc \\</span></span><br><span class=\"line\"><span class=\"bash\">  libjpeg-turbo \\</span></span><br><span class=\"line\"><span class=\"bash\">  libpng \\</span></span><br><span class=\"line\"><span class=\"bash\">  libwebp \\</span></span><br><span class=\"line\"><span class=\"bash\">  libx11 \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxcomposite \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxdamage \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxext \\</span></span><br><span class=\"line\"><span class=\"bash\">  libxfixes \\</span></span><br><span class=\"line\"><span class=\"bash\">  tzdata \\</span></span><br><span class=\"line\"><span class=\"bash\">  libexif \\</span></span><br><span class=\"line\"><span class=\"bash\">  udev \\</span></span><br><span class=\"line\"><span class=\"bash\">  xvfb \\</span></span><br><span class=\"line\"><span class=\"bash\">  zlib-dev \\</span></span><br><span class=\"line\"><span class=\"bash\">  chromium \\</span></span><br><span class=\"line\"><span class=\"bash\">  chromium-chromedriver &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">npm install cnpm -g --registry=https://r.npm.taobao.org &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">cnpm install puppeteer@0.13.0  &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">apk del --no-cache make gcc g++ python binutils-gold gnupg libstdc++ &amp;&amp; \\</span></span><br><span class=\"line\"><span class=\"bash\">docker-php-ext-install sockets</span></span><br><span class=\"line\"><span class=\"bash\">ENTRYPOINT [<span class=\"string\">\"/usr/bin/supervisord\"</span>, <span class=\"string\">\"-n\"</span>, <span class=\"string\">\"-c\"</span>,  <span class=\"string\">\"/etc/supervisor/conf.d/supervisord.conf\"</span>]%</span></span><br></pre></td></tr></table></figure></p>\n<p>因为我本身是用php，所以要下这个使用别人已经封装好的composer包<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer <span class=\"keyword\">require</span> jaeger/querylist-puppeteer</span><br></pre></td></tr></table></figure></p>\n<p>然后安装Node依赖（与composer一样在项目根目录下执行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">npm install @nesk/puphpeteer</span><br></pre></td></tr></table></figure></p>\n<p>下面是这个组件的用法<br>在QueryList中注册插件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">QL</span>\\<span class=\"title\">QueryList</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">QL</span>\\<span class=\"title\">Ext</span>\\<span class=\"title\">Chrome</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">$ql = QueryList::getInstance();</span><br><span class=\"line\"><span class=\"comment\">// 注册插件，默认注册的方法名为: chrome</span></span><br><span class=\"line\">$ql-&gt;use(Chrome::class);</span><br><span class=\"line\"><span class=\"comment\">// 或者自定义注册的方法名</span></span><br><span class=\"line\">$ql-&gt;use(Chrome::class,<span class=\"string\">'chrome'</span>);</span><br></pre></td></tr></table></figure></p>\n<p>基本用法<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 抓取的目标页面是使用Vue.js动态渲染的页面</span></span><br><span class=\"line\">$text = $ql-&gt;chrome(<span class=\"string\">'https://www.iviewui.com/components/button'</span>)-&gt;find(<span class=\"string\">'h1'</span>)-&gt;text();</span><br><span class=\"line\">print_r($text);</span><br><span class=\"line\"><span class=\"comment\">// 输出: Button 按钮</span></span><br><span class=\"line\">$rules = [</span><br><span class=\"line\"> <span class=\"string\">'h1'</span> =&gt; [<span class=\"string\">'h1'</span>,<span class=\"string\">'text'</span>]</span><br><span class=\"line\">];</span><br><span class=\"line\">$ql = $ql-&gt;chrome(<span class=\"string\">'https://www.iviewui.com/components/button'</span>);</span><br><span class=\"line\">$data = $ql-&gt;rules($rules)-&gt;queryData();</span><br></pre></td></tr></table></figure></p>\n<p>后面我优化了一下参数,我将抓取的步骤放到了队列中<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">public function execute($queue)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">            $ql = QueryList::getInstance();</span><br><span class=\"line\">                // 注册插件，默认注册的方法名为: chrome</span><br><span class=\"line\">                $ql-&gt;use(Chrome::class);</span><br><span class=\"line\">                $ql-&gt;use(Chrome::class,&apos;chrome&apos;);</span><br><span class=\"line\">                $url = &apos;https://www.ixigua.com/&apos;.$this-&gt;jumpUrl;</span><br><span class=\"line\">                $text = $ql-&gt;chrome($url,[executablePath =&gt; &apos;/usr/bin/chromium-browser&apos;, args=&gt; [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;,&apos;--proxy-server=&quot;direct://&quot;&apos;,</span><br><span class=\"line\">                &apos;--proxy-bypass-list=*&apos;,&apos;–disable-gpu&apos;,</span><br><span class=\"line\">                &apos;–disable-dev-shm-usage&apos;,</span><br><span class=\"line\">                &apos;–disable-setuid-sandbox&apos;,</span><br><span class=\"line\">                &apos;–no-first-run&apos;,</span><br><span class=\"line\">                &apos;–no-zygote&apos;,</span><br><span class=\"line\">                &apos;–single-process&apos;]],</span><br><span class=\"line\">                function ($page,$browser) &#123;</span><br><span class=\"line\">                    $page-&gt;setUserAgent(&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&apos;);</span><br><span class=\"line\">                    // 设置cookie</span><br><span class=\"line\">                    $page-&gt;setCookie([</span><br><span class=\"line\">                    &apos;name&apos; =&gt; &apos;foo&apos;,</span><br><span class=\"line\">                    &apos;value&apos; =&gt; &apos;xxx&apos;,</span><br><span class=\"line\">                    &apos;url&apos; =&gt; $url</span><br><span class=\"line\">                    ],[</span><br><span class=\"line\">                    &apos;name&apos; =&gt; &apos;foo2&apos;,</span><br><span class=\"line\">                    &apos;value&apos; =&gt; &apos;yyy&apos;,</span><br><span class=\"line\">                    &apos;url&apos; =&gt; $url</span><br><span class=\"line\">                    ]);</span><br><span class=\"line\">                    $page-&gt;goto($url);</span><br><span class=\"line\">                    // 等待h1元素出现</span><br><span class=\"line\">                    $page-&gt;waitFor(&apos;#vs&apos;);</span><br><span class=\"line\">                    $page-&gt;waitFor(&apos;xg-poster&apos;);</span><br><span class=\"line\">                    $page-&gt;waitForNavigation();</span><br><span class=\"line\">                    $page-&gt;screenshot([</span><br><span class=\"line\">                        &apos;path&apos; =&gt; &apos;page.png&apos;,</span><br><span class=\"line\">                        &apos;fullPage&apos; =&gt; true</span><br><span class=\"line\">                    ]);</span><br><span class=\"line\">                    // 获取页面HTML内容</span><br><span class=\"line\">                    $html = $page-&gt;content();</span><br><span class=\"line\">                    // 关闭浏览器</span><br><span class=\"line\">                    $browser-&gt;close();</span><br><span class=\"line\">                    // 返回值一定要是页面的HTML内容</span><br><span class=\"line\">                    return $html;</span><br><span class=\"line\">                &#125;)-&gt;getHtml();</span><br><span class=\"line\">                $img = &quot;#&lt;xg-poster.*&gt;([^&lt;]*)&lt;/xg-poster&gt;#&quot;;</span><br><span class=\"line\">                preg_match($img, $text, $contentImg);</span><br><span class=\"line\">                $str = explode(&quot;;&quot;,$contentImg[0]);</span><br><span class=\"line\">                $strUrl = explode(&quot;&amp;&quot;,$str[1]);</span><br><span class=\"line\">                $imgUrl=$strUrl[0];</span><br><span class=\"line\">                $s = file_get_contents($imgUrl);</span><br><span class=\"line\">                $moive = new Moive();</span><br><span class=\"line\">                $dir = \\Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/cover/&apos;.date(&apos;Ymd&apos;);</span><br><span class=\"line\">                if(!is_dir($dir)) &#123;</span><br><span class=\"line\">                    mkdir($dir);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                $imgShotPath=&apos;cover/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class=\"line\">                $imgPath = $dir.&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class=\"line\">                file_put_contents($imgPath, $s);</span><br><span class=\"line\">                $head=&quot;#&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;#&quot;;</span><br><span class=\"line\">                preg_match($head, $text, $contentHead);</span><br><span class=\"line\">                $regex = &quot;/src=\\s*[\\&apos;|\\&quot;]+?(.*?)[\\&apos;|\\&quot;]+?/&quot;;</span><br><span class=\"line\">                $return = preg_match_all($regex, $text, $content);</span><br><span class=\"line\">                $pathUrl = $content[1][4];</span><br><span class=\"line\">                $s = file_get_contents($pathUrl);</span><br><span class=\"line\">                $dir = \\Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/video/&apos;.date(&apos;Ymd&apos;);</span><br><span class=\"line\">                if(!is_dir($dir)) &#123;</span><br><span class=\"line\">                    mkdir($dir);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                $videoShotPath = &apos;video/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class=\"line\">                $videoPath = $dir.&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class=\"line\">                file_put_contents($videoPath, $s);</span><br><span class=\"line\">                $contentArray = explode(&quot;：&quot;, $contentHead[1]);</span><br><span class=\"line\">                $describe=$contentArray[1];</span><br><span class=\"line\">                $status = Moive::STATUS_SHOW;</span><br><span class=\"line\">                $num = 0;</span><br><span class=\"line\">                $this-&gt;saveData($moive, $describe, $status, $num, $imgShotPath, $videoShotPath);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></p>\n<p>其实我现在的代码还有个问题，就是渲染出来的页面有时候没有渲染好就打印出来了，接下来看看怎么优化</p>\n"},{"title":"php如何正确的统计中文","date":"2019-11-21T07:34:28.000Z","_content":"PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：\n``` php \necho strlen(\"你好ABC\") . \"\";\n//输出 9\necho mb_strlen(\"你好ABC\", 'UTF-8') . \"\";\n// 输出 5\necho mb_strwidth(\"你好ABC\") . \"\";\n//输出 7\n登录后复制\n```\n从上面的测试，我们可以看出：strlen 把中文字符算成 3 个字节，mb_strlen 不管中文还是英文，都算 1 个字节，而 mb_strwidth 则把中文算成 2 个字节，所以 mb_strwidth 才是我们想要的：中文 2 个字节，英文 1 个字节。\n","source":"_posts/php如何正确的统计中文.md","raw":"---\ntitle: php如何正确的统计中文\ndate: 2019-11-21 15:34:28\ntags: 技术\n---\nPHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：\n``` php \necho strlen(\"你好ABC\") . \"\";\n//输出 9\necho mb_strlen(\"你好ABC\", 'UTF-8') . \"\";\n// 输出 5\necho mb_strwidth(\"你好ABC\") . \"\";\n//输出 7\n登录后复制\n```\n从上面的测试，我们可以看出：strlen 把中文字符算成 3 个字节，mb_strlen 不管中文还是英文，都算 1 个字节，而 mb_strwidth 则把中文算成 2 个字节，所以 mb_strwidth 才是我们想要的：中文 2 个字节，英文 1 个字节。\n","slug":"php如何正确的统计中文","published":1,"updated":"2019-12-11T07:36:17.564Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sie000dth8lxmuvxck4","content":"<p>PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">echo</span> strlen(<span class=\"string\">\"你好ABC\"</span>) . <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//输出 9</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> mb_strlen(<span class=\"string\">\"你好ABC\"</span>, <span class=\"string\">'UTF-8'</span>) . <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出 5</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> mb_strwidth(<span class=\"string\">\"你好ABC\"</span>) . <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//输出 7</span></span><br><span class=\"line\">登录后复制</span><br></pre></td></tr></table></figure></p>\n<p>从上面的测试，我们可以看出：strlen 把中文字符算成 3 个字节，mb_strlen 不管中文还是英文，都算 1 个字节，而 mb_strwidth 则把中文算成 2 个字节，所以 mb_strwidth 才是我们想要的：中文 2 个字节，英文 1 个字节。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">echo</span> strlen(<span class=\"string\">\"你好ABC\"</span>) . <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//输出 9</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> mb_strlen(<span class=\"string\">\"你好ABC\"</span>, <span class=\"string\">'UTF-8'</span>) . <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">// 输出 5</span></span><br><span class=\"line\"><span class=\"keyword\">echo</span> mb_strwidth(<span class=\"string\">\"你好ABC\"</span>) . <span class=\"string\">\"\"</span>;</span><br><span class=\"line\"><span class=\"comment\">//输出 7</span></span><br><span class=\"line\">登录后复制</span><br></pre></td></tr></table></figure></p>\n<p>从上面的测试，我们可以看出：strlen 把中文字符算成 3 个字节，mb_strlen 不管中文还是英文，都算 1 个字节，而 mb_strwidth 则把中文算成 2 个字节，所以 mb_strwidth 才是我们想要的：中文 2 个字节，英文 1 个字节。</p>\n"},{"title":"vichrome像vi一样操作你的chrome浏览器","date":"2016-10-18T01:24:53.000Z","_content":"**vichrome**是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。\n下面是它的操作命令：\n## 基础篇\n- k 上移 \n- j 下移 \n- H 后退 \n- L 前进\n- gg 飞到顶部 \n- G 掉到底部 \n- gt 去下一个标签 (ctrl+l) \n- gT 去上一个标签 (ctrl+h)\n- t 新开一个标签 \n- x 关闭当前标签页 \n- X 关闭当前标签页并跳到下一个标签页  \n- u 恢复刚刚的标签页 \n- r 刷新 \n- f 进入f模式(可以点击链接) \n- F 在新标签中进入f模式 \n- i 聚焦在第一个输入框\n- esc 退出\n<!--more-->\n## 进阶篇\n- ctrl+f 下一页\n- ctrl+b 上一页\n- ctrl+d 下半页\n- ctrl+u 上半页\n- / 搜索\n- ? 反向搜索\n- a 在带链接的文本中搜索\n- n 下一个搜索结果\n- N 上一个搜索结果\n- tab 下一个候补选项\n- shift+tab 上一个候补选项\n- : 进入命令模式\n- yy 复制url\n- p/P 打开刚刚复制的url\n- o/O 打开(输入url)\n- s/S 用搜索引擎搜索\n- b/B 打开收藏夹\n## 高级篇\n- gp 新开一个窗口(对当前标签页)\n\n\n\n","source":"_posts/vichrome像vi一样操作你的chrome浏览器.md","raw":"---\ntitle: vichrome像vi一样操作你的chrome浏览器\ndate: 2016-10-18 09:24:53\ntag: 工具\ncategories: 技术\n\n---\n**vichrome**是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。\n下面是它的操作命令：\n## 基础篇\n- k 上移 \n- j 下移 \n- H 后退 \n- L 前进\n- gg 飞到顶部 \n- G 掉到底部 \n- gt 去下一个标签 (ctrl+l) \n- gT 去上一个标签 (ctrl+h)\n- t 新开一个标签 \n- x 关闭当前标签页 \n- X 关闭当前标签页并跳到下一个标签页  \n- u 恢复刚刚的标签页 \n- r 刷新 \n- f 进入f模式(可以点击链接) \n- F 在新标签中进入f模式 \n- i 聚焦在第一个输入框\n- esc 退出\n<!--more-->\n## 进阶篇\n- ctrl+f 下一页\n- ctrl+b 上一页\n- ctrl+d 下半页\n- ctrl+u 上半页\n- / 搜索\n- ? 反向搜索\n- a 在带链接的文本中搜索\n- n 下一个搜索结果\n- N 上一个搜索结果\n- tab 下一个候补选项\n- shift+tab 上一个候补选项\n- : 进入命令模式\n- yy 复制url\n- p/P 打开刚刚复制的url\n- o/O 打开(输入url)\n- s/S 用搜索引擎搜索\n- b/B 打开收藏夹\n## 高级篇\n- gp 新开一个窗口(对当前标签页)\n\n\n\n","slug":"vichrome像vi一样操作你的chrome浏览器","published":1,"updated":"2018-05-27T09:59:36.029Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sie000eth8l8dk6o7yh","content":"<p><strong>vichrome</strong>是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。<br>下面是它的操作命令：</p>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><ul>\n<li>k 上移 </li>\n<li>j 下移 </li>\n<li>H 后退 </li>\n<li>L 前进</li>\n<li>gg 飞到顶部 </li>\n<li>G 掉到底部 </li>\n<li>gt 去下一个标签 (ctrl+l) </li>\n<li>gT 去上一个标签 (ctrl+h)</li>\n<li>t 新开一个标签 </li>\n<li>x 关闭当前标签页 </li>\n<li>X 关闭当前标签页并跳到下一个标签页  </li>\n<li>u 恢复刚刚的标签页 </li>\n<li>r 刷新 </li>\n<li>f 进入f模式(可以点击链接) </li>\n<li>F 在新标签中进入f模式 </li>\n<li>i 聚焦在第一个输入框</li>\n<li>esc 退出<a id=\"more\"></a>\n<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2></li>\n<li>ctrl+f 下一页</li>\n<li>ctrl+b 上一页</li>\n<li>ctrl+d 下半页</li>\n<li>ctrl+u 上半页</li>\n<li>/ 搜索</li>\n<li>? 反向搜索</li>\n<li>a 在带链接的文本中搜索</li>\n<li>n 下一个搜索结果</li>\n<li>N 上一个搜索结果</li>\n<li>tab 下一个候补选项</li>\n<li>shift+tab 上一个候补选项</li>\n<li>: 进入命令模式</li>\n<li>yy 复制url</li>\n<li>p/P 打开刚刚复制的url</li>\n<li>o/O 打开(输入url)</li>\n<li>s/S 用搜索引擎搜索</li>\n<li>b/B 打开收藏夹<h2 id=\"高级篇\"><a href=\"#高级篇\" class=\"headerlink\" title=\"高级篇\"></a>高级篇</h2></li>\n<li>gp 新开一个窗口(对当前标签页)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>vichrome</strong>是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。<br>下面是它的操作命令：</p>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><ul>\n<li>k 上移 </li>\n<li>j 下移 </li>\n<li>H 后退 </li>\n<li>L 前进</li>\n<li>gg 飞到顶部 </li>\n<li>G 掉到底部 </li>\n<li>gt 去下一个标签 (ctrl+l) </li>\n<li>gT 去上一个标签 (ctrl+h)</li>\n<li>t 新开一个标签 </li>\n<li>x 关闭当前标签页 </li>\n<li>X 关闭当前标签页并跳到下一个标签页  </li>\n<li>u 恢复刚刚的标签页 </li>\n<li>r 刷新 </li>\n<li>f 进入f模式(可以点击链接) </li>\n<li>F 在新标签中进入f模式 </li>\n<li>i 聚焦在第一个输入框</li>\n<li>esc 退出","more":"<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2></li>\n<li>ctrl+f 下一页</li>\n<li>ctrl+b 上一页</li>\n<li>ctrl+d 下半页</li>\n<li>ctrl+u 上半页</li>\n<li>/ 搜索</li>\n<li>? 反向搜索</li>\n<li>a 在带链接的文本中搜索</li>\n<li>n 下一个搜索结果</li>\n<li>N 上一个搜索结果</li>\n<li>tab 下一个候补选项</li>\n<li>shift+tab 上一个候补选项</li>\n<li>: 进入命令模式</li>\n<li>yy 复制url</li>\n<li>p/P 打开刚刚复制的url</li>\n<li>o/O 打开(输入url)</li>\n<li>s/S 用搜索引擎搜索</li>\n<li>b/B 打开收藏夹<h2 id=\"高级篇\"><a href=\"#高级篇\" class=\"headerlink\" title=\"高级篇\"></a>高级篇</h2></li>\n<li>gp 新开一个窗口(对当前标签页)</li>\n</ul>"},{"title":"ubuntu下lnmp快速搭建","date":"2017-05-10T13:12:37.000Z","_content":"\n我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。\n>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8\n\n## 安装php7.1\n安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：\n\n``` bash\nsudo apt-get update  \nsudo apt-get install -y language-pack-en-base  \n```\n\n这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。\n\n安装完成之后，运行：\n\n``` bash\nlocale-gen en_US.UTF-8  \n```\n\n设定语言编码为<font color=\"red\">UTF-8</font>。\n\n进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：\n\n``` bash\nsudo apt-get install software-properties-common  \n```\n\n<!--more-->\nsoftware-properties-common是add-apt-repository所依赖的包，安装成功后，运行：\n\n``` bash\nsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php  \n\n```\n\n安装完成之后，运行<font color=\"red\">**sudo apt-get update**</font>更新安装包，把刚才添加的包拉取下来。 运行**<font color=\"red\">apt-cache search php7.1</font>**搜索php7.1开头的包检验是否安装成功，输出如下：\n\n``` bash\nroot@demo:~# apt-cache search php7.1  \nphp-yaml - YAML-1.1 parser and emitter for PHP  \nphp-apcu - APC User Cache for PHP  \nphp-ssh2 - Bindings for the libssh2 library  \nphp-igbinary - igbinary PHP serializer  \nphp-mailparse - Email message manipulation for PHP  \nphp-libsodium - PHP wrapper for the Sodium cryptographic library  \nphp-propro - propro module for PHP\n\n...\n...\n...\n```\n\n安装php7.1\n\n``` bash\nsudo apt-get -y install php7.1\n```\n\n安装完成后运行**<font color=\"red\">php -v</font>**查看是否安装成功,成功的话显示\n\n``` bash\nPHP 7.1.0beta2 (cli) ( NTS  )  \nCopyright (c) 1997-2016 The PHP Group  \nZend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  \n    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies\n```\n接着安装php7.1-mysql，这是php和mysql通信的模块\n\n``` bash\nsudo apt-get -y install php7.1-mysql  \n```\n安装 fpm，这是Nginx 用来解析php文件的：\n\n``` bash\nsudo apt-get install php7.1-fpm  \n```\n\n安装其他必备模块：\n\n``` bash\napt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring  \n```\n\n至此与php相关的模块安装安装完成。\n## 安装Mysql\n直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！\n\n>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 http://dev.mysql.com/downloads/mysql/ 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。\n下载.deb包到你的服务器：\n\n``` bash\nwget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb  \n```\n 然后使用dpkg命令添加Mysql的源：\n``` bash\nsudo dpkg -i mysql-apt-config_0.5.3-1_all.deb  \n```\n注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可\n安装\n\n``` bash\nsudo apt-get update  \nsudo apt-get install mysql-server  \n``` \n安装完成之后运行mysql -V查看版本：\n\n``` bash\nroot@demo:~# mysql -V  \n``` \nmysql  Ver 14.14 Distrib 5.7.15, for Linux (x86_64) using  EditLine wrapper  \n注意\n\n如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源\n\n``` bash\nsudo apt-add-repository --remove ppa:ondrej/mysql-5.6  \n``` \n 如果没有 apt-add-repository 先安装上\n``` bash\n sudo apt-get install software-properties-common\n``` \n然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。\n## 安装Nginx\n简单，运行：\n``` bash\nsudo apt-get -y install nginx  \n``` \n## nginx配置php\n\n``` bash\nsudo vim /etc/php/7.1/fpm/php.ini  \n``` \n输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：\n编辑fpm的配置文件： 运行：\n\n``` bash\nsudo vim /etc/php/7.1/fpm/pool.d/www.conf  \n``` \n找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。\n\n``` bash\nservice php7.1-fpm stop\nservice php7.1-fpm start\n``` \n配置Nginx：\n\n运行：\n\n``` bash\nsudo vim /etc/nginx/sites-available/default  \n``` \n下面是配置文件\n``` bash\nserver {  \n    #listen 80 default_server;\n    listen 80;\n    #listen [::]:80 default_server ipv6only=on;\n    \n    root /var/www;\n    index index.php index.html index.htm;\n                                        \n    # Make site accessible from http://localhost/\n    server_name lufficc.com www.lufficc.com;\n    \n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ /index.php?$query_string;\n        # Uncomment to enable naxsi on this location\n        # include /etc/nginx/naxsi.rules\n    }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        # With php7.0-cgi alone:\n        fastcgi_pass 127.0.0.1:9000;\n        # With php7.0-fpm:\n        fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n    }\n}\n``` \n> \n  - root：是你的项目的public目录，也就是网站的入口\n  - index：添加了，index.php，告诉Nginx先解析index.php文件\n  - server_name：你的域名，没有的话填写localhost\n  - location / try_files修改为了try_files $uri $uri/ /index.php?$query_string;\n  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。\n\n## 运行nginx服务\n\n``` bash\nsudo service nginx restart  \nsudo service php7.1-fpm restart  \n```\n如果出现下列错误\n``` bash\n[emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)\n```\n这是80端口被占用，运行下面命令，关闭80端口\n\n``` bash\nsudo fuser -k 80/tcp\nservice nginx start\n```\n**好了，一切完成！**\n\n\n\n\n\n\n\n","source":"_posts/ubuntu下lnmp快速搭建.md","raw":"---\ntitle: ubuntu下lnmp快速搭建\ndate: 2017-05-10 21:12:37\ntags: linux\ncategories: 技术\n\n---\n\n我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。\n>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8\n\n## 安装php7.1\n安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：\n\n``` bash\nsudo apt-get update  \nsudo apt-get install -y language-pack-en-base  \n```\n\n这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。\n\n安装完成之后，运行：\n\n``` bash\nlocale-gen en_US.UTF-8  \n```\n\n设定语言编码为<font color=\"red\">UTF-8</font>。\n\n进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：\n\n``` bash\nsudo apt-get install software-properties-common  \n```\n\n<!--more-->\nsoftware-properties-common是add-apt-repository所依赖的包，安装成功后，运行：\n\n``` bash\nsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php  \n\n```\n\n安装完成之后，运行<font color=\"red\">**sudo apt-get update**</font>更新安装包，把刚才添加的包拉取下来。 运行**<font color=\"red\">apt-cache search php7.1</font>**搜索php7.1开头的包检验是否安装成功，输出如下：\n\n``` bash\nroot@demo:~# apt-cache search php7.1  \nphp-yaml - YAML-1.1 parser and emitter for PHP  \nphp-apcu - APC User Cache for PHP  \nphp-ssh2 - Bindings for the libssh2 library  \nphp-igbinary - igbinary PHP serializer  \nphp-mailparse - Email message manipulation for PHP  \nphp-libsodium - PHP wrapper for the Sodium cryptographic library  \nphp-propro - propro module for PHP\n\n...\n...\n...\n```\n\n安装php7.1\n\n``` bash\nsudo apt-get -y install php7.1\n```\n\n安装完成后运行**<font color=\"red\">php -v</font>**查看是否安装成功,成功的话显示\n\n``` bash\nPHP 7.1.0beta2 (cli) ( NTS  )  \nCopyright (c) 1997-2016 The PHP Group  \nZend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  \n    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies\n```\n接着安装php7.1-mysql，这是php和mysql通信的模块\n\n``` bash\nsudo apt-get -y install php7.1-mysql  \n```\n安装 fpm，这是Nginx 用来解析php文件的：\n\n``` bash\nsudo apt-get install php7.1-fpm  \n```\n\n安装其他必备模块：\n\n``` bash\napt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring  \n```\n\n至此与php相关的模块安装安装完成。\n## 安装Mysql\n直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！\n\n>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 http://dev.mysql.com/downloads/mysql/ 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。\n下载.deb包到你的服务器：\n\n``` bash\nwget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb  \n```\n 然后使用dpkg命令添加Mysql的源：\n``` bash\nsudo dpkg -i mysql-apt-config_0.5.3-1_all.deb  \n```\n注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可\n安装\n\n``` bash\nsudo apt-get update  \nsudo apt-get install mysql-server  \n``` \n安装完成之后运行mysql -V查看版本：\n\n``` bash\nroot@demo:~# mysql -V  \n``` \nmysql  Ver 14.14 Distrib 5.7.15, for Linux (x86_64) using  EditLine wrapper  \n注意\n\n如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源\n\n``` bash\nsudo apt-add-repository --remove ppa:ondrej/mysql-5.6  \n``` \n 如果没有 apt-add-repository 先安装上\n``` bash\n sudo apt-get install software-properties-common\n``` \n然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。\n## 安装Nginx\n简单，运行：\n``` bash\nsudo apt-get -y install nginx  \n``` \n## nginx配置php\n\n``` bash\nsudo vim /etc/php/7.1/fpm/php.ini  \n``` \n输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：\n编辑fpm的配置文件： 运行：\n\n``` bash\nsudo vim /etc/php/7.1/fpm/pool.d/www.conf  \n``` \n找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。\n\n``` bash\nservice php7.1-fpm stop\nservice php7.1-fpm start\n``` \n配置Nginx：\n\n运行：\n\n``` bash\nsudo vim /etc/nginx/sites-available/default  \n``` \n下面是配置文件\n``` bash\nserver {  \n    #listen 80 default_server;\n    listen 80;\n    #listen [::]:80 default_server ipv6only=on;\n    \n    root /var/www;\n    index index.php index.html index.htm;\n                                        \n    # Make site accessible from http://localhost/\n    server_name lufficc.com www.lufficc.com;\n    \n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ /index.php?$query_string;\n        # Uncomment to enable naxsi on this location\n        # include /etc/nginx/naxsi.rules\n    }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        # With php7.0-cgi alone:\n        fastcgi_pass 127.0.0.1:9000;\n        # With php7.0-fpm:\n        fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n    }\n}\n``` \n> \n  - root：是你的项目的public目录，也就是网站的入口\n  - index：添加了，index.php，告诉Nginx先解析index.php文件\n  - server_name：你的域名，没有的话填写localhost\n  - location / try_files修改为了try_files $uri $uri/ /index.php?$query_string;\n  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。\n\n## 运行nginx服务\n\n``` bash\nsudo service nginx restart  \nsudo service php7.1-fpm restart  \n```\n如果出现下列错误\n``` bash\n[emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)\n```\n这是80端口被占用，运行下面命令，关闭80端口\n\n``` bash\nsudo fuser -k 80/tcp\nservice nginx start\n```\n**好了，一切完成！**\n\n\n\n\n\n\n\n","slug":"ubuntu下lnmp快速搭建","published":1,"updated":"2018-05-27T09:59:36.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sig000fth8l928r5oqi","content":"<p>我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。</p>\n<blockquote>\n<p>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8</p>\n</blockquote>\n<h2 id=\"安装php7-1\"><a href=\"#安装php7-1\" class=\"headerlink\" title=\"安装php7.1\"></a>安装php7.1</h2><p>安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update  </span><br><span class=\"line\">sudo apt-get install -y language-pack-en-base</span><br></pre></td></tr></table></figure>\n<p>这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。</p>\n<p>安装完成之后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locale-gen en_US.UTF-8</span><br></pre></td></tr></table></figure>\n<p>设定语言编码为<font color=\"red\">UTF-8</font>。</p>\n<p>进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>software-properties-common是add-apt-repository所依赖的包，安装成功后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure>\n<p>安装完成之后，运行<font color=\"red\"><strong>sudo apt-get update</strong></font>更新安装包，把刚才添加的包拉取下来。 运行<strong><font color=\"red\">apt-cache search php7.1</font></strong>搜索php7.1开头的包检验是否安装成功，输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@demo:~<span class=\"comment\"># apt-cache search php7.1  </span></span><br><span class=\"line\">php-yaml - YAML-1.1 parser and emitter <span class=\"keyword\">for</span> PHP  </span><br><span class=\"line\">php-apcu - APC User Cache <span class=\"keyword\">for</span> PHP  </span><br><span class=\"line\">php-ssh2 - Bindings <span class=\"keyword\">for</span> the libssh2 library  </span><br><span class=\"line\">php-igbinary - igbinary PHP serializer  </span><br><span class=\"line\">php-mailparse - Email message manipulation <span class=\"keyword\">for</span> PHP  </span><br><span class=\"line\">php-libsodium - PHP wrapper <span class=\"keyword\">for</span> the Sodium cryptographic library  </span><br><span class=\"line\">php-propro - propro module <span class=\"keyword\">for</span> PHP</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>安装php7.1</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get -y install php7.1</span><br></pre></td></tr></table></figure>\n<p>安装完成后运行<strong><font color=\"red\">php -v</font></strong>查看是否安装成功,成功的话显示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP 7.1.0beta2 (cli) ( NTS  )  </span><br><span class=\"line\">Copyright (c) 1997-2016 The PHP Group  </span><br><span class=\"line\">Zend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  </span><br><span class=\"line\">    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies</span><br></pre></td></tr></table></figure>\n<p>接着安装php7.1-mysql，这是php和mysql通信的模块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get -y install php7.1-mysql</span><br></pre></td></tr></table></figure>\n<p>安装 fpm，这是Nginx 用来解析php文件的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install php7.1-fpm</span><br></pre></td></tr></table></figure>\n<p>安装其他必备模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring</span><br></pre></td></tr></table></figure>\n<p>至此与php相关的模块安装安装完成。</p>\n<h2 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h2><p>直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！</p>\n<blockquote>\n<p>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 <a href=\"http://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/mysql/</a> 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。<br>下载.deb包到你的服务器：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb</span><br></pre></td></tr></table></figure>\n<p> 然后使用dpkg命令添加Mysql的源：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i mysql-apt-config_0.5.3-1_all.deb</span><br></pre></td></tr></table></figure></p>\n<p>注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可<br>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update  </span><br><span class=\"line\">sudo apt-get install mysql-server  </span><br><span class=\"line\">``` </span><br><span class=\"line\">安装完成之后运行mysql -V查看版本：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">root@demo:~<span class=\"comment\"># mysql -V  </span></span><br><span class=\"line\">``` </span><br><span class=\"line\">mysql  Ver 14.14 Distrib 5.7.15, <span class=\"keyword\">for</span> Linux (x86_64) using  EditLine wrapper  </span><br><span class=\"line\">注意</span><br><span class=\"line\"></span><br><span class=\"line\">如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo apt-add-repository --remove ppa:ondrej/mysql-5.6  </span><br><span class=\"line\">``` </span><br><span class=\"line\"> 如果没有 apt-add-repository 先安装上</span><br><span class=\"line\">``` bash</span><br><span class=\"line\"> sudo apt-get install software-properties-common</span><br><span class=\"line\">``` </span><br><span class=\"line\">然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。</span><br><span class=\"line\"><span class=\"comment\">## 安装Nginx</span></span><br><span class=\"line\">简单，运行：</span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo apt-get -y install nginx  </span><br><span class=\"line\">``` </span><br><span class=\"line\"><span class=\"comment\">## nginx配置php</span></span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo vim /etc/php/7.1/fpm/php.ini  </span><br><span class=\"line\">``` </span><br><span class=\"line\">输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：</span><br><span class=\"line\">编辑fpm的配置文件： 运行：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo vim /etc/php/7.1/fpm/pool.d/www.conf  </span><br><span class=\"line\">``` </span><br><span class=\"line\">找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">service php7.1-fpm stop</span><br><span class=\"line\">service php7.1-fpm start</span><br><span class=\"line\">``` </span><br><span class=\"line\">配置Nginx：</span><br><span class=\"line\"></span><br><span class=\"line\">运行：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo vim /etc/nginx/sites-available/default  </span><br><span class=\"line\">``` </span><br><span class=\"line\">下面是配置文件</span><br><span class=\"line\">``` bash</span><br><span class=\"line\">server &#123;  </span><br><span class=\"line\">    <span class=\"comment\">#listen 80 default_server;</span></span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    <span class=\"comment\">#listen [::]:80 default_server ipv6only=on;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    root /var/www;</span><br><span class=\"line\">    index index.php index.html index.htm;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">    <span class=\"comment\"># Make site accessible from http://localhost/</span></span><br><span class=\"line\">    server_name lufficc.com www.lufficc.com;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        <span class=\"comment\"># First attempt to serve request as file, then</span></span><br><span class=\"line\">        <span class=\"comment\"># as directory, then fall back to displaying a 404.</span></span><br><span class=\"line\">        try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</span><br><span class=\"line\">        <span class=\"comment\"># Uncomment to enable naxsi on this location</span></span><br><span class=\"line\">        <span class=\"comment\"># include /etc/nginx/naxsi.rules</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ \\.php$ &#123;</span><br><span class=\"line\">        include snippets/fastcgi-php.conf;</span><br><span class=\"line\">        <span class=\"comment\"># With php7.0-cgi alone:</span></span><br><span class=\"line\">        fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        <span class=\"comment\"># With php7.0-fpm:</span></span><br><span class=\"line\">        fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">  - root：是你的项目的public目录，也就是网站的入口</span><br><span class=\"line\">  - index：添加了，index.php，告诉Nginx先解析index.php文件</span><br><span class=\"line\">  - server_name：你的域名，没有的话填写localhost</span><br><span class=\"line\">  - location / try_files修改为了try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</span><br><span class=\"line\">  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 运行nginx服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo service nginx restart  </span><br><span class=\"line\">sudo service php7.1-fpm restart</span><br></pre></td></tr></table></figure>\n<p>如果出现下列错误<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[emerg]: <span class=\"built_in\">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class=\"keyword\">in</span> use)</span><br></pre></td></tr></table></figure></p>\n<p>这是80端口被占用，运行下面命令，关闭80端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo fuser -k 80/tcp</span><br><span class=\"line\">service nginx start</span><br></pre></td></tr></table></figure>\n<p><strong>好了，一切完成！</strong></p>\n","site":{"data":{}},"excerpt":"<p>我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。</p>\n<blockquote>\n<p>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8</p>\n</blockquote>\n<h2 id=\"安装php7-1\"><a href=\"#安装php7-1\" class=\"headerlink\" title=\"安装php7.1\"></a>安装php7.1</h2><p>安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update  </span><br><span class=\"line\">sudo apt-get install -y language-pack-en-base</span><br></pre></td></tr></table></figure>\n<p>这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。</p>\n<p>安装完成之后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">locale-gen en_US.UTF-8</span><br></pre></td></tr></table></figure>\n<p>设定语言编码为<font color=\"red\">UTF-8</font>。</p>\n<p>进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install software-properties-common</span><br></pre></td></tr></table></figure>","more":"<p>software-properties-common是add-apt-repository所依赖的包，安装成功后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</span><br></pre></td></tr></table></figure>\n<p>安装完成之后，运行<font color=\"red\"><strong>sudo apt-get update</strong></font>更新安装包，把刚才添加的包拉取下来。 运行<strong><font color=\"red\">apt-cache search php7.1</font></strong>搜索php7.1开头的包检验是否安装成功，输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@demo:~<span class=\"comment\"># apt-cache search php7.1  </span></span><br><span class=\"line\">php-yaml - YAML-1.1 parser and emitter <span class=\"keyword\">for</span> PHP  </span><br><span class=\"line\">php-apcu - APC User Cache <span class=\"keyword\">for</span> PHP  </span><br><span class=\"line\">php-ssh2 - Bindings <span class=\"keyword\">for</span> the libssh2 library  </span><br><span class=\"line\">php-igbinary - igbinary PHP serializer  </span><br><span class=\"line\">php-mailparse - Email message manipulation <span class=\"keyword\">for</span> PHP  </span><br><span class=\"line\">php-libsodium - PHP wrapper <span class=\"keyword\">for</span> the Sodium cryptographic library  </span><br><span class=\"line\">php-propro - propro module <span class=\"keyword\">for</span> PHP</span><br><span class=\"line\"></span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br><span class=\"line\">...</span><br></pre></td></tr></table></figure>\n<p>安装php7.1</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get -y install php7.1</span><br></pre></td></tr></table></figure>\n<p>安装完成后运行<strong><font color=\"red\">php -v</font></strong>查看是否安装成功,成功的话显示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">PHP 7.1.0beta2 (cli) ( NTS  )  </span><br><span class=\"line\">Copyright (c) 1997-2016 The PHP Group  </span><br><span class=\"line\">Zend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  </span><br><span class=\"line\">    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies</span><br></pre></td></tr></table></figure>\n<p>接着安装php7.1-mysql，这是php和mysql通信的模块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get -y install php7.1-mysql</span><br></pre></td></tr></table></figure>\n<p>安装 fpm，这是Nginx 用来解析php文件的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install php7.1-fpm</span><br></pre></td></tr></table></figure>\n<p>安装其他必备模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring</span><br></pre></td></tr></table></figure>\n<p>至此与php相关的模块安装安装完成。</p>\n<h2 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h2><p>直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！</p>\n<blockquote>\n<p>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 <a href=\"http://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/mysql/</a> 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。<br>下载.deb包到你的服务器：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb</span><br></pre></td></tr></table></figure>\n<p> 然后使用dpkg命令添加Mysql的源：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo dpkg -i mysql-apt-config_0.5.3-1_all.deb</span><br></pre></td></tr></table></figure></p>\n<p>注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可<br>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get update  </span><br><span class=\"line\">sudo apt-get install mysql-server  </span><br><span class=\"line\">``` </span><br><span class=\"line\">安装完成之后运行mysql -V查看版本：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">root@demo:~<span class=\"comment\"># mysql -V  </span></span><br><span class=\"line\">``` </span><br><span class=\"line\">mysql  Ver 14.14 Distrib 5.7.15, <span class=\"keyword\">for</span> Linux (x86_64) using  EditLine wrapper  </span><br><span class=\"line\">注意</span><br><span class=\"line\"></span><br><span class=\"line\">如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo apt-add-repository --remove ppa:ondrej/mysql-5.6  </span><br><span class=\"line\">``` </span><br><span class=\"line\"> 如果没有 apt-add-repository 先安装上</span><br><span class=\"line\">``` bash</span><br><span class=\"line\"> sudo apt-get install software-properties-common</span><br><span class=\"line\">``` </span><br><span class=\"line\">然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。</span><br><span class=\"line\"><span class=\"comment\">## 安装Nginx</span></span><br><span class=\"line\">简单，运行：</span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo apt-get -y install nginx  </span><br><span class=\"line\">``` </span><br><span class=\"line\"><span class=\"comment\">## nginx配置php</span></span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo vim /etc/php/7.1/fpm/php.ini  </span><br><span class=\"line\">``` </span><br><span class=\"line\">输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：</span><br><span class=\"line\">编辑fpm的配置文件： 运行：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo vim /etc/php/7.1/fpm/pool.d/www.conf  </span><br><span class=\"line\">``` </span><br><span class=\"line\">找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">service php7.1-fpm stop</span><br><span class=\"line\">service php7.1-fpm start</span><br><span class=\"line\">``` </span><br><span class=\"line\">配置Nginx：</span><br><span class=\"line\"></span><br><span class=\"line\">运行：</span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo vim /etc/nginx/sites-available/default  </span><br><span class=\"line\">``` </span><br><span class=\"line\">下面是配置文件</span><br><span class=\"line\">``` bash</span><br><span class=\"line\">server &#123;  </span><br><span class=\"line\">    <span class=\"comment\">#listen 80 default_server;</span></span><br><span class=\"line\">    listen 80;</span><br><span class=\"line\">    <span class=\"comment\">#listen [::]:80 default_server ipv6only=on;</span></span><br><span class=\"line\">    </span><br><span class=\"line\">    root /var/www;</span><br><span class=\"line\">    index index.php index.html index.htm;</span><br><span class=\"line\">                                        </span><br><span class=\"line\">    <span class=\"comment\"># Make site accessible from http://localhost/</span></span><br><span class=\"line\">    server_name lufficc.com www.lufficc.com;</span><br><span class=\"line\">    </span><br><span class=\"line\">    location / &#123;</span><br><span class=\"line\">        <span class=\"comment\"># First attempt to serve request as file, then</span></span><br><span class=\"line\">        <span class=\"comment\"># as directory, then fall back to displaying a 404.</span></span><br><span class=\"line\">        try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</span><br><span class=\"line\">        <span class=\"comment\"># Uncomment to enable naxsi on this location</span></span><br><span class=\"line\">        <span class=\"comment\"># include /etc/nginx/naxsi.rules</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    location ~ \\.php$ &#123;</span><br><span class=\"line\">        include snippets/fastcgi-php.conf;</span><br><span class=\"line\">        <span class=\"comment\"># With php7.0-cgi alone:</span></span><br><span class=\"line\">        fastcgi_pass 127.0.0.1:9000;</span><br><span class=\"line\">        <span class=\"comment\"># With php7.0-fpm:</span></span><br><span class=\"line\">        fastcgi_pass unix:/run/php/php7.0-fpm.sock;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">``` </span><br><span class=\"line\">&gt; </span><br><span class=\"line\">  - root：是你的项目的public目录，也就是网站的入口</span><br><span class=\"line\">  - index：添加了，index.php，告诉Nginx先解析index.php文件</span><br><span class=\"line\">  - server_name：你的域名，没有的话填写localhost</span><br><span class=\"line\">  - location / try_files修改为了try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</span><br><span class=\"line\">  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">## 运行nginx服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">``` bash</span><br><span class=\"line\">sudo service nginx restart  </span><br><span class=\"line\">sudo service php7.1-fpm restart</span><br></pre></td></tr></table></figure>\n<p>如果出现下列错误<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[emerg]: <span class=\"built_in\">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class=\"keyword\">in</span> use)</span><br></pre></td></tr></table></figure></p>\n<p>这是80端口被占用，运行下面命令，关闭80端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo fuser -k 80/tcp</span><br><span class=\"line\">service nginx start</span><br></pre></td></tr></table></figure>\n<p><strong>好了，一切完成！</strong></p>"},{"title":"vi的使用总结","date":"2016-09-21T14:15:36.000Z","_content":"# 初级篇\n## 移动篇\n- 上 k\n- 下 j\n- 左 h\n- 右 l\n\n- 至顶 gg\n- 至尾部 Shift+g\n- 行跳转 行号+gg\n\n- 行首 Shift+6 (^)\n- 行尾 Shift+4 ($) \n\n- 词组移动(词首) w \n- 词组移动(词首) W \n- 词组移动(词尾) e \n- 词组移动(词尾) E \n\n- 移动到查找的字母后 f\n- 移动到查找的字母后 F\n\n<!--more-->\n## 操作篇\n### 增    \n- 在单词前插入 i\n- 在单词前插入 a\n- 在句首前插入 I\n- 在句尾插入 A\n- 在下一行插入 o\n- 在上一行插入 O\n### 删    \n- 删除光标行内容 d\n- 删除光标至尾行内容 D\n- 删除当前行及n-1行数 数字dd\n### 改    \n- 复制 yy\n- 粘贴 p\n- 替换插入 s\n- 替换整句插入 S\n- 替换单个字母 r\n- 接下来的子都要替换 R\n- 当前行替换第一个单词 :s/oldwords/newwords/\n- 替换当前行所有单词 :s/oldwords/newwords/g\n- 替换每一行的第一个单词 :%s/oldwords/newwords/\n- 替换每一行的单词 :%s/oldwords/newwords/g\n\n### 查    \n- 向后查找 /\n- 向前查找 ?\n\n## 选中篇\n- 左选择 v+h\n- 右选择 v+l\n- 上选择 v+k\n- 下选择 v+j\n\n- 选择当前行V(shift+v) \n- 选择向上行V+k(shift+v) \n- 选择向下行V+j(shift+v) \n\n- 括号内的选择 v+i+) (不含括号)\n- 括号内的选择 v+a+) (包含括号)\n\n- 居中显示 zz \n- 头部显示 zt \n- 尾巴显示 zb \n## 退出篇\n- 不保存退出 :q \n- 保存退出 :wq \n- 保存 :w \n- 强制退出 :q! \n- 强制退出 ctrl+z \n- 恢复 fg\n## 文件切换篇\n- 向右切换 tg\n- 向左切换 tG\n\n","source":"_posts/vi的使用总结.md","raw":"---\ntitle: vi的使用总结\ndate: 2016-09-21 22:15:36\ntags: 编辑器\ncategories: 技术\n\n---\n# 初级篇\n## 移动篇\n- 上 k\n- 下 j\n- 左 h\n- 右 l\n\n- 至顶 gg\n- 至尾部 Shift+g\n- 行跳转 行号+gg\n\n- 行首 Shift+6 (^)\n- 行尾 Shift+4 ($) \n\n- 词组移动(词首) w \n- 词组移动(词首) W \n- 词组移动(词尾) e \n- 词组移动(词尾) E \n\n- 移动到查找的字母后 f\n- 移动到查找的字母后 F\n\n<!--more-->\n## 操作篇\n### 增    \n- 在单词前插入 i\n- 在单词前插入 a\n- 在句首前插入 I\n- 在句尾插入 A\n- 在下一行插入 o\n- 在上一行插入 O\n### 删    \n- 删除光标行内容 d\n- 删除光标至尾行内容 D\n- 删除当前行及n-1行数 数字dd\n### 改    \n- 复制 yy\n- 粘贴 p\n- 替换插入 s\n- 替换整句插入 S\n- 替换单个字母 r\n- 接下来的子都要替换 R\n- 当前行替换第一个单词 :s/oldwords/newwords/\n- 替换当前行所有单词 :s/oldwords/newwords/g\n- 替换每一行的第一个单词 :%s/oldwords/newwords/\n- 替换每一行的单词 :%s/oldwords/newwords/g\n\n### 查    \n- 向后查找 /\n- 向前查找 ?\n\n## 选中篇\n- 左选择 v+h\n- 右选择 v+l\n- 上选择 v+k\n- 下选择 v+j\n\n- 选择当前行V(shift+v) \n- 选择向上行V+k(shift+v) \n- 选择向下行V+j(shift+v) \n\n- 括号内的选择 v+i+) (不含括号)\n- 括号内的选择 v+a+) (包含括号)\n\n- 居中显示 zz \n- 头部显示 zt \n- 尾巴显示 zb \n## 退出篇\n- 不保存退出 :q \n- 保存退出 :wq \n- 保存 :w \n- 强制退出 :q! \n- 强制退出 ctrl+z \n- 恢复 fg\n## 文件切换篇\n- 向右切换 tg\n- 向左切换 tG\n\n","slug":"vi的使用总结","published":1,"updated":"2018-05-27T09:59:36.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sih000gth8l700zn1y2","content":"<h1 id=\"初级篇\"><a href=\"#初级篇\" class=\"headerlink\" title=\"初级篇\"></a>初级篇</h1><h2 id=\"移动篇\"><a href=\"#移动篇\" class=\"headerlink\" title=\"移动篇\"></a>移动篇</h2><ul>\n<li>上 k</li>\n<li>下 j</li>\n<li>左 h</li>\n<li><p>右 l</p>\n</li>\n<li><p>至顶 gg</p>\n</li>\n<li>至尾部 Shift+g</li>\n<li><p>行跳转 行号+gg</p>\n</li>\n<li><p>行首 Shift+6 (^)</p>\n</li>\n<li><p>行尾 Shift+4 ($) </p>\n</li>\n<li><p>词组移动(词首) w </p>\n</li>\n<li>词组移动(词首) W </li>\n<li>词组移动(词尾) e </li>\n<li><p>词组移动(词尾) E </p>\n</li>\n<li><p>移动到查找的字母后 f</p>\n</li>\n<li>移动到查找的字母后 F</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"操作篇\"><a href=\"#操作篇\" class=\"headerlink\" title=\"操作篇\"></a>操作篇</h2><h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li>在单词前插入 i</li>\n<li>在单词前插入 a</li>\n<li>在句首前插入 I</li>\n<li>在句尾插入 A</li>\n<li>在下一行插入 o</li>\n<li>在上一行插入 O<h3 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h3></li>\n<li>删除光标行内容 d</li>\n<li>删除光标至尾行内容 D</li>\n<li>删除当前行及n-1行数 数字dd<h3 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h3></li>\n<li>复制 yy</li>\n<li>粘贴 p</li>\n<li>替换插入 s</li>\n<li>替换整句插入 S</li>\n<li>替换单个字母 r</li>\n<li>接下来的子都要替换 R</li>\n<li>当前行替换第一个单词 :s/oldwords/newwords/</li>\n<li>替换当前行所有单词 :s/oldwords/newwords/g</li>\n<li>替换每一行的第一个单词 :%s/oldwords/newwords/</li>\n<li>替换每一行的单词 :%s/oldwords/newwords/g</li>\n</ul>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li>向后查找 /</li>\n<li>向前查找 ?</li>\n</ul>\n<h2 id=\"选中篇\"><a href=\"#选中篇\" class=\"headerlink\" title=\"选中篇\"></a>选中篇</h2><ul>\n<li>左选择 v+h</li>\n<li>右选择 v+l</li>\n<li>上选择 v+k</li>\n<li><p>下选择 v+j</p>\n</li>\n<li><p>选择当前行V(shift+v) </p>\n</li>\n<li>选择向上行V+k(shift+v) </li>\n<li><p>选择向下行V+j(shift+v) </p>\n</li>\n<li><p>括号内的选择 v+i+) (不含括号)</p>\n</li>\n<li><p>括号内的选择 v+a+) (包含括号)</p>\n</li>\n<li><p>居中显示 zz </p>\n</li>\n<li>头部显示 zt </li>\n<li>尾巴显示 zb <h2 id=\"退出篇\"><a href=\"#退出篇\" class=\"headerlink\" title=\"退出篇\"></a>退出篇</h2></li>\n<li>不保存退出 :q </li>\n<li>保存退出 :wq </li>\n<li>保存 :w </li>\n<li>强制退出 :q! </li>\n<li>强制退出 ctrl+z </li>\n<li>恢复 fg<h2 id=\"文件切换篇\"><a href=\"#文件切换篇\" class=\"headerlink\" title=\"文件切换篇\"></a>文件切换篇</h2></li>\n<li>向右切换 tg</li>\n<li>向左切换 tG</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"初级篇\"><a href=\"#初级篇\" class=\"headerlink\" title=\"初级篇\"></a>初级篇</h1><h2 id=\"移动篇\"><a href=\"#移动篇\" class=\"headerlink\" title=\"移动篇\"></a>移动篇</h2><ul>\n<li>上 k</li>\n<li>下 j</li>\n<li>左 h</li>\n<li><p>右 l</p>\n</li>\n<li><p>至顶 gg</p>\n</li>\n<li>至尾部 Shift+g</li>\n<li><p>行跳转 行号+gg</p>\n</li>\n<li><p>行首 Shift+6 (^)</p>\n</li>\n<li><p>行尾 Shift+4 ($) </p>\n</li>\n<li><p>词组移动(词首) w </p>\n</li>\n<li>词组移动(词首) W </li>\n<li>词组移动(词尾) e </li>\n<li><p>词组移动(词尾) E </p>\n</li>\n<li><p>移动到查找的字母后 f</p>\n</li>\n<li>移动到查找的字母后 F</li>\n</ul>","more":"<h2 id=\"操作篇\"><a href=\"#操作篇\" class=\"headerlink\" title=\"操作篇\"></a>操作篇</h2><h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li>在单词前插入 i</li>\n<li>在单词前插入 a</li>\n<li>在句首前插入 I</li>\n<li>在句尾插入 A</li>\n<li>在下一行插入 o</li>\n<li>在上一行插入 O<h3 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h3></li>\n<li>删除光标行内容 d</li>\n<li>删除光标至尾行内容 D</li>\n<li>删除当前行及n-1行数 数字dd<h3 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h3></li>\n<li>复制 yy</li>\n<li>粘贴 p</li>\n<li>替换插入 s</li>\n<li>替换整句插入 S</li>\n<li>替换单个字母 r</li>\n<li>接下来的子都要替换 R</li>\n<li>当前行替换第一个单词 :s/oldwords/newwords/</li>\n<li>替换当前行所有单词 :s/oldwords/newwords/g</li>\n<li>替换每一行的第一个单词 :%s/oldwords/newwords/</li>\n<li>替换每一行的单词 :%s/oldwords/newwords/g</li>\n</ul>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li>向后查找 /</li>\n<li>向前查找 ?</li>\n</ul>\n<h2 id=\"选中篇\"><a href=\"#选中篇\" class=\"headerlink\" title=\"选中篇\"></a>选中篇</h2><ul>\n<li>左选择 v+h</li>\n<li>右选择 v+l</li>\n<li>上选择 v+k</li>\n<li><p>下选择 v+j</p>\n</li>\n<li><p>选择当前行V(shift+v) </p>\n</li>\n<li>选择向上行V+k(shift+v) </li>\n<li><p>选择向下行V+j(shift+v) </p>\n</li>\n<li><p>括号内的选择 v+i+) (不含括号)</p>\n</li>\n<li><p>括号内的选择 v+a+) (包含括号)</p>\n</li>\n<li><p>居中显示 zz </p>\n</li>\n<li>头部显示 zt </li>\n<li>尾巴显示 zb <h2 id=\"退出篇\"><a href=\"#退出篇\" class=\"headerlink\" title=\"退出篇\"></a>退出篇</h2></li>\n<li>不保存退出 :q </li>\n<li>保存退出 :wq </li>\n<li>保存 :w </li>\n<li>强制退出 :q! </li>\n<li>强制退出 ctrl+z </li>\n<li>恢复 fg<h2 id=\"文件切换篇\"><a href=\"#文件切换篇\" class=\"headerlink\" title=\"文件切换篇\"></a>文件切换篇</h2></li>\n<li>向右切换 tg</li>\n<li>向左切换 tG</li>\n</ul>"},{"title":"swoole利用websocket进行wss访问","date":"2018-01-03T13:32:26.000Z","_content":"最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。\n> **websocket**: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n## 在docker中搭建swoole的环境\n* 先建立build_swoole.sh这样的安装shell文件\n``` shell\napk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev\nln -s /usr/bin/php-config7 /usr/bin/php-config\nln -s /usr/bin/phpize7 /usr/bin/phpize\ncd /root/\ngit clone https://github.com/swoole/swoole-src.git\ncd /root/swoole-src\nphpize\n./configure --enable-openssl\nmake && make install\napk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev\napk del --no-cache php-dev\napk del --no-cache git\napk del --no-cache build-base\napk del --no-cache make\napk del --no-cache openssl-dev\napk del --no-cache linux-headers\napk del --no-cache libaio-dev\napk del --no-cache pcre-dev\napk del --no-cache autoconf\napk del --no-cache .persistent-deps\napk del --no-cache libmcrypt-dev\napk del --no-cache g++\n# apk del --no-cache icu-dev\napk info\nphp -m\nrm -rf /var/cache/apk/*\nrm -rf /root/swoole-src/\nrm -rf /tmp/*\n```\n* 然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入`extension=swoole.so`\n``` shell\nFROM zacksleo/php:7.1-alpine-fpm-supervisor\nCOPY build_swoole.sh /root\nRUN sh /root/build_swoole.sh\n```\n* 接着`docker-composer build 创建对应的docker镜像`，并且运行`docker-composer up`，在进入对应的docker容器中`docker exec 你的镜像名`,执行命令`php -m`,如果出现swoole，那我们的swoole扩展就安装好了\n<!--more-->\n## 创建服务器的swoole的监听\n``` php\n<?php\n\nnamespace console\\controllers;\n\nuse common\\models\\QrcodeToken;\nuse yii;\nuse common\\models\\User;\nuse yii\\console\\Controller;\nuse Swoole\\WebSocket\\Server;\n\n/**\n * Class PremiumController\n * @package console\\controllers\n * @auth graychen <455803034@qq.com>\n */\nclass WebSocketController extends Controller\n{\n    public $server;\n\n    /**\n     * websocket 监听扫码登录\n     */\n    public function actionListenLogin()\n    {\n        $setConfig = array(\n            'ssl_key_file' => '/var/www/html/services/nginx/ssl-cert/ssl.key',\n            'ssl_cert_file' => '/var/www/html/services/nginx/ssl-cert/ssl.crt'\n        );\n        $this->server = new Server('0.0.0.0', 9502, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);\n        $this->server->set($setConfig);\n        $this->server->on('open', function (Server $server, $request) {\n            echo \"server: handshake success with fd{$request->fd}\\n\";\n        });\n        $this->server->on('message', function (Server $server, $frame) {\n            echo \"receive from {$frame->fd}:{$frame->data},opcode:{$frame->opcode},fin:{$frame->finish}\\n\";\n            $message = json_decode($frame->data);\n            $timestamp = $message->timestamp;\n            $token = $message->token;\n            swoole_timer_tick(1000, function ($timerId) use ($token, $server, $frame) {\n                $token = $this->findModel($token);\n                if ($token === null || $token->status == QrcodeToken::STATUS_EXPIRED) {\n                    $response = json_encode([\n                        'timestamp' => time(),\n                        'status' => QrcodeToken::STATUS_EXPIRED\n                    ]);\n                    $server->push($frame->fd, $response);\n                    swoole_timer_clear($timerId);\n                } else {\n                    if ($server->exist($frame->fd) && in_array($token->status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) {\n                        $response = json_encode([\n                            'timestamp' => $token->updated_at,\n                            'status' => $token->status\n                        ]);\n                        $server->push($frame->fd, $response);\n                    }\n                };\n            });\n        });\n        $this->server->on('close', function (Server $server, $fd) {\n            echo \"client {$fd} closed\\n\";\n        });\n        $this->server->start();\n    }\n\n    private function findModel($id)\n    {\n        clearstatcache();\n        $token = QrcodeToken::findOne(['id' => $id]);\n        return $token;\n    }\n}\n\n```\n* 如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。\n``` js\nvar error = false;\n    var timestamp = {$timestamp};\n    var _t = '{$token}';\n    function startWebSocket(){\n        var host=document.domain;\n        websocket = new WebSocket('wss://' + host + ':9502');\n        websocket.onopen = function (evt) {\n            var message={\n                timestamp:timestamp,\n                token:_t\n            };\n            if(message!==null){\n                websocket.send(JSON.stringify(message));\n            }\n        };\n        websocket.onclose = function (evt) {\n            console.log(\\\"关闭连接\\\");\n        };\n        websocket.onmessage = function (evt) {\n            var response=JSON.parse(evt.data);\n            if(response.status==1){                  \n              $('#fn-tips').text('已扫码, 请点击确认');\n              timestamp = response.timestamp;\n            }\n            if(response.status==2){\n              $('#fn-tips').text('已登录, 正在跳转···');\n              setTimeout(function(){\n                $('#ff-qrcode-token').submit();                    \n              },500);                  \n            }\n            if(response.status==-2){\n              alert('二维码已失效, 请刷新页面');\n            }\n            error = false;\n            timestamp = response.timestamp;                \n        };\n        \n        websocket.onerror = function (evt, e) {\n            console.log('错误代码: ' + evt.data);\n        };\n    }\n\n```\n\n\n\n\n\n","source":"_posts/websocket结合swoole进行wss访问.md","raw":"---\ntitle: swoole利用websocket进行wss访问\ndate: 2018-01-03 21:32:26\ntags: 技术\n---\n最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。\n> **websocket**: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n## 在docker中搭建swoole的环境\n* 先建立build_swoole.sh这样的安装shell文件\n``` shell\napk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev\nln -s /usr/bin/php-config7 /usr/bin/php-config\nln -s /usr/bin/phpize7 /usr/bin/phpize\ncd /root/\ngit clone https://github.com/swoole/swoole-src.git\ncd /root/swoole-src\nphpize\n./configure --enable-openssl\nmake && make install\napk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev\napk del --no-cache php-dev\napk del --no-cache git\napk del --no-cache build-base\napk del --no-cache make\napk del --no-cache openssl-dev\napk del --no-cache linux-headers\napk del --no-cache libaio-dev\napk del --no-cache pcre-dev\napk del --no-cache autoconf\napk del --no-cache .persistent-deps\napk del --no-cache libmcrypt-dev\napk del --no-cache g++\n# apk del --no-cache icu-dev\napk info\nphp -m\nrm -rf /var/cache/apk/*\nrm -rf /root/swoole-src/\nrm -rf /tmp/*\n```\n* 然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入`extension=swoole.so`\n``` shell\nFROM zacksleo/php:7.1-alpine-fpm-supervisor\nCOPY build_swoole.sh /root\nRUN sh /root/build_swoole.sh\n```\n* 接着`docker-composer build 创建对应的docker镜像`，并且运行`docker-composer up`，在进入对应的docker容器中`docker exec 你的镜像名`,执行命令`php -m`,如果出现swoole，那我们的swoole扩展就安装好了\n<!--more-->\n## 创建服务器的swoole的监听\n``` php\n<?php\n\nnamespace console\\controllers;\n\nuse common\\models\\QrcodeToken;\nuse yii;\nuse common\\models\\User;\nuse yii\\console\\Controller;\nuse Swoole\\WebSocket\\Server;\n\n/**\n * Class PremiumController\n * @package console\\controllers\n * @auth graychen <455803034@qq.com>\n */\nclass WebSocketController extends Controller\n{\n    public $server;\n\n    /**\n     * websocket 监听扫码登录\n     */\n    public function actionListenLogin()\n    {\n        $setConfig = array(\n            'ssl_key_file' => '/var/www/html/services/nginx/ssl-cert/ssl.key',\n            'ssl_cert_file' => '/var/www/html/services/nginx/ssl-cert/ssl.crt'\n        );\n        $this->server = new Server('0.0.0.0', 9502, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);\n        $this->server->set($setConfig);\n        $this->server->on('open', function (Server $server, $request) {\n            echo \"server: handshake success with fd{$request->fd}\\n\";\n        });\n        $this->server->on('message', function (Server $server, $frame) {\n            echo \"receive from {$frame->fd}:{$frame->data},opcode:{$frame->opcode},fin:{$frame->finish}\\n\";\n            $message = json_decode($frame->data);\n            $timestamp = $message->timestamp;\n            $token = $message->token;\n            swoole_timer_tick(1000, function ($timerId) use ($token, $server, $frame) {\n                $token = $this->findModel($token);\n                if ($token === null || $token->status == QrcodeToken::STATUS_EXPIRED) {\n                    $response = json_encode([\n                        'timestamp' => time(),\n                        'status' => QrcodeToken::STATUS_EXPIRED\n                    ]);\n                    $server->push($frame->fd, $response);\n                    swoole_timer_clear($timerId);\n                } else {\n                    if ($server->exist($frame->fd) && in_array($token->status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) {\n                        $response = json_encode([\n                            'timestamp' => $token->updated_at,\n                            'status' => $token->status\n                        ]);\n                        $server->push($frame->fd, $response);\n                    }\n                };\n            });\n        });\n        $this->server->on('close', function (Server $server, $fd) {\n            echo \"client {$fd} closed\\n\";\n        });\n        $this->server->start();\n    }\n\n    private function findModel($id)\n    {\n        clearstatcache();\n        $token = QrcodeToken::findOne(['id' => $id]);\n        return $token;\n    }\n}\n\n```\n* 如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。\n``` js\nvar error = false;\n    var timestamp = {$timestamp};\n    var _t = '{$token}';\n    function startWebSocket(){\n        var host=document.domain;\n        websocket = new WebSocket('wss://' + host + ':9502');\n        websocket.onopen = function (evt) {\n            var message={\n                timestamp:timestamp,\n                token:_t\n            };\n            if(message!==null){\n                websocket.send(JSON.stringify(message));\n            }\n        };\n        websocket.onclose = function (evt) {\n            console.log(\\\"关闭连接\\\");\n        };\n        websocket.onmessage = function (evt) {\n            var response=JSON.parse(evt.data);\n            if(response.status==1){                  \n              $('#fn-tips').text('已扫码, 请点击确认');\n              timestamp = response.timestamp;\n            }\n            if(response.status==2){\n              $('#fn-tips').text('已登录, 正在跳转···');\n              setTimeout(function(){\n                $('#ff-qrcode-token').submit();                    \n              },500);                  \n            }\n            if(response.status==-2){\n              alert('二维码已失效, 请刷新页面');\n            }\n            error = false;\n            timestamp = response.timestamp;                \n        };\n        \n        websocket.onerror = function (evt, e) {\n            console.log('错误代码: ' + evt.data);\n        };\n    }\n\n```\n\n\n\n\n\n","slug":"websocket结合swoole进行wss访问","published":1,"updated":"2018-05-27T09:59:36.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sii000hth8lsf5wh301","content":"<p>最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。</p>\n<blockquote>\n<p><strong>websocket</strong>: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n</blockquote>\n<h2 id=\"在docker中搭建swoole的环境\"><a href=\"#在docker中搭建swoole的环境\" class=\"headerlink\" title=\"在docker中搭建swoole的环境\"></a>在docker中搭建swoole的环境</h2><ul>\n<li><p>先建立build_swoole.sh这样的安装shell文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev</span><br><span class=\"line\">ln -s /usr/bin/php-config7 /usr/bin/php-config</span><br><span class=\"line\">ln -s /usr/bin/phpize7 /usr/bin/phpize</span><br><span class=\"line\">cd /root/</span><br><span class=\"line\">git clone https://github.com/swoole/swoole-src.git</span><br><span class=\"line\">cd /root/swoole-src</span><br><span class=\"line\">phpize</span><br><span class=\"line\">./configure --enable-openssl</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\">apk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev</span><br><span class=\"line\">apk del --no-cache php-dev</span><br><span class=\"line\">apk del --no-cache git</span><br><span class=\"line\">apk del --no-cache build-base</span><br><span class=\"line\">apk del --no-cache make</span><br><span class=\"line\">apk del --no-cache openssl-dev</span><br><span class=\"line\">apk del --no-cache linux-headers</span><br><span class=\"line\">apk del --no-cache libaio-dev</span><br><span class=\"line\">apk del --no-cache pcre-dev</span><br><span class=\"line\">apk del --no-cache autoconf</span><br><span class=\"line\">apk del --no-cache .persistent-deps</span><br><span class=\"line\">apk del --no-cache libmcrypt-dev</span><br><span class=\"line\">apk del --no-cache g++</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> apk del --no-cache icu-dev</span></span><br><span class=\"line\">apk info</span><br><span class=\"line\">php -m</span><br><span class=\"line\">rm -rf /var/cache/apk/*</span><br><span class=\"line\">rm -rf /root/swoole-src/</span><br><span class=\"line\">rm -rf /tmp/*</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入<code>extension=swoole.so</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM zacksleo/php:7.1-alpine-fpm-supervisor</span><br><span class=\"line\">COPY build_swoole.sh /root</span><br><span class=\"line\">RUN sh /root/build_swoole.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着<code>docker-composer build 创建对应的docker镜像</code>，并且运行<code>docker-composer up</code>，在进入对应的docker容器中<code>docker exec 你的镜像名</code>,执行命令<code>php -m</code>,如果出现swoole，那我们的swoole扩展就安装好了</p>\n<a id=\"more\"></a>\n<h2 id=\"创建服务器的swoole的监听\"><a href=\"#创建服务器的swoole的监听\" class=\"headerlink\" title=\"创建服务器的swoole的监听\"></a>创建服务器的swoole的监听</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">console</span>\\<span class=\"title\">controllers</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">QrcodeToken</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">User</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>\\<span class=\"title\">console</span>\\<span class=\"title\">Controller</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Swoole</span>\\<span class=\"title\">WebSocket</span>\\<span class=\"title\">Server</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Class PremiumController</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@package</span> console\\controllers</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@auth</span> graychen &lt;455803034<span class=\"doctag\">@qq</span>.com&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSocketController</span> <span class=\"keyword\">extends</span> <span class=\"title\">Controller</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $server;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * websocket 监听扫码登录</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionListenLogin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $setConfig = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">            <span class=\"string\">'ssl_key_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.key'</span>,</span><br><span class=\"line\">            <span class=\"string\">'ssl_cert_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.crt'</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server = <span class=\"keyword\">new</span> Server(<span class=\"string\">'0.0.0.0'</span>, <span class=\"number\">9502</span>, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;set($setConfig);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'open'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $request)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"server: handshake success with fd&#123;$request-&gt;fd&#125;\\n\"</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $frame)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n\"</span>;</span><br><span class=\"line\">            $message = json_decode($frame-&gt;data);</span><br><span class=\"line\">            $timestamp = $message-&gt;timestamp;</span><br><span class=\"line\">            $token = $message-&gt;token;</span><br><span class=\"line\">            swoole_timer_tick(<span class=\"number\">1000</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">($timerId)</span> <span class=\"title\">use</span> <span class=\"params\">($token, $server, $frame)</span> </span>&#123;</span><br><span class=\"line\">                $token = <span class=\"keyword\">$this</span>-&gt;findModel($token);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ($token === <span class=\"keyword\">null</span> || $token-&gt;status == QrcodeToken::STATUS_EXPIRED) &#123;</span><br><span class=\"line\">                    $response = json_encode([</span><br><span class=\"line\">                        <span class=\"string\">'timestamp'</span> =&gt; time(),</span><br><span class=\"line\">                        <span class=\"string\">'status'</span> =&gt; QrcodeToken::STATUS_EXPIRED</span><br><span class=\"line\">                    ]);</span><br><span class=\"line\">                    $server-&gt;push($frame-&gt;fd, $response);</span><br><span class=\"line\">                    swoole_timer_clear($timerId);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ($server-&gt;exist($frame-&gt;fd) &amp;&amp; in_array($token-&gt;status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) &#123;</span><br><span class=\"line\">                        $response = json_encode([</span><br><span class=\"line\">                            <span class=\"string\">'timestamp'</span> =&gt; $token-&gt;updated_at,</span><br><span class=\"line\">                            <span class=\"string\">'status'</span> =&gt; $token-&gt;status</span><br><span class=\"line\">                        ]);</span><br><span class=\"line\">                        $server-&gt;push($frame-&gt;fd, $response);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'close'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $fd)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"client &#123;$fd&#125; closed\\n\"</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findModel</span><span class=\"params\">($id)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        clearstatcache();</span><br><span class=\"line\">        $token = QrcodeToken::findOne([<span class=\"string\">'id'</span> =&gt; $id]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> error = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timestamp = &#123;$timestamp&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _t = <span class=\"string\">'&#123;$token&#125;'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startWebSocket</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> host=<span class=\"built_in\">document</span>.domain;</span><br><span class=\"line\">        websocket = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'wss://'</span> + host + <span class=\"string\">':9502'</span>);</span><br><span class=\"line\">        websocket.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> message=&#123;</span><br><span class=\"line\">                timestamp:timestamp,</span><br><span class=\"line\">                token:_t</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(message!==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                websocket.send(<span class=\"built_in\">JSON</span>.stringify(message));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        websocket.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(\\<span class=\"string\">\"关闭连接\\\");</span></span><br><span class=\"line\"><span class=\"string\">        &#125;;</span></span><br><span class=\"line\"><span class=\"string\">        websocket.onmessage = function (evt) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            var response=JSON.parse(evt.data);</span></span><br><span class=\"line\"><span class=\"string\">            if(response.status==1)&#123;                  </span></span><br><span class=\"line\"><span class=\"string\">              $('#fn-tips').text('已扫码, 请点击确认');</span></span><br><span class=\"line\"><span class=\"string\">              timestamp = response.timestamp;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            if(response.status==2)&#123;</span></span><br><span class=\"line\"><span class=\"string\">              $('#fn-tips').text('已登录, 正在跳转···');</span></span><br><span class=\"line\"><span class=\"string\">              setTimeout(function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">                $('#ff-qrcode-token').submit();                    </span></span><br><span class=\"line\"><span class=\"string\">              &#125;,500);                  </span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            if(response.status==-2)&#123;</span></span><br><span class=\"line\"><span class=\"string\">              alert('二维码已失效, 请刷新页面');</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            error = false;</span></span><br><span class=\"line\"><span class=\"string\">            timestamp = response.timestamp;                </span></span><br><span class=\"line\"><span class=\"string\">        &#125;;</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        websocket.onerror = function (evt, e) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            console.log('错误代码: ' + evt.data);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。</p>\n<blockquote>\n<p><strong>websocket</strong>: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n</blockquote>\n<h2 id=\"在docker中搭建swoole的环境\"><a href=\"#在docker中搭建swoole的环境\" class=\"headerlink\" title=\"在docker中搭建swoole的环境\"></a>在docker中搭建swoole的环境</h2><ul>\n<li><p>先建立build_swoole.sh这样的安装shell文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev</span><br><span class=\"line\">ln -s /usr/bin/php-config7 /usr/bin/php-config</span><br><span class=\"line\">ln -s /usr/bin/phpize7 /usr/bin/phpize</span><br><span class=\"line\">cd /root/</span><br><span class=\"line\">git clone https://github.com/swoole/swoole-src.git</span><br><span class=\"line\">cd /root/swoole-src</span><br><span class=\"line\">phpize</span><br><span class=\"line\">./configure --enable-openssl</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\">apk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev</span><br><span class=\"line\">apk del --no-cache php-dev</span><br><span class=\"line\">apk del --no-cache git</span><br><span class=\"line\">apk del --no-cache build-base</span><br><span class=\"line\">apk del --no-cache make</span><br><span class=\"line\">apk del --no-cache openssl-dev</span><br><span class=\"line\">apk del --no-cache linux-headers</span><br><span class=\"line\">apk del --no-cache libaio-dev</span><br><span class=\"line\">apk del --no-cache pcre-dev</span><br><span class=\"line\">apk del --no-cache autoconf</span><br><span class=\"line\">apk del --no-cache .persistent-deps</span><br><span class=\"line\">apk del --no-cache libmcrypt-dev</span><br><span class=\"line\">apk del --no-cache g++</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> apk del --no-cache icu-dev</span></span><br><span class=\"line\">apk info</span><br><span class=\"line\">php -m</span><br><span class=\"line\">rm -rf /var/cache/apk/*</span><br><span class=\"line\">rm -rf /root/swoole-src/</span><br><span class=\"line\">rm -rf /tmp/*</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入<code>extension=swoole.so</code></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">FROM zacksleo/php:7.1-alpine-fpm-supervisor</span><br><span class=\"line\">COPY build_swoole.sh /root</span><br><span class=\"line\">RUN sh /root/build_swoole.sh</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着<code>docker-composer build 创建对应的docker镜像</code>，并且运行<code>docker-composer up</code>，在进入对应的docker容器中<code>docker exec 你的镜像名</code>,执行命令<code>php -m</code>,如果出现swoole，那我们的swoole扩展就安装好了</p>","more":"<h2 id=\"创建服务器的swoole的监听\"><a href=\"#创建服务器的swoole的监听\" class=\"headerlink\" title=\"创建服务器的swoole的监听\"></a>创建服务器的swoole的监听</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">console</span>\\<span class=\"title\">controllers</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">QrcodeToken</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">User</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>\\<span class=\"title\">console</span>\\<span class=\"title\">Controller</span>;</span><br><span class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Swoole</span>\\<span class=\"title\">WebSocket</span>\\<span class=\"title\">Server</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Class PremiumController</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@package</span> console\\controllers</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@auth</span> graychen &lt;455803034<span class=\"doctag\">@qq</span>.com&gt;</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSocketController</span> <span class=\"keyword\">extends</span> <span class=\"title\">Controller</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $server;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * websocket 监听扫码登录</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionListenLogin</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $setConfig = <span class=\"keyword\">array</span>(</span><br><span class=\"line\">            <span class=\"string\">'ssl_key_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.key'</span>,</span><br><span class=\"line\">            <span class=\"string\">'ssl_cert_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.crt'</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server = <span class=\"keyword\">new</span> Server(<span class=\"string\">'0.0.0.0'</span>, <span class=\"number\">9502</span>, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;set($setConfig);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'open'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $request)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"server: handshake success with fd&#123;$request-&gt;fd&#125;\\n\"</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $frame)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n\"</span>;</span><br><span class=\"line\">            $message = json_decode($frame-&gt;data);</span><br><span class=\"line\">            $timestamp = $message-&gt;timestamp;</span><br><span class=\"line\">            $token = $message-&gt;token;</span><br><span class=\"line\">            swoole_timer_tick(<span class=\"number\">1000</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">($timerId)</span> <span class=\"title\">use</span> <span class=\"params\">($token, $server, $frame)</span> </span>&#123;</span><br><span class=\"line\">                $token = <span class=\"keyword\">$this</span>-&gt;findModel($token);</span><br><span class=\"line\">                <span class=\"keyword\">if</span> ($token === <span class=\"keyword\">null</span> || $token-&gt;status == QrcodeToken::STATUS_EXPIRED) &#123;</span><br><span class=\"line\">                    $response = json_encode([</span><br><span class=\"line\">                        <span class=\"string\">'timestamp'</span> =&gt; time(),</span><br><span class=\"line\">                        <span class=\"string\">'status'</span> =&gt; QrcodeToken::STATUS_EXPIRED</span><br><span class=\"line\">                    ]);</span><br><span class=\"line\">                    $server-&gt;push($frame-&gt;fd, $response);</span><br><span class=\"line\">                    swoole_timer_clear($timerId);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> ($server-&gt;exist($frame-&gt;fd) &amp;&amp; in_array($token-&gt;status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) &#123;</span><br><span class=\"line\">                        $response = json_encode([</span><br><span class=\"line\">                            <span class=\"string\">'timestamp'</span> =&gt; $token-&gt;updated_at,</span><br><span class=\"line\">                            <span class=\"string\">'status'</span> =&gt; $token-&gt;status</span><br><span class=\"line\">                        ]);</span><br><span class=\"line\">                        $server-&gt;push($frame-&gt;fd, $response);</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;);</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'close'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $fd)</span> </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"client &#123;$fd&#125; closed\\n\"</span>;</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findModel</span><span class=\"params\">($id)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        clearstatcache();</span><br><span class=\"line\">        $token = QrcodeToken::findOne([<span class=\"string\">'id'</span> =&gt; $id]);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> $token;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> error = <span class=\"literal\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> timestamp = &#123;$timestamp&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">var</span> _t = <span class=\"string\">'&#123;$token&#125;'</span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">startWebSocket</span>(<span class=\"params\"></span>)</span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">var</span> host=<span class=\"built_in\">document</span>.domain;</span><br><span class=\"line\">        websocket = <span class=\"keyword\">new</span> WebSocket(<span class=\"string\">'wss://'</span> + host + <span class=\"string\">':9502'</span>);</span><br><span class=\"line\">        websocket.onopen = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"keyword\">var</span> message=&#123;</span><br><span class=\"line\">                timestamp:timestamp,</span><br><span class=\"line\">                token:_t</span><br><span class=\"line\">            &#125;;</span><br><span class=\"line\">            <span class=\"keyword\">if</span>(message!==<span class=\"literal\">null</span>)&#123;</span><br><span class=\"line\">                websocket.send(<span class=\"built_in\">JSON</span>.stringify(message));</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        websocket.onclose = <span class=\"function\"><span class=\"keyword\">function</span> (<span class=\"params\">evt</span>) </span>&#123;</span><br><span class=\"line\">            <span class=\"built_in\">console</span>.log(\\<span class=\"string\">\"关闭连接\\\");</span></span><br><span class=\"line\"><span class=\"string\">        &#125;;</span></span><br><span class=\"line\"><span class=\"string\">        websocket.onmessage = function (evt) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            var response=JSON.parse(evt.data);</span></span><br><span class=\"line\"><span class=\"string\">            if(response.status==1)&#123;                  </span></span><br><span class=\"line\"><span class=\"string\">              $('#fn-tips').text('已扫码, 请点击确认');</span></span><br><span class=\"line\"><span class=\"string\">              timestamp = response.timestamp;</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            if(response.status==2)&#123;</span></span><br><span class=\"line\"><span class=\"string\">              $('#fn-tips').text('已登录, 正在跳转···');</span></span><br><span class=\"line\"><span class=\"string\">              setTimeout(function()&#123;</span></span><br><span class=\"line\"><span class=\"string\">                $('#ff-qrcode-token').submit();                    </span></span><br><span class=\"line\"><span class=\"string\">              &#125;,500);                  </span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            if(response.status==-2)&#123;</span></span><br><span class=\"line\"><span class=\"string\">              alert('二维码已失效, 请刷新页面');</span></span><br><span class=\"line\"><span class=\"string\">            &#125;</span></span><br><span class=\"line\"><span class=\"string\">            error = false;</span></span><br><span class=\"line\"><span class=\"string\">            timestamp = response.timestamp;                </span></span><br><span class=\"line\"><span class=\"string\">        &#125;;</span></span><br><span class=\"line\"><span class=\"string\">        </span></span><br><span class=\"line\"><span class=\"string\">        websocket.onerror = function (evt, e) &#123;</span></span><br><span class=\"line\"><span class=\"string\">            console.log('错误代码: ' + evt.data);</span></span><br><span class=\"line\"><span class=\"string\">        &#125;;</span></span><br><span class=\"line\"><span class=\"string\">    &#125;</span></span><br></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"yii2-queue队列的使用说明","date":"2017-07-28T04:15:36.000Z","_content":"## 概述\n\nyii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。\n\n## 来源\n\n+ [github](https://github.com/yiisoft/yii2-queue)\n+ [packaglist](https://packagist.org/packages/yiisoft/yii2-queue)\n\n<!--more-->\n## 安装 \n\n``` php\ncomposer require yiisoft/yii2-queue\n```\n或者\n\n``` php\n在composer中添加\"yiisoft/yii2-queue\": \"~2.0.0\",然后持续composer install\n```\n<!--more-->\n\n## 操作步骤\n发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：\n下面的例子以redis作为驱动，[其它驱动](https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md)\n首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/\n注意要为queue配置一个queue的redis配置\n```return [\n    'bootstrap' => [\n            'queue', // The component registers own console commands\n    ],\n    'compoents' => [\n        ...//其它的配置\n        'redis_queue' => [\n            'class' => 'yii\\redis\\Connection',\n            'hostname' => 'redis',\n            'port' => '6379',\n            'database' => 0,\n        ],\n        'queue' => [\n            'class' => \\yii\\queue\\redis\\Queue::class,\n            'redis' => 'redis2', // Redis connection component or its config\n            'channel' => 'queue', // Queue channel key\n            'as log' => \\yii\\queue\\LogBehavior::class\n        ],\n    ]\n```\n\n\n``` php\nclass DownloadJob extends Object implements \\yii\\queue\\Job\n{\n    public $url;\n    public $file;\n                \n    public function execute($queue)\n    {\n        file_put_contents($this->file, file_get_contents($this->url));\n    }\n}\n\n```\n\n以下是将任务发送到队列中的方法：\n\n``` php\nYii::$app->queue->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n\n```\n\n将作业推入5分钟后运行的队列：\n\n``` php\nYii::$app->queue->delay(5 * 60)->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n```\n\n执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。\n在循环中获取并执行任务的命令，直到队列为空：\n\n``` php\nyii queue/run\n```\n\n命令启动一个无限查询队列的守护程序：\n\n``` php\nyii queue/listen\n```\n该组件具有跟踪被推入队列的作业的状态的能力。\n\n``` php\n\n//将作业推入队列并获取按摩ID。\n$id = Yii::$app->queue->push(new SomeJob());\n\n//工作正在等待执行。\nYii::$app->queue->isWaiting($id);\n\n// Worker从队列中获取作业并执行它。\nYii::$app->queue->isReserved($id);\n\n// Worker已经执行了这个工作。\nYii::$app->queue->isDone($id);\n\n```\n## 使用Supervisor管理php yii queue/listen\nSupervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：\n``` php\nsudo apt-get install supervisor\n```\n主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。\n配置示例:\n``` php\n[program:yii-queue-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/bin/php /var/www/my_project/yii queue/listen --verbose=1 --color=0\nautostart=true\nautorestart=true\nuser=www-data\nnumprocs=4\nredirect_stderr=true\nstdout_logfile=/var/www/my_project/log/yii-queue-worker.log\n```\n\n\n\n\n\n\n","source":"_posts/yii2-queue队列的使用说明.md","raw":"---\ntitle: yii2-queue队列的使用说明\ndate: 2017-07-28 12:15:36\ntags: 编辑器\ncategories: 技术\n\n---\n## 概述\n\nyii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。\n\n## 来源\n\n+ [github](https://github.com/yiisoft/yii2-queue)\n+ [packaglist](https://packagist.org/packages/yiisoft/yii2-queue)\n\n<!--more-->\n## 安装 \n\n``` php\ncomposer require yiisoft/yii2-queue\n```\n或者\n\n``` php\n在composer中添加\"yiisoft/yii2-queue\": \"~2.0.0\",然后持续composer install\n```\n<!--more-->\n\n## 操作步骤\n发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：\n下面的例子以redis作为驱动，[其它驱动](https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md)\n首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/\n注意要为queue配置一个queue的redis配置\n```return [\n    'bootstrap' => [\n            'queue', // The component registers own console commands\n    ],\n    'compoents' => [\n        ...//其它的配置\n        'redis_queue' => [\n            'class' => 'yii\\redis\\Connection',\n            'hostname' => 'redis',\n            'port' => '6379',\n            'database' => 0,\n        ],\n        'queue' => [\n            'class' => \\yii\\queue\\redis\\Queue::class,\n            'redis' => 'redis2', // Redis connection component or its config\n            'channel' => 'queue', // Queue channel key\n            'as log' => \\yii\\queue\\LogBehavior::class\n        ],\n    ]\n```\n\n\n``` php\nclass DownloadJob extends Object implements \\yii\\queue\\Job\n{\n    public $url;\n    public $file;\n                \n    public function execute($queue)\n    {\n        file_put_contents($this->file, file_get_contents($this->url));\n    }\n}\n\n```\n\n以下是将任务发送到队列中的方法：\n\n``` php\nYii::$app->queue->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n\n```\n\n将作业推入5分钟后运行的队列：\n\n``` php\nYii::$app->queue->delay(5 * 60)->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n```\n\n执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。\n在循环中获取并执行任务的命令，直到队列为空：\n\n``` php\nyii queue/run\n```\n\n命令启动一个无限查询队列的守护程序：\n\n``` php\nyii queue/listen\n```\n该组件具有跟踪被推入队列的作业的状态的能力。\n\n``` php\n\n//将作业推入队列并获取按摩ID。\n$id = Yii::$app->queue->push(new SomeJob());\n\n//工作正在等待执行。\nYii::$app->queue->isWaiting($id);\n\n// Worker从队列中获取作业并执行它。\nYii::$app->queue->isReserved($id);\n\n// Worker已经执行了这个工作。\nYii::$app->queue->isDone($id);\n\n```\n## 使用Supervisor管理php yii queue/listen\nSupervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：\n``` php\nsudo apt-get install supervisor\n```\n主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。\n配置示例:\n``` php\n[program:yii-queue-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/bin/php /var/www/my_project/yii queue/listen --verbose=1 --color=0\nautostart=true\nautorestart=true\nuser=www-data\nnumprocs=4\nredirect_stderr=true\nstdout_logfile=/var/www/my_project/log/yii-queue-worker.log\n```\n\n\n\n\n\n\n","slug":"yii2-queue队列的使用说明","published":1,"updated":"2018-05-27T09:59:36.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sij000ith8lrdxq3zvw","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>yii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。</p>\n<h2 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h2><ul>\n<li><a href=\"https://github.com/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li><a href=\"https://packagist.org/packages/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">packaglist</a></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer <span class=\"keyword\">require</span> yiisoft/yii2-queue</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在composer中添加<span class=\"string\">\"yiisoft/yii2-queue\"</span>: <span class=\"string\">\"~2.0.0\"</span>,然后持续composer install</span><br></pre></td></tr></table></figure>\n<!--more-->\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><p>发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：<br>下面的例子以redis作为驱动，<a href=\"https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md\" target=\"_blank\" rel=\"noopener\">其它驱动</a><br>首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/<br>注意要为queue配置一个queue的redis配置<br><figure class=\"highlight plain\"><figcaption><span>[</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;bootstrap&apos; =&gt; [</span><br><span class=\"line\">        &apos;queue&apos;, // The component registers own console commands</span><br><span class=\"line\">],</span><br><span class=\"line\">&apos;compoents&apos; =&gt; [</span><br><span class=\"line\">    ...//其它的配置</span><br><span class=\"line\">    &apos;redis_queue&apos; =&gt; [</span><br><span class=\"line\">        &apos;class&apos; =&gt; &apos;yii\\redis\\Connection&apos;,</span><br><span class=\"line\">        &apos;hostname&apos; =&gt; &apos;redis&apos;,</span><br><span class=\"line\">        &apos;port&apos; =&gt; &apos;6379&apos;,</span><br><span class=\"line\">        &apos;database&apos; =&gt; 0,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &apos;queue&apos; =&gt; [</span><br><span class=\"line\">        &apos;class&apos; =&gt; \\yii\\queue\\redis\\Queue::class,</span><br><span class=\"line\">        &apos;redis&apos; =&gt; &apos;redis2&apos;, // Redis connection component or its config</span><br><span class=\"line\">        &apos;channel&apos; =&gt; &apos;queue&apos;, // Queue channel key</span><br><span class=\"line\">        &apos;as log&apos; =&gt; \\yii\\queue\\LogBehavior::class</span><br><span class=\"line\">    ],</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadJob</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">yii</span>\\<span class=\"title\">queue</span>\\<span class=\"title\">Job</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $url;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $file;</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span><span class=\"params\">($queue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        file_put_contents(<span class=\"keyword\">$this</span>-&gt;file, file_get_contents(<span class=\"keyword\">$this</span>-&gt;url));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是将任务发送到队列中的方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</span><br><span class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</span><br><span class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</span><br><span class=\"line\">]));</span><br></pre></td></tr></table></figure>\n<p>将作业推入5分钟后运行的队列：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Yii::$app-&gt;queue-&gt;delay(<span class=\"number\">5</span> * <span class=\"number\">60</span>)-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</span><br><span class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</span><br><span class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</span><br><span class=\"line\">]));</span><br></pre></td></tr></table></figure>\n<p>执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。<br>在循环中获取并执行任务的命令，直到队列为空：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yii queue/run</span><br></pre></td></tr></table></figure>\n<p>命令启动一个无限查询队列的守护程序：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yii queue/listen</span><br></pre></td></tr></table></figure>\n<p>该组件具有跟踪被推入队列的作业的状态的能力。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将作业推入队列并获取按摩ID。</span></span><br><span class=\"line\">$id = Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> SomeJob());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//工作正在等待执行。</span></span><br><span class=\"line\">Yii::$app-&gt;queue-&gt;isWaiting($id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Worker从队列中获取作业并执行它。</span></span><br><span class=\"line\">Yii::$app-&gt;queue-&gt;isReserved($id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Worker已经执行了这个工作。</span></span><br><span class=\"line\">Yii::$app-&gt;queue-&gt;isDone($id);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Supervisor管理php-yii-queue-listen\"><a href=\"#使用Supervisor管理php-yii-queue-listen\" class=\"headerlink\" title=\"使用Supervisor管理php yii queue/listen\"></a>使用Supervisor管理php yii queue/listen</h2><p>Supervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure></p>\n<p>主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。<br>配置示例:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:yii-queue-worker]</span><br><span class=\"line\">process_name=%(program_name)s_%(process_num)<span class=\"number\">02</span>d</span><br><span class=\"line\">command=/usr/bin/php /<span class=\"keyword\">var</span>/www/my_project/yii queue/listen --verbose=<span class=\"number\">1</span> --color=<span class=\"number\">0</span></span><br><span class=\"line\">autostart=<span class=\"keyword\">true</span></span><br><span class=\"line\">autorestart=<span class=\"keyword\">true</span></span><br><span class=\"line\">user=www-data</span><br><span class=\"line\">numprocs=<span class=\"number\">4</span></span><br><span class=\"line\">redirect_stderr=<span class=\"keyword\">true</span></span><br><span class=\"line\">stdout_logfile=/<span class=\"keyword\">var</span>/www/my_project/log/yii-queue-worker.log</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>yii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。</p>\n<h2 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h2><ul>\n<li><a href=\"https://github.com/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li><a href=\"https://packagist.org/packages/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">packaglist</a></li>\n</ul>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer <span class=\"keyword\">require</span> yiisoft/yii2-queue</span><br></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">在composer中添加<span class=\"string\">\"yiisoft/yii2-queue\"</span>: <span class=\"string\">\"~2.0.0\"</span>,然后持续composer install</span><br></pre></td></tr></table></figure>\n<!--more-->\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><p>发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：<br>下面的例子以redis作为驱动，<a href=\"https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md\" target=\"_blank\" rel=\"noopener\">其它驱动</a><br>首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/<br>注意要为queue配置一个queue的redis配置<br><figure class=\"highlight plain\"><figcaption><span>[</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&apos;bootstrap&apos; =&gt; [</span><br><span class=\"line\">        &apos;queue&apos;, // The component registers own console commands</span><br><span class=\"line\">],</span><br><span class=\"line\">&apos;compoents&apos; =&gt; [</span><br><span class=\"line\">    ...//其它的配置</span><br><span class=\"line\">    &apos;redis_queue&apos; =&gt; [</span><br><span class=\"line\">        &apos;class&apos; =&gt; &apos;yii\\redis\\Connection&apos;,</span><br><span class=\"line\">        &apos;hostname&apos; =&gt; &apos;redis&apos;,</span><br><span class=\"line\">        &apos;port&apos; =&gt; &apos;6379&apos;,</span><br><span class=\"line\">        &apos;database&apos; =&gt; 0,</span><br><span class=\"line\">    ],</span><br><span class=\"line\">    &apos;queue&apos; =&gt; [</span><br><span class=\"line\">        &apos;class&apos; =&gt; \\yii\\queue\\redis\\Queue::class,</span><br><span class=\"line\">        &apos;redis&apos; =&gt; &apos;redis2&apos;, // Redis connection component or its config</span><br><span class=\"line\">        &apos;channel&apos; =&gt; &apos;queue&apos;, // Queue channel key</span><br><span class=\"line\">        &apos;as log&apos; =&gt; \\yii\\queue\\LogBehavior::class</span><br><span class=\"line\">    ],</span><br><span class=\"line\">]</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadJob</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">yii</span>\\<span class=\"title\">queue</span>\\<span class=\"title\">Job</span></span></span><br><span class=\"line\"><span class=\"class\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $url;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> $file;</span><br><span class=\"line\">                </span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span><span class=\"params\">($queue)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        file_put_contents(<span class=\"keyword\">$this</span>-&gt;file, file_get_contents(<span class=\"keyword\">$this</span>-&gt;url));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以下是将任务发送到队列中的方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</span><br><span class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</span><br><span class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</span><br><span class=\"line\">]));</span><br></pre></td></tr></table></figure>\n<p>将作业推入5分钟后运行的队列：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Yii::$app-&gt;queue-&gt;delay(<span class=\"number\">5</span> * <span class=\"number\">60</span>)-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</span><br><span class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</span><br><span class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</span><br><span class=\"line\">]));</span><br></pre></td></tr></table></figure>\n<p>执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。<br>在循环中获取并执行任务的命令，直到队列为空：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yii queue/run</span><br></pre></td></tr></table></figure>\n<p>命令启动一个无限查询队列的守护程序：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">yii queue/listen</span><br></pre></td></tr></table></figure>\n<p>该组件具有跟踪被推入队列的作业的状态的能力。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//将作业推入队列并获取按摩ID。</span></span><br><span class=\"line\">$id = Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> SomeJob());</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//工作正在等待执行。</span></span><br><span class=\"line\">Yii::$app-&gt;queue-&gt;isWaiting($id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Worker从队列中获取作业并执行它。</span></span><br><span class=\"line\">Yii::$app-&gt;queue-&gt;isReserved($id);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// Worker已经执行了这个工作。</span></span><br><span class=\"line\">Yii::$app-&gt;queue-&gt;isDone($id);</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Supervisor管理php-yii-queue-listen\"><a href=\"#使用Supervisor管理php-yii-queue-listen\" class=\"headerlink\" title=\"使用Supervisor管理php yii queue/listen\"></a>使用Supervisor管理php yii queue/listen</h2><p>Supervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install supervisor</span><br></pre></td></tr></table></figure></p>\n<p>主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。<br>配置示例:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[program:yii-queue-worker]</span><br><span class=\"line\">process_name=%(program_name)s_%(process_num)<span class=\"number\">02</span>d</span><br><span class=\"line\">command=/usr/bin/php /<span class=\"keyword\">var</span>/www/my_project/yii queue/listen --verbose=<span class=\"number\">1</span> --color=<span class=\"number\">0</span></span><br><span class=\"line\">autostart=<span class=\"keyword\">true</span></span><br><span class=\"line\">autorestart=<span class=\"keyword\">true</span></span><br><span class=\"line\">user=www-data</span><br><span class=\"line\">numprocs=<span class=\"number\">4</span></span><br><span class=\"line\">redirect_stderr=<span class=\"keyword\">true</span></span><br><span class=\"line\">stdout_logfile=/<span class=\"keyword\">var</span>/www/my_project/log/yii-queue-worker.log</span><br></pre></td></tr></table></figure></p>"},{"title":"关于软件工程师的思考","date":"2019-10-16T04:40:13.000Z","_content":"最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。\n# 缺乏工程师的思维模式\n这是我目前最大的问题，我现在debug的能力还是偏弱的，遇到bug常常是靠猜测，凭借经验去假设出现bug的原因，然后就是去谷歌，去搜索之前是否有别人已经解决过这个问题。\n这其实是非常不好的表现，软件是千变万化的东西，这两种手段是非常偶发的，随机性很高的手段，不具有高效率和普遍性。软件的debug应该是一项工程调试，应该更多的关注软件\n本身的结构，本身的运行流程，通过错误日志来定位问题，通过错误提示或者异常来判断问题可能的原因。我在debug的过程中太过关注解决问题这件事情，往往忽视了排查问题原因\n的过程才是最重要的。一步一步按节奏不紧不慢地排查出问题的原因这个过程才是我接下来要努力提高的目标，近期要有意识地锻炼自己解决bug的能力，按照工程师的思维方式去排查\n问题的原因。\n# 源码重要还是文档重要\n我之前非常重视文档，觉得文档是开发者的字典。但其实开发者在迭代的过程中是很容易忘记同时修改文档的，所以看源码远远比看文档要更准确，更能反映一个项目的业务逻辑。\n而且另一方面，阅读源码你会更容易了解这个项目的来龙去脉，更能知道作者一些方法实现的过程，很容易知道这个项目的筋脉在哪里。之前一直不明白为什么要去看底层，为什么\n要去看框架的源码，因为了解框架的源码会更容易知道这些方法在项目的哪里，原来是因为那样才可以使用这个方法的，从整体的角度来看开发。\n# 知其然，知其所以然\n之前只知道一个东西的使用方法，但不知道它运行背后的原理，这个也是很重要的，一个方法的使用,原理和使用是相伴随行的，光是知道使用的话其实还是很难熟练变通的，要想游刃\n有余还是要仔细地思考背后的原理,这样才能游刃有余的知道使用过程中这些问题的答案，本质的一些东西是不会轻易改变的，大多数新东西的原理还是老的，所以掌握背后的原理其实\n还是更能知道这些新东西的使用。我的基础还是薄弱的，接下来一段时间要努力的补充基础知识，最基础的东西往往会影响一个软件的性能。\n# 结尾\n以上就是这段时间的感悟，希望能在接下来的一段时间努力地客服这些东西，只有这样，同样的教训才不会再次发生，才能成长的。\n","source":"_posts/关于软件工程师的思考.md","raw":"---\ntitle: 关于软件工程师的思考\ndate: 2019-10-16 12:40:13\ntags: 个人感悟\n---\n最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。\n# 缺乏工程师的思维模式\n这是我目前最大的问题，我现在debug的能力还是偏弱的，遇到bug常常是靠猜测，凭借经验去假设出现bug的原因，然后就是去谷歌，去搜索之前是否有别人已经解决过这个问题。\n这其实是非常不好的表现，软件是千变万化的东西，这两种手段是非常偶发的，随机性很高的手段，不具有高效率和普遍性。软件的debug应该是一项工程调试，应该更多的关注软件\n本身的结构，本身的运行流程，通过错误日志来定位问题，通过错误提示或者异常来判断问题可能的原因。我在debug的过程中太过关注解决问题这件事情，往往忽视了排查问题原因\n的过程才是最重要的。一步一步按节奏不紧不慢地排查出问题的原因这个过程才是我接下来要努力提高的目标，近期要有意识地锻炼自己解决bug的能力，按照工程师的思维方式去排查\n问题的原因。\n# 源码重要还是文档重要\n我之前非常重视文档，觉得文档是开发者的字典。但其实开发者在迭代的过程中是很容易忘记同时修改文档的，所以看源码远远比看文档要更准确，更能反映一个项目的业务逻辑。\n而且另一方面，阅读源码你会更容易了解这个项目的来龙去脉，更能知道作者一些方法实现的过程，很容易知道这个项目的筋脉在哪里。之前一直不明白为什么要去看底层，为什么\n要去看框架的源码，因为了解框架的源码会更容易知道这些方法在项目的哪里，原来是因为那样才可以使用这个方法的，从整体的角度来看开发。\n# 知其然，知其所以然\n之前只知道一个东西的使用方法，但不知道它运行背后的原理，这个也是很重要的，一个方法的使用,原理和使用是相伴随行的，光是知道使用的话其实还是很难熟练变通的，要想游刃\n有余还是要仔细地思考背后的原理,这样才能游刃有余的知道使用过程中这些问题的答案，本质的一些东西是不会轻易改变的，大多数新东西的原理还是老的，所以掌握背后的原理其实\n还是更能知道这些新东西的使用。我的基础还是薄弱的，接下来一段时间要努力的补充基础知识，最基础的东西往往会影响一个软件的性能。\n# 结尾\n以上就是这段时间的感悟，希望能在接下来的一段时间努力地客服这些东西，只有这样，同样的教训才不会再次发生，才能成长的。\n","slug":"关于软件工程师的思考","published":1,"updated":"2019-10-16T06:45:42.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sij000jth8lw164sovj","content":"<p>最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。</p>\n<h1 id=\"缺乏工程师的思维模式\"><a href=\"#缺乏工程师的思维模式\" class=\"headerlink\" title=\"缺乏工程师的思维模式\"></a>缺乏工程师的思维模式</h1><p>这是我目前最大的问题，我现在debug的能力还是偏弱的，遇到bug常常是靠猜测，凭借经验去假设出现bug的原因，然后就是去谷歌，去搜索之前是否有别人已经解决过这个问题。<br>这其实是非常不好的表现，软件是千变万化的东西，这两种手段是非常偶发的，随机性很高的手段，不具有高效率和普遍性。软件的debug应该是一项工程调试，应该更多的关注软件<br>本身的结构，本身的运行流程，通过错误日志来定位问题，通过错误提示或者异常来判断问题可能的原因。我在debug的过程中太过关注解决问题这件事情，往往忽视了排查问题原因<br>的过程才是最重要的。一步一步按节奏不紧不慢地排查出问题的原因这个过程才是我接下来要努力提高的目标，近期要有意识地锻炼自己解决bug的能力，按照工程师的思维方式去排查<br>问题的原因。</p>\n<h1 id=\"源码重要还是文档重要\"><a href=\"#源码重要还是文档重要\" class=\"headerlink\" title=\"源码重要还是文档重要\"></a>源码重要还是文档重要</h1><p>我之前非常重视文档，觉得文档是开发者的字典。但其实开发者在迭代的过程中是很容易忘记同时修改文档的，所以看源码远远比看文档要更准确，更能反映一个项目的业务逻辑。<br>而且另一方面，阅读源码你会更容易了解这个项目的来龙去脉，更能知道作者一些方法实现的过程，很容易知道这个项目的筋脉在哪里。之前一直不明白为什么要去看底层，为什么<br>要去看框架的源码，因为了解框架的源码会更容易知道这些方法在项目的哪里，原来是因为那样才可以使用这个方法的，从整体的角度来看开发。</p>\n<h1 id=\"知其然，知其所以然\"><a href=\"#知其然，知其所以然\" class=\"headerlink\" title=\"知其然，知其所以然\"></a>知其然，知其所以然</h1><p>之前只知道一个东西的使用方法，但不知道它运行背后的原理，这个也是很重要的，一个方法的使用,原理和使用是相伴随行的，光是知道使用的话其实还是很难熟练变通的，要想游刃<br>有余还是要仔细地思考背后的原理,这样才能游刃有余的知道使用过程中这些问题的答案，本质的一些东西是不会轻易改变的，大多数新东西的原理还是老的，所以掌握背后的原理其实<br>还是更能知道这些新东西的使用。我的基础还是薄弱的，接下来一段时间要努力的补充基础知识，最基础的东西往往会影响一个软件的性能。</p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>以上就是这段时间的感悟，希望能在接下来的一段时间努力地客服这些东西，只有这样，同样的教训才不会再次发生，才能成长的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。</p>\n<h1 id=\"缺乏工程师的思维模式\"><a href=\"#缺乏工程师的思维模式\" class=\"headerlink\" title=\"缺乏工程师的思维模式\"></a>缺乏工程师的思维模式</h1><p>这是我目前最大的问题，我现在debug的能力还是偏弱的，遇到bug常常是靠猜测，凭借经验去假设出现bug的原因，然后就是去谷歌，去搜索之前是否有别人已经解决过这个问题。<br>这其实是非常不好的表现，软件是千变万化的东西，这两种手段是非常偶发的，随机性很高的手段，不具有高效率和普遍性。软件的debug应该是一项工程调试，应该更多的关注软件<br>本身的结构，本身的运行流程，通过错误日志来定位问题，通过错误提示或者异常来判断问题可能的原因。我在debug的过程中太过关注解决问题这件事情，往往忽视了排查问题原因<br>的过程才是最重要的。一步一步按节奏不紧不慢地排查出问题的原因这个过程才是我接下来要努力提高的目标，近期要有意识地锻炼自己解决bug的能力，按照工程师的思维方式去排查<br>问题的原因。</p>\n<h1 id=\"源码重要还是文档重要\"><a href=\"#源码重要还是文档重要\" class=\"headerlink\" title=\"源码重要还是文档重要\"></a>源码重要还是文档重要</h1><p>我之前非常重视文档，觉得文档是开发者的字典。但其实开发者在迭代的过程中是很容易忘记同时修改文档的，所以看源码远远比看文档要更准确，更能反映一个项目的业务逻辑。<br>而且另一方面，阅读源码你会更容易了解这个项目的来龙去脉，更能知道作者一些方法实现的过程，很容易知道这个项目的筋脉在哪里。之前一直不明白为什么要去看底层，为什么<br>要去看框架的源码，因为了解框架的源码会更容易知道这些方法在项目的哪里，原来是因为那样才可以使用这个方法的，从整体的角度来看开发。</p>\n<h1 id=\"知其然，知其所以然\"><a href=\"#知其然，知其所以然\" class=\"headerlink\" title=\"知其然，知其所以然\"></a>知其然，知其所以然</h1><p>之前只知道一个东西的使用方法，但不知道它运行背后的原理，这个也是很重要的，一个方法的使用,原理和使用是相伴随行的，光是知道使用的话其实还是很难熟练变通的，要想游刃<br>有余还是要仔细地思考背后的原理,这样才能游刃有余的知道使用过程中这些问题的答案，本质的一些东西是不会轻易改变的，大多数新东西的原理还是老的，所以掌握背后的原理其实<br>还是更能知道这些新东西的使用。我的基础还是薄弱的，接下来一段时间要努力的补充基础知识，最基础的东西往往会影响一个软件的性能。</p>\n<h1 id=\"结尾\"><a href=\"#结尾\" class=\"headerlink\" title=\"结尾\"></a>结尾</h1><p>以上就是这段时间的感悟，希望能在接下来的一段时间努力地客服这些东西，只有这样，同样的教训才不会再次发生，才能成长的。</p>\n"},{"title":"利用gitlab进行持续部署","date":"2018-02-12T15:55:00.000Z","_content":"\n## GitLab-CI使用Docker进行持续部署\nDocker镜像通过私有仓库进行发布(如阿里云), 发布命令为:\n```ci\n docker login -u username -p password registry.demo.com\n docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\n```\n其中 `username`是用户名, `password`是密码, registry.demo.com是私有镜像库地址,\n`$CI_PROJECT_NAME` 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如\n```ci\ndocker build -t registry.demo.com/repos/image-name:latest .\n```\n`image-name`, 就是要构建的镜像名称, `latest`是TAG标签, `repos`是仓库的空间名称\n\n在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署\n<!--more-->\n项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需\n```\nimage: zacksleo/docker-composer:1.1\n\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\nstages:\n    - prepare    \n    - build\n    - deploy\n\nvariables:\n    COMPOSER_CACHE_DIR: \"/cache/composer\"\n    DOCKER_DRIVER: overlay\n\ninstalling-dependencies:\n    stage: prepare\n    script:\n        - composer install --prefer-dist -n --no-interaction -v --no-suggest\n    artifacts:\n        name: \"vendor\"\n        untracked: true\n        expire_in: 60 mins\n        paths:\n            - $CI_PROJECT_DIR/vendor    \ntest-image:\n    stage: build\n    image: docker:latest\n    services:\n        - docker:dind\n    dependencies:\n        - installing-dependencies\n    script:\n        - docker login -u username -p password registry.demo.com\n        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        \n        - ssh root@$DEPLOY_SERVER \"docker login -u username -p password registry.demo.com\"\n        - ssh root@$DEPLOY_SERVER \"cd /data/$CI_PROJECT_NAME && docker-compose stop && docker-compose rm -f && docker-compose pull && docker-compose up -d\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0\"\n```\n## GitLab-CI使用LFTP进行持续部署\n\nLFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。\n\n本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署\n\nmirror 命令及主要参数\n\n-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)\n-L 下载符号链接作为文件, 主要处理文件软链接的问题\n-v 详细输出日志\n-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)\n--transfer-all 传输所有文件, 不论新旧\n--parallel 同时传输的文件数\n--file 本地文件\n--target-directory 目标目录\n\n配置参考\n```\ndeploy:\n    stage: deploy\n    dependencies:\n        - installing-dependencies\n    script:\n        - apk add lftp\n        # 只上传新文件\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 指定目录覆盖上传 (强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 单独上传autoload文件(强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all\"\n    only:\n        - master\n```\n## GitLab-CI使用Rsync进行持续部署\nrsync命令是一个远程数据同步工具\n主要参数\n-r 递归目录\n-t 保留修改时间\n-v 详细日志\n-h 输出数字以人类可读的格式\n-z 在传输过程中压缩文件数据\n-e 指定要使用的远程shell, 注意该过程需要注入SSH\n\n配置参考\n```\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\n\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats\n```\n>注意\n远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误\n","source":"_posts/利用gitlab进行持续部署.md","raw":"---\ntitle: 利用gitlab进行持续部署\ndate: 2018-02-12 23:55:00\ntags: devops\ncategories: 技术\n\n---\n\n## GitLab-CI使用Docker进行持续部署\nDocker镜像通过私有仓库进行发布(如阿里云), 发布命令为:\n```ci\n docker login -u username -p password registry.demo.com\n docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\n```\n其中 `username`是用户名, `password`是密码, registry.demo.com是私有镜像库地址,\n`$CI_PROJECT_NAME` 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如\n```ci\ndocker build -t registry.demo.com/repos/image-name:latest .\n```\n`image-name`, 就是要构建的镜像名称, `latest`是TAG标签, `repos`是仓库的空间名称\n\n在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署\n<!--more-->\n项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需\n```\nimage: zacksleo/docker-composer:1.1\n\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\nstages:\n    - prepare    \n    - build\n    - deploy\n\nvariables:\n    COMPOSER_CACHE_DIR: \"/cache/composer\"\n    DOCKER_DRIVER: overlay\n\ninstalling-dependencies:\n    stage: prepare\n    script:\n        - composer install --prefer-dist -n --no-interaction -v --no-suggest\n    artifacts:\n        name: \"vendor\"\n        untracked: true\n        expire_in: 60 mins\n        paths:\n            - $CI_PROJECT_DIR/vendor    \ntest-image:\n    stage: build\n    image: docker:latest\n    services:\n        - docker:dind\n    dependencies:\n        - installing-dependencies\n    script:\n        - docker login -u username -p password registry.demo.com\n        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        \n        - ssh root@$DEPLOY_SERVER \"docker login -u username -p password registry.demo.com\"\n        - ssh root@$DEPLOY_SERVER \"cd /data/$CI_PROJECT_NAME && docker-compose stop && docker-compose rm -f && docker-compose pull && docker-compose up -d\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0\"\n```\n## GitLab-CI使用LFTP进行持续部署\n\nLFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。\n\n本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署\n\nmirror 命令及主要参数\n\n-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)\n-L 下载符号链接作为文件, 主要处理文件软链接的问题\n-v 详细输出日志\n-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)\n--transfer-all 传输所有文件, 不论新旧\n--parallel 同时传输的文件数\n--file 本地文件\n--target-directory 目标目录\n\n配置参考\n```\ndeploy:\n    stage: deploy\n    dependencies:\n        - installing-dependencies\n    script:\n        - apk add lftp\n        # 只上传新文件\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 指定目录覆盖上传 (强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 单独上传autoload文件(强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all\"\n    only:\n        - master\n```\n## GitLab-CI使用Rsync进行持续部署\nrsync命令是一个远程数据同步工具\n主要参数\n-r 递归目录\n-t 保留修改时间\n-v 详细日志\n-h 输出数字以人类可读的格式\n-z 在传输过程中压缩文件数据\n-e 指定要使用的远程shell, 注意该过程需要注入SSH\n\n配置参考\n```\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\n\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats\n```\n>注意\n远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误\n","slug":"利用gitlab进行持续部署","published":1,"updated":"2018-05-27T09:59:36.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sik000kth8ldsbgsynk","content":"<h2 id=\"GitLab-CI使用Docker进行持续部署\"><a href=\"#GitLab-CI使用Docker进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Docker进行持续部署\"></a>GitLab-CI使用Docker进行持续部署</h2><p>Docker镜像通过私有仓库进行发布(如阿里云), 发布命令为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login -u username -p password registry.demo.com</span><br><span class=\"line\">docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</span><br><span class=\"line\">docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>username</code>是用户名, <code>password</code>是密码, registry.demo.com是私有镜像库地址,<br><code>$CI_PROJECT_NAME</code> 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t registry.demo.com/repos/image-name:latest .</span><br></pre></td></tr></table></figure></p>\n<p><code>image-name</code>, 就是要构建的镜像名称, <code>latest</code>是TAG标签, <code>repos</code>是仓库的空间名称</p>\n<p>在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署<br><a id=\"more\"></a><br>项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image: zacksleo/docker-composer:1.1</span><br><span class=\"line\"></span><br><span class=\"line\">before_script:</span><br><span class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class=\"line\">    - apk add rsync</span><br><span class=\"line\">    - eval $(ssh-agent -s)</span><br><span class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</span><br><span class=\"line\">    - chmod 0600 ~/deploy.key</span><br><span class=\"line\">    - ssh-add ~/deploy.key</span><br><span class=\"line\">    - mkdir -p ~/.ssh</span><br><span class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class=\"line\">    - export APP_ENV=testing</span><br><span class=\"line\"></span><br><span class=\"line\">stages:</span><br><span class=\"line\">    - prepare    </span><br><span class=\"line\">    - build</span><br><span class=\"line\">    - deploy</span><br><span class=\"line\"></span><br><span class=\"line\">variables:</span><br><span class=\"line\">    COMPOSER_CACHE_DIR: &quot;/cache/composer&quot;</span><br><span class=\"line\">    DOCKER_DRIVER: overlay</span><br><span class=\"line\"></span><br><span class=\"line\">installing-dependencies:</span><br><span class=\"line\">    stage: prepare</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - composer install --prefer-dist -n --no-interaction -v --no-suggest</span><br><span class=\"line\">    artifacts:</span><br><span class=\"line\">        name: &quot;vendor&quot;</span><br><span class=\"line\">        untracked: true</span><br><span class=\"line\">        expire_in: 60 mins</span><br><span class=\"line\">        paths:</span><br><span class=\"line\">            - $CI_PROJECT_DIR/vendor    </span><br><span class=\"line\">test-image:</span><br><span class=\"line\">    stage: build</span><br><span class=\"line\">    image: docker:latest</span><br><span class=\"line\">    services:</span><br><span class=\"line\">        - docker:dind</span><br><span class=\"line\">    dependencies:</span><br><span class=\"line\">        - installing-dependencies</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - docker login -u username -p password registry.demo.com</span><br><span class=\"line\">        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</span><br><span class=\"line\">        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</span><br><span class=\"line\">testing-server:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">    image: alpine</span><br><span class=\"line\">    variables:</span><br><span class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - cd deploy</span><br><span class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        </span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker login -u username -p password registry.demo.com&quot;</span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;cd /data/$CI_PROJECT_NAME &amp;&amp; docker-compose stop &amp;&amp; docker-compose rm -f &amp;&amp; docker-compose pull &amp;&amp; docker-compose up -d&quot;</span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets&quot;</span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用LFTP进行持续部署\"><a href=\"#GitLab-CI使用LFTP进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用LFTP进行持续部署\"></a>GitLab-CI使用LFTP进行持续部署</h2><p>LFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。</p>\n<p>本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署</p>\n<p>mirror 命令及主要参数</p>\n<p>-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)<br>-L 下载符号链接作为文件, 主要处理文件软链接的问题<br>-v 详细输出日志<br>-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)<br>–transfer-all 传输所有文件, 不论新旧<br>–parallel 同时传输的文件数<br>–file 本地文件<br>–target-directory 目标目录</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">    dependencies:</span><br><span class=\"line\">        - installing-dependencies</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - apk add lftp</span><br><span class=\"line\">        # 只上传新文件</span><br><span class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/&quot;</span><br><span class=\"line\">        # 指定目录覆盖上传 (强制更新)</span><br><span class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/&quot;</span><br><span class=\"line\">        # 单独上传autoload文件(强制更新)</span><br><span class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all&quot;</span><br><span class=\"line\">    only:</span><br><span class=\"line\">        - master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用Rsync进行持续部署\"><a href=\"#GitLab-CI使用Rsync进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Rsync进行持续部署\"></a>GitLab-CI使用Rsync进行持续部署</h2><p>rsync命令是一个远程数据同步工具<br>主要参数<br>-r 递归目录<br>-t 保留修改时间<br>-v 详细日志<br>-h 输出数字以人类可读的格式<br>-z 在传输过程中压缩文件数据<br>-e 指定要使用的远程shell, 注意该过程需要注入SSH</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before_script:</span><br><span class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class=\"line\">    - apk add rsync</span><br><span class=\"line\">    - eval $(ssh-agent -s)</span><br><span class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</span><br><span class=\"line\">    - chmod 0600 ~/deploy.key</span><br><span class=\"line\">    - ssh-add ~/deploy.key</span><br><span class=\"line\">    - mkdir -p ~/.ssh</span><br><span class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class=\"line\">    - export APP_ENV=testing</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">testing-server:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">    image: alpine</span><br><span class=\"line\">    variables:</span><br><span class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - cd deploy</span><br><span class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意<br>远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"GitLab-CI使用Docker进行持续部署\"><a href=\"#GitLab-CI使用Docker进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Docker进行持续部署\"></a>GitLab-CI使用Docker进行持续部署</h2><p>Docker镜像通过私有仓库进行发布(如阿里云), 发布命令为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker login -u username -p password registry.demo.com</span><br><span class=\"line\">docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</span><br><span class=\"line\">docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</span><br></pre></td></tr></table></figure></p>\n<p>其中 <code>username</code>是用户名, <code>password</code>是密码, registry.demo.com是私有镜像库地址,<br><code>$CI_PROJECT_NAME</code> 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t registry.demo.com/repos/image-name:latest .</span><br></pre></td></tr></table></figure></p>\n<p><code>image-name</code>, 就是要构建的镜像名称, <code>latest</code>是TAG标签, <code>repos</code>是仓库的空间名称</p>\n<p>在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署<br>","more":"<br>项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">image: zacksleo/docker-composer:1.1</span><br><span class=\"line\"></span><br><span class=\"line\">before_script:</span><br><span class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class=\"line\">    - apk add rsync</span><br><span class=\"line\">    - eval $(ssh-agent -s)</span><br><span class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</span><br><span class=\"line\">    - chmod 0600 ~/deploy.key</span><br><span class=\"line\">    - ssh-add ~/deploy.key</span><br><span class=\"line\">    - mkdir -p ~/.ssh</span><br><span class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class=\"line\">    - export APP_ENV=testing</span><br><span class=\"line\"></span><br><span class=\"line\">stages:</span><br><span class=\"line\">    - prepare    </span><br><span class=\"line\">    - build</span><br><span class=\"line\">    - deploy</span><br><span class=\"line\"></span><br><span class=\"line\">variables:</span><br><span class=\"line\">    COMPOSER_CACHE_DIR: &quot;/cache/composer&quot;</span><br><span class=\"line\">    DOCKER_DRIVER: overlay</span><br><span class=\"line\"></span><br><span class=\"line\">installing-dependencies:</span><br><span class=\"line\">    stage: prepare</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - composer install --prefer-dist -n --no-interaction -v --no-suggest</span><br><span class=\"line\">    artifacts:</span><br><span class=\"line\">        name: &quot;vendor&quot;</span><br><span class=\"line\">        untracked: true</span><br><span class=\"line\">        expire_in: 60 mins</span><br><span class=\"line\">        paths:</span><br><span class=\"line\">            - $CI_PROJECT_DIR/vendor    </span><br><span class=\"line\">test-image:</span><br><span class=\"line\">    stage: build</span><br><span class=\"line\">    image: docker:latest</span><br><span class=\"line\">    services:</span><br><span class=\"line\">        - docker:dind</span><br><span class=\"line\">    dependencies:</span><br><span class=\"line\">        - installing-dependencies</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - docker login -u username -p password registry.demo.com</span><br><span class=\"line\">        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</span><br><span class=\"line\">        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</span><br><span class=\"line\">testing-server:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">    image: alpine</span><br><span class=\"line\">    variables:</span><br><span class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - cd deploy</span><br><span class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        </span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker login -u username -p password registry.demo.com&quot;</span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;cd /data/$CI_PROJECT_NAME &amp;&amp; docker-compose stop &amp;&amp; docker-compose rm -f &amp;&amp; docker-compose pull &amp;&amp; docker-compose up -d&quot;</span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets&quot;</span><br><span class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0&quot;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用LFTP进行持续部署\"><a href=\"#GitLab-CI使用LFTP进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用LFTP进行持续部署\"></a>GitLab-CI使用LFTP进行持续部署</h2><p>LFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。</p>\n<p>本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署</p>\n<p>mirror 命令及主要参数</p>\n<p>-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)<br>-L 下载符号链接作为文件, 主要处理文件软链接的问题<br>-v 详细输出日志<br>-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)<br>–transfer-all 传输所有文件, 不论新旧<br>–parallel 同时传输的文件数<br>–file 本地文件<br>–target-directory 目标目录</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">    dependencies:</span><br><span class=\"line\">        - installing-dependencies</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - apk add lftp</span><br><span class=\"line\">        # 只上传新文件</span><br><span class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/&quot;</span><br><span class=\"line\">        # 指定目录覆盖上传 (强制更新)</span><br><span class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/&quot;</span><br><span class=\"line\">        # 单独上传autoload文件(强制更新)</span><br><span class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all&quot;</span><br><span class=\"line\">    only:</span><br><span class=\"line\">        - master</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用Rsync进行持续部署\"><a href=\"#GitLab-CI使用Rsync进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Rsync进行持续部署\"></a>GitLab-CI使用Rsync进行持续部署</h2><p>rsync命令是一个远程数据同步工具<br>主要参数<br>-r 递归目录<br>-t 保留修改时间<br>-v 详细日志<br>-h 输出数字以人类可读的格式<br>-z 在传输过程中压缩文件数据<br>-e 指定要使用的远程shell, 注意该过程需要注入SSH</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">before_script:</span><br><span class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class=\"line\">    - apk add rsync</span><br><span class=\"line\">    - eval $(ssh-agent -s)</span><br><span class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</span><br><span class=\"line\">    - chmod 0600 ~/deploy.key</span><br><span class=\"line\">    - ssh-add ~/deploy.key</span><br><span class=\"line\">    - mkdir -p ~/.ssh</span><br><span class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class=\"line\">    - export APP_ENV=testing</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">testing-server:</span><br><span class=\"line\">    stage: deploy</span><br><span class=\"line\">    image: alpine</span><br><span class=\"line\">    variables:</span><br><span class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</span><br><span class=\"line\">    script:</span><br><span class=\"line\">        - cd deploy</span><br><span class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意<br>远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误</p>\n</blockquote>"},{"title":"压力测试，压力山大","date":"2017-06-21T12:09:31.000Z","_content":"压力测试的基本概念\n### 吞吐率（Requests per second）\n概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。\n计算公式：总请求数 / 处理完成这些请求数所花费的时间，即\nRequest per second = Complete requests / Time taken for tests\n\n### 并发连接数（The number of concurrent connections）\n概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n\n### 并发用户数（The number of concurrent users，Concurrency Level）\n概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。\n\n### 用户平均请求等待时间（Time per request）\n计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即\nTime per request = Time taken for tests /（ Complete requests / Concurrency Level）\n\n<!--more-->\n### 服务器平均请求等待时间（Time per request: across all concurrent requests）\n计算公式：处理完成所有请求数所花费的时间 / 总请求数，即\nTime taken for / testsComplete requests\n可以看到，它是吞吐率的倒数。\n同时，它也=用户平均请求等待时间/并发用户数，即\nTime per request / Concurrency Level\n### 压力测试工具\n## ab\nab工具简介\nab全称为：apache bench\n在官网上的解释如下：\nab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。\n开始测试:\n输入命令\n`ab -n 100 -c 10 https://www.baidu.com/`\n>其中－n表示请求数，－c表示并发数\n\n测试结果分析\n上面的命令运行完毕后就出来测试报告了\n``` bash\ngraychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/\nThis is ApacheBench, Version 2.3 <$Revision: 1706008 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking www.baidu.com (be patient).....done\n\n\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n\nDocument Path:          /\nDocument Length:        227 bytes\n\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n\n这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80\n``` bash\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n```\n这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）\n``` bash\nDocument Path:          /\nDocument Length:        227 bytes\n这段展示了压力测试的几个重要指标\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n```\n\n`Concurrency Level: 10`\n//并发请求数\n`Time taken for tests: 1.765 seconds`\n//整个测试持续的时间\n`Complete requests: 100`\n//完成的请求数\n`Failed requests: 0`\n//失败的请求数\n\n`Total transferred:      103255 bytes`\n//整个场景中的网络传输量\n`HTML transferred:       22700 bytes`\n//整个场景中的HTML内容传输量\n**//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       176.522 [ms] (mean)`\n**//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       17.652 [ms] (mean, across all concurrent requests)`\n**//服务器平均请求处理时间，大家最关心的指标之三**\n\n`Transfer rate:          57.12 [Kbytes/sec] received`\n//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题\n\n这段表示网络上消耗的时间的分解\n``` bash\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n```\n这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内...，重要的是看90%的处理时间。\n``` zsh\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n## 登陆的测试\n有时候进行压力测试需要用户登录，怎么办？\n请参考以下步骤：\n\n先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来\n如果只用到一个Cookie，那么只需键入命令：\nab －n 100 －C key＝value http://test.com/\n\n如果需要多个Cookie，就直接设Header：\nab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/\n\n\n\n\n\n\n","source":"_posts/压力测试，压力山大.md","raw":"---\ntitle: 压力测试，压力山大\ndate: 2017-06-21 20:09:31\ntags: php php扩展 c\ncategories: 技术\n\n---\n压力测试的基本概念\n### 吞吐率（Requests per second）\n概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。\n计算公式：总请求数 / 处理完成这些请求数所花费的时间，即\nRequest per second = Complete requests / Time taken for tests\n\n### 并发连接数（The number of concurrent connections）\n概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n\n### 并发用户数（The number of concurrent users，Concurrency Level）\n概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。\n\n### 用户平均请求等待时间（Time per request）\n计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即\nTime per request = Time taken for tests /（ Complete requests / Concurrency Level）\n\n<!--more-->\n### 服务器平均请求等待时间（Time per request: across all concurrent requests）\n计算公式：处理完成所有请求数所花费的时间 / 总请求数，即\nTime taken for / testsComplete requests\n可以看到，它是吞吐率的倒数。\n同时，它也=用户平均请求等待时间/并发用户数，即\nTime per request / Concurrency Level\n### 压力测试工具\n## ab\nab工具简介\nab全称为：apache bench\n在官网上的解释如下：\nab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。\n开始测试:\n输入命令\n`ab -n 100 -c 10 https://www.baidu.com/`\n>其中－n表示请求数，－c表示并发数\n\n测试结果分析\n上面的命令运行完毕后就出来测试报告了\n``` bash\ngraychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/\nThis is ApacheBench, Version 2.3 <$Revision: 1706008 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking www.baidu.com (be patient).....done\n\n\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n\nDocument Path:          /\nDocument Length:        227 bytes\n\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n\n这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80\n``` bash\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n```\n这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）\n``` bash\nDocument Path:          /\nDocument Length:        227 bytes\n这段展示了压力测试的几个重要指标\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n```\n\n`Concurrency Level: 10`\n//并发请求数\n`Time taken for tests: 1.765 seconds`\n//整个测试持续的时间\n`Complete requests: 100`\n//完成的请求数\n`Failed requests: 0`\n//失败的请求数\n\n`Total transferred:      103255 bytes`\n//整个场景中的网络传输量\n`HTML transferred:       22700 bytes`\n//整个场景中的HTML内容传输量\n**//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       176.522 [ms] (mean)`\n**//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       17.652 [ms] (mean, across all concurrent requests)`\n**//服务器平均请求处理时间，大家最关心的指标之三**\n\n`Transfer rate:          57.12 [Kbytes/sec] received`\n//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题\n\n这段表示网络上消耗的时间的分解\n``` bash\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n```\n这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内...，重要的是看90%的处理时间。\n``` zsh\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n## 登陆的测试\n有时候进行压力测试需要用户登录，怎么办？\n请参考以下步骤：\n\n先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来\n如果只用到一个Cookie，那么只需键入命令：\nab －n 100 －C key＝value http://test.com/\n\n如果需要多个Cookie，就直接设Header：\nab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/\n\n\n\n\n\n\n","slug":"压力测试，压力山大","published":1,"updated":"2018-05-27T09:59:36.030Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sil000lth8l9mq0a85y","content":"<p>压力测试的基本概念</p>\n<h3 id=\"吞吐率（Requests-per-second）\"><a href=\"#吞吐率（Requests-per-second）\" class=\"headerlink\" title=\"吞吐率（Requests per second）\"></a>吞吐率（Requests per second）</h3><p>概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br>计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br>Request per second = Complete requests / Time taken for tests</p>\n<h3 id=\"并发连接数（The-number-of-concurrent-connections）\"><a href=\"#并发连接数（The-number-of-concurrent-connections）\" class=\"headerlink\" title=\"并发连接数（The number of concurrent connections）\"></a>并发连接数（The number of concurrent connections）</h3><p>概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p>\n<h3 id=\"并发用户数（The-number-of-concurrent-users，Concurrency-Level）\"><a href=\"#并发用户数（The-number-of-concurrent-users，Concurrency-Level）\" class=\"headerlink\" title=\"并发用户数（The number of concurrent users，Concurrency Level）\"></a>并发用户数（The number of concurrent users，Concurrency Level）</h3><p>概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</p>\n<h3 id=\"用户平均请求等待时间（Time-per-request）\"><a href=\"#用户平均请求等待时间（Time-per-request）\" class=\"headerlink\" title=\"用户平均请求等待时间（Time per request）\"></a>用户平均请求等待时间（Time per request）</h3><p>计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p>\n<a id=\"more\"></a>\n<h3 id=\"服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\"><a href=\"#服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\" class=\"headerlink\" title=\"服务器平均请求等待时间（Time per request: across all concurrent requests）\"></a>服务器平均请求等待时间（Time per request: across all concurrent requests）</h3><p>计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br>Time taken for / testsComplete requests<br>可以看到，它是吞吐率的倒数。<br>同时，它也=用户平均请求等待时间/并发用户数，即<br>Time per request / Concurrency Level</p>\n<h3 id=\"压力测试工具\"><a href=\"#压力测试工具\" class=\"headerlink\" title=\"压力测试工具\"></a>压力测试工具</h3><h2 id=\"ab\"><a href=\"#ab\" class=\"headerlink\" title=\"ab\"></a>ab</h2><p>ab工具简介<br>ab全称为：apache bench<br>在官网上的解释如下：<br>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。<br>开始测试:<br>输入命令<br><code>ab -n 100 -c 10 https://www.baidu.com/</code></p>\n<blockquote>\n<p>其中－n表示请求数，－c表示并发数</p>\n</blockquote>\n<p>测试结果分析<br>上面的命令运行完毕后就出来测试报告了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/</span><br><span class=\"line\">This is ApacheBench, Version 2.3 &lt;<span class=\"variable\">$Revision</span>: 1706008 $&gt;</span><br><span class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class=\"line\">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmarking www.baidu.com (be patient).....done</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Server Software:        bfe/1.0.8.18</span><br><span class=\"line\">Server Hostname:        www.baidu.com</span><br><span class=\"line\">Server Port:            443</span><br><span class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        227 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      10</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</span><br><span class=\"line\">Complete requests:      100</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      103255 bytes</span><br><span class=\"line\">HTML transferred:       22700 bytes</span><br><span class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       176.522 [ms] (mean)</span><br><span class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:      104  126  12.3    125     162</span><br><span class=\"line\">Processing:    32   39   5.7     38      68</span><br><span class=\"line\">Waiting:       32   38   5.0     37      60</span><br><span class=\"line\">Total:        138  165  14.1    164     220</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">        50%    164</span><br><span class=\"line\">        66%    170</span><br><span class=\"line\">        75%    173</span><br><span class=\"line\">        80%    177</span><br><span class=\"line\">        90%    184</span><br></pre></td></tr></table></figure></p>\n<p>这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是<a href=\"http://www.baidu.com，端口是80\" target=\"_blank\" rel=\"noopener\">www.baidu.com，端口是80</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Server Software:        bfe/1.0.8.18</span><br><span class=\"line\">Server Hostname:        www.baidu.com</span><br><span class=\"line\">Server Port:            443</span><br><span class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</span><br></pre></td></tr></table></figure></p>\n<p>这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        227 bytes</span><br><span class=\"line\">这段展示了压力测试的几个重要指标</span><br><span class=\"line\">Concurrency Level:      10</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</span><br><span class=\"line\">Complete requests:      100</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      103255 bytes</span><br><span class=\"line\">HTML transferred:       22700 bytes</span><br><span class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       176.522 [ms] (mean)</span><br><span class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</span><br></pre></td></tr></table></figure></p>\n<p><code>Concurrency Level: 10</code><br>//并发请求数<br><code>Time taken for tests: 1.765 seconds</code><br>//整个测试持续的时间<br><code>Complete requests: 100</code><br>//完成的请求数<br><code>Failed requests: 0</code><br>//失败的请求数</p>\n<p><code>Total transferred:      103255 bytes</code><br>//整个场景中的网络传输量<br><code>HTML transferred:       22700 bytes</code><br>//整个场景中的HTML内容传输量<br><strong>//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       176.522 [ms] (mean)</code><br><strong>//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       17.652 [ms] (mean, across all concurrent requests)</code><br><strong>//服务器平均请求处理时间，大家最关心的指标之三</strong></p>\n<p><code>Transfer rate:          57.12 [Kbytes/sec] received</code><br>//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</p>\n<p>这段表示网络上消耗的时间的分解<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:      104  126  12.3    125     162</span><br><span class=\"line\">Processing:    32   39   5.7     38      68</span><br><span class=\"line\">Waiting:       32   38   5.0     37      60</span><br><span class=\"line\">Total:        138  165  14.1    164     220</span><br></pre></td></tr></table></figure></p>\n<p>这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内…，重要的是看90%的处理时间。<br><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">        50%    164</span><br><span class=\"line\">        66%    170</span><br><span class=\"line\">        75%    173</span><br><span class=\"line\">        80%    177</span><br><span class=\"line\">        90%    184</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"登陆的测试\"><a href=\"#登陆的测试\" class=\"headerlink\" title=\"登陆的测试\"></a>登陆的测试</h2><p>有时候进行压力测试需要用户登录，怎么办？<br>请参考以下步骤：</p>\n<p>先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来<br>如果只用到一个Cookie，那么只需键入命令：<br>ab －n 100 －C key＝value <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>\n<p>如果需要多个Cookie，就直接设Header：<br>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>\n","site":{"data":{}},"excerpt":"<p>压力测试的基本概念</p>\n<h3 id=\"吞吐率（Requests-per-second）\"><a href=\"#吞吐率（Requests-per-second）\" class=\"headerlink\" title=\"吞吐率（Requests per second）\"></a>吞吐率（Requests per second）</h3><p>概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br>计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br>Request per second = Complete requests / Time taken for tests</p>\n<h3 id=\"并发连接数（The-number-of-concurrent-connections）\"><a href=\"#并发连接数（The-number-of-concurrent-connections）\" class=\"headerlink\" title=\"并发连接数（The number of concurrent connections）\"></a>并发连接数（The number of concurrent connections）</h3><p>概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p>\n<h3 id=\"并发用户数（The-number-of-concurrent-users，Concurrency-Level）\"><a href=\"#并发用户数（The-number-of-concurrent-users，Concurrency-Level）\" class=\"headerlink\" title=\"并发用户数（The number of concurrent users，Concurrency Level）\"></a>并发用户数（The number of concurrent users，Concurrency Level）</h3><p>概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</p>\n<h3 id=\"用户平均请求等待时间（Time-per-request）\"><a href=\"#用户平均请求等待时间（Time-per-request）\" class=\"headerlink\" title=\"用户平均请求等待时间（Time per request）\"></a>用户平均请求等待时间（Time per request）</h3><p>计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p>","more":"<h3 id=\"服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\"><a href=\"#服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\" class=\"headerlink\" title=\"服务器平均请求等待时间（Time per request: across all concurrent requests）\"></a>服务器平均请求等待时间（Time per request: across all concurrent requests）</h3><p>计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br>Time taken for / testsComplete requests<br>可以看到，它是吞吐率的倒数。<br>同时，它也=用户平均请求等待时间/并发用户数，即<br>Time per request / Concurrency Level</p>\n<h3 id=\"压力测试工具\"><a href=\"#压力测试工具\" class=\"headerlink\" title=\"压力测试工具\"></a>压力测试工具</h3><h2 id=\"ab\"><a href=\"#ab\" class=\"headerlink\" title=\"ab\"></a>ab</h2><p>ab工具简介<br>ab全称为：apache bench<br>在官网上的解释如下：<br>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。<br>开始测试:<br>输入命令<br><code>ab -n 100 -c 10 https://www.baidu.com/</code></p>\n<blockquote>\n<p>其中－n表示请求数，－c表示并发数</p>\n</blockquote>\n<p>测试结果分析<br>上面的命令运行完毕后就出来测试报告了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">graychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/</span><br><span class=\"line\">This is ApacheBench, Version 2.3 &lt;<span class=\"variable\">$Revision</span>: 1706008 $&gt;</span><br><span class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</span><br><span class=\"line\">Licensed to The Apache Software Foundation, http://www.apache.org/</span><br><span class=\"line\"></span><br><span class=\"line\">Benchmarking www.baidu.com (be patient).....done</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">Server Software:        bfe/1.0.8.18</span><br><span class=\"line\">Server Hostname:        www.baidu.com</span><br><span class=\"line\">Server Port:            443</span><br><span class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</span><br><span class=\"line\"></span><br><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        227 bytes</span><br><span class=\"line\"></span><br><span class=\"line\">Concurrency Level:      10</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</span><br><span class=\"line\">Complete requests:      100</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      103255 bytes</span><br><span class=\"line\">HTML transferred:       22700 bytes</span><br><span class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       176.522 [ms] (mean)</span><br><span class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</span><br><span class=\"line\"></span><br><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:      104  126  12.3    125     162</span><br><span class=\"line\">Processing:    32   39   5.7     38      68</span><br><span class=\"line\">Waiting:       32   38   5.0     37      60</span><br><span class=\"line\">Total:        138  165  14.1    164     220</span><br><span class=\"line\"></span><br><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">        50%    164</span><br><span class=\"line\">        66%    170</span><br><span class=\"line\">        75%    173</span><br><span class=\"line\">        80%    177</span><br><span class=\"line\">        90%    184</span><br></pre></td></tr></table></figure></p>\n<p>这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是<a href=\"http://www.baidu.com，端口是80\" target=\"_blank\" rel=\"noopener\">www.baidu.com，端口是80</a><br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Server Software:        bfe/1.0.8.18</span><br><span class=\"line\">Server Hostname:        www.baidu.com</span><br><span class=\"line\">Server Port:            443</span><br><span class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</span><br></pre></td></tr></table></figure></p>\n<p>这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Document Path:          /</span><br><span class=\"line\">Document Length:        227 bytes</span><br><span class=\"line\">这段展示了压力测试的几个重要指标</span><br><span class=\"line\">Concurrency Level:      10</span><br><span class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</span><br><span class=\"line\">Complete requests:      100</span><br><span class=\"line\">Failed requests:        0</span><br><span class=\"line\">Total transferred:      103255 bytes</span><br><span class=\"line\">HTML transferred:       22700 bytes</span><br><span class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></span><br><span class=\"line\">Time per request:       176.522 [ms] (mean)</span><br><span class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</span><br><span class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</span><br></pre></td></tr></table></figure></p>\n<p><code>Concurrency Level: 10</code><br>//并发请求数<br><code>Time taken for tests: 1.765 seconds</code><br>//整个测试持续的时间<br><code>Complete requests: 100</code><br>//完成的请求数<br><code>Failed requests: 0</code><br>//失败的请求数</p>\n<p><code>Total transferred:      103255 bytes</code><br>//整个场景中的网络传输量<br><code>HTML transferred:       22700 bytes</code><br>//整个场景中的HTML内容传输量<br><strong>//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       176.522 [ms] (mean)</code><br><strong>//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       17.652 [ms] (mean, across all concurrent requests)</code><br><strong>//服务器平均请求处理时间，大家最关心的指标之三</strong></p>\n<p><code>Transfer rate:          57.12 [Kbytes/sec] received</code><br>//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</p>\n<p>这段表示网络上消耗的时间的分解<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Connection Times (ms)</span><br><span class=\"line\">min  mean[+/-sd] median   max</span><br><span class=\"line\">Connect:      104  126  12.3    125     162</span><br><span class=\"line\">Processing:    32   39   5.7     38      68</span><br><span class=\"line\">Waiting:       32   38   5.0     37      60</span><br><span class=\"line\">Total:        138  165  14.1    164     220</span><br></pre></td></tr></table></figure></p>\n<p>这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内…，重要的是看90%的处理时间。<br><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Percentage of the requests served within a certain time (ms)</span><br><span class=\"line\">        50%    164</span><br><span class=\"line\">        66%    170</span><br><span class=\"line\">        75%    173</span><br><span class=\"line\">        80%    177</span><br><span class=\"line\">        90%    184</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"登陆的测试\"><a href=\"#登陆的测试\" class=\"headerlink\" title=\"登陆的测试\"></a>登陆的测试</h2><p>有时候进行压力测试需要用户登录，怎么办？<br>请参考以下步骤：</p>\n<p>先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来<br>如果只用到一个Cookie，那么只需键入命令：<br>ab －n 100 －C key＝value <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>\n<p>如果需要多个Cookie，就直接设Header：<br>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>"},{"title":"变身吧！我的linux配置环境","date":"2016-10-18T06:35:17.000Z","_content":" 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。\n# 先上效果图\n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面带终端效果图.png)\n## 终端改造  Terminator\nubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。\n### 安装方式\nsudo apt-get install terminator\n### 常用快捷键\n垂直分割窗口 `Ctrl+Shift+e`\n水平分割窗口 `Ctrl+Shift+o`\n复制         `Ctrl+Shift+c`\n粘贴         `Ctrl+Shift+v`\n切换窗口     `Ctrl+Shift+n`\n将分割的某个窗口放大至全屏使用         `Ctrl+Shift+x`\n从放大的某一窗口回到多窗口格局         `Ctrl+Shift+z`\n ![\"我是傲娇的效果图\"](/assets/blogImg/多窗终端.png)\n\n<!--more-->\n### 终端主题\n ``` shell\n apt-get install zsh\n wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh\n chsh -s `which zsh`\n sudo shutdown -r 0\n ```\n 我用的主题是`ys`\n\n### 桌面主题\n 首先在这里[下载](https://github.com/anmoljagetia/Flatabulous/archive/master.zip)主题包，将文件解压后移动到`/usr/share/themes/`,接着安装图标:\n ```shell\n sudo add-apt-repository ppa:noobslab/icons\n sudo apt-get update\n sudo apt-get install ultra-flat-icons```\n \n 然后需要`unity-tweak-tool`\n ```shell\n sudo apt-get install unity-tweak-tool\n sudo unity-tweak-tool\n```\n在Themes和icons下分别选择刚刚的主题和图标，大功告成！\n\n ![\"我是傲娇的效果图\"](/assets/blogImg/选择主题.png)\n \n完成后的样子 \n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面效果图.png)\n\n","source":"_posts/变身吧！我的linux配置环境.md","raw":"---\ntitle: 变身吧！我的linux配置环境\ndate: 2016-10-18 14:35:17\ntags: linux\ncategories: 技术\n\n---\n 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。\n# 先上效果图\n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面带终端效果图.png)\n## 终端改造  Terminator\nubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。\n### 安装方式\nsudo apt-get install terminator\n### 常用快捷键\n垂直分割窗口 `Ctrl+Shift+e`\n水平分割窗口 `Ctrl+Shift+o`\n复制         `Ctrl+Shift+c`\n粘贴         `Ctrl+Shift+v`\n切换窗口     `Ctrl+Shift+n`\n将分割的某个窗口放大至全屏使用         `Ctrl+Shift+x`\n从放大的某一窗口回到多窗口格局         `Ctrl+Shift+z`\n ![\"我是傲娇的效果图\"](/assets/blogImg/多窗终端.png)\n\n<!--more-->\n### 终端主题\n ``` shell\n apt-get install zsh\n wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh\n chsh -s `which zsh`\n sudo shutdown -r 0\n ```\n 我用的主题是`ys`\n\n### 桌面主题\n 首先在这里[下载](https://github.com/anmoljagetia/Flatabulous/archive/master.zip)主题包，将文件解压后移动到`/usr/share/themes/`,接着安装图标:\n ```shell\n sudo add-apt-repository ppa:noobslab/icons\n sudo apt-get update\n sudo apt-get install ultra-flat-icons```\n \n 然后需要`unity-tweak-tool`\n ```shell\n sudo apt-get install unity-tweak-tool\n sudo unity-tweak-tool\n```\n在Themes和icons下分别选择刚刚的主题和图标，大功告成！\n\n ![\"我是傲娇的效果图\"](/assets/blogImg/选择主题.png)\n \n完成后的样子 \n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面效果图.png)\n\n","slug":"变身吧！我的linux配置环境","published":1,"updated":"2018-05-27T09:59:36.033Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sim000mth8lzr09mluk","content":"<p> 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。</p>\n<h1 id=\"先上效果图\"><a href=\"#先上效果图\" class=\"headerlink\" title=\"先上效果图\"></a>先上效果图</h1><p> <img src=\"/assets/blogImg/桌面带终端效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"终端改造-Terminator\"><a href=\"#终端改造-Terminator\" class=\"headerlink\" title=\"终端改造  Terminator\"></a>终端改造  Terminator</h2><p>ubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。</p>\n<h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h3><p>sudo apt-get install terminator</p>\n<h3 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h3><p>垂直分割窗口 <code>Ctrl+Shift+e</code><br>水平分割窗口 <code>Ctrl+Shift+o</code><br>复制         <code>Ctrl+Shift+c</code><br>粘贴         <code>Ctrl+Shift+v</code><br>切换窗口     <code>Ctrl+Shift+n</code><br>将分割的某个窗口放大至全屏使用         <code>Ctrl+Shift+x</code><br>从放大的某一窗口回到多窗口格局         <code>Ctrl+Shift+z</code><br> <img src=\"/assets/blogImg/多窗终端.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<a id=\"more\"></a>\n<h3 id=\"终端主题\"><a href=\"#终端主题\" class=\"headerlink\" title=\"终端主题\"></a>终端主题</h3> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install zsh</span><br><span class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh</span><br><span class=\"line\">chsh -s `which zsh`</span><br><span class=\"line\">sudo shutdown -r 0</span><br></pre></td></tr></table></figure>\n<p> 我用的主题是<code>ys</code></p>\n<h3 id=\"桌面主题\"><a href=\"#桌面主题\" class=\"headerlink\" title=\"桌面主题\"></a>桌面主题</h3><p> 首先在这里<a href=\"https://github.com/anmoljagetia/Flatabulous/archive/master.zip\" target=\"_blank\" rel=\"noopener\">下载</a>主题包，将文件解压后移动到<code>/usr/share/themes/</code>,接着安装图标:<br> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:noobslab/icons</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure></p>\n<p> 然后需要<code>unity-tweak-tool</code><br> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install unity-tweak-tool</span><br><span class=\"line\">sudo unity-tweak-tool</span><br></pre></td></tr></table></figure></p>\n<p>在Themes和icons下分别选择刚刚的主题和图标，大功告成！</p>\n<p> <img src=\"/assets/blogImg/选择主题.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>完成后的样子<br> <img src=\"/assets/blogImg/桌面效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n","site":{"data":{}},"excerpt":"<p> 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。</p>\n<h1 id=\"先上效果图\"><a href=\"#先上效果图\" class=\"headerlink\" title=\"先上效果图\"></a>先上效果图</h1><p> <img src=\"/assets/blogImg/桌面带终端效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"终端改造-Terminator\"><a href=\"#终端改造-Terminator\" class=\"headerlink\" title=\"终端改造  Terminator\"></a>终端改造  Terminator</h2><p>ubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。</p>\n<h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h3><p>sudo apt-get install terminator</p>\n<h3 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h3><p>垂直分割窗口 <code>Ctrl+Shift+e</code><br>水平分割窗口 <code>Ctrl+Shift+o</code><br>复制         <code>Ctrl+Shift+c</code><br>粘贴         <code>Ctrl+Shift+v</code><br>切换窗口     <code>Ctrl+Shift+n</code><br>将分割的某个窗口放大至全屏使用         <code>Ctrl+Shift+x</code><br>从放大的某一窗口回到多窗口格局         <code>Ctrl+Shift+z</code><br> <img src=\"/assets/blogImg/多窗终端.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>","more":"<h3 id=\"终端主题\"><a href=\"#终端主题\" class=\"headerlink\" title=\"终端主题\"></a>终端主题</h3> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apt-get install zsh</span><br><span class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh</span><br><span class=\"line\">chsh -s `which zsh`</span><br><span class=\"line\">sudo shutdown -r 0</span><br></pre></td></tr></table></figure>\n<p> 我用的主题是<code>ys</code></p>\n<h3 id=\"桌面主题\"><a href=\"#桌面主题\" class=\"headerlink\" title=\"桌面主题\"></a>桌面主题</h3><p> 首先在这里<a href=\"https://github.com/anmoljagetia/Flatabulous/archive/master.zip\" target=\"_blank\" rel=\"noopener\">下载</a>主题包，将文件解压后移动到<code>/usr/share/themes/</code>,接着安装图标:<br> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo add-apt-repository ppa:noobslab/icons</span><br><span class=\"line\">sudo apt-get update</span><br><span class=\"line\">sudo apt-get install ultra-flat-icons</span><br></pre></td></tr></table></figure></p>\n<p> 然后需要<code>unity-tweak-tool</code><br> <figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install unity-tweak-tool</span><br><span class=\"line\">sudo unity-tweak-tool</span><br></pre></td></tr></table></figure></p>\n<p>在Themes和icons下分别选择刚刚的主题和图标，大功告成！</p>\n<p> <img src=\"/assets/blogImg/选择主题.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>完成后的样子<br> <img src=\"/assets/blogImg/桌面效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>"},{"title":"在k8s上部署dashboard后台管理界面","date":"2019-12-20T08:30:34.000Z","_content":"在昨天成功部署了k8s后，我今天尝试着部署它的后台web界面\n# 下载官方的yaml\n``` \nwget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml\n```\n由于官方的yaml不直接对外开放，需要在本地直接进行`kubectl proxy`进行代理,所以我们通过修改yaml来直接暴露端口和服务。有两个地方要修改：\n## 第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行\n``` shell\n 90 # ------------------- Dashboard Deployment ------------------- #\n 91 \n 92 kind: Deployment\n 93 apiVersion: apps/v1\n 94 metadata:\n 95 labels:\n 96 k8s-app: kubernetes-dashboard\n 97 name: kubernetes-dashboard\n 98 namespace: kube-system\n 99 spec:\n100 replicas: 1\n101 revisionHistoryLimit: 10\n102 selector:\n103 matchLabels:\n104 k8s-app: kubernetes-dashboard\n105 template:\n106 metadata:\n107 labels:\n108 k8s-app: kubernetes-dashboard\n109 spec:\n110 containers:\n111 - name: kubernetes-dashboard\n112 #image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1\n113 image: mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.0\n114 ports:\n115 - containerPort: 8443\n116 protocol: TCP\n```\n## 第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:\n``` shell\n148 # ------------------- Dashboard Service ------------------- #\n149 \n150 kind: Service\n151 apiVersion: v1\n152 metadata:\n153 labels:\n154 k8s-app: kubernetes-dashboard\n155 name: kubernetes-dashboard\n156 namespace: kube-system\n157 spec:\n158 type: NodePort\n159 ports:\n160 - port: 443\n161 targetPort: 8443\n162 selector:\n163 k8s-app: kubernetes-dashboard\n```\n## 部署到k8s集群\n``` shell\n# kubectl apply -f kubernetes-dashboard.yaml \n# kubectl get pods -n kube-system |grep dashboard\nkubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 98s\n# kubectl get pods,svc -n kube-system\nNAME READY STATUS RESTARTS AGE\npod/coredns-78d4cf999f-5hcjm 1/1 Running 0 3h21m\npod/coredns-78d4cf999f-6mlql 1/1 Running 0 3h21m\npod/etcd-k8sm-218 1/1 Running 0 3h20m\npod/kube-apiserver-k8sm-218 1/1 Running 0 3h19m\npod/kube-controller-manager-k8sm-218 1/1 Running 0 3h20m\npod/kube-flannel-ds-amd64-6kfhg 1/1 Running 0 3h13m\npod/kube-flannel-ds-amd64-c4fr4 1/1 Running 0 152m\npod/kube-flannel-ds-amd64-qhc2w 1/1 Running 0 151m\npod/kube-proxy-7hntq 1/1 Running 0 151m\npod/kube-proxy-b4txb 1/1 Running 0 3h21m\npod/kube-proxy-bz529 1/1 Running 0 152m\npod/kube-scheduler-k8sm-218 1/1 Running 0 3h20m\npod/kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 3m5s\n\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\nservice/kube-dns ClusterIP 10.96.0.10 <none> 53/UDP,53/TCP 3h21m\nservice/kubernetes-dashboard NodePort 10.104.4.26 <none> 443:30023/TCP 3m5s\n```\n> 因为我是阿里云的ecs，还要在安全组添加30023进入的端口才能在外部访问\n![截屏2019-12-21上午9.22.32.png](https://ws1.sinaimg.cn/large/6919c235gy1ga4315f1moj227u15mtg2.jpg)\n## Token （令牌） 认证方式登录\n\n1）授权 (所有 namespace )\n\n// 创建serviceaccount\n``` shell\n# kubectl create serviceaccount dashboard-serviceaccount -n kube-system\n```\n// 创建clusterrolebinding\n``` shell\n# kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-serviceaccount\n```\n2）获取令牌（用于网页登录）\n\n// 查看口令列表\n``` shell\n# kubectl get secret -n kube-system |grep dashboard-serviceaccount-token\ndashboard-serviceaccount-token-f45wg kubernetes.io/service-account-token 3 22s\n```\n// 获取口令\n``` shell\n# kubectl describe secret dashboard-serviceaccount-token-f45wg -n kube-system\n```\n3）将获取到的token放在令牌里\n![截屏2019-12-21上午9.25.38.png](https://ws1.sinaimg.cn/large/6919c235gy1ga434bjbalj227k13sgsr.jpg)\n4) 登录成功\n![截屏2019-12-21上午9.33.33.png](https://ws1.sinaimg.cn/large/6919c235gy1ga43c9j0ywj228011oq93.jpg)\n5) 但是我还是遇到了\n![截屏2019-12-21上午9.36.05.png](https://ws1.sinaimg.cn/large/6919c235gy1ga43f7ljwhj227o108n06.jpg)\n这个问题暂时还没有解决\n 参考文章:\n-------------------\n[30分钟带你搭建一套Dashboard的kubernetes（K8S）集群](https://zhuanlan.zhihu.com/p/92923128)\n[使用kubeadm安装Kubernetes 1.8版本](https://www.kubernetes.org.cn/2906.html)\n","source":"_posts/在k8s上部署dashboard后台管理界面.md","raw":"---\ntitle: 在k8s上部署dashboard后台管理界面\ndate: 2019-12-20 16:30:34\ntags: devops\n---\n在昨天成功部署了k8s后，我今天尝试着部署它的后台web界面\n# 下载官方的yaml\n``` \nwget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml\n```\n由于官方的yaml不直接对外开放，需要在本地直接进行`kubectl proxy`进行代理,所以我们通过修改yaml来直接暴露端口和服务。有两个地方要修改：\n## 第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行\n``` shell\n 90 # ------------------- Dashboard Deployment ------------------- #\n 91 \n 92 kind: Deployment\n 93 apiVersion: apps/v1\n 94 metadata:\n 95 labels:\n 96 k8s-app: kubernetes-dashboard\n 97 name: kubernetes-dashboard\n 98 namespace: kube-system\n 99 spec:\n100 replicas: 1\n101 revisionHistoryLimit: 10\n102 selector:\n103 matchLabels:\n104 k8s-app: kubernetes-dashboard\n105 template:\n106 metadata:\n107 labels:\n108 k8s-app: kubernetes-dashboard\n109 spec:\n110 containers:\n111 - name: kubernetes-dashboard\n112 #image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1\n113 image: mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.0\n114 ports:\n115 - containerPort: 8443\n116 protocol: TCP\n```\n## 第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:\n``` shell\n148 # ------------------- Dashboard Service ------------------- #\n149 \n150 kind: Service\n151 apiVersion: v1\n152 metadata:\n153 labels:\n154 k8s-app: kubernetes-dashboard\n155 name: kubernetes-dashboard\n156 namespace: kube-system\n157 spec:\n158 type: NodePort\n159 ports:\n160 - port: 443\n161 targetPort: 8443\n162 selector:\n163 k8s-app: kubernetes-dashboard\n```\n## 部署到k8s集群\n``` shell\n# kubectl apply -f kubernetes-dashboard.yaml \n# kubectl get pods -n kube-system |grep dashboard\nkubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 98s\n# kubectl get pods,svc -n kube-system\nNAME READY STATUS RESTARTS AGE\npod/coredns-78d4cf999f-5hcjm 1/1 Running 0 3h21m\npod/coredns-78d4cf999f-6mlql 1/1 Running 0 3h21m\npod/etcd-k8sm-218 1/1 Running 0 3h20m\npod/kube-apiserver-k8sm-218 1/1 Running 0 3h19m\npod/kube-controller-manager-k8sm-218 1/1 Running 0 3h20m\npod/kube-flannel-ds-amd64-6kfhg 1/1 Running 0 3h13m\npod/kube-flannel-ds-amd64-c4fr4 1/1 Running 0 152m\npod/kube-flannel-ds-amd64-qhc2w 1/1 Running 0 151m\npod/kube-proxy-7hntq 1/1 Running 0 151m\npod/kube-proxy-b4txb 1/1 Running 0 3h21m\npod/kube-proxy-bz529 1/1 Running 0 152m\npod/kube-scheduler-k8sm-218 1/1 Running 0 3h20m\npod/kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 3m5s\n\nNAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE\nservice/kube-dns ClusterIP 10.96.0.10 <none> 53/UDP,53/TCP 3h21m\nservice/kubernetes-dashboard NodePort 10.104.4.26 <none> 443:30023/TCP 3m5s\n```\n> 因为我是阿里云的ecs，还要在安全组添加30023进入的端口才能在外部访问\n![截屏2019-12-21上午9.22.32.png](https://ws1.sinaimg.cn/large/6919c235gy1ga4315f1moj227u15mtg2.jpg)\n## Token （令牌） 认证方式登录\n\n1）授权 (所有 namespace )\n\n// 创建serviceaccount\n``` shell\n# kubectl create serviceaccount dashboard-serviceaccount -n kube-system\n```\n// 创建clusterrolebinding\n``` shell\n# kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-serviceaccount\n```\n2）获取令牌（用于网页登录）\n\n// 查看口令列表\n``` shell\n# kubectl get secret -n kube-system |grep dashboard-serviceaccount-token\ndashboard-serviceaccount-token-f45wg kubernetes.io/service-account-token 3 22s\n```\n// 获取口令\n``` shell\n# kubectl describe secret dashboard-serviceaccount-token-f45wg -n kube-system\n```\n3）将获取到的token放在令牌里\n![截屏2019-12-21上午9.25.38.png](https://ws1.sinaimg.cn/large/6919c235gy1ga434bjbalj227k13sgsr.jpg)\n4) 登录成功\n![截屏2019-12-21上午9.33.33.png](https://ws1.sinaimg.cn/large/6919c235gy1ga43c9j0ywj228011oq93.jpg)\n5) 但是我还是遇到了\n![截屏2019-12-21上午9.36.05.png](https://ws1.sinaimg.cn/large/6919c235gy1ga43f7ljwhj227o108n06.jpg)\n这个问题暂时还没有解决\n 参考文章:\n-------------------\n[30分钟带你搭建一套Dashboard的kubernetes（K8S）集群](https://zhuanlan.zhihu.com/p/92923128)\n[使用kubeadm安装Kubernetes 1.8版本](https://www.kubernetes.org.cn/2906.html)\n","slug":"在k8s上部署dashboard后台管理界面","published":1,"updated":"2019-12-21T01:52:51.800Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sim000nth8l0qlsxiwj","content":"<p>在昨天成功部署了k8s后，我今天尝试着部署它的后台web界面</p>\n<h1 id=\"下载官方的yaml\"><a href=\"#下载官方的yaml\" class=\"headerlink\" title=\"下载官方的yaml\"></a>下载官方的yaml</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>\n<p>由于官方的yaml不直接对外开放，需要在本地直接进行<code>kubectl proxy</code>进行代理,所以我们通过修改yaml来直接暴露端口和服务。有两个地方要修改：</p>\n<h2 id=\"第一个是修改镜像-kubernetes-dashboard-yaml配置文件112行\"><a href=\"#第一个是修改镜像-kubernetes-dashboard-yaml配置文件112行\" class=\"headerlink\" title=\"第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行\"></a>第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 90 # ------------------- Dashboard Deployment ------------------- #</span><br><span class=\"line\"> 91 </span><br><span class=\"line\"> 92 kind: Deployment</span><br><span class=\"line\"> 93 apiVersion: apps/v1</span><br><span class=\"line\"> 94 metadata:</span><br><span class=\"line\"> 95 labels:</span><br><span class=\"line\"> 96 k8s-app: kubernetes-dashboard</span><br><span class=\"line\"> 97 name: kubernetes-dashboard</span><br><span class=\"line\"> 98 namespace: kube-system</span><br><span class=\"line\"> 99 spec:</span><br><span class=\"line\">100 replicas: 1</span><br><span class=\"line\">101 revisionHistoryLimit: 10</span><br><span class=\"line\">102 selector:</span><br><span class=\"line\">103 matchLabels:</span><br><span class=\"line\">104 k8s-app: kubernetes-dashboard</span><br><span class=\"line\">105 template:</span><br><span class=\"line\">106 metadata:</span><br><span class=\"line\">107 labels:</span><br><span class=\"line\">108 k8s-app: kubernetes-dashboard</span><br><span class=\"line\">109 spec:</span><br><span class=\"line\">110 containers:</span><br><span class=\"line\">111 - name: kubernetes-dashboard</span><br><span class=\"line\">112 #image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br><span class=\"line\">113 image: mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.0</span><br><span class=\"line\">114 ports:</span><br><span class=\"line\">115 - containerPort: 8443</span><br><span class=\"line\">116 protocol: TCP</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二个是添加一个type-指定端口类型为-NodePort，这样外界可以通过地址-nodeIP-nodePort-访问-dashboard-kubernetes-dashboard-yaml配置文件158行\"><a href=\"#第二个是添加一个type-指定端口类型为-NodePort，这样外界可以通过地址-nodeIP-nodePort-访问-dashboard-kubernetes-dashboard-yaml配置文件158行\" class=\"headerlink\" title=\"第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:\"></a>第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">148 # ------------------- Dashboard Service ------------------- #</span><br><span class=\"line\">149 </span><br><span class=\"line\">150 kind: Service</span><br><span class=\"line\">151 apiVersion: v1</span><br><span class=\"line\">152 metadata:</span><br><span class=\"line\">153 labels:</span><br><span class=\"line\">154 k8s-app: kubernetes-dashboard</span><br><span class=\"line\">155 name: kubernetes-dashboard</span><br><span class=\"line\">156 namespace: kube-system</span><br><span class=\"line\">157 spec:</span><br><span class=\"line\">158 type: NodePort</span><br><span class=\"line\">159 ports:</span><br><span class=\"line\">160 - port: 443</span><br><span class=\"line\">161 targetPort: 8443</span><br><span class=\"line\">162 selector:</span><br><span class=\"line\">163 k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure>\n<h2 id=\"部署到k8s集群\"><a href=\"#部署到k8s集群\" class=\"headerlink\" title=\"部署到k8s集群\"></a>部署到k8s集群</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl apply <span class=\"_\">-f</span> kubernetes-dashboard.yaml </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl get pods -n kube-system |grep dashboard</span></span><br><span class=\"line\">kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 98s</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl get pods,svc -n kube-system</span></span><br><span class=\"line\">NAME READY STATUS RESTARTS AGE</span><br><span class=\"line\">pod/coredns-78d4cf999f-5hcjm 1/1 Running 0 3h21m</span><br><span class=\"line\">pod/coredns-78d4cf999f-6mlql 1/1 Running 0 3h21m</span><br><span class=\"line\">pod/etcd-k8sm-218 1/1 Running 0 3h20m</span><br><span class=\"line\">pod/kube-apiserver-k8sm-218 1/1 Running 0 3h19m</span><br><span class=\"line\">pod/kube-controller-manager-k8sm-218 1/1 Running 0 3h20m</span><br><span class=\"line\">pod/kube-flannel-ds-amd64-6kfhg 1/1 Running 0 3h13m</span><br><span class=\"line\">pod/kube-flannel-ds-amd64-c4fr4 1/1 Running 0 152m</span><br><span class=\"line\">pod/kube-flannel-ds-amd64-qhc2w 1/1 Running 0 151m</span><br><span class=\"line\">pod/kube-proxy-7hntq 1/1 Running 0 151m</span><br><span class=\"line\">pod/kube-proxy-b4txb 1/1 Running 0 3h21m</span><br><span class=\"line\">pod/kube-proxy-bz529 1/1 Running 0 152m</span><br><span class=\"line\">pod/kube-scheduler-k8sm-218 1/1 Running 0 3h20m</span><br><span class=\"line\">pod/kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 3m5s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class=\"line\">service/kube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP 3h21m</span><br><span class=\"line\">service/kubernetes-dashboard NodePort 10.104.4.26 &lt;none&gt; 443:30023/TCP 3m5s</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为我是阿里云的ecs，还要在安全组添加30023进入的端口才能在外部访问<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga4315f1moj227u15mtg2.jpg\" alt=\"截屏2019-12-21上午9.22.32.png\"></p>\n</blockquote>\n<h2 id=\"Token-（令牌）-认证方式登录\"><a href=\"#Token-（令牌）-认证方式登录\" class=\"headerlink\" title=\"Token （令牌） 认证方式登录\"></a>Token （令牌） 认证方式登录</h2><p>1）授权 (所有 namespace )</p>\n<p>// 创建serviceaccount<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl create serviceaccount dashboard-serviceaccount -n kube-system</span></span><br></pre></td></tr></table></figure></p>\n<p>// 创建clusterrolebinding<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-serviceaccount</span></span><br></pre></td></tr></table></figure></p>\n<p>2）获取令牌（用于网页登录）</p>\n<p>// 查看口令列表<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl get secret -n kube-system |grep dashboard-serviceaccount-token</span></span><br><span class=\"line\">dashboard-serviceaccount-token-f45wg kubernetes.io/service-account-token 3 22s</span><br></pre></td></tr></table></figure></p>\n<p>// 获取口令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl describe secret dashboard-serviceaccount-token<span class=\"_\">-f</span>45wg -n kube-system</span></span><br></pre></td></tr></table></figure></p>\n<p>3）将获取到的token放在令牌里<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga434bjbalj227k13sgsr.jpg\" alt=\"截屏2019-12-21上午9.25.38.png\"><br>4) 登录成功<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga43c9j0ywj228011oq93.jpg\" alt=\"截屏2019-12-21上午9.33.33.png\"><br>5) 但是我还是遇到了<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga43f7ljwhj227o108n06.jpg\" alt=\"截屏2019-12-21上午9.36.05.png\"><br>这个问题暂时还没有解决</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://zhuanlan.zhihu.com/p/92923128\" target=\"_blank\" rel=\"noopener\">30分钟带你搭建一套Dashboard的kubernetes（K8S）集群</a><br><a href=\"https://www.kubernetes.org.cn/2906.html\" target=\"_blank\" rel=\"noopener\">使用kubeadm安装Kubernetes 1.8版本</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在昨天成功部署了k8s后，我今天尝试着部署它的后台web界面</p>\n<h1 id=\"下载官方的yaml\"><a href=\"#下载官方的yaml\" class=\"headerlink\" title=\"下载官方的yaml\"></a>下载官方的yaml</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure>\n<p>由于官方的yaml不直接对外开放，需要在本地直接进行<code>kubectl proxy</code>进行代理,所以我们通过修改yaml来直接暴露端口和服务。有两个地方要修改：</p>\n<h2 id=\"第一个是修改镜像-kubernetes-dashboard-yaml配置文件112行\"><a href=\"#第一个是修改镜像-kubernetes-dashboard-yaml配置文件112行\" class=\"headerlink\" title=\"第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行\"></a>第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> 90 # ------------------- Dashboard Deployment ------------------- #</span><br><span class=\"line\"> 91 </span><br><span class=\"line\"> 92 kind: Deployment</span><br><span class=\"line\"> 93 apiVersion: apps/v1</span><br><span class=\"line\"> 94 metadata:</span><br><span class=\"line\"> 95 labels:</span><br><span class=\"line\"> 96 k8s-app: kubernetes-dashboard</span><br><span class=\"line\"> 97 name: kubernetes-dashboard</span><br><span class=\"line\"> 98 namespace: kube-system</span><br><span class=\"line\"> 99 spec:</span><br><span class=\"line\">100 replicas: 1</span><br><span class=\"line\">101 revisionHistoryLimit: 10</span><br><span class=\"line\">102 selector:</span><br><span class=\"line\">103 matchLabels:</span><br><span class=\"line\">104 k8s-app: kubernetes-dashboard</span><br><span class=\"line\">105 template:</span><br><span class=\"line\">106 metadata:</span><br><span class=\"line\">107 labels:</span><br><span class=\"line\">108 k8s-app: kubernetes-dashboard</span><br><span class=\"line\">109 spec:</span><br><span class=\"line\">110 containers:</span><br><span class=\"line\">111 - name: kubernetes-dashboard</span><br><span class=\"line\">112 #image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br><span class=\"line\">113 image: mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.0</span><br><span class=\"line\">114 ports:</span><br><span class=\"line\">115 - containerPort: 8443</span><br><span class=\"line\">116 protocol: TCP</span><br></pre></td></tr></table></figure>\n<h2 id=\"第二个是添加一个type-指定端口类型为-NodePort，这样外界可以通过地址-nodeIP-nodePort-访问-dashboard-kubernetes-dashboard-yaml配置文件158行\"><a href=\"#第二个是添加一个type-指定端口类型为-NodePort，这样外界可以通过地址-nodeIP-nodePort-访问-dashboard-kubernetes-dashboard-yaml配置文件158行\" class=\"headerlink\" title=\"第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:\"></a>第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">148 # ------------------- Dashboard Service ------------------- #</span><br><span class=\"line\">149 </span><br><span class=\"line\">150 kind: Service</span><br><span class=\"line\">151 apiVersion: v1</span><br><span class=\"line\">152 metadata:</span><br><span class=\"line\">153 labels:</span><br><span class=\"line\">154 k8s-app: kubernetes-dashboard</span><br><span class=\"line\">155 name: kubernetes-dashboard</span><br><span class=\"line\">156 namespace: kube-system</span><br><span class=\"line\">157 spec:</span><br><span class=\"line\">158 type: NodePort</span><br><span class=\"line\">159 ports:</span><br><span class=\"line\">160 - port: 443</span><br><span class=\"line\">161 targetPort: 8443</span><br><span class=\"line\">162 selector:</span><br><span class=\"line\">163 k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure>\n<h2 id=\"部署到k8s集群\"><a href=\"#部署到k8s集群\" class=\"headerlink\" title=\"部署到k8s集群\"></a>部署到k8s集群</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl apply <span class=\"_\">-f</span> kubernetes-dashboard.yaml </span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl get pods -n kube-system |grep dashboard</span></span><br><span class=\"line\">kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 98s</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl get pods,svc -n kube-system</span></span><br><span class=\"line\">NAME READY STATUS RESTARTS AGE</span><br><span class=\"line\">pod/coredns-78d4cf999f-5hcjm 1/1 Running 0 3h21m</span><br><span class=\"line\">pod/coredns-78d4cf999f-6mlql 1/1 Running 0 3h21m</span><br><span class=\"line\">pod/etcd-k8sm-218 1/1 Running 0 3h20m</span><br><span class=\"line\">pod/kube-apiserver-k8sm-218 1/1 Running 0 3h19m</span><br><span class=\"line\">pod/kube-controller-manager-k8sm-218 1/1 Running 0 3h20m</span><br><span class=\"line\">pod/kube-flannel-ds-amd64-6kfhg 1/1 Running 0 3h13m</span><br><span class=\"line\">pod/kube-flannel-ds-amd64-c4fr4 1/1 Running 0 152m</span><br><span class=\"line\">pod/kube-flannel-ds-amd64-qhc2w 1/1 Running 0 151m</span><br><span class=\"line\">pod/kube-proxy-7hntq 1/1 Running 0 151m</span><br><span class=\"line\">pod/kube-proxy-b4txb 1/1 Running 0 3h21m</span><br><span class=\"line\">pod/kube-proxy-bz529 1/1 Running 0 152m</span><br><span class=\"line\">pod/kube-scheduler-k8sm-218 1/1 Running 0 3h20m</span><br><span class=\"line\">pod/kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 3m5s</span><br><span class=\"line\"></span><br><span class=\"line\">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class=\"line\">service/kube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP 3h21m</span><br><span class=\"line\">service/kubernetes-dashboard NodePort 10.104.4.26 &lt;none&gt; 443:30023/TCP 3m5s</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>因为我是阿里云的ecs，还要在安全组添加30023进入的端口才能在外部访问<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga4315f1moj227u15mtg2.jpg\" alt=\"截屏2019-12-21上午9.22.32.png\"></p>\n</blockquote>\n<h2 id=\"Token-（令牌）-认证方式登录\"><a href=\"#Token-（令牌）-认证方式登录\" class=\"headerlink\" title=\"Token （令牌） 认证方式登录\"></a>Token （令牌） 认证方式登录</h2><p>1）授权 (所有 namespace )</p>\n<p>// 创建serviceaccount<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl create serviceaccount dashboard-serviceaccount -n kube-system</span></span><br></pre></td></tr></table></figure></p>\n<p>// 创建clusterrolebinding<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-serviceaccount</span></span><br></pre></td></tr></table></figure></p>\n<p>2）获取令牌（用于网页登录）</p>\n<p>// 查看口令列表<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl get secret -n kube-system |grep dashboard-serviceaccount-token</span></span><br><span class=\"line\">dashboard-serviceaccount-token-f45wg kubernetes.io/service-account-token 3 22s</span><br></pre></td></tr></table></figure></p>\n<p>// 获取口令<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> kubectl describe secret dashboard-serviceaccount-token<span class=\"_\">-f</span>45wg -n kube-system</span></span><br></pre></td></tr></table></figure></p>\n<p>3）将获取到的token放在令牌里<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga434bjbalj227k13sgsr.jpg\" alt=\"截屏2019-12-21上午9.25.38.png\"><br>4) 登录成功<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga43c9j0ywj228011oq93.jpg\" alt=\"截屏2019-12-21上午9.33.33.png\"><br>5) 但是我还是遇到了<br><img src=\"https://ws1.sinaimg.cn/large/6919c235gy1ga43f7ljwhj227o108n06.jpg\" alt=\"截屏2019-12-21上午9.36.05.png\"><br>这个问题暂时还没有解决</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://zhuanlan.zhihu.com/p/92923128\" target=\"_blank\" rel=\"noopener\">30分钟带你搭建一套Dashboard的kubernetes（K8S）集群</a><br><a href=\"https://www.kubernetes.org.cn/2906.html\" target=\"_blank\" rel=\"noopener\">使用kubeadm安装Kubernetes 1.8版本</a></p>\n"},{"title":"在minikube部署个node服务","date":"2019-08-22T10:51:09.000Z","_content":"## 创建Node.js应用程序\n先编写server.js\n``` js\nvar http = require('http');\n\nvar handleRequest = function(request, response) {\n  console.log('Received request for URL: ' + request.url);\n  response.writeHead(200);\n  response.end('Hello World!');\n};\nvar www = http.createServer(handleRequest);\nwww.listen(8080);\n```\n然后在http://localhost:8080/中看到\"Hello World\"\n## 创建Docker容器镜像\n在hellonode文件夹中创建一个Dockerfile命名的文件。Dockerfile描述了build的镜像，通过现有的镜像扩展（extend）build Docker容器镜像，本教程中的镜像扩展（extend）了现有的Node.js镜像。\n``` Dockerfile\nFROM node:6.9.2\nEXPOSE 8080\nCOPY server.js .\nCMD node server.js\n```\n确保使用Minikube Docker守护进程\n``` \neval $(minikube docker-env)\n```\n注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。\n使用Minikube Docker守护进程build Docker镜像：\n```\ndocker build -t hello-node:v1 .\n```\n## 创建Deployment\n使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像：\n```\nkubectl run hello-node --image=hello-node:v1 --port=8080\n```\n查看Deployment：\n```\nkubectl get deployments\n```\n输出：\n\n```\nNAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nhello-node   1         1         1            1           3m\n```\n查看Pod：\n```\nkubectl get pods\n```\n输出：\n```\nNAME                         READY     STATUS    RESTARTS   AGE\nhello-node-714049816-ztzrb   1/1       Running   0          6m\n```\n查看群集events：\n\n```\nkubectl get events\n```\n查看kubectl配置：\n```\nkubectl config view\n```\n## 创建Service\n默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。\n我们可以使用kubectl expose命令将Pod暴露到外部环境：\n```\nkubectl expose deployment hello-node --type=LoadBalancer\n```\n查看刚创建的Service：\n```\nkubectl get services\n```\n输出：\n\n```\nNAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE\nhello-node   10.0.0.71    <pending>     8080/TCP   6m\nkubernetes   10.0.0.1     <none>        443/TCP    14d\n```\n通过--type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。\n```\nminikube service hello-node\n```\n将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。\n最后可以查看到一些日志\n```\nkubectl logs <POD-NAME>\n```\n更新应用程序\n编辑server.js文件以返回新消息：\n```\nresponse.end('Hello World Again!');\n```\nbuild新版本镜像\n```\ndocker build -t hello-node:v2 .\n```\nDeployment更新镜像：\n```\nkubectl set image deployment/hello-node hello-node=hello-node:v2\n```\n再次运行应用以查看新消息：\n```\nminikube service hello-node\n```\n","source":"_posts/在minikube部署个node服务.md","raw":"---\ntitle: 在minikube部署个node服务\ndate: 2019-08-22 18:51:09\ntags: DevOps\n---\n## 创建Node.js应用程序\n先编写server.js\n``` js\nvar http = require('http');\n\nvar handleRequest = function(request, response) {\n  console.log('Received request for URL: ' + request.url);\n  response.writeHead(200);\n  response.end('Hello World!');\n};\nvar www = http.createServer(handleRequest);\nwww.listen(8080);\n```\n然后在http://localhost:8080/中看到\"Hello World\"\n## 创建Docker容器镜像\n在hellonode文件夹中创建一个Dockerfile命名的文件。Dockerfile描述了build的镜像，通过现有的镜像扩展（extend）build Docker容器镜像，本教程中的镜像扩展（extend）了现有的Node.js镜像。\n``` Dockerfile\nFROM node:6.9.2\nEXPOSE 8080\nCOPY server.js .\nCMD node server.js\n```\n确保使用Minikube Docker守护进程\n``` \neval $(minikube docker-env)\n```\n注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。\n使用Minikube Docker守护进程build Docker镜像：\n```\ndocker build -t hello-node:v1 .\n```\n## 创建Deployment\n使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像：\n```\nkubectl run hello-node --image=hello-node:v1 --port=8080\n```\n查看Deployment：\n```\nkubectl get deployments\n```\n输出：\n\n```\nNAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE\nhello-node   1         1         1            1           3m\n```\n查看Pod：\n```\nkubectl get pods\n```\n输出：\n```\nNAME                         READY     STATUS    RESTARTS   AGE\nhello-node-714049816-ztzrb   1/1       Running   0          6m\n```\n查看群集events：\n\n```\nkubectl get events\n```\n查看kubectl配置：\n```\nkubectl config view\n```\n## 创建Service\n默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。\n我们可以使用kubectl expose命令将Pod暴露到外部环境：\n```\nkubectl expose deployment hello-node --type=LoadBalancer\n```\n查看刚创建的Service：\n```\nkubectl get services\n```\n输出：\n\n```\nNAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE\nhello-node   10.0.0.71    <pending>     8080/TCP   6m\nkubernetes   10.0.0.1     <none>        443/TCP    14d\n```\n通过--type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。\n```\nminikube service hello-node\n```\n将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。\n最后可以查看到一些日志\n```\nkubectl logs <POD-NAME>\n```\n更新应用程序\n编辑server.js文件以返回新消息：\n```\nresponse.end('Hello World Again!');\n```\nbuild新版本镜像\n```\ndocker build -t hello-node:v2 .\n```\nDeployment更新镜像：\n```\nkubectl set image deployment/hello-node hello-node=hello-node:v2\n```\n再次运行应用以查看新消息：\n```\nminikube service hello-node\n```\n","slug":"在minikube部署个node服务","published":1,"updated":"2019-08-22T11:10:28.688Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sin000oth8lhuajn27t","content":"<h2 id=\"创建Node-js应用程序\"><a href=\"#创建Node-js应用程序\" class=\"headerlink\" title=\"创建Node.js应用程序\"></a>创建Node.js应用程序</h2><p>先编写server.js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> handleRequest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Received request for URL: '</span> + request.url);</span><br><span class=\"line\">  response.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">  response.end(<span class=\"string\">'Hello World!'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> www = http.createServer(handleRequest);</span><br><span class=\"line\">www.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure></p>\n<p>然后在<a href=\"http://localhost:8080/中看到&quot;Hello\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/中看到&quot;Hello</a> World”</p>\n<h2 id=\"创建Docker容器镜像\"><a href=\"#创建Docker容器镜像\" class=\"headerlink\" title=\"创建Docker容器镜像\"></a>创建Docker容器镜像</h2><p>在hellonode文件夹中创建一个Dockerfile命名的文件。Dockerfile描述了build的镜像，通过现有的镜像扩展（extend）build Docker容器镜像，本教程中的镜像扩展（extend）了现有的Node.js镜像。<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">6.9</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> server.js .</span></span><br><span class=\"line\"><span class=\"bash\">CMD node server.js</span></span><br></pre></td></tr></table></figure></p>\n<p>确保使用Minikube Docker守护进程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。<br>使用Minikube Docker守护进程build Docker镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t hello-node:v1 .</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建Deployment\"><a href=\"#创建Deployment\" class=\"headerlink\" title=\"创建Deployment\"></a>创建Deployment</h2><p>使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl run hello-node --image=hello-node:v1 --port=8080</span><br></pre></td></tr></table></figure></p>\n<p>查看Deployment：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get deployments</span><br></pre></td></tr></table></figure></p>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">hello-node   1         1         1            1           3m</span><br></pre></td></tr></table></figure>\n<p>查看Pod：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME                         READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">hello-node-714049816-ztzrb   1/1       Running   0          6m</span><br></pre></td></tr></table></figure></p>\n<p>查看群集events：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get events</span><br></pre></td></tr></table></figure>\n<p>查看kubectl配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl config view</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建Service\"><a href=\"#创建Service\" class=\"headerlink\" title=\"创建Service\"></a>创建Service</h2><p>默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。<br>我们可以使用kubectl expose命令将Pod暴露到外部环境：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl expose deployment hello-node --type=LoadBalancer</span><br></pre></td></tr></table></figure></p>\n<p>查看刚创建的Service：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get services</span><br></pre></td></tr></table></figure></p>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class=\"line\">hello-node   10.0.0.71    &lt;pending&gt;     8080/TCP   6m</span><br><span class=\"line\">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP    14d</span><br></pre></td></tr></table></figure>\n<p>通过–type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube service hello-node</span><br></pre></td></tr></table></figure></p>\n<p>将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。<br>最后可以查看到一些日志<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs &lt;POD-NAME&gt;</span><br></pre></td></tr></table></figure></p>\n<p>更新应用程序<br>编辑server.js文件以返回新消息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.end(&apos;Hello World Again!&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>build新版本镜像<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t hello-node:v2 .</span><br></pre></td></tr></table></figure></p>\n<p>Deployment更新镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl set image deployment/hello-node hello-node=hello-node:v2</span><br></pre></td></tr></table></figure></p>\n<p>再次运行应用以查看新消息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube service hello-node</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"创建Node-js应用程序\"><a href=\"#创建Node-js应用程序\" class=\"headerlink\" title=\"创建Node.js应用程序\"></a>创建Node.js应用程序</h2><p>先编写server.js<br><figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">var</span> http = <span class=\"built_in\">require</span>(<span class=\"string\">'http'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">var</span> handleRequest = <span class=\"function\"><span class=\"keyword\">function</span>(<span class=\"params\">request, response</span>) </span>&#123;</span><br><span class=\"line\">  <span class=\"built_in\">console</span>.log(<span class=\"string\">'Received request for URL: '</span> + request.url);</span><br><span class=\"line\">  response.writeHead(<span class=\"number\">200</span>);</span><br><span class=\"line\">  response.end(<span class=\"string\">'Hello World!'</span>);</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">var</span> www = http.createServer(handleRequest);</span><br><span class=\"line\">www.listen(<span class=\"number\">8080</span>);</span><br></pre></td></tr></table></figure></p>\n<p>然后在<a href=\"http://localhost:8080/中看到&quot;Hello\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/中看到&quot;Hello</a> World”</p>\n<h2 id=\"创建Docker容器镜像\"><a href=\"#创建Docker容器镜像\" class=\"headerlink\" title=\"创建Docker容器镜像\"></a>创建Docker容器镜像</h2><p>在hellonode文件夹中创建一个Dockerfile命名的文件。Dockerfile描述了build的镜像，通过现有的镜像扩展（extend）build Docker容器镜像，本教程中的镜像扩展（extend）了现有的Node.js镜像。<br><figure class=\"highlight dockerfile\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">FROM</span> node:<span class=\"number\">6.9</span>.<span class=\"number\">2</span></span><br><span class=\"line\"><span class=\"keyword\">EXPOSE</span> <span class=\"number\">8080</span></span><br><span class=\"line\"><span class=\"keyword\">COPY</span><span class=\"bash\"> server.js .</span></span><br><span class=\"line\"><span class=\"bash\">CMD node server.js</span></span><br></pre></td></tr></table></figure></p>\n<p>确保使用Minikube Docker守护进程<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure></p>\n<p>注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。<br>使用Minikube Docker守护进程build Docker镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t hello-node:v1 .</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建Deployment\"><a href=\"#创建Deployment\" class=\"headerlink\" title=\"创建Deployment\"></a>创建Deployment</h2><p>使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl run hello-node --image=hello-node:v1 --port=8080</span><br></pre></td></tr></table></figure></p>\n<p>查看Deployment：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get deployments</span><br></pre></td></tr></table></figure></p>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class=\"line\">hello-node   1         1         1            1           3m</span><br></pre></td></tr></table></figure>\n<p>查看Pod：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods</span><br></pre></td></tr></table></figure></p>\n<p>输出：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME                         READY     STATUS    RESTARTS   AGE</span><br><span class=\"line\">hello-node-714049816-ztzrb   1/1       Running   0          6m</span><br></pre></td></tr></table></figure></p>\n<p>查看群集events：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get events</span><br></pre></td></tr></table></figure>\n<p>查看kubectl配置：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl config view</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"创建Service\"><a href=\"#创建Service\" class=\"headerlink\" title=\"创建Service\"></a>创建Service</h2><p>默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。<br>我们可以使用kubectl expose命令将Pod暴露到外部环境：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl expose deployment hello-node --type=LoadBalancer</span><br></pre></td></tr></table></figure></p>\n<p>查看刚创建的Service：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get services</span><br></pre></td></tr></table></figure></p>\n<p>输出：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class=\"line\">hello-node   10.0.0.71    &lt;pending&gt;     8080/TCP   6m</span><br><span class=\"line\">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP    14d</span><br></pre></td></tr></table></figure>\n<p>通过–type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube service hello-node</span><br></pre></td></tr></table></figure></p>\n<p>将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。<br>最后可以查看到一些日志<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl logs &lt;POD-NAME&gt;</span><br></pre></td></tr></table></figure></p>\n<p>更新应用程序<br>编辑server.js文件以返回新消息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">response.end(&apos;Hello World Again!&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>build新版本镜像<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker build -t hello-node:v2 .</span><br></pre></td></tr></table></figure></p>\n<p>Deployment更新镜像：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl set image deployment/hello-node hello-node=hello-node:v2</span><br></pre></td></tr></table></figure></p>\n<p>再次运行应用以查看新消息：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">minikube service hello-node</span><br></pre></td></tr></table></figure></p>\n"},{"title":"在程序开发中++i与i++的区别在哪里","date":"2019-11-13T12:56:10.000Z","_content":"i++ 与 ++i 的主要区别有两个：\n1、 i++ 返回原来的值，++i 返回加1后的值。\n2、 i++ 不能作为左值，而++i 可以。\n毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。\n首先解释下什么是左值（以下两段引用自中文维基百科『右值引用』词条）。\n>> 左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。\n一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。\n比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。\n左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。\n比如，\n```\nint i = 0;\nint *p1 = &(++i); //正确\nint *p2 = &(i++); //错误\n\n++i = 1; //正确\ni++ = 5; //错误\n```\n那么为什么『i++ 不能作为左值，而++i 可以』？看它们各自的实现就一目了然了：以下代码来自博客：为什么(i++)不能做左值，而(++i)可以// 前缀形式：\nint& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用\n```\n{//函数本身无参，意味着是在自身空间内增加1的\n  *this += 1;  // 增加\n  return *this;  // 取回值\n}\n\n//后缀形式:\nconst int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。\n{//函数带参，说明有另外的空间开辟\n  int oldValue = *this;  // 取回值\n  ++(*this);  // 增加\n  return oldValue;  // 返回被取回的值\n}\n```\n如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。\n","source":"_posts/在程序开发中-i与i-的区别在哪里.md","raw":"---\ntitle: 在程序开发中++i与i++的区别在哪里\ndate: 2019-11-13 20:56:10\ntags: 技术\n---\ni++ 与 ++i 的主要区别有两个：\n1、 i++ 返回原来的值，++i 返回加1后的值。\n2、 i++ 不能作为左值，而++i 可以。\n毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。\n首先解释下什么是左值（以下两段引用自中文维基百科『右值引用』词条）。\n>> 左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。\n一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。\n比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。\n左值与右值的根本区别在于是否允许取地址&运算符获得对应的内存地址。\n比如，\n```\nint i = 0;\nint *p1 = &(++i); //正确\nint *p2 = &(i++); //错误\n\n++i = 1; //正确\ni++ = 5; //错误\n```\n那么为什么『i++ 不能作为左值，而++i 可以』？看它们各自的实现就一目了然了：以下代码来自博客：为什么(i++)不能做左值，而(++i)可以// 前缀形式：\nint& int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用\n```\n{//函数本身无参，意味着是在自身空间内增加1的\n  *this += 1;  // 增加\n  return *this;  // 取回值\n}\n\n//后缀形式:\nconst int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。\n{//函数带参，说明有另外的空间开辟\n  int oldValue = *this;  // 取回值\n  ++(*this);  // 增加\n  return oldValue;  // 返回被取回的值\n}\n```\n如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。\n","slug":"在程序开发中-i与i-的区别在哪里","published":1,"updated":"2019-11-13T12:59:03.291Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sin000pth8l289u3qwh","content":"<p>i++ 与 ++i 的主要区别有两个：<br>1、 i++ 返回原来的值，++i 返回加1后的值。<br>2、 i++ 不能作为左值，而++i 可以。<br>毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。<br>首先解释下什么是左值（以下两段引用自中文维基百科『右值引用』词条）。</p>\n<blockquote>\n<blockquote>\n<p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。<br>一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。<br>比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<br>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。<br>比如，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">int *p1 = &amp;(++i); //正确</span><br><span class=\"line\">int *p2 = &amp;(i++); //错误</span><br><span class=\"line\"></span><br><span class=\"line\">++i = 1; //正确</span><br><span class=\"line\">i++ = 5; //错误</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n</blockquote>\n<p>那么为什么『i++ 不能作为左值，而++i 可以』？看它们各自的实现就一目了然了：以下代码来自博客：为什么(i++)不能做左值，而(++i)可以// 前缀形式：<br>int&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;//函数本身无参，意味着是在自身空间内增加1的</span><br><span class=\"line\">  *this += 1;  // 增加</span><br><span class=\"line\">  return *this;  // 取回值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//后缀形式:</span><br><span class=\"line\">const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。</span><br><span class=\"line\">&#123;//函数带参，说明有另外的空间开辟</span><br><span class=\"line\">  int oldValue = *this;  // 取回值</span><br><span class=\"line\">  ++(*this);  // 增加</span><br><span class=\"line\">  return oldValue;  // 返回被取回的值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>i++ 与 ++i 的主要区别有两个：<br>1、 i++ 返回原来的值，++i 返回加1后的值。<br>2、 i++ 不能作为左值，而++i 可以。<br>毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。<br>首先解释下什么是左值（以下两段引用自中文维基百科『右值引用』词条）。</p>\n<blockquote>\n<blockquote>\n<p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。<br>一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。<br>比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<br>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。<br>比如，<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int i = 0;</span><br><span class=\"line\">int *p1 = &amp;(++i); //正确</span><br><span class=\"line\">int *p2 = &amp;(i++); //错误</span><br><span class=\"line\"></span><br><span class=\"line\">++i = 1; //正确</span><br><span class=\"line\">i++ = 5; //错误</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n</blockquote>\n<p>那么为什么『i++ 不能作为左值，而++i 可以』？看它们各自的实现就一目了然了：以下代码来自博客：为什么(i++)不能做左值，而(++i)可以// 前缀形式：<br>int&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;//函数本身无参，意味着是在自身空间内增加1的</span><br><span class=\"line\">  *this += 1;  // 增加</span><br><span class=\"line\">  return *this;  // 取回值</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">//后缀形式:</span><br><span class=\"line\">const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。</span><br><span class=\"line\">&#123;//函数带参，说明有另外的空间开辟</span><br><span class=\"line\">  int oldValue = *this;  // 取回值</span><br><span class=\"line\">  ++(*this);  // 增加</span><br><span class=\"line\">  return oldValue;  // 返回被取回的值</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。</p>\n"},{"title":"国内环境利用kubeadm进行kubernetes安装","date":"2019-12-18T12:10:10.000Z","_content":"最近想要学习kubernetes，特地从阿里云购买了两台云主机，用的是kubeadm部署，由于被墙不能直接执行kubeadm init,比较麻烦，所以练习下kubernetes的安装。\n> 先介绍下两台都是centos7,需要注意的是作为主节点的云主机要有两个cpu，内存大于2gb，不然会提示cpu不够和内存限制\n# Kubernetes主要核心组件\n- etcd保存了整个集群的状态；\n- apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；\n- controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；\n- scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；\n- kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；\n- Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；\n- kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；\n除了核心组件，还有一些推荐的Add-ons：\n- kube-dns负责为整个集群提供DNS服务\n- Ingress Controller为服务提供外网入口\n- Heapster提供资源监控\n- Dashboard提供GUI\n- Federation提供跨可用区的集群\n- Fluentd-elasticsearch提供集群日志采集、存储与查询\n# 安装kubeadm\n采用国内阿里云镜像源，安装kubelet、kubeadm、kubectl:\n``` shell \ncat <<EOF > /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nexclude=kube*\nEOF\n\n# Set SELinux in permissive mode (effectively disabling it)\nsetenforce 0\nsed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\n\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\n\nsystemctl enable kubelet\n\n```\ncentos7用户还需要设置路由：\n``` shell\ncat <<EOF >  /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsysctl --system\n```\nKubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动，关闭系统的Swap方法如下:\n``` shell\nswapoff -a\n```\n修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：\n``` shell\nvm.swappiness=0\n```\n执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。\n\n# 获取镜像列表\n由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。\n``` shell\nkubeadm config images list\n```\n然后我们创建一个k8s.shell文件\n``` shell\nimages=(  # 下面的镜像应该去除\"k8s.gcr.io/\"的前缀，版本换成上面获取到的版本\n    kube-apiserver:v1.17.0\n    kube-controller-manager:v1.17.0\n    kube-scheduler:v1.17.0\n    kube-proxy:v1.17.0\n    pause:3.1\n    etcd:3.4.3-0\n    coredns:1.6.5\n)\n\nfor imageName in ${images[@]} ; do\n    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName\n    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName\n    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName\ndone\n```\n然后chmod +x ./k8s.shell给这个shell文件加上执行权限，然后./k8s.shell执行它，它就会从阿里云拉取对应的组件的镜像了\n# 初始化环境\n``` shell\nkubeadm init --pod-network-cidr=10.244.0.0/16 # 这一步注意，如果需要特定的网络插件，需要额外加参数，具体看网络插件的介绍\n```\n# 配置授权信息\n所需的命令在init成功后也会有提示，主要是为了保存相关的配置信息在用户目录下，这样不用每次都输入相关的认证信息。\n``` shell\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n添加网络插件,以下是各个网桥，选择其中一个就可以了\n```\n## CNI bridge\n``` shell\nmkdir -p /etc/cni/net.d\ncat >/etc/cni/net.d/10-mynet.conf <<-EOF\n{\n    \"cniVersion\": \"0.3.0\",\n    \"name\": \"mynet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.244.0.0/16\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n    }\n}\nEOF\ncat >/etc/cni/net.d/99-loopback.conf <<-EOF\n{\n    \"cniVersion\": \"0.3.0\",\n    \"type\": \"loopback\"\n}\nEOF\n```\n## flannel\n需要在kubeadm init 时设置 --pod-network-cidr=10.244.0.0/16\n``` shell\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n```\nweave\n``` shell\nsysctl net.bridge.bridge-nf-call-iptables=1\nkubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\"\ncalico\n```\n需要 kubeadm init 时设置 --pod-network-cidr=192.168.0.0/16\n``` shell \nkubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml\nkubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kub\n```\n# 查看是否安装成功\n``` shell\nkubectl get pods -n kube-system\n```\n如果出现类似下面的情况就说明安装完成了，接下来就可以开始k8s之旅了。\n``` shell\nNAME                              READY   STATUS              RESTARTS   AGE\ncoredns-86c58d9df4-mmjls          1/1     Running             0          6h26m\ncoredns-86c58d9df4-p7brk          1/1     Running             0          6h26m\netcd-promote                      1/1     Running             1          6h26m\nkube-apiserver-promote            1/1     Running             1          6h26m\nkube-controller-manager-promote   1/1     Running             1          6h25m\nkube-proxy-6ml6w                  1/1     Running             1          6h26m\nkube-scheduler-promote            1/1     Running             1          6h25m\n```\n# 从节点加入主节点\n在从节点重复上面的步骤，就是\n``` shell\nkubectl kubeadm join 主节点内部ip:6443 --token 你的token     --discovery-token-ca-cert-hash sha256:你的ca-cert\n```\n但是我的从节点没有执行成功，提示不对\n``` shell\n[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# kubectl get pod\nThe connection to the server localhost:8080 was refused - did you specify the right host or port?\n```\n后面进过查找原因，发现是从节点的\n问题原因是kubectl命令需使用kubernetes-admin来运行，解决方法如下，将主节点中的/etc/kubernetes/admin.conf文件拷贝到从节点相同目录下，然后配置环境变量：\n``` shell\necho \"export KUBECONFIG=/etc/kubernetes/admin.conf\" >> ~/.bash_profile\n ```\n可生效\n``` shell \nsource ~/.bash_profile\n[root@master kubernetes]# scp ./admin.conf root@你的ip:/etc/kubernetes/\n```\n然后再执行一次kubeadm reset，再kubeadm join的命令，\n后面\n``` shell\n[root@iZ8vbcuptq5g86qk6lk4x1Z kubernetes]# kubectl get nodes\nNAME                      STATUS   ROLES    AGE     VERSION\niz8vbbld8tet39uo7wyi2jz   Ready    master   3h54m   v1.17.0\niz8vbcuptq5g86qk6lk4x1z   Ready    <none>   86m     v1.17.0\n```\n 参考文章:\n-------------------\n[kubernetes安装国内环境](https://zhuanlan.zhihu.com/p/46341911)\n[kubernetes部署](https://zhuanlan.zhihu.com/p/55740564)\n[深入剖析k8s之网络模型与CNI网络插件](https://blog.liu-kevin.com/2019/04/22/14-shen-ru-pou-xi-k8szhi-wang-luo-mo-xing-yu-cniwang-luo-cha-jian/)\n[从节点The connection to the server localhost:8080 was refused - did you specify the right host or port?](https://www.cnblogs.com/taoweizhong/p/11545953.html)\n\n","source":"_posts/国内环境kubernetes安装.md","raw":"---\ntitle: 国内环境利用kubeadm进行kubernetes安装\ndate: 2019-12-18 20:10:10\ntags: devops\n---\n最近想要学习kubernetes，特地从阿里云购买了两台云主机，用的是kubeadm部署，由于被墙不能直接执行kubeadm init,比较麻烦，所以练习下kubernetes的安装。\n> 先介绍下两台都是centos7,需要注意的是作为主节点的云主机要有两个cpu，内存大于2gb，不然会提示cpu不够和内存限制\n# Kubernetes主要核心组件\n- etcd保存了整个集群的状态；\n- apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；\n- controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；\n- scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；\n- kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；\n- Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；\n- kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；\n除了核心组件，还有一些推荐的Add-ons：\n- kube-dns负责为整个集群提供DNS服务\n- Ingress Controller为服务提供外网入口\n- Heapster提供资源监控\n- Dashboard提供GUI\n- Federation提供跨可用区的集群\n- Fluentd-elasticsearch提供集群日志采集、存储与查询\n# 安装kubeadm\n采用国内阿里云镜像源，安装kubelet、kubeadm、kubectl:\n``` shell \ncat <<EOF > /etc/yum.repos.d/kubernetes.repo\n[kubernetes]\nname=Kubernetes\nbaseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/\nenabled=1\ngpgcheck=1\nrepo_gpgcheck=1\ngpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg\nexclude=kube*\nEOF\n\n# Set SELinux in permissive mode (effectively disabling it)\nsetenforce 0\nsed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config\n\nyum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes\n\nsystemctl enable kubelet\n\n```\ncentos7用户还需要设置路由：\n``` shell\ncat <<EOF >  /etc/sysctl.d/k8s.conf\nnet.bridge.bridge-nf-call-ip6tables = 1\nnet.bridge.bridge-nf-call-iptables = 1\nEOF\nsysctl --system\n```\nKubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动，关闭系统的Swap方法如下:\n``` shell\nswapoff -a\n```\n修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：\n``` shell\nvm.swappiness=0\n```\n执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。\n\n# 获取镜像列表\n由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。\n``` shell\nkubeadm config images list\n```\n然后我们创建一个k8s.shell文件\n``` shell\nimages=(  # 下面的镜像应该去除\"k8s.gcr.io/\"的前缀，版本换成上面获取到的版本\n    kube-apiserver:v1.17.0\n    kube-controller-manager:v1.17.0\n    kube-scheduler:v1.17.0\n    kube-proxy:v1.17.0\n    pause:3.1\n    etcd:3.4.3-0\n    coredns:1.6.5\n)\n\nfor imageName in ${images[@]} ; do\n    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName\n    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName\n    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName\ndone\n```\n然后chmod +x ./k8s.shell给这个shell文件加上执行权限，然后./k8s.shell执行它，它就会从阿里云拉取对应的组件的镜像了\n# 初始化环境\n``` shell\nkubeadm init --pod-network-cidr=10.244.0.0/16 # 这一步注意，如果需要特定的网络插件，需要额外加参数，具体看网络插件的介绍\n```\n# 配置授权信息\n所需的命令在init成功后也会有提示，主要是为了保存相关的配置信息在用户目录下，这样不用每次都输入相关的认证信息。\n``` shell\nmkdir -p $HOME/.kube\nsudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\nsudo chown $(id -u):$(id -g) $HOME/.kube/config\n添加网络插件,以下是各个网桥，选择其中一个就可以了\n```\n## CNI bridge\n``` shell\nmkdir -p /etc/cni/net.d\ncat >/etc/cni/net.d/10-mynet.conf <<-EOF\n{\n    \"cniVersion\": \"0.3.0\",\n    \"name\": \"mynet\",\n    \"type\": \"bridge\",\n    \"bridge\": \"cni0\",\n    \"isGateway\": true,\n    \"ipMasq\": true,\n    \"ipam\": {\n        \"type\": \"host-local\",\n        \"subnet\": \"10.244.0.0/16\",\n        \"routes\": [\n            {\"dst\": \"0.0.0.0/0\"}\n        ]\n    }\n}\nEOF\ncat >/etc/cni/net.d/99-loopback.conf <<-EOF\n{\n    \"cniVersion\": \"0.3.0\",\n    \"type\": \"loopback\"\n}\nEOF\n```\n## flannel\n需要在kubeadm init 时设置 --pod-network-cidr=10.244.0.0/16\n``` shell\nkubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n```\nweave\n``` shell\nsysctl net.bridge.bridge-nf-call-iptables=1\nkubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\"\ncalico\n```\n需要 kubeadm init 时设置 --pod-network-cidr=192.168.0.0/16\n``` shell \nkubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml\nkubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kub\n```\n# 查看是否安装成功\n``` shell\nkubectl get pods -n kube-system\n```\n如果出现类似下面的情况就说明安装完成了，接下来就可以开始k8s之旅了。\n``` shell\nNAME                              READY   STATUS              RESTARTS   AGE\ncoredns-86c58d9df4-mmjls          1/1     Running             0          6h26m\ncoredns-86c58d9df4-p7brk          1/1     Running             0          6h26m\netcd-promote                      1/1     Running             1          6h26m\nkube-apiserver-promote            1/1     Running             1          6h26m\nkube-controller-manager-promote   1/1     Running             1          6h25m\nkube-proxy-6ml6w                  1/1     Running             1          6h26m\nkube-scheduler-promote            1/1     Running             1          6h25m\n```\n# 从节点加入主节点\n在从节点重复上面的步骤，就是\n``` shell\nkubectl kubeadm join 主节点内部ip:6443 --token 你的token     --discovery-token-ca-cert-hash sha256:你的ca-cert\n```\n但是我的从节点没有执行成功，提示不对\n``` shell\n[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# kubectl get pod\nThe connection to the server localhost:8080 was refused - did you specify the right host or port?\n```\n后面进过查找原因，发现是从节点的\n问题原因是kubectl命令需使用kubernetes-admin来运行，解决方法如下，将主节点中的/etc/kubernetes/admin.conf文件拷贝到从节点相同目录下，然后配置环境变量：\n``` shell\necho \"export KUBECONFIG=/etc/kubernetes/admin.conf\" >> ~/.bash_profile\n ```\n可生效\n``` shell \nsource ~/.bash_profile\n[root@master kubernetes]# scp ./admin.conf root@你的ip:/etc/kubernetes/\n```\n然后再执行一次kubeadm reset，再kubeadm join的命令，\n后面\n``` shell\n[root@iZ8vbcuptq5g86qk6lk4x1Z kubernetes]# kubectl get nodes\nNAME                      STATUS   ROLES    AGE     VERSION\niz8vbbld8tet39uo7wyi2jz   Ready    master   3h54m   v1.17.0\niz8vbcuptq5g86qk6lk4x1z   Ready    <none>   86m     v1.17.0\n```\n 参考文章:\n-------------------\n[kubernetes安装国内环境](https://zhuanlan.zhihu.com/p/46341911)\n[kubernetes部署](https://zhuanlan.zhihu.com/p/55740564)\n[深入剖析k8s之网络模型与CNI网络插件](https://blog.liu-kevin.com/2019/04/22/14-shen-ru-pou-xi-k8szhi-wang-luo-mo-xing-yu-cniwang-luo-cha-jian/)\n[从节点The connection to the server localhost:8080 was refused - did you specify the right host or port?](https://www.cnblogs.com/taoweizhong/p/11545953.html)\n\n","slug":"国内环境kubernetes安装","published":1,"updated":"2019-12-21T01:43:47.457Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sio000qth8lgbpd9t7a","content":"<p>最近想要学习kubernetes，特地从阿里云购买了两台云主机，用的是kubeadm部署，由于被墙不能直接执行kubeadm init,比较麻烦，所以练习下kubernetes的安装。</p>\n<blockquote>\n<p>先介绍下两台都是centos7,需要注意的是作为主节点的云主机要有两个cpu，内存大于2gb，不然会提示cpu不够和内存限制</p>\n</blockquote>\n<h1 id=\"Kubernetes主要核心组件\"><a href=\"#Kubernetes主要核心组件\" class=\"headerlink\" title=\"Kubernetes主要核心组件\"></a>Kubernetes主要核心组件</h1><ul>\n<li>etcd保存了整个集群的状态；</li>\n<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>\n<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>\n<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>\n<li>kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li>\n<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>\n<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；<br>除了核心组件，还有一些推荐的Add-ons：</li>\n<li>kube-dns负责为整个集群提供DNS服务</li>\n<li>Ingress Controller为服务提供外网入口</li>\n<li>Heapster提供资源监控</li>\n<li>Dashboard提供GUI</li>\n<li>Federation提供跨可用区的集群</li>\n<li>Fluentd-elasticsearch提供集群日志采集、存储与查询<h1 id=\"安装kubeadm\"><a href=\"#安装kubeadm\" class=\"headerlink\" title=\"安装kubeadm\"></a>安装kubeadm</h1>采用国内阿里云镜像源，安装kubelet、kubeadm、kubectl:<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class=\"line\">[kubernetes]</span><br><span class=\"line\">name=Kubernetes</span><br><span class=\"line\">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">repo_gpgcheck=1</span><br><span class=\"line\">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class=\"line\">exclude=kube*</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Set SELinux <span class=\"keyword\">in</span> permissive mode (effectively disabling it)</span></span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable kubelet</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>centos7用户还需要设置路由：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class=\"line\">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class=\"line\">net.bridge.bridge-nf-call-iptables = 1</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sysctl --system</span><br></pre></td></tr></table></figure></p>\n<p>Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动，关闭系统的Swap方法如下:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swapoff -a</span><br></pre></td></tr></table></figure></p>\n<p>修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.swappiness=0</span><br></pre></td></tr></table></figure></p>\n<p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。</p>\n<h1 id=\"获取镜像列表\"><a href=\"#获取镜像列表\" class=\"headerlink\" title=\"获取镜像列表\"></a>获取镜像列表</h1><p>由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm config images list</span><br></pre></td></tr></table></figure></p>\n<p>然后我们创建一个k8s.shell文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">images=(  # 下面的镜像应该去除\"k8s.gcr.io/\"的前缀，版本换成上面获取到的版本</span><br><span class=\"line\">    kube-apiserver:v1.17.0</span><br><span class=\"line\">    kube-controller-manager:v1.17.0</span><br><span class=\"line\">    kube-scheduler:v1.17.0</span><br><span class=\"line\">    kube-proxy:v1.17.0</span><br><span class=\"line\">    pause:3.1</span><br><span class=\"line\">    etcd:3.4.3-0</span><br><span class=\"line\">    coredns:1.6.5</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">for imageName in $&#123;images[@]&#125; ; do</span><br><span class=\"line\">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class=\"line\">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName</span><br><span class=\"line\">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>然后chmod +x ./k8s.shell给这个shell文件加上执行权限，然后./k8s.shell执行它，它就会从阿里云拉取对应的组件的镜像了</p>\n<h1 id=\"初始化环境\"><a href=\"#初始化环境\" class=\"headerlink\" title=\"初始化环境\"></a>初始化环境</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm init --pod-network-cidr=10.244.0.0/16 # 这一步注意，如果需要特定的网络插件，需要额外加参数，具体看网络插件的介绍</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置授权信息\"><a href=\"#配置授权信息\" class=\"headerlink\" title=\"配置授权信息\"></a>配置授权信息</h1><p>所需的命令在init成功后也会有提示，主要是为了保存相关的配置信息在用户目录下，这样不用每次都输入相关的认证信息。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p $HOME/.kube</span><br><span class=\"line\">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class=\"line\">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class=\"line\">添加网络插件,以下是各个网桥，选择其中一个就可以了</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"CNI-bridge\"><a href=\"#CNI-bridge\" class=\"headerlink\" title=\"CNI bridge\"></a>CNI bridge</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /etc/cni/net.d</span><br><span class=\"line\">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"cniVersion\": \"0.3.0\",</span><br><span class=\"line\">    \"name\": \"mynet\",</span><br><span class=\"line\">    \"type\": \"bridge\",</span><br><span class=\"line\">    \"bridge\": \"cni0\",</span><br><span class=\"line\">    \"isGateway\": true,</span><br><span class=\"line\">    \"ipMasq\": true,</span><br><span class=\"line\">    \"ipam\": &#123;</span><br><span class=\"line\">        \"type\": \"host-local\",</span><br><span class=\"line\">        \"subnet\": \"10.244.0.0/16\",</span><br><span class=\"line\">        \"routes\": [</span><br><span class=\"line\">            &#123;\"dst\": \"0.0.0.0/0\"&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"cniVersion\": \"0.3.0\",</span><br><span class=\"line\">    \"type\": \"loopback\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<h2 id=\"flannel\"><a href=\"#flannel\" class=\"headerlink\" title=\"flannel\"></a>flannel</h2><p>需要在kubeadm init 时设置 –pod-network-cidr=10.244.0.0/16<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p>\n<p>weave<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.bridge.bridge-nf-call-iptables=1</span><br><span class=\"line\">kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\"</span><br><span class=\"line\">calico</span><br></pre></td></tr></table></figure></p>\n<p>需要 kubeadm init 时设置 –pod-network-cidr=192.168.0.0/16<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span><br><span class=\"line\">kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kub</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"查看是否安装成功\"><a href=\"#查看是否安装成功\" class=\"headerlink\" title=\"查看是否安装成功\"></a>查看是否安装成功</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>\n<p>如果出现类似下面的情况就说明安装完成了，接下来就可以开始k8s之旅了。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME                              READY   STATUS              RESTARTS   AGE</span><br><span class=\"line\">coredns-86c58d9df4-mmjls          1/1     Running             0          6h26m</span><br><span class=\"line\">coredns-86c58d9df4-p7brk          1/1     Running             0          6h26m</span><br><span class=\"line\">etcd-promote                      1/1     Running             1          6h26m</span><br><span class=\"line\">kube-apiserver-promote            1/1     Running             1          6h26m</span><br><span class=\"line\">kube-controller-manager-promote   1/1     Running             1          6h25m</span><br><span class=\"line\">kube-proxy-6ml6w                  1/1     Running             1          6h26m</span><br><span class=\"line\">kube-scheduler-promote            1/1     Running             1          6h25m</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"从节点加入主节点\"><a href=\"#从节点加入主节点\" class=\"headerlink\" title=\"从节点加入主节点\"></a>从节点加入主节点</h1><p>在从节点重复上面的步骤，就是<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl kubeadm join 主节点内部ip:6443 --token 你的token     --discovery-token-ca-cert-hash sha256:你的ca-cert</span><br></pre></td></tr></table></figure></p>\n<p>但是我的从节点没有执行成功，提示不对<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# kubectl get pod</span><br><span class=\"line\">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure></p>\n<p>后面进过查找原因，发现是从节点的<br>问题原因是kubectl命令需使用kubernetes-admin来运行，解决方法如下，将主节点中的/etc/kubernetes/admin.conf文件拷贝到从节点相同目录下，然后配置环境变量：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"export KUBECONFIG=/etc/kubernetes/admin.conf\" &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>可生效<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bash_profile</span><br><span class=\"line\">[root@master kubernetes]# scp ./admin.conf root@你的ip:/etc/kubernetes/</span><br></pre></td></tr></table></figure></p>\n<p>然后再执行一次kubeadm reset，再kubeadm join的命令，<br>后面<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbcuptq5g86qk6lk4x1Z kubernetes]# kubectl get nodes</span><br><span class=\"line\">NAME                      STATUS   ROLES    AGE     VERSION</span><br><span class=\"line\">iz8vbbld8tet39uo7wyi2jz   Ready    master   3h54m   v1.17.0</span><br><span class=\"line\">iz8vbcuptq5g86qk6lk4x1z   Ready    &lt;none&gt;   86m     v1.17.0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://zhuanlan.zhihu.com/p/46341911\" target=\"_blank\" rel=\"noopener\">kubernetes安装国内环境</a><br><a href=\"https://zhuanlan.zhihu.com/p/55740564\" target=\"_blank\" rel=\"noopener\">kubernetes部署</a><br><a href=\"https://blog.liu-kevin.com/2019/04/22/14-shen-ru-pou-xi-k8szhi-wang-luo-mo-xing-yu-cniwang-luo-cha-jian/\" target=\"_blank\" rel=\"noopener\">深入剖析k8s之网络模型与CNI网络插件</a><br><a href=\"https://www.cnblogs.com/taoweizhong/p/11545953.html\" target=\"_blank\" rel=\"noopener\">从节点The connection to the server localhost:8080 was refused - did you specify the right host or port?</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>最近想要学习kubernetes，特地从阿里云购买了两台云主机，用的是kubeadm部署，由于被墙不能直接执行kubeadm init,比较麻烦，所以练习下kubernetes的安装。</p>\n<blockquote>\n<p>先介绍下两台都是centos7,需要注意的是作为主节点的云主机要有两个cpu，内存大于2gb，不然会提示cpu不够和内存限制</p>\n</blockquote>\n<h1 id=\"Kubernetes主要核心组件\"><a href=\"#Kubernetes主要核心组件\" class=\"headerlink\" title=\"Kubernetes主要核心组件\"></a>Kubernetes主要核心组件</h1><ul>\n<li>etcd保存了整个集群的状态；</li>\n<li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li>\n<li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li>\n<li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li>\n<li>kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li>\n<li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li>\n<li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；<br>除了核心组件，还有一些推荐的Add-ons：</li>\n<li>kube-dns负责为整个集群提供DNS服务</li>\n<li>Ingress Controller为服务提供外网入口</li>\n<li>Heapster提供资源监控</li>\n<li>Dashboard提供GUI</li>\n<li>Federation提供跨可用区的集群</li>\n<li>Fluentd-elasticsearch提供集群日志采集、存储与查询<h1 id=\"安装kubeadm\"><a href=\"#安装kubeadm\" class=\"headerlink\" title=\"安装kubeadm\"></a>安装kubeadm</h1>采用国内阿里云镜像源，安装kubelet、kubeadm、kubectl:<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class=\"line\">[kubernetes]</span><br><span class=\"line\">name=Kubernetes</span><br><span class=\"line\">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class=\"line\">enabled=1</span><br><span class=\"line\">gpgcheck=1</span><br><span class=\"line\">repo_gpgcheck=1</span><br><span class=\"line\">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class=\"line\">exclude=kube*</span><br><span class=\"line\">EOF</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\"> Set SELinux <span class=\"keyword\">in</span> permissive mode (effectively disabling it)</span></span><br><span class=\"line\">setenforce 0</span><br><span class=\"line\">sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br><span class=\"line\"></span><br><span class=\"line\">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class=\"line\"></span><br><span class=\"line\">systemctl enable kubelet</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>centos7用户还需要设置路由：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class=\"line\">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class=\"line\">net.bridge.bridge-nf-call-iptables = 1</span><br><span class=\"line\">EOF</span><br><span class=\"line\">sysctl --system</span><br></pre></td></tr></table></figure></p>\n<p>Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动，关闭系统的Swap方法如下:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">swapoff -a</span><br></pre></td></tr></table></figure></p>\n<p>修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vm.swappiness=0</span><br></pre></td></tr></table></figure></p>\n<p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。</p>\n<h1 id=\"获取镜像列表\"><a href=\"#获取镜像列表\" class=\"headerlink\" title=\"获取镜像列表\"></a>获取镜像列表</h1><p>由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm config images list</span><br></pre></td></tr></table></figure></p>\n<p>然后我们创建一个k8s.shell文件<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">images=(  # 下面的镜像应该去除\"k8s.gcr.io/\"的前缀，版本换成上面获取到的版本</span><br><span class=\"line\">    kube-apiserver:v1.17.0</span><br><span class=\"line\">    kube-controller-manager:v1.17.0</span><br><span class=\"line\">    kube-scheduler:v1.17.0</span><br><span class=\"line\">    kube-proxy:v1.17.0</span><br><span class=\"line\">    pause:3.1</span><br><span class=\"line\">    etcd:3.4.3-0</span><br><span class=\"line\">    coredns:1.6.5</span><br><span class=\"line\">)</span><br><span class=\"line\"></span><br><span class=\"line\">for imageName in $&#123;images[@]&#125; ; do</span><br><span class=\"line\">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class=\"line\">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName</span><br><span class=\"line\">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class=\"line\">done</span><br></pre></td></tr></table></figure></p>\n<p>然后chmod +x ./k8s.shell给这个shell文件加上执行权限，然后./k8s.shell执行它，它就会从阿里云拉取对应的组件的镜像了</p>\n<h1 id=\"初始化环境\"><a href=\"#初始化环境\" class=\"headerlink\" title=\"初始化环境\"></a>初始化环境</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubeadm init --pod-network-cidr=10.244.0.0/16 # 这一步注意，如果需要特定的网络插件，需要额外加参数，具体看网络插件的介绍</span><br></pre></td></tr></table></figure>\n<h1 id=\"配置授权信息\"><a href=\"#配置授权信息\" class=\"headerlink\" title=\"配置授权信息\"></a>配置授权信息</h1><p>所需的命令在init成功后也会有提示，主要是为了保存相关的配置信息在用户目录下，这样不用每次都输入相关的认证信息。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p $HOME/.kube</span><br><span class=\"line\">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class=\"line\">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class=\"line\">添加网络插件,以下是各个网桥，选择其中一个就可以了</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"CNI-bridge\"><a href=\"#CNI-bridge\" class=\"headerlink\" title=\"CNI bridge\"></a>CNI bridge</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir -p /etc/cni/net.d</span><br><span class=\"line\">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"cniVersion\": \"0.3.0\",</span><br><span class=\"line\">    \"name\": \"mynet\",</span><br><span class=\"line\">    \"type\": \"bridge\",</span><br><span class=\"line\">    \"bridge\": \"cni0\",</span><br><span class=\"line\">    \"isGateway\": true,</span><br><span class=\"line\">    \"ipMasq\": true,</span><br><span class=\"line\">    \"ipam\": &#123;</span><br><span class=\"line\">        \"type\": \"host-local\",</span><br><span class=\"line\">        \"subnet\": \"10.244.0.0/16\",</span><br><span class=\"line\">        \"routes\": [</span><br><span class=\"line\">            &#123;\"dst\": \"0.0.0.0/0\"&#125;</span><br><span class=\"line\">        ]</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br><span class=\"line\">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    \"cniVersion\": \"0.3.0\",</span><br><span class=\"line\">    \"type\": \"loopback\"</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<h2 id=\"flannel\"><a href=\"#flannel\" class=\"headerlink\" title=\"flannel\"></a>flannel</h2><p>需要在kubeadm init 时设置 –pod-network-cidr=10.244.0.0/16<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p>\n<p>weave<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sysctl net.bridge.bridge-nf-call-iptables=1</span><br><span class=\"line\">kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\"</span><br><span class=\"line\">calico</span><br></pre></td></tr></table></figure></p>\n<p>需要 kubeadm init 时设置 –pod-network-cidr=192.168.0.0/16<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span><br><span class=\"line\">kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kub</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"查看是否安装成功\"><a href=\"#查看是否安装成功\" class=\"headerlink\" title=\"查看是否安装成功\"></a>查看是否安装成功</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure>\n<p>如果出现类似下面的情况就说明安装完成了，接下来就可以开始k8s之旅了。<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">NAME                              READY   STATUS              RESTARTS   AGE</span><br><span class=\"line\">coredns-86c58d9df4-mmjls          1/1     Running             0          6h26m</span><br><span class=\"line\">coredns-86c58d9df4-p7brk          1/1     Running             0          6h26m</span><br><span class=\"line\">etcd-promote                      1/1     Running             1          6h26m</span><br><span class=\"line\">kube-apiserver-promote            1/1     Running             1          6h26m</span><br><span class=\"line\">kube-controller-manager-promote   1/1     Running             1          6h25m</span><br><span class=\"line\">kube-proxy-6ml6w                  1/1     Running             1          6h26m</span><br><span class=\"line\">kube-scheduler-promote            1/1     Running             1          6h25m</span><br></pre></td></tr></table></figure></p>\n<h1 id=\"从节点加入主节点\"><a href=\"#从节点加入主节点\" class=\"headerlink\" title=\"从节点加入主节点\"></a>从节点加入主节点</h1><p>在从节点重复上面的步骤，就是<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl kubeadm join 主节点内部ip:6443 --token 你的token     --discovery-token-ca-cert-hash sha256:你的ca-cert</span><br></pre></td></tr></table></figure></p>\n<p>但是我的从节点没有执行成功，提示不对<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# kubectl get pod</span><br><span class=\"line\">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure></p>\n<p>后面进过查找原因，发现是从节点的<br>问题原因是kubectl命令需使用kubernetes-admin来运行，解决方法如下，将主节点中的/etc/kubernetes/admin.conf文件拷贝到从节点相同目录下，然后配置环境变量：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">echo \"export KUBECONFIG=/etc/kubernetes/admin.conf\" &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p>\n<p>可生效<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">source ~/.bash_profile</span><br><span class=\"line\">[root@master kubernetes]# scp ./admin.conf root@你的ip:/etc/kubernetes/</span><br></pre></td></tr></table></figure></p>\n<p>然后再执行一次kubeadm reset，再kubeadm join的命令，<br>后面<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbcuptq5g86qk6lk4x1Z kubernetes]# kubectl get nodes</span><br><span class=\"line\">NAME                      STATUS   ROLES    AGE     VERSION</span><br><span class=\"line\">iz8vbbld8tet39uo7wyi2jz   Ready    master   3h54m   v1.17.0</span><br><span class=\"line\">iz8vbcuptq5g86qk6lk4x1z   Ready    &lt;none&gt;   86m     v1.17.0</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://zhuanlan.zhihu.com/p/46341911\" target=\"_blank\" rel=\"noopener\">kubernetes安装国内环境</a><br><a href=\"https://zhuanlan.zhihu.com/p/55740564\" target=\"_blank\" rel=\"noopener\">kubernetes部署</a><br><a href=\"https://blog.liu-kevin.com/2019/04/22/14-shen-ru-pou-xi-k8szhi-wang-luo-mo-xing-yu-cniwang-luo-cha-jian/\" target=\"_blank\" rel=\"noopener\">深入剖析k8s之网络模型与CNI网络插件</a><br><a href=\"https://www.cnblogs.com/taoweizhong/p/11545953.html\" target=\"_blank\" rel=\"noopener\">从节点The connection to the server localhost:8080 was refused - did you specify the right host or port?</a></p>\n"},{"title":"探索php中的变量zval结构体二","date":"2017-06-20T09:04:13.000Z","_content":"上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:\n       ` zend_uint refcount__gc `\n       ` zend_uchar is_ref__gc `\n``` c\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc; /*  */\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n```\nphp中的引用计数\n先看例子\n\n``` php\n<?php\n$a = 'Hello World';\n$b = $a;\nunset($a);      \n```\n\n<!--more-->\nPHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？\n这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：\n\n``` c\n    zval *helloval;\n    MAKE_STD_ZVAL(helloval);\n    ZVAL_STRING(helloval, \"Hello World\", 1);\n    zend_hash_add(EG(active_symbol_table), \"a\", sizeof(\"a\"),&helloval, sizeof(zval*), NULL);\n    ZVAL_ADDREF(helloval); //这句很特殊，我们显式的增加了helloval结构体的refcount\n    zend_hash_add(EG(active_symbol_table), \"b\", sizeof(\"b\"),&helloval, sizeof(zval*), NULL)\n```\n这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！\n引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？\n\n``` php\n    $a = 1;\n    $b = $a;\n    $b += 5;\n```\n从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。\n\n``` c\nzval *get_var_and_separate(char *varname, int varname_len TSRMLS_DC)\n{\n        zval **varval, *varcopy;\n        if (zend_hash_find(EG(active_symbol_table),varname, varname_len + 1, (void**)&varval) == FAILURE)\n        {\n            /* 如果在符号表里找不到这个变量则直接return */\n            return NULL;\n        }\n\n        if ((*varval)->refcount < 2)\n        {   \n        //如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return\n        return *varval;\n        }\n            \n        /* 否则，复制一份zval*的值 */\n        MAKE_STD_ZVAL(varcopy);\n        varcopy = *varval;\n            \n        /* 复制任何在zval*内已分配的结构*/\n        zval_copy_ctor(varcopy);\n\n        /* 从符号表中删除原来的变量\n         * 这将减少该过程中varval的refcount的值\n         */\n        zend_hash_del(EG(active_symbol_table), varname, varname_len + 1);\n\n        /* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/\n        varcopy->refcount = 1;\n        varcopy->is_ref = 0;\n        zend_hash_add(EG(active_symbol_table), varname, varname_len + 1,&varcopy, sizeof(zval*), NULL);\n            \n        /* 返回新zval的地址 */\n        return varcopy;\n}  \n```\n\n现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。\nChange on Write\n\n如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？\n\n``` php\n    $a = 1;\n    $b = &$a;\n    $b += 5;        \n```\n\n作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：\n``` c\n    /* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/\n    if ((*varval)->is_ref || (*varval)->refcount < 2) {\n            return *varval;\n    }       \n\n```\n\n这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。\nSeparation Anxiety\n\n我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：\n\n``` php\n    $a = 1;\n    $b = $a;\n    $c = &$a;       \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref1.jpg)\n这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】\n\n\n\n同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！\n``` php\n    //上图对应的代码\n    $a = 1;\n    $b = &$a;\n    $c = $a;        \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref2.jpg)\n\n需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/探索php中的变量zval结构体二.md","raw":"---\ntitle: 探索php中的变量zval结构体二\ndate: 2017-06-20 17:04:13\ntags: php php扩展 c\ncategories: 技术\n\n---\n上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:\n       ` zend_uint refcount__gc `\n       ` zend_uchar is_ref__gc `\n``` c\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc; /*  */\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n```\nphp中的引用计数\n先看例子\n\n``` php\n<?php\n$a = 'Hello World';\n$b = $a;\nunset($a);      \n```\n\n<!--more-->\nPHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？\n这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：\n\n``` c\n    zval *helloval;\n    MAKE_STD_ZVAL(helloval);\n    ZVAL_STRING(helloval, \"Hello World\", 1);\n    zend_hash_add(EG(active_symbol_table), \"a\", sizeof(\"a\"),&helloval, sizeof(zval*), NULL);\n    ZVAL_ADDREF(helloval); //这句很特殊，我们显式的增加了helloval结构体的refcount\n    zend_hash_add(EG(active_symbol_table), \"b\", sizeof(\"b\"),&helloval, sizeof(zval*), NULL)\n```\n这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！\n引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？\n\n``` php\n    $a = 1;\n    $b = $a;\n    $b += 5;\n```\n从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。\n\n``` c\nzval *get_var_and_separate(char *varname, int varname_len TSRMLS_DC)\n{\n        zval **varval, *varcopy;\n        if (zend_hash_find(EG(active_symbol_table),varname, varname_len + 1, (void**)&varval) == FAILURE)\n        {\n            /* 如果在符号表里找不到这个变量则直接return */\n            return NULL;\n        }\n\n        if ((*varval)->refcount < 2)\n        {   \n        //如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return\n        return *varval;\n        }\n            \n        /* 否则，复制一份zval*的值 */\n        MAKE_STD_ZVAL(varcopy);\n        varcopy = *varval;\n            \n        /* 复制任何在zval*内已分配的结构*/\n        zval_copy_ctor(varcopy);\n\n        /* 从符号表中删除原来的变量\n         * 这将减少该过程中varval的refcount的值\n         */\n        zend_hash_del(EG(active_symbol_table), varname, varname_len + 1);\n\n        /* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/\n        varcopy->refcount = 1;\n        varcopy->is_ref = 0;\n        zend_hash_add(EG(active_symbol_table), varname, varname_len + 1,&varcopy, sizeof(zval*), NULL);\n            \n        /* 返回新zval的地址 */\n        return varcopy;\n}  \n```\n\n现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。\nChange on Write\n\n如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？\n\n``` php\n    $a = 1;\n    $b = &$a;\n    $b += 5;        \n```\n\n作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：\n``` c\n    /* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/\n    if ((*varval)->is_ref || (*varval)->refcount < 2) {\n            return *varval;\n    }       \n\n```\n\n这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。\nSeparation Anxiety\n\n我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：\n\n``` php\n    $a = 1;\n    $b = $a;\n    $c = &$a;       \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref1.jpg)\n这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】\n\n\n\n同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！\n``` php\n    //上图对应的代码\n    $a = 1;\n    $b = &$a;\n    $c = $a;        \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref2.jpg)\n\n需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"探索php中的变量zval结构体二","published":1,"updated":"2018-05-27T09:59:36.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sio000rth8l4sti5ku4","content":"<p>上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:<br>       <code>zend_uint refcount__gc</code><br>       <code>zend_uchar is_ref__gc</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</span><br><span class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></span><br><span class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></span><br><span class=\"line\">        zend_uint refcount__gc; <span class=\"comment\">/*  */</span></span><br><span class=\"line\">        zend_uchar is_ref__gc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</span><br></pre></td></tr></table></figure></p>\n<p>php中的引用计数<br>先看例子</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$a = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>PHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br>这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval *helloval;</span><br><span class=\"line\">MAKE_STD_ZVAL(helloval);</span><br><span class=\"line\">ZVAL_STRING(helloval, <span class=\"string\">\"Hello World\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"a\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"a\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">ZVAL_ADDREF(helloval); <span class=\"comment\">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></span><br><span class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"b\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"b\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>)</span><br></pre></td></tr></table></figure>\n<p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！<br>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">$b += <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">zval *<span class=\"title\">get_var_and_separate</span><span class=\"params\">(<span class=\"keyword\">char</span> *varname, <span class=\"keyword\">int</span> varname_len TSRMLS_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        zval **varval, *varcopy;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class=\"number\">1</span>, (<span class=\"keyword\">void</span>**)&amp;varval) == FAILURE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 如果在符号表里找不到这个变量则直接return */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*varval)-&gt;refcount &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">        <span class=\"comment\">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *varval;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">/* 否则，复制一份zval*的值 */</span></span><br><span class=\"line\">        MAKE_STD_ZVAL(varcopy);</span><br><span class=\"line\">        varcopy = *varval;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">/* 复制任何在zval*内已分配的结构*/</span></span><br><span class=\"line\">        zval_copy_ctor(varcopy);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 从符号表中删除原来的变量</span></span><br><span class=\"line\"><span class=\"comment\">         * 这将减少该过程中varval的refcount的值</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></span><br><span class=\"line\">        varcopy-&gt;refcount = <span class=\"number\">1</span>;</span><br><span class=\"line\">        varcopy-&gt;is_ref = <span class=\"number\">0</span>;</span><br><span class=\"line\">        zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>,&amp;varcopy, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">/* 返回新zval的地址 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> varcopy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。<br>Change on Write</p>\n<p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$b += <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *varval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。<br>Separation Anxiety</p>\n<p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">$c = &amp;$a;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/assets/blogImg/is_ref1.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】</p>\n<p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上图对应的代码</span></span><br><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/is_ref2.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>\n","site":{"data":{}},"excerpt":"<p>上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:<br>       <code>zend_uint refcount__gc</code><br>       <code>zend_uchar is_ref__gc</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</span><br><span class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></span><br><span class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></span><br><span class=\"line\">        zend_uint refcount__gc; <span class=\"comment\">/*  */</span></span><br><span class=\"line\">        zend_uchar is_ref__gc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</span><br></pre></td></tr></table></figure></p>\n<p>php中的引用计数<br>先看例子</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$a = <span class=\"string\">'Hello World'</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\"><span class=\"keyword\">unset</span>($a);</span><br></pre></td></tr></table></figure>","more":"<p>PHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br>这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval *helloval;</span><br><span class=\"line\">MAKE_STD_ZVAL(helloval);</span><br><span class=\"line\">ZVAL_STRING(helloval, <span class=\"string\">\"Hello World\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"a\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"a\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">ZVAL_ADDREF(helloval); <span class=\"comment\">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></span><br><span class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"b\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"b\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>)</span><br></pre></td></tr></table></figure>\n<p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！<br>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">$b += <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">zval *<span class=\"title\">get_var_and_separate</span><span class=\"params\">(<span class=\"keyword\">char</span> *varname, <span class=\"keyword\">int</span> varname_len TSRMLS_DC)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        zval **varval, *varcopy;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class=\"number\">1</span>, (<span class=\"keyword\">void</span>**)&amp;varval) == FAILURE)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"comment\">/* 如果在符号表里找不到这个变量则直接return */</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((*varval)-&gt;refcount &lt; <span class=\"number\">2</span>)</span><br><span class=\"line\">        &#123;   </span><br><span class=\"line\">        <span class=\"comment\">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> *varval;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">/* 否则，复制一份zval*的值 */</span></span><br><span class=\"line\">        MAKE_STD_ZVAL(varcopy);</span><br><span class=\"line\">        varcopy = *varval;</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">/* 复制任何在zval*内已分配的结构*/</span></span><br><span class=\"line\">        zval_copy_ctor(varcopy);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 从符号表中删除原来的变量</span></span><br><span class=\"line\"><span class=\"comment\">         * 这将减少该过程中varval的refcount的值</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">        zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></span><br><span class=\"line\">        varcopy-&gt;refcount = <span class=\"number\">1</span>;</span><br><span class=\"line\">        varcopy-&gt;is_ref = <span class=\"number\">0</span>;</span><br><span class=\"line\">        zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>,&amp;varcopy, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</span><br><span class=\"line\">            </span><br><span class=\"line\">        <span class=\"comment\">/* 返回新zval的地址 */</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> varcopy;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。<br>Change on Write</p>\n<p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$b += <span class=\"number\">5</span>;</span><br></pre></td></tr></table></figure>\n<p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> *varval;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。<br>Separation Anxiety</p>\n<p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = $a;</span><br><span class=\"line\">$c = &amp;$a;</span><br></pre></td></tr></table></figure>\n<p> <img src=\"/assets/blogImg/is_ref1.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】</p>\n<p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//上图对应的代码</span></span><br><span class=\"line\">$a = <span class=\"number\">1</span>;</span><br><span class=\"line\">$b = &amp;$a;</span><br><span class=\"line\">$c = $a;</span><br></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/is_ref2.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>"},{"title":"解析jwt","date":"2019-08-21T11:01:07.000Z","_content":"# jwt是什么\njwt全称是JSON Web Token，是目前流行的跨域认证解决方案\n# 为什么使用jwt\n要知道为什么使用jwt，我们先来看看传统的认证方式\n1、用户向服务器发送用户名和密码。\n2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。\n3、服务器向用户返回一个 session_id，写入用户的 Cookie。\n4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。\n5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n这种方式的扩展性不好，如果是服务器集群，就要求session数据共享，每台服务器都能读取session\n一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。\n另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。\n# jwt的原理\njwt的原理是服务器认证后，生成一个JSON对象，发回给用户\n``` json \n{\n  \"姓名\": \"张三\",\n  \"角色\": \"管理员\",\n  \"到期时间\": \"2018年7月1日0点0分\"\n}\n```\n以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n# jwt的数据结构\n它是一个很长的字符串，中间用点（.）分隔成三个部分。例如\n``` php\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1bmlvbmlkIjoiMDdhMjIwMDE5ODI1YWY5YjYwZDVlYWI1NGI1OTNkYmYiLCJ3eF91bmlvbmlkIjpudWxsLCJwbGF0Zm9ybSI6IkhXTUNfQVBQIiwiZXhwaXJlX2F0IjoxNTY3MjIxMDY5fQ.AsdOrML1WrCBtOiCs4afi5cCPbWK5dLPO_29Vb1w0EE\n```\n>>> jwt的三个部分如下\n* Header(头部)\n* Payload(负载)\n* Signature(签名)\n写成一行就是*Header.Payload.Signature*\nHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。\n``` php\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。\n3.2 Payload\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。\n``` php\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n```\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n``` json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n这个json对象使用Base64URL 算法转成字符串\n3.3 Signature\nSignature 部分是对前两部分的签名，防止数据篡改。\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\n``` php\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。\n## jwt的使用方式\njwt可以存储在cookie里，也可以存储在localStorage\n在header里面放 Authorization: Bearer <token>\n也可以放在post的请求数据体里\n代码实现\n[参考这个jwt类](https://github.com/firebase/php-jwt)\n``` php\npublic static function encode($payload, $key, $alg = 'HS256', $keyId = null, $head = null)\n    {\n        $header = array('typ' => 'JWT', 'alg' => $alg);\n        if ($keyId !== null) {\n            $header['kid'] = $keyId;\n        }\n        if ( isset($head) && is_array($head) ) {\n            $header = array_merge($head, $header);\n        }\n        $segments = array();\n        $segments[] = static::urlsafeB64Encode(static::jsonEncode($header));\n        $segments[] = static::urlsafeB64Encode(static::jsonEncode($payload));\n        $signing_input = implode('.', $segments);\n\n        $signature = static::sign($signing_input, $key, $alg);\n        $segments[] = static::urlsafeB64Encode($signature);\n\n        return implode('.', $segments);\n    }\n```\n## 参考资料\n\n+ [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n","source":"_posts/解析jwt.md","raw":"---\ntitle: 解析jwt\ndate: 2019-08-21 19:01:07\ntags: 技术\n---\n# jwt是什么\njwt全称是JSON Web Token，是目前流行的跨域认证解决方案\n# 为什么使用jwt\n要知道为什么使用jwt，我们先来看看传统的认证方式\n1、用户向服务器发送用户名和密码。\n2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。\n3、服务器向用户返回一个 session_id，写入用户的 Cookie。\n4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。\n5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。\n这种方式的扩展性不好，如果是服务器集群，就要求session数据共享，每台服务器都能读取session\n一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。\n另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。\n# jwt的原理\njwt的原理是服务器认证后，生成一个JSON对象，发回给用户\n``` json \n{\n  \"姓名\": \"张三\",\n  \"角色\": \"管理员\",\n  \"到期时间\": \"2018年7月1日0点0分\"\n}\n```\n以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。\n服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。\n# jwt的数据结构\n它是一个很长的字符串，中间用点（.）分隔成三个部分。例如\n``` php\neyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1bmlvbmlkIjoiMDdhMjIwMDE5ODI1YWY5YjYwZDVlYWI1NGI1OTNkYmYiLCJ3eF91bmlvbmlkIjpudWxsLCJwbGF0Zm9ybSI6IkhXTUNfQVBQIiwiZXhwaXJlX2F0IjoxNTY3MjIxMDY5fQ.AsdOrML1WrCBtOiCs4afi5cCPbWK5dLPO_29Vb1w0EE\n```\n>>> jwt的三个部分如下\n* Header(头部)\n* Payload(负载)\n* Signature(签名)\n写成一行就是*Header.Payload.Signature*\nHeader 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。\n``` php\n{\n  \"alg\": \"HS256\",\n  \"typ\": \"JWT\"\n}\n```\n上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。\n3.2 Payload\nPayload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。\n``` php\niss (issuer)：签发人\nexp (expiration time)：过期时间\nsub (subject)：主题\naud (audience)：受众\nnbf (Not Before)：生效时间\niat (Issued At)：签发时间\njti (JWT ID)：编号\n```\n除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。\n``` json\n{\n  \"sub\": \"1234567890\",\n  \"name\": \"John Doe\",\n  \"admin\": true\n}\n```\n注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。\n这个json对象使用Base64URL 算法转成字符串\n3.3 Signature\nSignature 部分是对前两部分的签名，防止数据篡改。\n首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。\n``` php\nHMACSHA256(\n  base64UrlEncode(header) + \".\" +\n  base64UrlEncode(payload),\n  secret)\n```\n算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用\"点\"（.）分隔，就可以返回给用户。\n## jwt的使用方式\njwt可以存储在cookie里，也可以存储在localStorage\n在header里面放 Authorization: Bearer <token>\n也可以放在post的请求数据体里\n代码实现\n[参考这个jwt类](https://github.com/firebase/php-jwt)\n``` php\npublic static function encode($payload, $key, $alg = 'HS256', $keyId = null, $head = null)\n    {\n        $header = array('typ' => 'JWT', 'alg' => $alg);\n        if ($keyId !== null) {\n            $header['kid'] = $keyId;\n        }\n        if ( isset($head) && is_array($head) ) {\n            $header = array_merge($head, $header);\n        }\n        $segments = array();\n        $segments[] = static::urlsafeB64Encode(static::jsonEncode($header));\n        $segments[] = static::urlsafeB64Encode(static::jsonEncode($payload));\n        $signing_input = implode('.', $segments);\n\n        $signature = static::sign($signing_input, $key, $alg);\n        $segments[] = static::urlsafeB64Encode($signature);\n\n        return implode('.', $segments);\n    }\n```\n## 参考资料\n\n+ [JSON Web Token 入门教程](http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html)\n","slug":"解析jwt","published":1,"updated":"2019-08-21T13:09:47.393Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sip000sth8lp9stt1na","content":"<h1 id=\"jwt是什么\"><a href=\"#jwt是什么\" class=\"headerlink\" title=\"jwt是什么\"></a>jwt是什么</h1><p>jwt全称是JSON Web Token，是目前流行的跨域认证解决方案</p>\n<h1 id=\"为什么使用jwt\"><a href=\"#为什么使用jwt\" class=\"headerlink\" title=\"为什么使用jwt\"></a>为什么使用jwt</h1><p>要知道为什么使用jwt，我们先来看看传统的认证方式<br>1、用户向服务器发送用户名和密码。<br>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。<br>3、服务器向用户返回一个 session_id，写入用户的 Cookie。<br>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。<br>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。<br>这种方式的扩展性不好，如果是服务器集群，就要求session数据共享，每台服务器都能读取session<br>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。<br>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>\n<h1 id=\"jwt的原理\"><a href=\"#jwt的原理\" class=\"headerlink\" title=\"jwt的原理\"></a>jwt的原理</h1><p>jwt的原理是服务器认证后，生成一个JSON对象，发回给用户<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"姓名\"</span>: <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"角色\"</span>: <span class=\"string\">\"管理员\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"到期时间\"</span>: <span class=\"string\">\"2018年7月1日0点0分\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>\n<h1 id=\"jwt的数据结构\"><a href=\"#jwt的数据结构\" class=\"headerlink\" title=\"jwt的数据结构\"></a>jwt的数据结构</h1><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。例如<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1bmlvbmlkIjoiMDdhMjIwMDE5ODI1YWY5YjYwZDVlYWI1NGI1OTNkYmYiLCJ3eF91bmlvbmlkIjpudWxsLCJwbGF0Zm9ybSI6IkhXTUNfQVBQIiwiZXhwaXJlX2F0IjoxNTY3MjIxMDY5fQ.AsdOrML1WrCBtOiCs4afi5cCPbWK5dLPO_29Vb1w0EE</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>jwt的三个部分如下</p>\n<ul>\n<li>Header(头部)</li>\n<li>Payload(负载)</li>\n<li>Signature(签名)<br>写成一行就是<em>Header.Payload.Signature</em><br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"alg\"</span>: <span class=\"string\">\"HS256\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"typ\"</span>: <span class=\"string\">\"JWT\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>3.2 Payload<br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iss (issuer)：签发人</span><br><span class=\"line\">exp (expiration time)：过期时间</span><br><span class=\"line\">sub (subject)：主题</span><br><span class=\"line\">aud (audience)：受众</span><br><span class=\"line\">nbf (Not Before)：生效时间</span><br><span class=\"line\">iat (Issued At)：签发时间</span><br><span class=\"line\">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p>\n<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"sub\"</span>: <span class=\"string\">\"1234567890\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"John Doe\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"admin\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个json对象使用Base64URL 算法转成字符串<br>3.3 Signature<br>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256(</span><br><span class=\"line\">  base64UrlEncode(header) + <span class=\"string\">\".\"</span> +</span><br><span class=\"line\">  base64UrlEncode(payload),</span><br><span class=\"line\">  secret)</span><br></pre></td></tr></table></figure></p>\n<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>\n<h2 id=\"jwt的使用方式\"><a href=\"#jwt的使用方式\" class=\"headerlink\" title=\"jwt的使用方式\"></a>jwt的使用方式</h2><p>jwt可以存储在cookie里，也可以存储在localStorage<br>在header里面放 Authorization: Bearer <token><br>也可以放在post的请求数据体里<br>代码实现<br><a href=\"https://github.com/firebase/php-jwt\" target=\"_blank\" rel=\"noopener\">参考这个jwt类</a><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encode</span><span class=\"params\">($payload, $key, $alg = <span class=\"string\">'HS256'</span>, $keyId = null, $head = null)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $header = <span class=\"keyword\">array</span>(<span class=\"string\">'typ'</span> =&gt; <span class=\"string\">'JWT'</span>, <span class=\"string\">'alg'</span> =&gt; $alg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ($keyId !== <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            $header[<span class=\"string\">'kid'</span>] = $keyId;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">isset</span>($head) &amp;&amp; is_array($head) ) &#123;</span><br><span class=\"line\">            $header = array_merge($head, $header);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $segments = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">        $segments[] = <span class=\"keyword\">static</span>::urlsafeB64Encode(<span class=\"keyword\">static</span>::jsonEncode($header));</span><br><span class=\"line\">        $segments[] = <span class=\"keyword\">static</span>::urlsafeB64Encode(<span class=\"keyword\">static</span>::jsonEncode($payload));</span><br><span class=\"line\">        $signing_input = implode(<span class=\"string\">'.'</span>, $segments);</span><br><span class=\"line\"></span><br><span class=\"line\">        $signature = <span class=\"keyword\">static</span>::sign($signing_input, $key, $alg);</span><br><span class=\"line\">        $segments[] = <span class=\"keyword\">static</span>::urlsafeB64Encode($signature);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> implode(<span class=\"string\">'.'</span>, $segments);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></token></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">JSON Web Token 入门教程</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"jwt是什么\"><a href=\"#jwt是什么\" class=\"headerlink\" title=\"jwt是什么\"></a>jwt是什么</h1><p>jwt全称是JSON Web Token，是目前流行的跨域认证解决方案</p>\n<h1 id=\"为什么使用jwt\"><a href=\"#为什么使用jwt\" class=\"headerlink\" title=\"为什么使用jwt\"></a>为什么使用jwt</h1><p>要知道为什么使用jwt，我们先来看看传统的认证方式<br>1、用户向服务器发送用户名和密码。<br>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。<br>3、服务器向用户返回一个 session_id，写入用户的 Cookie。<br>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。<br>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。<br>这种方式的扩展性不好，如果是服务器集群，就要求session数据共享，每台服务器都能读取session<br>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。<br>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p>\n<h1 id=\"jwt的原理\"><a href=\"#jwt的原理\" class=\"headerlink\" title=\"jwt的原理\"></a>jwt的原理</h1><p>jwt的原理是服务器认证后，生成一个JSON对象，发回给用户<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"姓名\"</span>: <span class=\"string\">\"张三\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"角色\"</span>: <span class=\"string\">\"管理员\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"到期时间\"</span>: <span class=\"string\">\"2018年7月1日0点0分\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p>\n<h1 id=\"jwt的数据结构\"><a href=\"#jwt的数据结构\" class=\"headerlink\" title=\"jwt的数据结构\"></a>jwt的数据结构</h1><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。例如<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1bmlvbmlkIjoiMDdhMjIwMDE5ODI1YWY5YjYwZDVlYWI1NGI1OTNkYmYiLCJ3eF91bmlvbmlkIjpudWxsLCJwbGF0Zm9ybSI6IkhXTUNfQVBQIiwiZXhwaXJlX2F0IjoxNTY3MjIxMDY5fQ.AsdOrML1WrCBtOiCs4afi5cCPbWK5dLPO_29Vb1w0EE</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>jwt的三个部分如下</p>\n<ul>\n<li>Header(头部)</li>\n<li>Payload(负载)</li>\n<li>Signature(签名)<br>写成一行就是<em>Header.Payload.Signature</em><br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"string\">\"alg\"</span>: <span class=\"string\">\"HS256\"</span>,</span><br><span class=\"line\">  <span class=\"string\">\"typ\"</span>: <span class=\"string\">\"JWT\"</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>3.2 Payload<br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">iss (issuer)：签发人</span><br><span class=\"line\">exp (expiration time)：过期时间</span><br><span class=\"line\">sub (subject)：主题</span><br><span class=\"line\">aud (audience)：受众</span><br><span class=\"line\">nbf (Not Before)：生效时间</span><br><span class=\"line\">iat (Issued At)：签发时间</span><br><span class=\"line\">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p>\n<p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。<br><figure class=\"highlight json\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  <span class=\"attr\">\"sub\"</span>: <span class=\"string\">\"1234567890\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"name\"</span>: <span class=\"string\">\"John Doe\"</span>,</span><br><span class=\"line\">  <span class=\"attr\">\"admin\"</span>: <span class=\"literal\">true</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个json对象使用Base64URL 算法转成字符串<br>3.3 Signature<br>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">HMACSHA256(</span><br><span class=\"line\">  base64UrlEncode(header) + <span class=\"string\">\".\"</span> +</span><br><span class=\"line\">  base64UrlEncode(payload),</span><br><span class=\"line\">  secret)</span><br></pre></td></tr></table></figure></p>\n<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p>\n<h2 id=\"jwt的使用方式\"><a href=\"#jwt的使用方式\" class=\"headerlink\" title=\"jwt的使用方式\"></a>jwt的使用方式</h2><p>jwt可以存储在cookie里，也可以存储在localStorage<br>在header里面放 Authorization: Bearer <token><br>也可以放在post的请求数据体里<br>代码实现<br><a href=\"https://github.com/firebase/php-jwt\" target=\"_blank\" rel=\"noopener\">参考这个jwt类</a><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">encode</span><span class=\"params\">($payload, $key, $alg = <span class=\"string\">'HS256'</span>, $keyId = null, $head = null)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span>&#123;</span><br><span class=\"line\">        $header = <span class=\"keyword\">array</span>(<span class=\"string\">'typ'</span> =&gt; <span class=\"string\">'JWT'</span>, <span class=\"string\">'alg'</span> =&gt; $alg);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ($keyId !== <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            $header[<span class=\"string\">'kid'</span>] = $keyId;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( <span class=\"keyword\">isset</span>($head) &amp;&amp; is_array($head) ) &#123;</span><br><span class=\"line\">            $header = array_merge($head, $header);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        $segments = <span class=\"keyword\">array</span>();</span><br><span class=\"line\">        $segments[] = <span class=\"keyword\">static</span>::urlsafeB64Encode(<span class=\"keyword\">static</span>::jsonEncode($header));</span><br><span class=\"line\">        $segments[] = <span class=\"keyword\">static</span>::urlsafeB64Encode(<span class=\"keyword\">static</span>::jsonEncode($payload));</span><br><span class=\"line\">        $signing_input = implode(<span class=\"string\">'.'</span>, $segments);</span><br><span class=\"line\"></span><br><span class=\"line\">        $signature = <span class=\"keyword\">static</span>::sign($signing_input, $key, $alg);</span><br><span class=\"line\">        $segments[] = <span class=\"keyword\">static</span>::urlsafeB64Encode($signature);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> implode(<span class=\"string\">'.'</span>, $segments);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure></token></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\" target=\"_blank\" rel=\"noopener\">JSON Web Token 入门教程</a></li>\n</ul>\n"},{"title":"深入解析php的容器模式","date":"2016-10-19T03:20:43.000Z","_content":"先说结论，**容器**在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。\n### 我是傲娇的代码块:\n\n``` php\n\n<?php\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n  private $_binContainerngs = [];//服务列表\n  private $_instances= [];//已经实例化的服务\n\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n  //检测是否已经绑定\n  public function has($name){\n  return isset($this->_binContainerngs[$name]) or isset($this->_instances[$name]);\n  }\n\n  //卸载服务\n  public function remove($name){\n  unset($this->_binContainerngs[$name],$this->_instances[$name]);\n  }\n  //设置服务\n  public function set($name,$class){\n  $this->_registerService($name,$class);\n  }\n  //设置共享服务\n  public function setShared($name,$class){\n  $this->_registerService($name,$class,true);\n  }\n  //注册服务\n  private function _registerService($name,$class,$shared=false){\n  $this->remove($name);\n  if(!($class instanceof \\Closure) && is_object($class)){\n  $this->_instances[$name]=$class;\n  }else{\n  $this->_binContainerngs[$name]=array(\"class\"=>$class,\"shared\"=>$shared);\n  }\n  }\n  //ArrayAccess接口，检测服务是否存在\n  public function offsetExists($offset){\n  return $this->has($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetGet($offset){\n  return $this->get($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetSet($offset,$value){\n  return $this->set($offset,$value);\n  }\n  //卸载服务\n  public function offsetUnset($offset){\n  return $this->remove($offset);\n  }\n}\n\n```\n\n<!--more-->\n### 使用方式\n\n``` php\n\n<?php\nheader(\"Content-Type:text/html;charset=utf8\");\nclass A{\n  public $name;\n  public $age;\n  public function __construct($name=\"\"){\n  $this->name = $name;\n\n  }\n\n}\n\ninclude \"Container.class.php\";\n$Container = new Container();\n\n/**\n* @brief $Container->setShared 匿名函数方式注册一个名为a1的服务\n*\n* @param 'a1'\n* @param\n*/\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n\n$a1 = $Container->get('a1',array(\"小李\"));\necho $a1->name.\"<br/>\";//小李\n/**\n* @brief $Container->set 直接以类名方式注册\n*\n* @param 'a2'\n* @param 'A'\n*/\n$Container->set('a2','A');\n\n$a2 = $Container->get('a2',array(\"小张\"));\necho $a2->name.\"<br/>\";//小张\n/**\n* @brief $Container->set 直接传入实例化的对象\n*\n* @param 'a3'\n* @param \"小唐\"\n*/\n$Container->set('a3',new A(\"小唐\"));\necho $a3->name.\"<br/>\";//小唐\n\n```\n### 分析\n通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式\n- 匿名函数方式注册\n- 类名方式注册\n- 直接传入实例化的对象的注册\n然后get方法\n``` php\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n```\n\n实际上通过分析get方法对这三种注入方式的数组都做了对应的处理\n# 匿名方式\n\n``` php\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n```\n\n``` php\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }\n```\n  \n\n  首先通过**$concrete instanceof \\Closure**来判断是否是匿名函数，然后通过**call_user_func_array($concrete,$params)**来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。\n# 类名方式注册\n\n``` php\n$Container->set('a2','A');\n\n```\n\n``` php\n\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }\n  }\n\n```\n\n 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名\n# 带参数的类实例化,使用反射(接口方式)\n\n``` php\n$Container->set('a3',new A(\"小唐\"));\n```\n``` php\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  \n```\n> **reflectionClass**: ReflectionClass 类报告了一个类的有关信息。\n> **newInstanceArgs**: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。\n","source":"_posts/深入解析php的容器模式.md","raw":"\ntitle: 深入解析php的容器模式\ndate: 2016-10-19 11:20:43\ntag: php\ncategories: 技术\n---\n先说结论，**容器**在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。\n### 我是傲娇的代码块:\n\n``` php\n\n<?php\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n  private $_binContainerngs = [];//服务列表\n  private $_instances= [];//已经实例化的服务\n\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n  //检测是否已经绑定\n  public function has($name){\n  return isset($this->_binContainerngs[$name]) or isset($this->_instances[$name]);\n  }\n\n  //卸载服务\n  public function remove($name){\n  unset($this->_binContainerngs[$name],$this->_instances[$name]);\n  }\n  //设置服务\n  public function set($name,$class){\n  $this->_registerService($name,$class);\n  }\n  //设置共享服务\n  public function setShared($name,$class){\n  $this->_registerService($name,$class,true);\n  }\n  //注册服务\n  private function _registerService($name,$class,$shared=false){\n  $this->remove($name);\n  if(!($class instanceof \\Closure) && is_object($class)){\n  $this->_instances[$name]=$class;\n  }else{\n  $this->_binContainerngs[$name]=array(\"class\"=>$class,\"shared\"=>$shared);\n  }\n  }\n  //ArrayAccess接口，检测服务是否存在\n  public function offsetExists($offset){\n  return $this->has($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetGet($offset){\n  return $this->get($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetSet($offset,$value){\n  return $this->set($offset,$value);\n  }\n  //卸载服务\n  public function offsetUnset($offset){\n  return $this->remove($offset);\n  }\n}\n\n```\n\n<!--more-->\n### 使用方式\n\n``` php\n\n<?php\nheader(\"Content-Type:text/html;charset=utf8\");\nclass A{\n  public $name;\n  public $age;\n  public function __construct($name=\"\"){\n  $this->name = $name;\n\n  }\n\n}\n\ninclude \"Container.class.php\";\n$Container = new Container();\n\n/**\n* @brief $Container->setShared 匿名函数方式注册一个名为a1的服务\n*\n* @param 'a1'\n* @param\n*/\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n\n$a1 = $Container->get('a1',array(\"小李\"));\necho $a1->name.\"<br/>\";//小李\n/**\n* @brief $Container->set 直接以类名方式注册\n*\n* @param 'a2'\n* @param 'A'\n*/\n$Container->set('a2','A');\n\n$a2 = $Container->get('a2',array(\"小张\"));\necho $a2->name.\"<br/>\";//小张\n/**\n* @brief $Container->set 直接传入实例化的对象\n*\n* @param 'a3'\n* @param \"小唐\"\n*/\n$Container->set('a3',new A(\"小唐\"));\necho $a3->name.\"<br/>\";//小唐\n\n```\n### 分析\n通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式\n- 匿名函数方式注册\n- 类名方式注册\n- 直接传入实例化的对象的注册\n然后get方法\n``` php\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n```\n\n实际上通过分析get方法对这三种注入方式的数组都做了对应的处理\n# 匿名方式\n\n``` php\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n```\n\n``` php\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }\n```\n  \n\n  首先通过**$concrete instanceof \\Closure**来判断是否是匿名函数，然后通过**call_user_func_array($concrete,$params)**来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。\n# 类名方式注册\n\n``` php\n$Container->set('a2','A');\n\n```\n\n``` php\n\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }\n  }\n\n```\n\n 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名\n# 带参数的类实例化,使用反射(接口方式)\n\n``` php\n$Container->set('a3',new A(\"小唐\"));\n```\n``` php\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  \n```\n> **reflectionClass**: ReflectionClass 类报告了一个类的有关信息。\n> **newInstanceArgs**: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。\n","slug":"深入解析php的容器模式","published":1,"updated":"2018-05-27T09:59:36.027Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sip000tth8lzqwz4puy","content":"<p>先说结论，<strong>容器</strong>在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。</p>\n<h3 id=\"我是傲娇的代码块\"><a href=\"#我是傲娇的代码块\" class=\"headerlink\" title=\"我是傲娇的代码块:\"></a>我是傲娇的代码块:</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> 服务容器</span></span><br><span class=\"line\"><span class=\"comment\">* author Graychen</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> $_binContainerngs = [];<span class=\"comment\">//服务列表</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//获取服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//先从实例化的列表中查找</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//检测有没有注册该服务</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  $concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">  $obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">  $obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">  $obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">  $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">  $obj = $class-&gt;newInstanceArgs($params);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> $obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//检测是否已经绑定</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置共享服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//注册服务</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;remove($name);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">header(<span class=\"string\">\"Content-Type:text/html;charset=utf8\"</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $name;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $age;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;name = $name;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">\"Container.class.php\"</span>;</span><br><span class=\"line\">$Container = <span class=\"keyword\">new</span> Container();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> $Container-&gt;setShared 匿名函数方式注册一个名为a1的服务</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'a1'</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$a1 = $Container-&gt;get(<span class=\"string\">'a1'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小李\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $a1-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小李</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接以类名方式注册</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'a2'</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'A'</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$a2 = $Container-&gt;get(<span class=\"string\">'a2'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小张\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $a2-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小张</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接传入实例化的对象</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'a3'</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> \"小唐\"</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $a3-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小唐</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式</p>\n<ul>\n<li>匿名函数方式注册</li>\n<li>类名方式注册</li>\n<li>直接传入实例化的对象的注册<br>然后get方法<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//先从实例化的列表中查找</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检测有没有注册该服务</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">$obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">$obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</span><br><span class=\"line\"><span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> $obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际上通过分析get方法对这三种注入方式的数组都做了对应的处理</p>\n<h1 id=\"匿名方式\"><a href=\"#匿名方式\" class=\"headerlink\" title=\"匿名方式\"></a>匿名方式</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">$obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  首先通过<strong>$concrete instanceof \\Closure</strong>来判断是否是匿名函数，然后通过<strong>call_user_func_array($concrete,$params)</strong>来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。</p>\n<h1 id=\"类名方式注册\"><a href=\"#类名方式注册\" class=\"headerlink\" title=\"类名方式注册\"></a>类名方式注册</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名</p>\n<h1 id=\"带参数的类实例化-使用反射-接口方式\"><a href=\"#带参数的类实例化-使用反射-接口方式\" class=\"headerlink\" title=\"带参数的类实例化,使用反射(接口方式)\"></a>带参数的类实例化,使用反射(接口方式)</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>reflectionClass</strong>: ReflectionClass 类报告了一个类的有关信息。<br><strong>newInstanceArgs</strong>: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>先说结论，<strong>容器</strong>在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。</p>\n<h3 id=\"我是傲娇的代码块\"><a href=\"#我是傲娇的代码块\" class=\"headerlink\" title=\"我是傲娇的代码块:\"></a>我是傲娇的代码块:</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> 服务容器</span></span><br><span class=\"line\"><span class=\"comment\">* author Graychen</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">private</span> $_binContainerngs = [];<span class=\"comment\">//服务列表</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//获取服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//先从实例化的列表中查找</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//检测有没有注册该服务</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  $concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">  $obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">  $obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">  &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">  $obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">  $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">  $obj = $class-&gt;newInstanceArgs($params);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></span><br><span class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"keyword\">return</span> $obj;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//检测是否已经绑定</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//设置共享服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//注册服务</span></span><br><span class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;remove($name);</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</span><br><span class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">  <span class=\"comment\">//卸载服务</span></span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">header(<span class=\"string\">\"Content-Type:text/html;charset=utf8\"</span>);</span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $name;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> $age;</span><br><span class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">$this</span>-&gt;name = $name;</span><br><span class=\"line\"></span><br><span class=\"line\">  &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">\"Container.class.php\"</span>;</span><br><span class=\"line\">$Container = <span class=\"keyword\">new</span> Container();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> $Container-&gt;setShared 匿名函数方式注册一个名为a1的服务</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'a1'</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span></span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">$a1 = $Container-&gt;get(<span class=\"string\">'a1'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小李\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $a1-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小李</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接以类名方式注册</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'a2'</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'A'</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">$a2 = $Container-&gt;get(<span class=\"string\">'a2'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小张\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $a2-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小张</span></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接传入实例化的对象</span></span><br><span class=\"line\"><span class=\"comment\">*</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> 'a3'</span></span><br><span class=\"line\"><span class=\"comment\">* <span class=\"doctag\">@param</span> \"小唐\"</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</span><br><span class=\"line\"><span class=\"keyword\">echo</span> $a3-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小唐</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式</p>\n<ul>\n<li>匿名函数方式注册</li>\n<li>类名方式注册</li>\n<li>直接传入实例化的对象的注册<br>然后get方法<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//获取服务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//先从实例化的列表中查找</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//检测有没有注册该服务</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">$concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></span><br><span class=\"line\"></span><br><span class=\"line\">$obj = <span class=\"keyword\">null</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">$obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</span><br><span class=\"line\"><span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">return</span> $obj;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际上通过分析get方法对这三种注入方式的数组都做了对应的处理</p>\n<h1 id=\"匿名方式\"><a href=\"#匿名方式\" class=\"headerlink\" title=\"匿名方式\"></a>匿名方式</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</span><br><span class=\"line\">  &#125;);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></span><br><span class=\"line\">$obj = call_user_func_array($concrete,$params);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>  首先通过<strong>$concrete instanceof \\Closure</strong>来判断是否是匿名函数，然后通过<strong>call_user_func_array($concrete,$params)</strong>来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。</p>\n<h1 id=\"类名方式注册\"><a href=\"#类名方式注册\" class=\"headerlink\" title=\"类名方式注册\"></a>类名方式注册</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></span><br><span class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</span><br><span class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p> 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名</p>\n<h1 id=\"带参数的类实例化-使用反射-接口方式\"><a href=\"#带参数的类实例化-使用反射-接口方式\" class=\"headerlink\" title=\"带参数的类实例化,使用反射(接口方式)\"></a>带参数的类实例化,使用反射(接口方式)</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></span><br><span class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</span><br><span class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</span><br></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>reflectionClass</strong>: ReflectionClass 类报告了一个类的有关信息。<br><strong>newInstanceArgs</strong>: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。</p>\n</blockquote>"},{"title":"解析php的内存管理","date":"2017-06-21T05:59:12.000Z","_content":"## php的内存管理\n在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。\n> 内存泄露\n每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。\n对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。\n\n## Zend内存管理器\n使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是\"请求感知\"的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。\n![\"我是傲娇的效果图\"](/assets/blogImg/zend_manage.jpg)\n 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。 \n 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求\"跳出\"时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为\"永久性分配\"），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：\n 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。\n\n| C语言原生函数 |   PHP内核封装后的函数|\n| :-------------|  :------------------:|\n| void *malloc(size_t count);  |  void *emalloc(size_t count); void *pemalloc(size_t count, char persistent);|\n|  void *calloc(size_t count); |  void *ecalloc(size_t count); void *pecalloc(size_t count, char persistent);|\n|  void *realloc(void *ptr, size_t count); |   void *erealloc(void *ptr, size_t count); void *perealloc(void *ptr, size_t count, char persistent);|\n|  void *strdup(void *ptr); |  void *estrdup(void *ptr); void *pestrdup(void *ptr, char persistent);|\n|  void free(void *ptr); | void efree(void *ptr); void pefree(void *ptr, char persistent);|\n你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： ````c void *estrndup(void *ptr，int len);\n该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：\n\n```c\nZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n        char *p;\n\n        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n            if (UNEXPECTED(p == NULL))\n            {\n                        return p;\n                            \n            }\n        memcpy(p, s, length);\n        p[length] = 0;\n        return p;\n}\n```\n<!--more-->\n\n在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。\nvoid *safe_emalloc(size_t size, size_t count, size_t addtl);\nvoid *safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);\n这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：\"为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？\"。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一\"可能性相当小\"的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。\n","source":"_posts/解析php的内存管理.md","raw":"---\ntitle: 解析php的内存管理\ndate: 2017-06-21 13:59:12\ntags: php php扩展 c\ncategories: 技术\n\n---\n## php的内存管理\n在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。\n> 内存泄露\n每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。\n对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。\n\n## Zend内存管理器\n使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是\"请求感知\"的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。\n![\"我是傲娇的效果图\"](/assets/blogImg/zend_manage.jpg)\n 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。 \n 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求\"跳出\"时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为\"永久性分配\"），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：\n 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。\n\n| C语言原生函数 |   PHP内核封装后的函数|\n| :-------------|  :------------------:|\n| void *malloc(size_t count);  |  void *emalloc(size_t count); void *pemalloc(size_t count, char persistent);|\n|  void *calloc(size_t count); |  void *ecalloc(size_t count); void *pecalloc(size_t count, char persistent);|\n|  void *realloc(void *ptr, size_t count); |   void *erealloc(void *ptr, size_t count); void *perealloc(void *ptr, size_t count, char persistent);|\n|  void *strdup(void *ptr); |  void *estrdup(void *ptr); void *pestrdup(void *ptr, char persistent);|\n|  void free(void *ptr); | void efree(void *ptr); void pefree(void *ptr, char persistent);|\n你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： ````c void *estrndup(void *ptr，int len);\n该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：\n\n```c\nZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n        char *p;\n\n        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n            if (UNEXPECTED(p == NULL))\n            {\n                        return p;\n                            \n            }\n        memcpy(p, s, length);\n        p[length] = 0;\n        return p;\n}\n```\n<!--more-->\n\n在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。\nvoid *safe_emalloc(size_t size, size_t count, size_t addtl);\nvoid *safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);\n这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：\"为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？\"。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一\"可能性相当小\"的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。\n","slug":"解析php的内存管理","published":1,"updated":"2018-05-27T09:59:36.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00siq000uth8lzjh4w4i7","content":"<h2 id=\"php的内存管理\"><a href=\"#php的内存管理\" class=\"headerlink\" title=\"php的内存管理\"></a>php的内存管理</h2><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p>\n<blockquote>\n<p>内存泄露<br>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。<br>对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。</p>\n</blockquote>\n<h2 id=\"Zend内存管理器\"><a href=\"#Zend内存管理器\" class=\"headerlink\" title=\"Zend内存管理器\"></a>Zend内存管理器</h2><p>使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br><img src=\"/assets/blogImg/zend_manage.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br> 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br> 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">C语言原生函数</th>\n<th style=\"text-align:center\">PHP内核封装后的函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">void *malloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>emalloc(size_t count); void </em>pemalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void *calloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>ecalloc(size_t count); void </em>pecalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>realloc(void </em>ptr, size_t count);</td>\n<td style=\"text-align:center\">void <em>erealloc(void </em>ptr, size_t count); void <em>perealloc(void </em>ptr, size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>strdup(void </em>ptr);</td>\n<td style=\"text-align:center\">void <em>estrdup(void </em>ptr); void <em>pestrdup(void </em>ptr, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void free(void *ptr);</td>\n<td style=\"text-align:center\">void efree(void <em>ptr); void pefree(void </em>ptr, char persistent);</td>\n</tr>\n</tbody>\n</table>\n<p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： <figure class=\"highlight plain\"><figcaption><span>void *estrndup(void *ptr，int len);</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\">ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        char *p;</span><br><span class=\"line\"></span><br><span class=\"line\">        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\">            if (UNEXPECTED(p == NULL))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                        return p;</span><br><span class=\"line\">                            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        memcpy(p, s, length);</span><br><span class=\"line\">        p[length] = 0;</span><br><span class=\"line\">        return p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br>void <em>safe_emalloc(size_t size, size_t count, size_t addtl);<br>void </em>safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);<br>这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"php的内存管理\"><a href=\"#php的内存管理\" class=\"headerlink\" title=\"php的内存管理\"></a>php的内存管理</h2><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p>\n<blockquote>\n<p>内存泄露<br>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。<br>对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。</p>\n</blockquote>\n<h2 id=\"Zend内存管理器\"><a href=\"#Zend内存管理器\" class=\"headerlink\" title=\"Zend内存管理器\"></a>Zend内存管理器</h2><p>使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br><img src=\"/assets/blogImg/zend_manage.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br> 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br> 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">C语言原生函数</th>\n<th style=\"text-align:center\">PHP内核封装后的函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">void *malloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>emalloc(size_t count); void </em>pemalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void *calloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>ecalloc(size_t count); void </em>pecalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>realloc(void </em>ptr, size_t count);</td>\n<td style=\"text-align:center\">void <em>erealloc(void </em>ptr, size_t count); void <em>perealloc(void </em>ptr, size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>strdup(void </em>ptr);</td>\n<td style=\"text-align:center\">void <em>estrdup(void </em>ptr); void <em>pestrdup(void </em>ptr, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void free(void *ptr);</td>\n<td style=\"text-align:center\">void efree(void <em>ptr); void pefree(void </em>ptr, char persistent);</td>\n</tr>\n</tbody>\n</table>\n<p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： <figure class=\"highlight plain\"><figcaption><span>void *estrndup(void *ptr，int len);</span></figcaption><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</span><br><span class=\"line\"></span><br><span class=\"line\">```c</span><br><span class=\"line\">ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        char *p;</span><br><span class=\"line\"></span><br><span class=\"line\">        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</span><br><span class=\"line\">            if (UNEXPECTED(p == NULL))</span><br><span class=\"line\">            &#123;</span><br><span class=\"line\">                        return p;</span><br><span class=\"line\">                            </span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        memcpy(p, s, length);</span><br><span class=\"line\">        p[length] = 0;</span><br><span class=\"line\">        return p;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","more":"<p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br>void <em>safe_emalloc(size_t size, size_t count, size_t addtl);<br>void </em>safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);<br>这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p>"},{"title":"秒杀防止库存超卖的思路","date":"2019-07-25T08:09:11.000Z","_content":"","source":"_posts/秒杀防止库存超卖的思路.md","raw":"---\ntitle: 秒杀防止库存超卖的思路\ndate: 2019-07-25 16:09:11\ntags:\n---\n","slug":"秒杀防止库存超卖的思路","published":1,"updated":"2019-07-25T08:09:11.055Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sir000vth8lyabnvpej","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"计划虽然不酷，但是很有用","date":"2017-02-04T06:26:37.000Z","_content":"\n这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！\n ![\"我是傲娇的女神\"](/assets/blogImg/女神2.jpg)\n 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。\n## 目标\n 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，\n 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是\n 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。\n## 计划\n 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上\n 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！\n## 计划详情\n 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品\n## 我是傲娇的分割线O(∩_∩)O~~\n### 第一个项目\n\n<!--more-->\n#### 代号：**OnePiece**\n![\"我是伟大的OnePiece\"](/assets/blogImg/onepiece.png)\n>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。\n\n#### 项目介绍\n这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，\n前台做完之后再开始做后台功能，我要倒过来做。\n#### 可能会用到的技术\n- 语言：php+js\n- 框架：laravel+vue.js\n- 平台：移动端\n- 类型：移动端的网站\n做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。\n#### 项目时间安排\n今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）\n","source":"_posts/计划虽然不酷，但是很有用.md","raw":"---\ntitle: 计划虽然不酷，但是很有用\ndate: 2017-02-04 14:26:37\ntag: php\ncategories: 随笔\n\n---\n\n这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！\n ![\"我是傲娇的女神\"](/assets/blogImg/女神2.jpg)\n 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。\n## 目标\n 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，\n 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是\n 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。\n## 计划\n 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上\n 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！\n## 计划详情\n 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品\n## 我是傲娇的分割线O(∩_∩)O~~\n### 第一个项目\n\n<!--more-->\n#### 代号：**OnePiece**\n![\"我是伟大的OnePiece\"](/assets/blogImg/onepiece.png)\n>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。\n\n#### 项目介绍\n这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，\n前台做完之后再开始做后台功能，我要倒过来做。\n#### 可能会用到的技术\n- 语言：php+js\n- 框架：laravel+vue.js\n- 平台：移动端\n- 类型：移动端的网站\n做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。\n#### 项目时间安排\n今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）\n","slug":"计划虽然不酷，但是很有用","published":1,"updated":"2018-05-27T09:59:36.035Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sir000wth8lm3d9tnsf","content":"<p>这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！<br> <img src=\"/assets/blogImg/女神2.jpg\" alt=\"&quot;我是傲娇的女神&quot;\"><br> 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p> 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，<br> 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是<br> 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p> 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上<br> 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！</p>\n<h2 id=\"计划详情\"><a href=\"#计划详情\" class=\"headerlink\" title=\"计划详情\"></a>计划详情</h2><p> 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品</p>\n<h2 id=\"我是傲娇的分割线O-∩-∩-O\"><a href=\"#我是傲娇的分割线O-∩-∩-O\" class=\"headerlink\" title=\"我是傲娇的分割线O(∩_∩)O~~\"></a>我是傲娇的分割线O(∩_∩)O~~</h2><h3 id=\"第一个项目\"><a href=\"#第一个项目\" class=\"headerlink\" title=\"第一个项目\"></a>第一个项目</h3><a id=\"more\"></a>\n<h4 id=\"代号：OnePiece\"><a href=\"#代号：OnePiece\" class=\"headerlink\" title=\"代号：OnePiece\"></a>代号：<strong>OnePiece</strong></h4><p><img src=\"/assets/blogImg/onepiece.png\" alt=\"&quot;我是伟大的OnePiece&quot;\"></p>\n<blockquote>\n<p>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。</p>\n</blockquote>\n<h4 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h4><p>这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，<br>前台做完之后再开始做后台功能，我要倒过来做。</p>\n<h4 id=\"可能会用到的技术\"><a href=\"#可能会用到的技术\" class=\"headerlink\" title=\"可能会用到的技术\"></a>可能会用到的技术</h4><ul>\n<li>语言：php+js</li>\n<li>框架：laravel+vue.js</li>\n<li>平台：移动端</li>\n<li>类型：移动端的网站<br>做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。<h4 id=\"项目时间安排\"><a href=\"#项目时间安排\" class=\"headerlink\" title=\"项目时间安排\"></a>项目时间安排</h4>今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！<br> <img src=\"/assets/blogImg/女神2.jpg\" alt=\"&quot;我是傲娇的女神&quot;\"><br> 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p> 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，<br> 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是<br> 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p> 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上<br> 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！</p>\n<h2 id=\"计划详情\"><a href=\"#计划详情\" class=\"headerlink\" title=\"计划详情\"></a>计划详情</h2><p> 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品</p>\n<h2 id=\"我是傲娇的分割线O-∩-∩-O\"><a href=\"#我是傲娇的分割线O-∩-∩-O\" class=\"headerlink\" title=\"我是傲娇的分割线O(∩_∩)O~~\"></a>我是傲娇的分割线O(∩_∩)O~~</h2><h3 id=\"第一个项目\"><a href=\"#第一个项目\" class=\"headerlink\" title=\"第一个项目\"></a>第一个项目</h3>","more":"<h4 id=\"代号：OnePiece\"><a href=\"#代号：OnePiece\" class=\"headerlink\" title=\"代号：OnePiece\"></a>代号：<strong>OnePiece</strong></h4><p><img src=\"/assets/blogImg/onepiece.png\" alt=\"&quot;我是伟大的OnePiece&quot;\"></p>\n<blockquote>\n<p>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。</p>\n</blockquote>\n<h4 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h4><p>这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，<br>前台做完之后再开始做后台功能，我要倒过来做。</p>\n<h4 id=\"可能会用到的技术\"><a href=\"#可能会用到的技术\" class=\"headerlink\" title=\"可能会用到的技术\"></a>可能会用到的技术</h4><ul>\n<li>语言：php+js</li>\n<li>框架：laravel+vue.js</li>\n<li>平台：移动端</li>\n<li>类型：移动端的网站<br>做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。<h4 id=\"项目时间安排\"><a href=\"#项目时间安排\" class=\"headerlink\" title=\"项目时间安排\"></a>项目时间安排</h4>今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）</li>\n</ul>"},{"title":"记一次mysql容器的异常退出","date":"2019-12-17T07:07:47.000Z","_content":"刚刚利用docker-compose部署时mysql一直异常退出，之前mysql都是好的，知道我再docker里面添加了supervisor开启了队列以后，本来以为和队列有关，直到在登录阿里云的远程连接时发现了错误语句。\nout of memory kill process,觉得是内存的原因，然后用free -m这个命令看了下系统的内存，才发现原来是内存不足，后面给阿里云升级了内存配置，mysql就能正常启动了。\n>> OOM Killer，一个保护机制，用于避免在内存不足的时候不至于出现严重问题，把一些无关的进程优先杀掉，即在内存严重不足时，系统为了继续运转，内核会挑选一个进程，将其杀掉，以释放内存，缓解内存不足情况，不过这种保护是有限的，不能完全的保护进程的运行\n","source":"_posts/记一次mysql容器的异常退出.md","raw":"---\ntitle: 记一次mysql容器的异常退出\ndate: 2019-12-17 15:07:47\ntags: 技术\n---\n刚刚利用docker-compose部署时mysql一直异常退出，之前mysql都是好的，知道我再docker里面添加了supervisor开启了队列以后，本来以为和队列有关，直到在登录阿里云的远程连接时发现了错误语句。\nout of memory kill process,觉得是内存的原因，然后用free -m这个命令看了下系统的内存，才发现原来是内存不足，后面给阿里云升级了内存配置，mysql就能正常启动了。\n>> OOM Killer，一个保护机制，用于避免在内存不足的时候不至于出现严重问题，把一些无关的进程优先杀掉，即在内存严重不足时，系统为了继续运转，内核会挑选一个进程，将其杀掉，以释放内存，缓解内存不足情况，不过这种保护是有限的，不能完全的保护进程的运行\n","slug":"记一次mysql容器的异常退出","published":1,"updated":"2019-12-17T07:19:26.398Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sis000xth8lg9ti8nui","content":"<p>刚刚利用docker-compose部署时mysql一直异常退出，之前mysql都是好的，知道我再docker里面添加了supervisor开启了队列以后，本来以为和队列有关，直到在登录阿里云的远程连接时发现了错误语句。<br>out of memory kill process,觉得是内存的原因，然后用free -m这个命令看了下系统的内存，才发现原来是内存不足，后面给阿里云升级了内存配置，mysql就能正常启动了。</p>\n<blockquote>\n<blockquote>\n<p>OOM Killer，一个保护机制，用于避免在内存不足的时候不至于出现严重问题，把一些无关的进程优先杀掉，即在内存严重不足时，系统为了继续运转，内核会挑选一个进程，将其杀掉，以释放内存，缓解内存不足情况，不过这种保护是有限的，不能完全的保护进程的运行</p>\n</blockquote>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>刚刚利用docker-compose部署时mysql一直异常退出，之前mysql都是好的，知道我再docker里面添加了supervisor开启了队列以后，本来以为和队列有关，直到在登录阿里云的远程连接时发现了错误语句。<br>out of memory kill process,觉得是内存的原因，然后用free -m这个命令看了下系统的内存，才发现原来是内存不足，后面给阿里云升级了内存配置，mysql就能正常启动了。</p>\n<blockquote>\n<blockquote>\n<p>OOM Killer，一个保护机制，用于避免在内存不足的时候不至于出现严重问题，把一些无关的进程优先杀掉，即在内存严重不足时，系统为了继续运转，内核会挑选一个进程，将其杀掉，以释放内存，缓解内存不足情况，不过这种保护是有限的，不能完全的保护进程的运行</p>\n</blockquote>\n</blockquote>\n"},{"title":"记一次阿里云ssh登录不上的bug","date":"2019-12-11T07:00:54.000Z","_content":"刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。\n#问题描述#\n ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/systemd/generator/-.mount, as it already exists.Duplicate entry in /etc/fstab?\n #原因#\n 系统盘才是挂载到根的。您数据盘也挂载到根。就有问题。我帮您注释了\n ```\n /dev/vdb/ ext3 defaults 0 0\n ```\n","source":"_posts/记一次阿里云ssh登录不上的bug.md","raw":"---\ntitle: 记一次阿里云ssh登录不上的bug\ndate: 2019-12-11 15:00:54\ntags: 技术\n---\n刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。\n#问题描述#\n ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/systemd/generator/-.mount, as it already exists.Duplicate entry in /etc/fstab?\n #原因#\n 系统盘才是挂载到根的。您数据盘也挂载到根。就有问题。我帮您注释了\n ```\n /dev/vdb/ ext3 defaults 0 0\n ```\n","slug":"记一次阿里云ssh登录不上的bug","published":1,"updated":"2019-12-11T07:06:18.818Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sit000yth8llenny9hb","content":"<p>刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。</p>\n<p>#问题描述#<br> ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/systemd/generator/-.mount, as it already exists.Duplicate entry in /etc/fstab?</p>\n<p> #原因#<br> 系统盘才是挂载到根的。您数据盘也挂载到根。就有问题。我帮您注释了<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/dev/vdb/ ext3 defaults 0 0</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"","more":"<p>刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。</p>\n<p>#问题描述#<br> ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/systemd/generator/-.mount, as it already exists.Duplicate entry in /etc/fstab?</p>\n<p> #原因#<br> 系统盘才是挂载到根的。您数据盘也挂载到根。就有问题。我帮您注释了<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/dev/vdb/ ext3 defaults 0 0</span><br></pre></td></tr></table></figure></p>\n"},{"title":"谈谈mysql的四种事务隔离级别","date":"2019-10-17T12:28:07.000Z","_content":"这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。\n## 事务的并发问题\n事务为什么需要隔离级别，这是因为事务有这几个问题。\n1脏读:事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据是脏数据\n2不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致\n3幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入一条具体分数的记录，当系统管理员A结束后发现还有一条记录没改正，就好像发生幻觉一样。\n> 不可重复读侧重于修改，幻读侧重于新增火删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。\n## Mysql事务隔离级别\n\n|事务隔离级别 |\t脏读  |\t不可重复读|\t幻读  |\n| ----------- |:-----:|:---------:|:-----:|\n|读未提交（read-uncommitted）|\t是|\t是|\t是|\n|不可重复读（read-committed）|\t否|\t是|\t是|\n|可重复读（repeatable-read） |\t否|\t否|\t是|\n|串行化（serializable）\t     |  否|\t否|\t否|\n\n> mysql默认的事务隔离级别为repeatable-read\n## 用例子说明各个隔离级别的情况\n### 读未提交\n\n``` mysql \n客户端A\n\nmysql> set session transaction isolation level read uncommitted; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n2在客户端A的事务提交之前，打开另一个客户端B，更新表account；\n``` mysql \n客户端B\nmysql> set session transaction isolation level read uncommitted;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> update account set  balance=balance-50 where id = 1; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：\n\n``` mysql \n客户端A\n\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n4一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据\n``` mysql \n客户端B\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> rollback; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别\n客户端A\n``` mysql \nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> update account set  balance=balance-50 where id = 1; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n\n## 读已提交\n\n``` mysql \n客户端A\n\nmysql> set session transaction isolation level read uncommitted; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：\n\n","source":"_posts/谈谈mysql的四种事务隔离级别.md","raw":"---\ntitle: 谈谈mysql的四种事务隔离级别\ndate: 2019-10-17 20:28:07\ntags: 技术\n---\n这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。\n## 事务的并发问题\n事务为什么需要隔离级别，这是因为事务有这几个问题。\n1脏读:事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据是脏数据\n2不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致\n3幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入一条具体分数的记录，当系统管理员A结束后发现还有一条记录没改正，就好像发生幻觉一样。\n> 不可重复读侧重于修改，幻读侧重于新增火删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。\n## Mysql事务隔离级别\n\n|事务隔离级别 |\t脏读  |\t不可重复读|\t幻读  |\n| ----------- |:-----:|:---------:|:-----:|\n|读未提交（read-uncommitted）|\t是|\t是|\t是|\n|不可重复读（read-committed）|\t否|\t是|\t是|\n|可重复读（repeatable-read） |\t否|\t否|\t是|\n|串行化（serializable）\t     |  否|\t否|\t否|\n\n> mysql默认的事务隔离级别为repeatable-read\n## 用例子说明各个隔离级别的情况\n### 读未提交\n\n``` mysql \n客户端A\n\nmysql> set session transaction isolation level read uncommitted; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n2在客户端A的事务提交之前，打开另一个客户端B，更新表account；\n``` mysql \n客户端B\nmysql> set session transaction isolation level read uncommitted;\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> update account set  balance=balance-50 where id = 1; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：\n\n``` mysql \n客户端A\n\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n4一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据\n``` mysql \n客户端B\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> rollback; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别\n客户端A\n``` mysql \nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> update account set  balance=balance-50 where id = 1; \nQuery OK, 0 rows affected (0.00 sec)\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 400     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n\n## 读已提交\n\n``` mysql \n客户端A\n\nmysql> set session transaction isolation level read uncommitted; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> start transaction; \nQuery OK, 0 rows affected (0.00 sec)\n\nmysql> select * from account; \n+------+------+---------+\n| id   | name | balance |\n+------+------+---------+\n| 1   | lilei | 450     |\n| 2   | hanmei| 16000   |\n| 3   | lucy  | 2400    |\n+------+------+---------+\n3 rows in set (0.00 sec)\n```\n2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：\n\n","slug":"谈谈mysql的四种事务隔离级别","published":1,"updated":"2019-10-19T16:07:01.859Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sit000zth8loo18tuxu","content":"<p>这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。</p>\n<h2 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h2><p>事务为什么需要隔离级别，这是因为事务有这几个问题。<br>1脏读:事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据是脏数据<br>2不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致<br>3幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入一条具体分数的记录，当系统管理员A结束后发现还有一条记录没改正，就好像发生幻觉一样。</p>\n<blockquote>\n<p>不可重复读侧重于修改，幻读侧重于新增火删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。</p>\n</blockquote>\n<h2 id=\"Mysql事务隔离级别\"><a href=\"#Mysql事务隔离级别\" class=\"headerlink\" title=\"Mysql事务隔离级别\"></a>Mysql事务隔离级别</h2><table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读未提交（read-uncommitted）</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>mysql默认的事务隔离级别为repeatable-read</p>\n</blockquote>\n<h2 id=\"用例子说明各个隔离级别的情况\"><a href=\"#用例子说明各个隔离级别的情况\" class=\"headerlink\" title=\"用例子说明各个隔离级别的情况\"></a>用例子说明各个隔离级别的情况</h2><h3 id=\"读未提交\"><a href=\"#读未提交\" class=\"headerlink\" title=\"读未提交\"></a>读未提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>2在客户端A的事务提交之前，打开另一个客户端B，更新表account；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端B</span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br><span class=\"line\">4一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据</span><br><span class=\"line\">``` mysql </span><br><span class=\"line\">客户端B</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; rollback; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别<br>客户端A<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"读已提交\"><a href=\"#读已提交\" class=\"headerlink\" title=\"读已提交\"></a>读已提交</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。</p>\n<h2 id=\"事务的并发问题\"><a href=\"#事务的并发问题\" class=\"headerlink\" title=\"事务的并发问题\"></a>事务的并发问题</h2><p>事务为什么需要隔离级别，这是因为事务有这几个问题。<br>1脏读:事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据是脏数据<br>2不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致<br>3幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入一条具体分数的记录，当系统管理员A结束后发现还有一条记录没改正，就好像发生幻觉一样。</p>\n<blockquote>\n<p>不可重复读侧重于修改，幻读侧重于新增火删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。</p>\n</blockquote>\n<h2 id=\"Mysql事务隔离级别\"><a href=\"#Mysql事务隔离级别\" class=\"headerlink\" title=\"Mysql事务隔离级别\"></a>Mysql事务隔离级别</h2><table>\n<thead>\n<tr>\n<th>事务隔离级别</th>\n<th style=\"text-align:center\">脏读</th>\n<th style=\"text-align:center\">不可重复读</th>\n<th style=\"text-align:center\">幻读</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>读未提交（read-uncommitted）</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>不可重复读（read-committed）</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>可重复读（repeatable-read）</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">是</td>\n</tr>\n<tr>\n<td>串行化（serializable）</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n<td style=\"text-align:center\">否</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>mysql默认的事务隔离级别为repeatable-read</p>\n</blockquote>\n<h2 id=\"用例子说明各个隔离级别的情况\"><a href=\"#用例子说明各个隔离级别的情况\" class=\"headerlink\" title=\"用例子说明各个隔离级别的情况\"></a>用例子说明各个隔离级别的情况</h2><h3 id=\"读未提交\"><a href=\"#读未提交\" class=\"headerlink\" title=\"读未提交\"></a>读未提交</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>2在客户端A的事务提交之前，打开另一个客户端B，更新表account；<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端B</span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<p>3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br><span class=\"line\">4一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据</span><br><span class=\"line\">``` mysql </span><br><span class=\"line\">客户端B</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; rollback; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别<br>客户端A<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 400     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"读已提交\"><a href=\"#读已提交\" class=\"headerlink\" title=\"读已提交\"></a>读已提交</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">客户端A</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; start transaction; </span><br><span class=\"line\">Query OK, 0 rows affected (0.00 sec)</span><br><span class=\"line\"></span><br><span class=\"line\">mysql&gt; select * from account; </span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| id   | name | balance |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">| 1   | lilei | 450     |</span><br><span class=\"line\">| 2   | hanmei| 16000   |</span><br><span class=\"line\">| 3   | lucy  | 2400    |</span><br><span class=\"line\">+------+------+---------+</span><br><span class=\"line\">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure>\n<p>2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>\n"},{"title":"集中式日志管理elk搭建","date":"2018-02-10T05:56:26.000Z","_content":"前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。\n> elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本\n- Elasticsearch 高可用性，实时索引，拓展简单，接口友好\n- Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表\n- Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据\n- Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据\n- X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索\n\n## elk的初始化\n其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的[docker-elk](https://github.com/deviantony/docker-elk)\n使用git clone git@github.com:deviantony/docker-elk.git后执行docker-compose up,然后我们访问http://localhost:5601,以下是它的端口\n- 5000: Logstash TCP input.\n- 9200: Elasticsearch HTTP\n- 9300: Elasticsearch TCP transport\n- 5601: Kibana\n<!--more-->\n## elk 配置\n我们先配置'elk/logstash/pipeline/logstash.conf'\n```\ninput {\n        beats { #通过这个端口接收filebeat组件发送过来的日志\n                port => 5043\n        }\n}\n## Add your filters / logstash plugins configuration here\nfilter {\n        grok { # 正则形式将无序的日志整理成有序的结构形式\n                match => { \"message\" => \"%{GREEDYDATA:health_Timestamp}\\[%{IPV4:health_IPaddress}\\]\\[-\\]\\[-\\]\\[%{LOGLEVEL:health_LogLevel}\\]\\[%{NOTSPACE:health_Category}\\]%{GREEDYDATA:health_Text}\" } \n        }    \n        geoip { #通过这个可以将ip和地理位置相关联\n                source => \"clientip\"\n        }\n}\noutput { #将日志信息交给elasticsearch处理\n        elasticsearch {\n                hosts => \"elasticsearch:9200\"\n        }\n}\n```\n## filebeat配置\n然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口\n- 现在docker-compose.yml添加filebeat组件\n```\nfilebeat:\n        image: docker.elastic.co/beats/filebeat:6.0.0\n        hostname: filebeat\n        container_name: filebeat\n        restart: always\n        volumes:\n        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml\n        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json\n        - ./api/runtime/logs:/var/logs\n        - ./api/runtime/debug:/var/debug\n        depends_on:\n        - web\n```\n- 接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml\n```\nfilebeat.prospectors:\n- type: log\n  paths:\n      - \"/var/logs/*.log\"\n     #- \"/var/debug/*.data\"\nregistry_file: /etc/registry/mark\n#============================= 将以时间的日志归并为一行 ===============================\n  multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'\n  multiline.negate: true\n  multiline.match: after\n  multiline.timeout: 10s\nenable: true\n#============================= Filebeat modules ===============================\n#\nfilebeat.config.modules:\n# Glob pattern for configuration loading\n  path: /usr/share/filebeat/modules.d/*.yml\n#\n# Set to true to enable config reloading\nreload.enabled: true\n\noutput:\nlogstash:\nhosts: [\"刚刚配置的elk的ip地址:5043\"]\n\nlogging:\nfiles:\nrotateeverybytes: 10485760 # = 10MB\n```\n\n 参考文章:\n-------------------\n[官网](https://www.elastic.co/cn/products)\n[使用Docker搭建ELK日志系统](http://blog.csdn.net/sysushui/article/details/78461498)\n[ELK---合并多行日志（php.log）](https://www.jianshu.com/p/a980cd121212)\n[docker容器日志集中ELK](https://jicki.me/2016/10/11/docker-elk-filebeat/)\n[filebeat+logstash配置搭建](https://my.oschina.net/openplus/blog/1584861)\n[关于Logstash中grok插件的正则表达式例子](https://www.cnblogs.com/stozen/p/5638369.html)\n[使用Logstash收集PHP相关日志-Linux SA John-51CTO博客](http://blog.51cto.com/john88wang/1641723)\n[Logstash整合Kafka](https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/)\n","source":"_posts/集中式日志管理elk搭建.md","raw":"---\ntitle: 集中式日志管理elk搭建\ndate: 2018-02-10 13:56:26\ntags: linux基础 \ncategories: 技术\n---\n前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。\n> elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本\n- Elasticsearch 高可用性，实时索引，拓展简单，接口友好\n- Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表\n- Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据\n- Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据\n- X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索\n\n## elk的初始化\n其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的[docker-elk](https://github.com/deviantony/docker-elk)\n使用git clone git@github.com:deviantony/docker-elk.git后执行docker-compose up,然后我们访问http://localhost:5601,以下是它的端口\n- 5000: Logstash TCP input.\n- 9200: Elasticsearch HTTP\n- 9300: Elasticsearch TCP transport\n- 5601: Kibana\n<!--more-->\n## elk 配置\n我们先配置'elk/logstash/pipeline/logstash.conf'\n```\ninput {\n        beats { #通过这个端口接收filebeat组件发送过来的日志\n                port => 5043\n        }\n}\n## Add your filters / logstash plugins configuration here\nfilter {\n        grok { # 正则形式将无序的日志整理成有序的结构形式\n                match => { \"message\" => \"%{GREEDYDATA:health_Timestamp}\\[%{IPV4:health_IPaddress}\\]\\[-\\]\\[-\\]\\[%{LOGLEVEL:health_LogLevel}\\]\\[%{NOTSPACE:health_Category}\\]%{GREEDYDATA:health_Text}\" } \n        }    \n        geoip { #通过这个可以将ip和地理位置相关联\n                source => \"clientip\"\n        }\n}\noutput { #将日志信息交给elasticsearch处理\n        elasticsearch {\n                hosts => \"elasticsearch:9200\"\n        }\n}\n```\n## filebeat配置\n然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口\n- 现在docker-compose.yml添加filebeat组件\n```\nfilebeat:\n        image: docker.elastic.co/beats/filebeat:6.0.0\n        hostname: filebeat\n        container_name: filebeat\n        restart: always\n        volumes:\n        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml\n        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json\n        - ./api/runtime/logs:/var/logs\n        - ./api/runtime/debug:/var/debug\n        depends_on:\n        - web\n```\n- 接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml\n```\nfilebeat.prospectors:\n- type: log\n  paths:\n      - \"/var/logs/*.log\"\n     #- \"/var/debug/*.data\"\nregistry_file: /etc/registry/mark\n#============================= 将以时间的日志归并为一行 ===============================\n  multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'\n  multiline.negate: true\n  multiline.match: after\n  multiline.timeout: 10s\nenable: true\n#============================= Filebeat modules ===============================\n#\nfilebeat.config.modules:\n# Glob pattern for configuration loading\n  path: /usr/share/filebeat/modules.d/*.yml\n#\n# Set to true to enable config reloading\nreload.enabled: true\n\noutput:\nlogstash:\nhosts: [\"刚刚配置的elk的ip地址:5043\"]\n\nlogging:\nfiles:\nrotateeverybytes: 10485760 # = 10MB\n```\n\n 参考文章:\n-------------------\n[官网](https://www.elastic.co/cn/products)\n[使用Docker搭建ELK日志系统](http://blog.csdn.net/sysushui/article/details/78461498)\n[ELK---合并多行日志（php.log）](https://www.jianshu.com/p/a980cd121212)\n[docker容器日志集中ELK](https://jicki.me/2016/10/11/docker-elk-filebeat/)\n[filebeat+logstash配置搭建](https://my.oschina.net/openplus/blog/1584861)\n[关于Logstash中grok插件的正则表达式例子](https://www.cnblogs.com/stozen/p/5638369.html)\n[使用Logstash收集PHP相关日志-Linux SA John-51CTO博客](http://blog.51cto.com/john88wang/1641723)\n[Logstash整合Kafka](https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/)\n","slug":"集中式日志管理elk搭建","published":1,"updated":"2018-05-27T09:59:36.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00siu0010th8lpg1mbu73","content":"<p>前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。</p>\n<blockquote>\n<p>elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本</p>\n<ul>\n<li>Elasticsearch 高可用性，实时索引，拓展简单，接口友好</li>\n<li>Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表</li>\n<li>Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据</li>\n<li>Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据</li>\n<li>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索</li>\n</ul>\n</blockquote>\n<h2 id=\"elk的初始化\"><a href=\"#elk的初始化\" class=\"headerlink\" title=\"elk的初始化\"></a>elk的初始化</h2><p>其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的<a href=\"https://github.com/deviantony/docker-elk\" target=\"_blank\" rel=\"noopener\">docker-elk</a><br>使用git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:deviantony/docker-elk.git后执行docker-compose up,然后我们访问<a href=\"http://localhost:5601,以下是它的端口\" target=\"_blank\" rel=\"noopener\">http://localhost:5601,以下是它的端口</a></p>\n<ul>\n<li>5000: Logstash TCP input.</li>\n<li>9200: Elasticsearch HTTP</li>\n<li>9300: Elasticsearch TCP transport</li>\n<li>5601: Kibana<a id=\"more\"></a>\n<h2 id=\"elk-配置\"><a href=\"#elk-配置\" class=\"headerlink\" title=\"elk 配置\"></a>elk 配置</h2>我们先配置’elk/logstash/pipeline/logstash.conf’<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">        beats &#123; #通过这个端口接收filebeat组件发送过来的日志</span><br><span class=\"line\">                port =&gt; 5043</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">## Add your filters / logstash plugins configuration here</span><br><span class=\"line\">filter &#123;</span><br><span class=\"line\">        grok &#123; # 正则形式将无序的日志整理成有序的结构形式</span><br><span class=\"line\">                match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;GREEDYDATA:health_Timestamp&#125;\\[%&#123;IPV4:health_IPaddress&#125;\\]\\[-\\]\\[-\\]\\[%&#123;LOGLEVEL:health_LogLevel&#125;\\]\\[%&#123;NOTSPACE:health_Category&#125;\\]%&#123;GREEDYDATA:health_Text&#125;&quot; &#125; </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        geoip &#123; #通过这个可以将ip和地理位置相关联</span><br><span class=\"line\">                source =&gt; &quot;clientip&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output &#123; #将日志信息交给elasticsearch处理</span><br><span class=\"line\">        elasticsearch &#123;</span><br><span class=\"line\">                hosts =&gt; &quot;elasticsearch:9200&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"filebeat配置\"><a href=\"#filebeat配置\" class=\"headerlink\" title=\"filebeat配置\"></a>filebeat配置</h2><p>然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口</p>\n<ul>\n<li><p>现在docker-compose.yml添加filebeat组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filebeat:</span><br><span class=\"line\">        image: docker.elastic.co/beats/filebeat:6.0.0</span><br><span class=\"line\">        hostname: filebeat</span><br><span class=\"line\">        container_name: filebeat</span><br><span class=\"line\">        restart: always</span><br><span class=\"line\">        volumes:</span><br><span class=\"line\">        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml</span><br><span class=\"line\">        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json</span><br><span class=\"line\">        - ./api/runtime/logs:/var/logs</span><br><span class=\"line\">        - ./api/runtime/debug:/var/debug</span><br><span class=\"line\">        depends_on:</span><br><span class=\"line\">        - web</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filebeat.prospectors:</span><br><span class=\"line\">- type: log</span><br><span class=\"line\">  paths:</span><br><span class=\"line\">      - &quot;/var/logs/*.log&quot;</span><br><span class=\"line\">     #- &quot;/var/debug/*.data&quot;</span><br><span class=\"line\">registry_file: /etc/registry/mark</span><br><span class=\"line\">#============================= 将以时间的日志归并为一行 ===============================</span><br><span class=\"line\">  multiline.pattern: &apos;^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&apos;</span><br><span class=\"line\">  multiline.negate: true</span><br><span class=\"line\">  multiline.match: after</span><br><span class=\"line\">  multiline.timeout: 10s</span><br><span class=\"line\">enable: true</span><br><span class=\"line\">#============================= Filebeat modules ===============================</span><br><span class=\"line\">#</span><br><span class=\"line\">filebeat.config.modules:</span><br><span class=\"line\"># Glob pattern for configuration loading</span><br><span class=\"line\">  path: /usr/share/filebeat/modules.d/*.yml</span><br><span class=\"line\">#</span><br><span class=\"line\"># Set to true to enable config reloading</span><br><span class=\"line\">reload.enabled: true</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">logstash:</span><br><span class=\"line\">hosts: [&quot;刚刚配置的elk的ip地址:5043&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">logging:</span><br><span class=\"line\">files:</span><br><span class=\"line\">rotateeverybytes: 10485760 # = 10MB</span><br></pre></td></tr></table></figure>\n<p>参考文章:</p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://www.elastic.co/cn/products\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"http://blog.csdn.net/sysushui/article/details/78461498\" target=\"_blank\" rel=\"noopener\">使用Docker搭建ELK日志系统</a><br><a href=\"https://www.jianshu.com/p/a980cd121212\" target=\"_blank\" rel=\"noopener\">ELK—合并多行日志（php.log）</a><br><a href=\"https://jicki.me/2016/10/11/docker-elk-filebeat/\" target=\"_blank\" rel=\"noopener\">docker容器日志集中ELK</a><br><a href=\"https://my.oschina.net/openplus/blog/1584861\" target=\"_blank\" rel=\"noopener\">filebeat+logstash配置搭建</a><br><a href=\"https://www.cnblogs.com/stozen/p/5638369.html\" target=\"_blank\" rel=\"noopener\">关于Logstash中grok插件的正则表达式例子</a><br><a href=\"http://blog.51cto.com/john88wang/1641723\" target=\"_blank\" rel=\"noopener\">使用Logstash收集PHP相关日志-Linux SA John-51CTO博客</a><br><a href=\"https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/\" target=\"_blank\" rel=\"noopener\">Logstash整合Kafka</a></p>\n","site":{"data":{}},"excerpt":"<p>前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。</p>\n<blockquote>\n<p>elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本</p>\n<ul>\n<li>Elasticsearch 高可用性，实时索引，拓展简单，接口友好</li>\n<li>Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表</li>\n<li>Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据</li>\n<li>Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据</li>\n<li>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索</li>\n</ul>\n</blockquote>\n<h2 id=\"elk的初始化\"><a href=\"#elk的初始化\" class=\"headerlink\" title=\"elk的初始化\"></a>elk的初始化</h2><p>其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的<a href=\"https://github.com/deviantony/docker-elk\" target=\"_blank\" rel=\"noopener\">docker-elk</a><br>使用git clone <a href=\"mailto:git@github.com\" target=\"_blank\" rel=\"noopener\">git@github.com</a>:deviantony/docker-elk.git后执行docker-compose up,然后我们访问<a href=\"http://localhost:5601,以下是它的端口\" target=\"_blank\" rel=\"noopener\">http://localhost:5601,以下是它的端口</a></p>\n<ul>\n<li>5000: Logstash TCP input.</li>\n<li>9200: Elasticsearch HTTP</li>\n<li>9300: Elasticsearch TCP transport</li>\n<li>5601: Kibana","more":"<h2 id=\"elk-配置\"><a href=\"#elk-配置\" class=\"headerlink\" title=\"elk 配置\"></a>elk 配置</h2>我们先配置’elk/logstash/pipeline/logstash.conf’<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">input &#123;</span><br><span class=\"line\">        beats &#123; #通过这个端口接收filebeat组件发送过来的日志</span><br><span class=\"line\">                port =&gt; 5043</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">## Add your filters / logstash plugins configuration here</span><br><span class=\"line\">filter &#123;</span><br><span class=\"line\">        grok &#123; # 正则形式将无序的日志整理成有序的结构形式</span><br><span class=\"line\">                match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;GREEDYDATA:health_Timestamp&#125;\\[%&#123;IPV4:health_IPaddress&#125;\\]\\[-\\]\\[-\\]\\[%&#123;LOGLEVEL:health_LogLevel&#125;\\]\\[%&#123;NOTSPACE:health_Category&#125;\\]%&#123;GREEDYDATA:health_Text&#125;&quot; &#125; </span><br><span class=\"line\">        &#125;    </span><br><span class=\"line\">        geoip &#123; #通过这个可以将ip和地理位置相关联</span><br><span class=\"line\">                source =&gt; &quot;clientip&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">output &#123; #将日志信息交给elasticsearch处理</span><br><span class=\"line\">        elasticsearch &#123;</span><br><span class=\"line\">                hosts =&gt; &quot;elasticsearch:9200&quot;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"filebeat配置\"><a href=\"#filebeat配置\" class=\"headerlink\" title=\"filebeat配置\"></a>filebeat配置</h2><p>然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口</p>\n<ul>\n<li><p>现在docker-compose.yml添加filebeat组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filebeat:</span><br><span class=\"line\">        image: docker.elastic.co/beats/filebeat:6.0.0</span><br><span class=\"line\">        hostname: filebeat</span><br><span class=\"line\">        container_name: filebeat</span><br><span class=\"line\">        restart: always</span><br><span class=\"line\">        volumes:</span><br><span class=\"line\">        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml</span><br><span class=\"line\">        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json</span><br><span class=\"line\">        - ./api/runtime/logs:/var/logs</span><br><span class=\"line\">        - ./api/runtime/debug:/var/debug</span><br><span class=\"line\">        depends_on:</span><br><span class=\"line\">        - web</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">filebeat.prospectors:</span><br><span class=\"line\">- type: log</span><br><span class=\"line\">  paths:</span><br><span class=\"line\">      - &quot;/var/logs/*.log&quot;</span><br><span class=\"line\">     #- &quot;/var/debug/*.data&quot;</span><br><span class=\"line\">registry_file: /etc/registry/mark</span><br><span class=\"line\">#============================= 将以时间的日志归并为一行 ===============================</span><br><span class=\"line\">  multiline.pattern: &apos;^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&apos;</span><br><span class=\"line\">  multiline.negate: true</span><br><span class=\"line\">  multiline.match: after</span><br><span class=\"line\">  multiline.timeout: 10s</span><br><span class=\"line\">enable: true</span><br><span class=\"line\">#============================= Filebeat modules ===============================</span><br><span class=\"line\">#</span><br><span class=\"line\">filebeat.config.modules:</span><br><span class=\"line\"># Glob pattern for configuration loading</span><br><span class=\"line\">  path: /usr/share/filebeat/modules.d/*.yml</span><br><span class=\"line\">#</span><br><span class=\"line\"># Set to true to enable config reloading</span><br><span class=\"line\">reload.enabled: true</span><br><span class=\"line\"></span><br><span class=\"line\">output:</span><br><span class=\"line\">logstash:</span><br><span class=\"line\">hosts: [&quot;刚刚配置的elk的ip地址:5043&quot;]</span><br><span class=\"line\"></span><br><span class=\"line\">logging:</span><br><span class=\"line\">files:</span><br><span class=\"line\">rotateeverybytes: 10485760 # = 10MB</span><br></pre></td></tr></table></figure>\n<p>参考文章:</p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://www.elastic.co/cn/products\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"http://blog.csdn.net/sysushui/article/details/78461498\" target=\"_blank\" rel=\"noopener\">使用Docker搭建ELK日志系统</a><br><a href=\"https://www.jianshu.com/p/a980cd121212\" target=\"_blank\" rel=\"noopener\">ELK—合并多行日志（php.log）</a><br><a href=\"https://jicki.me/2016/10/11/docker-elk-filebeat/\" target=\"_blank\" rel=\"noopener\">docker容器日志集中ELK</a><br><a href=\"https://my.oschina.net/openplus/blog/1584861\" target=\"_blank\" rel=\"noopener\">filebeat+logstash配置搭建</a><br><a href=\"https://www.cnblogs.com/stozen/p/5638369.html\" target=\"_blank\" rel=\"noopener\">关于Logstash中grok插件的正则表达式例子</a><br><a href=\"http://blog.51cto.com/john88wang/1641723\" target=\"_blank\" rel=\"noopener\">使用Logstash收集PHP相关日志-Linux SA John-51CTO博客</a><br><a href=\"https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/\" target=\"_blank\" rel=\"noopener\">Logstash整合Kafka</a></p>"},{"title":"记录一次阿里云上docker启动不了的bug","date":"2019-10-09T05:25:06.000Z","_content":"# 最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\n``` shell\nsystemctl status docker.service\n● docker.service - Docker Application Container Engine\n   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)\n   Active: failed (Result: start-limit) since 六 2019-09-28 12:05:46 CST; 5min ago\n     Docs: https://docs.docker.com\n  Process: 1250 ExecStart=/usr/bin/dockerd --registry-mirror=39.98.73.138 --registry-mirror=<your accelerate address> --registry-mirror=<your accelerate address> --registry-mirror=<your accelerate address> -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)\n Main PID: 1250 (code=exited, status=1/FAILURE)\n\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service holdoff time over, scheduling restart.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopped Docker Application Container Engine.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.\n[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# journalctl -xe\n--\n-- Unit docker.socket has finished shutting down.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopping Docker Socket for the API.\n-- Subject: Unit docker.socket has begun shutting down\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.socket has begun shutting down.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Starting Docker Socket for the API.\n-- Subject: Unit docker.socket has begun start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.socket has begun starting up.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Listening on Docker Socket for the API.\n-- Subject: Unit docker.socket has finished start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.socket has finished starting up.\n--\n-- The start-up result is done.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.\n-- Subject: Unit docker.service has failed\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.service has failed.\n--\n-- The result is failed.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.\n9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 6 of user root.\n-- Subject: Unit session-6.scope has finished start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit session-6.scope has finished starting up.\n--\n-- The start-up result is done.\n9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1271]: (root) CMD (/usr/lib64/sa/sa1 1 1)\n9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 7 of user root.\n-- Subject: Unit session-7.scope has finished start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit session-7.scope has finished starting up.\n--\n-- The start-up result is done.\n9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1277]: (root) CMD (/usr/lib64/sa/sa1 1 1)\nlines 2500-2550/2550 (END)  \n```\n# 解决的步骤:\n1）清除/etc/systemd/system/目录下的 docker.service.requires这个目录的生成是安装别的系统Kubernete时生成的依赖信息。\n个人总结：对这类问题清除/etc/systemd/system目录下不用的目录和文件是首选\n2）执行systemctl daemon-reload或重启系统\n\n\n## 参考资料\n\n+ [启动DOCKER时，遇到一个很奇葩的问题？](http://www.talkwithtrend.com/Question/415283?order=desc)\n","source":"_posts/记录一次阿里云上docker启动不了的bug.md","raw":"---\ntitle: 记录一次阿里云上docker启动不了的bug\ndate: 2019-10-09 13:25:06\ntags: docker\n---\n# 最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\n``` shell\nsystemctl status docker.service\n● docker.service - Docker Application Container Engine\n   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)\n   Active: failed (Result: start-limit) since 六 2019-09-28 12:05:46 CST; 5min ago\n     Docs: https://docs.docker.com\n  Process: 1250 ExecStart=/usr/bin/dockerd --registry-mirror=39.98.73.138 --registry-mirror=<your accelerate address> --registry-mirror=<your accelerate address> --registry-mirror=<your accelerate address> -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)\n Main PID: 1250 (code=exited, status=1/FAILURE)\n\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.\n9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service holdoff time over, scheduling restart.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopped Docker Application Container Engine.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.\n[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# journalctl -xe\n--\n-- Unit docker.socket has finished shutting down.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopping Docker Socket for the API.\n-- Subject: Unit docker.socket has begun shutting down\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.socket has begun shutting down.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Starting Docker Socket for the API.\n-- Subject: Unit docker.socket has begun start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.socket has begun starting up.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Listening on Docker Socket for the API.\n-- Subject: Unit docker.socket has finished start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.socket has finished starting up.\n--\n-- The start-up result is done.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.\n-- Subject: Unit docker.service has failed\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit docker.service has failed.\n--\n-- The result is failed.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.\n9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.\n9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 6 of user root.\n-- Subject: Unit session-6.scope has finished start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit session-6.scope has finished starting up.\n--\n-- The start-up result is done.\n9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1271]: (root) CMD (/usr/lib64/sa/sa1 1 1)\n9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 7 of user root.\n-- Subject: Unit session-7.scope has finished start-up\n-- Defined-By: systemd\n-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel\n--\n-- Unit session-7.scope has finished starting up.\n--\n-- The start-up result is done.\n9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1277]: (root) CMD (/usr/lib64/sa/sa1 1 1)\nlines 2500-2550/2550 (END)  \n```\n# 解决的步骤:\n1）清除/etc/systemd/system/目录下的 docker.service.requires这个目录的生成是安装别的系统Kubernete时生成的依赖信息。\n个人总结：对这类问题清除/etc/systemd/system目录下不用的目录和文件是首选\n2）执行systemctl daemon-reload或重启系统\n\n\n## 参考资料\n\n+ [启动DOCKER时，遇到一个很奇葩的问题？](http://www.talkwithtrend.com/Question/415283?order=desc)\n","slug":"记录一次阿里云上docker启动不了的bug","published":1,"updated":"2019-10-09T05:34:15.872Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00siv0011th8lxi2t4sd3","content":"<h1 id=\"最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\"><a href=\"#最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\" class=\"headerlink\" title=\"最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\"></a>最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker.service</span><br><span class=\"line\">● docker.service - Docker Application Container Engine</span><br><span class=\"line\">   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class=\"line\">   Active: failed (Result: start-limit) since 六 2019-09-28 12:05:46 CST; 5min ago</span><br><span class=\"line\">     Docs: https://docs.docker.com</span><br><span class=\"line\">  Process: 1250 ExecStart=/usr/bin/dockerd --registry-mirror=39.98.73.138 --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)</span><br><span class=\"line\"> Main PID: 1250 (code=exited, status=1/FAILURE)</span><br><span class=\"line\"></span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE</span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service holdoff time over, scheduling restart.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopped Docker Application Container Engine.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class=\"line\">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# journalctl -xe</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has finished shutting down.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopping Docker Socket for the API.</span><br><span class=\"line\">-- Subject: Unit docker.socket has begun shutting down</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has begun shutting down.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Starting Docker Socket for the API.</span><br><span class=\"line\">-- Subject: Unit docker.socket has begun start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has begun starting up.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Listening on Docker Socket for the API.</span><br><span class=\"line\">-- Subject: Unit docker.socket has finished start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has finished starting up.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The start-up result is done.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class=\"line\">-- Subject: Unit docker.service has failed</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.service has failed.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The result is failed.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class=\"line\">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 6 of user root.</span><br><span class=\"line\">-- Subject: Unit session-6.scope has finished start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit session-6.scope has finished starting up.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The start-up result is done.</span><br><span class=\"line\">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1271]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class=\"line\">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 7 of user root.</span><br><span class=\"line\">-- Subject: Unit session-7.scope has finished start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit session-7.scope has finished starting up.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The start-up result is done.</span><br><span class=\"line\">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1277]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class=\"line\">lines 2500-2550/2550 (END)</span><br></pre></td></tr></table></figure>\n<h1 id=\"解决的步骤\"><a href=\"#解决的步骤\" class=\"headerlink\" title=\"解决的步骤:\"></a>解决的步骤:</h1><p>1）清除/etc/systemd/system/目录下的 docker.service.requires这个目录的生成是安装别的系统Kubernete时生成的依赖信息。<br>个人总结：对这类问题清除/etc/systemd/system目录下不用的目录和文件是首选<br>2）执行systemctl daemon-reload或重启系统</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.talkwithtrend.com/Question/415283?order=desc\" target=\"_blank\" rel=\"noopener\">启动DOCKER时，遇到一个很奇葩的问题？</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\"><a href=\"#最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\" class=\"headerlink\" title=\"最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。\"></a>最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。</h1><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">systemctl status docker.service</span><br><span class=\"line\">● docker.service - Docker Application Container Engine</span><br><span class=\"line\">   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class=\"line\">   Active: failed (Result: start-limit) since 六 2019-09-28 12:05:46 CST; 5min ago</span><br><span class=\"line\">     Docs: https://docs.docker.com</span><br><span class=\"line\">  Process: 1250 ExecStart=/usr/bin/dockerd --registry-mirror=39.98.73.138 --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)</span><br><span class=\"line\"> Main PID: 1250 (code=exited, status=1/FAILURE)</span><br><span class=\"line\"></span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE</span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class=\"line\">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service holdoff time over, scheduling restart.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopped Docker Application Container Engine.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class=\"line\">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# journalctl -xe</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has finished shutting down.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopping Docker Socket for the API.</span><br><span class=\"line\">-- Subject: Unit docker.socket has begun shutting down</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has begun shutting down.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Starting Docker Socket for the API.</span><br><span class=\"line\">-- Subject: Unit docker.socket has begun start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has begun starting up.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Listening on Docker Socket for the API.</span><br><span class=\"line\">-- Subject: Unit docker.socket has finished start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.socket has finished starting up.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The start-up result is done.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class=\"line\">-- Subject: Unit docker.service has failed</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit docker.service has failed.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The result is failed.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class=\"line\">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class=\"line\">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 6 of user root.</span><br><span class=\"line\">-- Subject: Unit session-6.scope has finished start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit session-6.scope has finished starting up.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The start-up result is done.</span><br><span class=\"line\">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1271]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class=\"line\">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 7 of user root.</span><br><span class=\"line\">-- Subject: Unit session-7.scope has finished start-up</span><br><span class=\"line\">-- Defined-By: systemd</span><br><span class=\"line\">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class=\"line\">--</span><br><span class=\"line\">-- Unit session-7.scope has finished starting up.</span><br><span class=\"line\">--</span><br><span class=\"line\">-- The start-up result is done.</span><br><span class=\"line\">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1277]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class=\"line\">lines 2500-2550/2550 (END)</span><br></pre></td></tr></table></figure>\n<h1 id=\"解决的步骤\"><a href=\"#解决的步骤\" class=\"headerlink\" title=\"解决的步骤:\"></a>解决的步骤:</h1><p>1）清除/etc/systemd/system/目录下的 docker.service.requires这个目录的生成是安装别的系统Kubernete时生成的依赖信息。<br>个人总结：对这类问题清除/etc/systemd/system目录下不用的目录和文件是首选<br>2）执行systemctl daemon-reload或重启系统</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"http://www.talkwithtrend.com/Question/415283?order=desc\" target=\"_blank\" rel=\"noopener\">启动DOCKER时，遇到一个很奇葩的问题？</a></li>\n</ul>\n"},{"title":"helm在k8s上的部署","date":"2019-12-21T01:57:06.000Z","_content":"helm是k8s集群上的包管理工具，类似centos上的yum，ubuntu上的apt-get。\n在安装了k8s后我今天打算安装helm,来部署ingress暴露我的服务\n## 基本概念\n> 对于应用发布者而言，可以通过helm打包应用，管理应用依赖关系，管理应用版本并发布应用到软件仓库。\n> 对于使用者而言，使用helm后不用需要了解kubernetes的yaml语法并编写应用部署文件，可以通过helm下载并在kubernetes上安装需要的应用。\n> 除此以外，helm还提供了kubernetes上的软件部署，删除，升级，回滚应用的强大功能。\n## 组件说明\n- helm: kubernetes的应用打包工具，也是命令行工具的名称。\n- tiller: helm的服务端，部署在kubernetes集群中，用于处理helm的相关命令。\n- chart: helm的打包格式，内部包含了一组相关的kubernetes资源。\n- repoistory: helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，helm可以对接多个不同的Repository。\n- release: 使用helm install命令在kubernetes集群中安装的Chart称为Release。\n## 安装\nHelm由客户端命helm令行工具和服务端tiller组成，Helm的安装十分简单。 下载helm命令行工具到master节点node1的/usr/local/bin下，这里下载的2.13.1版本：\n``` shell \nwget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz\ntar -zxvf helm-v2.13.1-linux-amd64.tar.gz\ncd linux-amd64/\ncp helm /usr/local/bin/\n```\n因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建rbac-config.yaml文件：\n``` shell\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: tiller\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRoleBinding\nmetadata:\n  name: tiller\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n  - kind: ServiceAccount\n    name: tiller\n    namespace: kube-system\n```\n``` shell\nkubectl create -f rbac-config.yaml\nserviceaccount/tiller created\nclusterrolebinding.rbac.authorization.k8s.io/tiller created\n```\n接下来使用helm部署tiller:\n``` shell\nhelm init --service-account tiller --skip-refresh\n```\n但是没有启动，查看了原因是镜像被强了，只能去阿里云下载对应的镜像,然后更名\n``` shell\ndocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1\ndocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 gcr.io/kubernetes-helm/tiller:v2.13.1\n```\n然后再执行一遍\n``` shell\nhelm init --service-account tiller --skip-refresh\nCreating /root/.helm\nCreating /root/.helm/repository\nCreating /root/.helm/repository/cache\nCreating /root/.helm/repository/local\nCreating /root/.helm/plugins\nCreating /root/.helm/starters\nCreating /root/.helm/cache/archive\nCreating /root/.helm/repository/repositories.yaml\nAdding stable repo with URL: https://kubernetes-charts.storage.googleapis.com\nAdding local repo with URL: http://127.0.0.1:8879/charts\n$HELM_HOME has been configured at /root/.helm.\n\nTiller (the Helm server-side component) has been installed into your Kubernetes Cluster.\n\nPlease note: by default, Tiller is deployed with an insecure 'allow unauthenticated users' policy.\nTo prevent this, run `helm init` with the --tiller-tls-verify flag.\nFor more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation\nHappy Helming!\n```\ntiller默认被部署在k8s集群中的kube-system这个namespace下：\n``` shell\nkubectl get pod -n kube-system -l app=helm\nNAME                            READY   STATUS    RESTARTS   AGE\ntiller-deploy-6966cf57d8-kfxlg   1/1     Running   0          83s\n```\n``` shell \n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# helm version\nClient: &version.Version{SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"}\nServer: &version.Version{SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"}\n```\n## 使用Helm部署Nginx Ingress\n为了便于将集群中的服务暴露到集群外部，从集群外部访问，接下来使用Helm将Nginx Ingress部署到Kubernetes上。 Nginx Ingress Controller被部署在Kubernetes的边缘节点上\n``` shell\nkubectl label node node1 node-role.kubernetes.io/edge=\nnode/node1 labeled\n```\n我们将node1做为边缘节点，打上Label：\n``` shell\nkubectl get node\nNAME    STATUS   ROLES         AGE   VERSION\nnode1   Ready    edge,master   24m   v1.14.0\nnode2   Ready    <none>        11m   v1.14.0\n```\nstable/nginx-ingress chart的值文件ingress-nginx.yaml：\n``` shell\ncontroller:\n  replicaCount: 1\n  hostNetwork: true\n  nodeSelector:\n    node-role.kubernetes.io/edge: ''\n  affinity:\n    podAntiAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n        - labelSelector:\n            matchExpressions:\n            - key: app\n              operator: In\n              values:\n              - nginx-ingress\n            - key: component\n              operator: In\n              values:\n              - controller\n          topologyKey: kubernetes.io/hostname\n  tolerations:\n      - key: node-role.kubernetes.io/master\n        operator: Exists\n        effect: NoSchedule\n\ndefaultBackend:\n  nodeSelector:\n    node-role.kubernetes.io/edge: ''\n  tolerations:\n      - key: node-role.kubernetes.io/master\n        operator: Exists\n        effect: NoSchedule\n```\nnginx ingress controller的副本数replicaCount为1，将被调度到node1这个边缘节点上。这里并没有指定nginx ingress controller service的externalIPs，而是通过hostNetwork: true设置nginx ingress controller使用宿主机网络。\n``` \nhelm repo update\n\nhelm install stable/nginx-ingress \\\n-n nginx-ingress \\\n--namespace ingress-nginx  \\\n-f ingress-nginx.yaml\n```\n当然意料之中的没有这么一番丰顺\n``` shell\nkubectl get pods -n ingress-nginx\nNAME                                            READY   STATUS             RESTARTS   AGE\nnginx-ingress-controller-5f94977665-xx5dh       1/1     Running            0          4h43m\nnginx-ingress-default-backend-774bd49bf-mm56k   0/1     ImagePullBackOff   0          4h43m\n```\n## 然后我们通过kubectl describe这个命令查看这个pod没有启动的原因\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl --namespace=ingress-nginx describe pod nginx-ingress-default-backend-774bd49bf-mm56k\n``` shell\nName:         nginx-ingress-default-backend-774bd49bf-mm56k\nNamespace:    ingress-nginx\nPriority:     0\nNode:         iz8vbbld8tet39uo7wyi2jz/172.26.139.97\nStart Time:   Fri, 20 Dec 2019 19:49:53 +0800\nLabels:       app=nginx-ingress\n              component=default-backend\n              pod-template-hash=774bd49bf\n              release=nginx-ingress\nAnnotations:  <none>\nStatus:       Pending\nIP:           10.244.0.6\nIPs:\n  IP:           10.244.0.6\nControlled By:  ReplicaSet/nginx-ingress-default-backend-774bd49bf\nContainers:\n  nginx-ingress-default-backend:\n    Container ID:\n    Image:          k8s.gcr.io/defaultbackend-amd64:1.5\n    Image ID:\n    Port:           8080/TCP\n    Host Port:      0/TCP\n    State:          Waiting\n      Reason:       ImagePullBackOff\n    Ready:          False\n    Restart Count:  0\n    Liveness:       http-get http://:8080/healthz delay=30s timeout=5s period=10s #success=1 #failure=3\n    Readiness:      http-get http://:8080/healthz delay=0s timeout=5s period=5s #success=1 #failure=6\n    Environment:    <none>\n    Mounts:\n      /var/run/secrets/kubernetes.io/serviceaccount from nginx-ingress-backend-token-ftx8j (ro)\nConditions:\n  Type              Status\n  Initialized       True\n  Ready             False\n  ContainersReady   False\n  PodScheduled      True\nVolumes:\n  nginx-ingress-backend-token-ftx8j:\n    Type:        Secret (a volume populated by a Secret)\n    SecretName:  nginx-ingress-backend-token-ftx8j\n    Optional:    false\nQoS Class:       BestEffort\nNode-Selectors:  node-role.kubernetes.io/edge=\nTolerations:     node-role.kubernetes.io/master:NoSchedule\n                 node.kubernetes.io/not-ready:NoExecute for 300s\n                 node.kubernetes.io/unreachable:NoExecute for 300s\nEvents:\n  Type     Reason  Age                     From                              Message\n  ----     ------  ----                    ----                              -------\n  Warning  Failed  58m (x17 over 3h58m)    kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ErrImagePull\n  Warning  Failed  3m7s (x264 over 3h58m)  kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ImagePullBackOff\n```\n原来还是对应的image没有下载过来\n```\ndocker pull registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5\ndocker tag googlecontainer/defaultbackend-amd64:1.1 k8s.gcr.io/defaultbackend-amd64:1.5\ndocker rmi registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5\n```\n然后我们确认下对应的pod和service是否启动成功\n``` shell\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get pods -n ingress-nginx\nNAME                                            READY   STATUS    RESTARTS   AGE\nnginx-ingress-controller-5f94977665-xx5dh       1/1     Running   0          5h9m\nnginx-ingress-default-backend-774bd49bf-mm56k   1/1     Running   0          5h9m\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get service -n ingress-nginx\nNAME                            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE\nnginx-ingress-controller        LoadBalancer   10.96.96.226    <pending>     80:32074/TCP,443:32522/TCP   5h13m\nnginx-ingress-default-backend   ClusterIP      10.96.228.114   <none>        80/TCP                       5h13m\n```\n然后访问下链接，测试是否链接成功\n``` shell\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# curl 172.26.139.97\ndefault backend - 404\n```\n这样就可以了\n## 参考资料\n\n+ [使用kubeadm安装Kubernetes 1.14](https://blog.frognew.com/2019/04/kubeadm-install-kubernetes-1.14.html#31-helm)\n+ [kubernetes 1.12.1 Ingress-nginx 部署使用](https://www.jianshu.com/p/e30b06906b77)\n+ [Helm入门](https://juejin.im/post/5d54f87ff265da03b1204581)\n+ [K8s安装Ingress](https://blog.bwcxtech.com/posts/5c50d041/)\n","source":"_posts/helm在k8s上的部署.md","raw":"---\ntitle: helm在k8s上的部署\ndate: 2019-12-21 09:57:06\ntags: devops\n---\nhelm是k8s集群上的包管理工具，类似centos上的yum，ubuntu上的apt-get。\n在安装了k8s后我今天打算安装helm,来部署ingress暴露我的服务\n## 基本概念\n> 对于应用发布者而言，可以通过helm打包应用，管理应用依赖关系，管理应用版本并发布应用到软件仓库。\n> 对于使用者而言，使用helm后不用需要了解kubernetes的yaml语法并编写应用部署文件，可以通过helm下载并在kubernetes上安装需要的应用。\n> 除此以外，helm还提供了kubernetes上的软件部署，删除，升级，回滚应用的强大功能。\n## 组件说明\n- helm: kubernetes的应用打包工具，也是命令行工具的名称。\n- tiller: helm的服务端，部署在kubernetes集群中，用于处理helm的相关命令。\n- chart: helm的打包格式，内部包含了一组相关的kubernetes资源。\n- repoistory: helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，helm可以对接多个不同的Repository。\n- release: 使用helm install命令在kubernetes集群中安装的Chart称为Release。\n## 安装\nHelm由客户端命helm令行工具和服务端tiller组成，Helm的安装十分简单。 下载helm命令行工具到master节点node1的/usr/local/bin下，这里下载的2.13.1版本：\n``` shell \nwget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz\ntar -zxvf helm-v2.13.1-linux-amd64.tar.gz\ncd linux-amd64/\ncp helm /usr/local/bin/\n```\n因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建rbac-config.yaml文件：\n``` shell\napiVersion: v1\nkind: ServiceAccount\nmetadata:\n  name: tiller\n  namespace: kube-system\n---\napiVersion: rbac.authorization.k8s.io/v1beta1\nkind: ClusterRoleBinding\nmetadata:\n  name: tiller\nroleRef:\n  apiGroup: rbac.authorization.k8s.io\n  kind: ClusterRole\n  name: cluster-admin\nsubjects:\n  - kind: ServiceAccount\n    name: tiller\n    namespace: kube-system\n```\n``` shell\nkubectl create -f rbac-config.yaml\nserviceaccount/tiller created\nclusterrolebinding.rbac.authorization.k8s.io/tiller created\n```\n接下来使用helm部署tiller:\n``` shell\nhelm init --service-account tiller --skip-refresh\n```\n但是没有启动，查看了原因是镜像被强了，只能去阿里云下载对应的镜像,然后更名\n``` shell\ndocker pull registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1\ndocker tag registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 gcr.io/kubernetes-helm/tiller:v2.13.1\n```\n然后再执行一遍\n``` shell\nhelm init --service-account tiller --skip-refresh\nCreating /root/.helm\nCreating /root/.helm/repository\nCreating /root/.helm/repository/cache\nCreating /root/.helm/repository/local\nCreating /root/.helm/plugins\nCreating /root/.helm/starters\nCreating /root/.helm/cache/archive\nCreating /root/.helm/repository/repositories.yaml\nAdding stable repo with URL: https://kubernetes-charts.storage.googleapis.com\nAdding local repo with URL: http://127.0.0.1:8879/charts\n$HELM_HOME has been configured at /root/.helm.\n\nTiller (the Helm server-side component) has been installed into your Kubernetes Cluster.\n\nPlease note: by default, Tiller is deployed with an insecure 'allow unauthenticated users' policy.\nTo prevent this, run `helm init` with the --tiller-tls-verify flag.\nFor more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation\nHappy Helming!\n```\ntiller默认被部署在k8s集群中的kube-system这个namespace下：\n``` shell\nkubectl get pod -n kube-system -l app=helm\nNAME                            READY   STATUS    RESTARTS   AGE\ntiller-deploy-6966cf57d8-kfxlg   1/1     Running   0          83s\n```\n``` shell \n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# helm version\nClient: &version.Version{SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"}\nServer: &version.Version{SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"}\n```\n## 使用Helm部署Nginx Ingress\n为了便于将集群中的服务暴露到集群外部，从集群外部访问，接下来使用Helm将Nginx Ingress部署到Kubernetes上。 Nginx Ingress Controller被部署在Kubernetes的边缘节点上\n``` shell\nkubectl label node node1 node-role.kubernetes.io/edge=\nnode/node1 labeled\n```\n我们将node1做为边缘节点，打上Label：\n``` shell\nkubectl get node\nNAME    STATUS   ROLES         AGE   VERSION\nnode1   Ready    edge,master   24m   v1.14.0\nnode2   Ready    <none>        11m   v1.14.0\n```\nstable/nginx-ingress chart的值文件ingress-nginx.yaml：\n``` shell\ncontroller:\n  replicaCount: 1\n  hostNetwork: true\n  nodeSelector:\n    node-role.kubernetes.io/edge: ''\n  affinity:\n    podAntiAffinity:\n        requiredDuringSchedulingIgnoredDuringExecution:\n        - labelSelector:\n            matchExpressions:\n            - key: app\n              operator: In\n              values:\n              - nginx-ingress\n            - key: component\n              operator: In\n              values:\n              - controller\n          topologyKey: kubernetes.io/hostname\n  tolerations:\n      - key: node-role.kubernetes.io/master\n        operator: Exists\n        effect: NoSchedule\n\ndefaultBackend:\n  nodeSelector:\n    node-role.kubernetes.io/edge: ''\n  tolerations:\n      - key: node-role.kubernetes.io/master\n        operator: Exists\n        effect: NoSchedule\n```\nnginx ingress controller的副本数replicaCount为1，将被调度到node1这个边缘节点上。这里并没有指定nginx ingress controller service的externalIPs，而是通过hostNetwork: true设置nginx ingress controller使用宿主机网络。\n``` \nhelm repo update\n\nhelm install stable/nginx-ingress \\\n-n nginx-ingress \\\n--namespace ingress-nginx  \\\n-f ingress-nginx.yaml\n```\n当然意料之中的没有这么一番丰顺\n``` shell\nkubectl get pods -n ingress-nginx\nNAME                                            READY   STATUS             RESTARTS   AGE\nnginx-ingress-controller-5f94977665-xx5dh       1/1     Running            0          4h43m\nnginx-ingress-default-backend-774bd49bf-mm56k   0/1     ImagePullBackOff   0          4h43m\n```\n## 然后我们通过kubectl describe这个命令查看这个pod没有启动的原因\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl --namespace=ingress-nginx describe pod nginx-ingress-default-backend-774bd49bf-mm56k\n``` shell\nName:         nginx-ingress-default-backend-774bd49bf-mm56k\nNamespace:    ingress-nginx\nPriority:     0\nNode:         iz8vbbld8tet39uo7wyi2jz/172.26.139.97\nStart Time:   Fri, 20 Dec 2019 19:49:53 +0800\nLabels:       app=nginx-ingress\n              component=default-backend\n              pod-template-hash=774bd49bf\n              release=nginx-ingress\nAnnotations:  <none>\nStatus:       Pending\nIP:           10.244.0.6\nIPs:\n  IP:           10.244.0.6\nControlled By:  ReplicaSet/nginx-ingress-default-backend-774bd49bf\nContainers:\n  nginx-ingress-default-backend:\n    Container ID:\n    Image:          k8s.gcr.io/defaultbackend-amd64:1.5\n    Image ID:\n    Port:           8080/TCP\n    Host Port:      0/TCP\n    State:          Waiting\n      Reason:       ImagePullBackOff\n    Ready:          False\n    Restart Count:  0\n    Liveness:       http-get http://:8080/healthz delay=30s timeout=5s period=10s #success=1 #failure=3\n    Readiness:      http-get http://:8080/healthz delay=0s timeout=5s period=5s #success=1 #failure=6\n    Environment:    <none>\n    Mounts:\n      /var/run/secrets/kubernetes.io/serviceaccount from nginx-ingress-backend-token-ftx8j (ro)\nConditions:\n  Type              Status\n  Initialized       True\n  Ready             False\n  ContainersReady   False\n  PodScheduled      True\nVolumes:\n  nginx-ingress-backend-token-ftx8j:\n    Type:        Secret (a volume populated by a Secret)\n    SecretName:  nginx-ingress-backend-token-ftx8j\n    Optional:    false\nQoS Class:       BestEffort\nNode-Selectors:  node-role.kubernetes.io/edge=\nTolerations:     node-role.kubernetes.io/master:NoSchedule\n                 node.kubernetes.io/not-ready:NoExecute for 300s\n                 node.kubernetes.io/unreachable:NoExecute for 300s\nEvents:\n  Type     Reason  Age                     From                              Message\n  ----     ------  ----                    ----                              -------\n  Warning  Failed  58m (x17 over 3h58m)    kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ErrImagePull\n  Warning  Failed  3m7s (x264 over 3h58m)  kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ImagePullBackOff\n```\n原来还是对应的image没有下载过来\n```\ndocker pull registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5\ndocker tag googlecontainer/defaultbackend-amd64:1.1 k8s.gcr.io/defaultbackend-amd64:1.5\ndocker rmi registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5\n```\n然后我们确认下对应的pod和service是否启动成功\n``` shell\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get pods -n ingress-nginx\nNAME                                            READY   STATUS    RESTARTS   AGE\nnginx-ingress-controller-5f94977665-xx5dh       1/1     Running   0          5h9m\nnginx-ingress-default-backend-774bd49bf-mm56k   1/1     Running   0          5h9m\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get service -n ingress-nginx\nNAME                            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE\nnginx-ingress-controller        LoadBalancer   10.96.96.226    <pending>     80:32074/TCP,443:32522/TCP   5h13m\nnginx-ingress-default-backend   ClusterIP      10.96.228.114   <none>        80/TCP                       5h13m\n```\n然后访问下链接，测试是否链接成功\n``` shell\n[root@iZ8vbbld8tet39uo7wyi2jZ ~]# curl 172.26.139.97\ndefault backend - 404\n```\n这样就可以了\n## 参考资料\n\n+ [使用kubeadm安装Kubernetes 1.14](https://blog.frognew.com/2019/04/kubeadm-install-kubernetes-1.14.html#31-helm)\n+ [kubernetes 1.12.1 Ingress-nginx 部署使用](https://www.jianshu.com/p/e30b06906b77)\n+ [Helm入门](https://juejin.im/post/5d54f87ff265da03b1204581)\n+ [K8s安装Ingress](https://blog.bwcxtech.com/posts/5c50d041/)\n","slug":"helm在k8s上的部署","published":1,"updated":"2019-12-21T03:01:53.533Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjk0014th8lymfy8pa5","content":"<p>helm是k8s集群上的包管理工具，类似centos上的yum，ubuntu上的apt-get。<br>在安装了k8s后我今天打算安装helm,来部署ingress暴露我的服务</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>对于应用发布者而言，可以通过helm打包应用，管理应用依赖关系，管理应用版本并发布应用到软件仓库。<br>对于使用者而言，使用helm后不用需要了解kubernetes的yaml语法并编写应用部署文件，可以通过helm下载并在kubernetes上安装需要的应用。<br>除此以外，helm还提供了kubernetes上的软件部署，删除，升级，回滚应用的强大功能。</p>\n</blockquote>\n<h2 id=\"组件说明\"><a href=\"#组件说明\" class=\"headerlink\" title=\"组件说明\"></a>组件说明</h2><ul>\n<li>helm: kubernetes的应用打包工具，也是命令行工具的名称。</li>\n<li>tiller: helm的服务端，部署在kubernetes集群中，用于处理helm的相关命令。</li>\n<li>chart: helm的打包格式，内部包含了一组相关的kubernetes资源。</li>\n<li>repoistory: helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，helm可以对接多个不同的Repository。</li>\n<li>release: 使用helm install命令在kubernetes集群中安装的Chart称为Release。<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2>Helm由客户端命helm令行工具和服务端tiller组成，Helm的安装十分简单。 下载helm命令行工具到master节点node1的/usr/local/bin下，这里下载的2.13.1版本：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz</span><br><span class=\"line\">tar -zxvf helm-v2.13.1-linux-amd64.tar.gz</span><br><span class=\"line\">cd linux-amd64/</span><br><span class=\"line\">cp helm /usr/local/bin/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建rbac-config.yaml文件：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: tiller</span><br><span class=\"line\">  namespace: kube-system</span><br><span class=\"line\">---</span><br><span class=\"line\">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class=\"line\">kind: ClusterRoleBinding</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: tiller</span><br><span class=\"line\">roleRef:</span><br><span class=\"line\">  apiGroup: rbac.authorization.k8s.io</span><br><span class=\"line\">  kind: ClusterRole</span><br><span class=\"line\">  name: cluster-admin</span><br><span class=\"line\">subjects:</span><br><span class=\"line\">  - kind: ServiceAccount</span><br><span class=\"line\">    name: tiller</span><br><span class=\"line\">    namespace: kube-system</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f rbac-config.yaml</span><br><span class=\"line\">serviceaccount/tiller created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/tiller created</span><br></pre></td></tr></table></figure>\n<p>接下来使用helm部署tiller:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init --service-account tiller --skip-refresh</span><br></pre></td></tr></table></figure></p>\n<p>但是没有启动，查看了原因是镜像被强了，只能去阿里云下载对应的镜像,然后更名<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1</span><br><span class=\"line\">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 gcr.io/kubernetes-helm/tiller:v2.13.1</span><br></pre></td></tr></table></figure></p>\n<p>然后再执行一遍<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init --service-account tiller --skip-refresh</span><br><span class=\"line\">Creating /root/.helm</span><br><span class=\"line\">Creating /root/.helm/repository</span><br><span class=\"line\">Creating /root/.helm/repository/cache</span><br><span class=\"line\">Creating /root/.helm/repository/local</span><br><span class=\"line\">Creating /root/.helm/plugins</span><br><span class=\"line\">Creating /root/.helm/starters</span><br><span class=\"line\">Creating /root/.helm/cache/archive</span><br><span class=\"line\">Creating /root/.helm/repository/repositories.yaml</span><br><span class=\"line\">Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com</span><br><span class=\"line\">Adding local repo with URL: http://127.0.0.1:8879/charts</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">HELM_HOME has been configured at /root/.helm.</span></span><br><span class=\"line\"></span><br><span class=\"line\">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span><br><span class=\"line\"></span><br><span class=\"line\">Please note: by default, Tiller is deployed with an insecure 'allow unauthenticated users' policy.</span><br><span class=\"line\">To prevent this, run `helm init` with the --tiller-tls-verify flag.</span><br><span class=\"line\">For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation</span><br><span class=\"line\">Happy Helming!</span><br></pre></td></tr></table></figure></p>\n<p>tiller默认被部署在k8s集群中的kube-system这个namespace下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n kube-system -l app=helm</span><br><span class=\"line\">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">tiller-deploy-6966cf57d8-kfxlg   1/1     Running   0          83s</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# helm version</span><br><span class=\"line\">Client: &amp;version.Version&#123;SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"&#125;</span><br><span class=\"line\">Server: &amp;version.Version&#123;SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Helm部署Nginx-Ingress\"><a href=\"#使用Helm部署Nginx-Ingress\" class=\"headerlink\" title=\"使用Helm部署Nginx Ingress\"></a>使用Helm部署Nginx Ingress</h2><p>为了便于将集群中的服务暴露到集群外部，从集群外部访问，接下来使用Helm将Nginx Ingress部署到Kubernetes上。 Nginx Ingress Controller被部署在Kubernetes的边缘节点上<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl label node node1 node-role.kubernetes.io/edge=</span><br><span class=\"line\">node/node1 labeled</span><br></pre></td></tr></table></figure></p>\n<p>我们将node1做为边缘节点，打上Label：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get node</span><br><span class=\"line\">NAME    STATUS   ROLES         AGE   VERSION</span><br><span class=\"line\">node1   Ready    edge,master   24m   v1.14.0</span><br><span class=\"line\">node2   Ready    &lt;none&gt;        11m   v1.14.0</span><br></pre></td></tr></table></figure></p>\n<p>stable/nginx-ingress chart的值文件ingress-nginx.yaml：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">controller:</span><br><span class=\"line\">  replicaCount: 1</span><br><span class=\"line\">  hostNetwork: true</span><br><span class=\"line\">  nodeSelector:</span><br><span class=\"line\">    node-role.kubernetes.io/edge: ''</span><br><span class=\"line\">  affinity:</span><br><span class=\"line\">    podAntiAffinity:</span><br><span class=\"line\">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class=\"line\">        - labelSelector:</span><br><span class=\"line\">            matchExpressions:</span><br><span class=\"line\">            - key: app</span><br><span class=\"line\">              operator: In</span><br><span class=\"line\">              values:</span><br><span class=\"line\">              - nginx-ingress</span><br><span class=\"line\">            - key: component</span><br><span class=\"line\">              operator: In</span><br><span class=\"line\">              values:</span><br><span class=\"line\">              - controller</span><br><span class=\"line\">          topologyKey: kubernetes.io/hostname</span><br><span class=\"line\">  tolerations:</span><br><span class=\"line\">      - key: node-role.kubernetes.io/master</span><br><span class=\"line\">        operator: Exists</span><br><span class=\"line\">        effect: NoSchedule</span><br><span class=\"line\"></span><br><span class=\"line\">defaultBackend:</span><br><span class=\"line\">  nodeSelector:</span><br><span class=\"line\">    node-role.kubernetes.io/edge: ''</span><br><span class=\"line\">  tolerations:</span><br><span class=\"line\">      - key: node-role.kubernetes.io/master</span><br><span class=\"line\">        operator: Exists</span><br><span class=\"line\">        effect: NoSchedule</span><br></pre></td></tr></table></figure></p>\n<p>nginx ingress controller的副本数replicaCount为1，将被调度到node1这个边缘节点上。这里并没有指定nginx ingress controller service的externalIPs，而是通过hostNetwork: true设置nginx ingress controller使用宿主机网络。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo update</span><br><span class=\"line\"></span><br><span class=\"line\">helm install stable/nginx-ingress \\</span><br><span class=\"line\">-n nginx-ingress \\</span><br><span class=\"line\">--namespace ingress-nginx  \\</span><br><span class=\"line\">-f ingress-nginx.yaml</span><br></pre></td></tr></table></figure></p>\n<p>当然意料之中的没有这么一番丰顺<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods -n ingress-nginx</span><br><span class=\"line\">NAME                                            READY   STATUS             RESTARTS   AGE</span><br><span class=\"line\">nginx-ingress-controller-5f94977665-xx5dh       1/1     Running            0          4h43m</span><br><span class=\"line\">nginx-ingress-default-backend-774bd49bf-mm56k   0/1     ImagePullBackOff   0          4h43m</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"然后我们通过kubectl-describe这个命令查看这个pod没有启动的原因\"><a href=\"#然后我们通过kubectl-describe这个命令查看这个pod没有启动的原因\" class=\"headerlink\" title=\"然后我们通过kubectl describe这个命令查看这个pod没有启动的原因\"></a>然后我们通过kubectl describe这个命令查看这个pod没有启动的原因</h2><p>[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl –namespace=ingress-nginx describe pod nginx-ingress-default-backend-774bd49bf-mm56k<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Name:         nginx-ingress-default-backend-774bd49bf-mm56k</span><br><span class=\"line\">Namespace:    ingress-nginx</span><br><span class=\"line\">Priority:     0</span><br><span class=\"line\">Node:         iz8vbbld8tet39uo7wyi2jz/172.26.139.97</span><br><span class=\"line\">Start Time:   Fri, 20 Dec 2019 19:49:53 +0800</span><br><span class=\"line\">Labels:       app=nginx-ingress</span><br><span class=\"line\">              component=default-backend</span><br><span class=\"line\">              pod-template-hash=774bd49bf</span><br><span class=\"line\">              release=nginx-ingress</span><br><span class=\"line\">Annotations:  &lt;none&gt;</span><br><span class=\"line\">Status:       Pending</span><br><span class=\"line\">IP:           10.244.0.6</span><br><span class=\"line\">IPs:</span><br><span class=\"line\">  IP:           10.244.0.6</span><br><span class=\"line\">Controlled By:  ReplicaSet/nginx-ingress-default-backend-774bd49bf</span><br><span class=\"line\">Containers:</span><br><span class=\"line\">  nginx-ingress-default-backend:</span><br><span class=\"line\">    Container ID:</span><br><span class=\"line\">    Image:          k8s.gcr.io/defaultbackend-amd64:1.5</span><br><span class=\"line\">    Image ID:</span><br><span class=\"line\">    Port:           8080/TCP</span><br><span class=\"line\">    Host Port:      0/TCP</span><br><span class=\"line\">    State:          Waiting</span><br><span class=\"line\">      Reason:       ImagePullBackOff</span><br><span class=\"line\">    Ready:          False</span><br><span class=\"line\">    Restart Count:  0</span><br><span class=\"line\">    Liveness:       http-get http://:8080/healthz delay=30s timeout=5s period=10s #success=1 #failure=3</span><br><span class=\"line\">    Readiness:      http-get http://:8080/healthz delay=0s timeout=5s period=5s #success=1 #failure=6</span><br><span class=\"line\">    Environment:    &lt;none&gt;</span><br><span class=\"line\">    Mounts:</span><br><span class=\"line\">      /var/run/secrets/kubernetes.io/serviceaccount from nginx-ingress-backend-token-ftx8j (ro)</span><br><span class=\"line\">Conditions:</span><br><span class=\"line\">  Type              Status</span><br><span class=\"line\">  Initialized       True</span><br><span class=\"line\">  Ready             False</span><br><span class=\"line\">  ContainersReady   False</span><br><span class=\"line\">  PodScheduled      True</span><br><span class=\"line\">Volumes:</span><br><span class=\"line\">  nginx-ingress-backend-token-ftx8j:</span><br><span class=\"line\">    Type:        Secret (a volume populated by a Secret)</span><br><span class=\"line\">    SecretName:  nginx-ingress-backend-token-ftx8j</span><br><span class=\"line\">    Optional:    false</span><br><span class=\"line\">QoS Class:       BestEffort</span><br><span class=\"line\">Node-Selectors:  node-role.kubernetes.io/edge=</span><br><span class=\"line\">Tolerations:     node-role.kubernetes.io/master:NoSchedule</span><br><span class=\"line\">                 node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class=\"line\">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class=\"line\">Events:</span><br><span class=\"line\">  Type     Reason  Age                     From                              Message</span><br><span class=\"line\">  ----     ------  ----                    ----                              -------</span><br><span class=\"line\">  Warning  Failed  58m (x17 over 3h58m)    kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ErrImagePull</span><br><span class=\"line\">  Warning  Failed  3m7s (x264 over 3h58m)  kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ImagePullBackOff</span><br></pre></td></tr></table></figure></p>\n<p>原来还是对应的image没有下载过来<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5</span><br><span class=\"line\">docker tag googlecontainer/defaultbackend-amd64:1.1 k8s.gcr.io/defaultbackend-amd64:1.5</span><br><span class=\"line\">docker rmi registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5</span><br></pre></td></tr></table></figure></p>\n<p>然后我们确认下对应的pod和service是否启动成功<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get pods -n ingress-nginx</span><br><span class=\"line\">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">nginx-ingress-controller-5f94977665-xx5dh       1/1     Running   0          5h9m</span><br><span class=\"line\">nginx-ingress-default-backend-774bd49bf-mm56k   1/1     Running   0          5h9m</span><br><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get service -n ingress-nginx</span><br><span class=\"line\">NAME                            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class=\"line\">nginx-ingress-controller        LoadBalancer   10.96.96.226    &lt;pending&gt;     80:32074/TCP,443:32522/TCP   5h13m</span><br><span class=\"line\">nginx-ingress-default-backend   ClusterIP      10.96.228.114   &lt;none&gt;        80/TCP                       5h13m</span><br></pre></td></tr></table></figure></p>\n<p>然后访问下链接，测试是否链接成功<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# curl 172.26.139.97</span><br><span class=\"line\">default backend - 404</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以了</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.frognew.com/2019/04/kubeadm-install-kubernetes-1.14.html#31-helm\" target=\"_blank\" rel=\"noopener\">使用kubeadm安装Kubernetes 1.14</a></li>\n<li><a href=\"https://www.jianshu.com/p/e30b06906b77\" target=\"_blank\" rel=\"noopener\">kubernetes 1.12.1 Ingress-nginx 部署使用</a></li>\n<li><a href=\"https://juejin.im/post/5d54f87ff265da03b1204581\" target=\"_blank\" rel=\"noopener\">Helm入门</a></li>\n<li><a href=\"https://blog.bwcxtech.com/posts/5c50d041/\" target=\"_blank\" rel=\"noopener\">K8s安装Ingress</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>helm是k8s集群上的包管理工具，类似centos上的yum，ubuntu上的apt-get。<br>在安装了k8s后我今天打算安装helm,来部署ingress暴露我的服务</p>\n<h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><blockquote>\n<p>对于应用发布者而言，可以通过helm打包应用，管理应用依赖关系，管理应用版本并发布应用到软件仓库。<br>对于使用者而言，使用helm后不用需要了解kubernetes的yaml语法并编写应用部署文件，可以通过helm下载并在kubernetes上安装需要的应用。<br>除此以外，helm还提供了kubernetes上的软件部署，删除，升级，回滚应用的强大功能。</p>\n</blockquote>\n<h2 id=\"组件说明\"><a href=\"#组件说明\" class=\"headerlink\" title=\"组件说明\"></a>组件说明</h2><ul>\n<li>helm: kubernetes的应用打包工具，也是命令行工具的名称。</li>\n<li>tiller: helm的服务端，部署在kubernetes集群中，用于处理helm的相关命令。</li>\n<li>chart: helm的打包格式，内部包含了一组相关的kubernetes资源。</li>\n<li>repoistory: helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，helm可以对接多个不同的Repository。</li>\n<li>release: 使用helm install命令在kubernetes集群中安装的Chart称为Release。<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2>Helm由客户端命helm令行工具和服务端tiller组成，Helm的安装十分简单。 下载helm命令行工具到master节点node1的/usr/local/bin下，这里下载的2.13.1版本：<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz</span><br><span class=\"line\">tar -zxvf helm-v2.13.1-linux-amd64.tar.gz</span><br><span class=\"line\">cd linux-amd64/</span><br><span class=\"line\">cp helm /usr/local/bin/</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建rbac-config.yaml文件：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">apiVersion: v1</span><br><span class=\"line\">kind: ServiceAccount</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: tiller</span><br><span class=\"line\">  namespace: kube-system</span><br><span class=\"line\">---</span><br><span class=\"line\">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class=\"line\">kind: ClusterRoleBinding</span><br><span class=\"line\">metadata:</span><br><span class=\"line\">  name: tiller</span><br><span class=\"line\">roleRef:</span><br><span class=\"line\">  apiGroup: rbac.authorization.k8s.io</span><br><span class=\"line\">  kind: ClusterRole</span><br><span class=\"line\">  name: cluster-admin</span><br><span class=\"line\">subjects:</span><br><span class=\"line\">  - kind: ServiceAccount</span><br><span class=\"line\">    name: tiller</span><br><span class=\"line\">    namespace: kube-system</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl create -f rbac-config.yaml</span><br><span class=\"line\">serviceaccount/tiller created</span><br><span class=\"line\">clusterrolebinding.rbac.authorization.k8s.io/tiller created</span><br></pre></td></tr></table></figure>\n<p>接下来使用helm部署tiller:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init --service-account tiller --skip-refresh</span><br></pre></td></tr></table></figure></p>\n<p>但是没有启动，查看了原因是镜像被强了，只能去阿里云下载对应的镜像,然后更名<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1</span><br><span class=\"line\">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 gcr.io/kubernetes-helm/tiller:v2.13.1</span><br></pre></td></tr></table></figure></p>\n<p>然后再执行一遍<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm init --service-account tiller --skip-refresh</span><br><span class=\"line\">Creating /root/.helm</span><br><span class=\"line\">Creating /root/.helm/repository</span><br><span class=\"line\">Creating /root/.helm/repository/cache</span><br><span class=\"line\">Creating /root/.helm/repository/local</span><br><span class=\"line\">Creating /root/.helm/plugins</span><br><span class=\"line\">Creating /root/.helm/starters</span><br><span class=\"line\">Creating /root/.helm/cache/archive</span><br><span class=\"line\">Creating /root/.helm/repository/repositories.yaml</span><br><span class=\"line\">Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com</span><br><span class=\"line\">Adding local repo with URL: http://127.0.0.1:8879/charts</span><br><span class=\"line\"><span class=\"meta\">$</span><span class=\"bash\">HELM_HOME has been configured at /root/.helm.</span></span><br><span class=\"line\"></span><br><span class=\"line\">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span><br><span class=\"line\"></span><br><span class=\"line\">Please note: by default, Tiller is deployed with an insecure 'allow unauthenticated users' policy.</span><br><span class=\"line\">To prevent this, run `helm init` with the --tiller-tls-verify flag.</span><br><span class=\"line\">For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation</span><br><span class=\"line\">Happy Helming!</span><br></pre></td></tr></table></figure></p>\n<p>tiller默认被部署在k8s集群中的kube-system这个namespace下：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pod -n kube-system -l app=helm</span><br><span class=\"line\">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">tiller-deploy-6966cf57d8-kfxlg   1/1     Running   0          83s</span><br></pre></td></tr></table></figure></p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# helm version</span><br><span class=\"line\">Client: &amp;version.Version&#123;SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"&#125;</span><br><span class=\"line\">Server: &amp;version.Version&#123;SemVer:\"v2.13.1\", GitCommit:\"618447cbf203d147601b4b9bd7f8c37a5d39fbb4\", GitTreeState:\"clean\"&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"使用Helm部署Nginx-Ingress\"><a href=\"#使用Helm部署Nginx-Ingress\" class=\"headerlink\" title=\"使用Helm部署Nginx Ingress\"></a>使用Helm部署Nginx Ingress</h2><p>为了便于将集群中的服务暴露到集群外部，从集群外部访问，接下来使用Helm将Nginx Ingress部署到Kubernetes上。 Nginx Ingress Controller被部署在Kubernetes的边缘节点上<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl label node node1 node-role.kubernetes.io/edge=</span><br><span class=\"line\">node/node1 labeled</span><br></pre></td></tr></table></figure></p>\n<p>我们将node1做为边缘节点，打上Label：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get node</span><br><span class=\"line\">NAME    STATUS   ROLES         AGE   VERSION</span><br><span class=\"line\">node1   Ready    edge,master   24m   v1.14.0</span><br><span class=\"line\">node2   Ready    &lt;none&gt;        11m   v1.14.0</span><br></pre></td></tr></table></figure></p>\n<p>stable/nginx-ingress chart的值文件ingress-nginx.yaml：<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">controller:</span><br><span class=\"line\">  replicaCount: 1</span><br><span class=\"line\">  hostNetwork: true</span><br><span class=\"line\">  nodeSelector:</span><br><span class=\"line\">    node-role.kubernetes.io/edge: ''</span><br><span class=\"line\">  affinity:</span><br><span class=\"line\">    podAntiAffinity:</span><br><span class=\"line\">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class=\"line\">        - labelSelector:</span><br><span class=\"line\">            matchExpressions:</span><br><span class=\"line\">            - key: app</span><br><span class=\"line\">              operator: In</span><br><span class=\"line\">              values:</span><br><span class=\"line\">              - nginx-ingress</span><br><span class=\"line\">            - key: component</span><br><span class=\"line\">              operator: In</span><br><span class=\"line\">              values:</span><br><span class=\"line\">              - controller</span><br><span class=\"line\">          topologyKey: kubernetes.io/hostname</span><br><span class=\"line\">  tolerations:</span><br><span class=\"line\">      - key: node-role.kubernetes.io/master</span><br><span class=\"line\">        operator: Exists</span><br><span class=\"line\">        effect: NoSchedule</span><br><span class=\"line\"></span><br><span class=\"line\">defaultBackend:</span><br><span class=\"line\">  nodeSelector:</span><br><span class=\"line\">    node-role.kubernetes.io/edge: ''</span><br><span class=\"line\">  tolerations:</span><br><span class=\"line\">      - key: node-role.kubernetes.io/master</span><br><span class=\"line\">        operator: Exists</span><br><span class=\"line\">        effect: NoSchedule</span><br></pre></td></tr></table></figure></p>\n<p>nginx ingress controller的副本数replicaCount为1，将被调度到node1这个边缘节点上。这里并没有指定nginx ingress controller service的externalIPs，而是通过hostNetwork: true设置nginx ingress controller使用宿主机网络。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">helm repo update</span><br><span class=\"line\"></span><br><span class=\"line\">helm install stable/nginx-ingress \\</span><br><span class=\"line\">-n nginx-ingress \\</span><br><span class=\"line\">--namespace ingress-nginx  \\</span><br><span class=\"line\">-f ingress-nginx.yaml</span><br></pre></td></tr></table></figure></p>\n<p>当然意料之中的没有这么一番丰顺<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">kubectl get pods -n ingress-nginx</span><br><span class=\"line\">NAME                                            READY   STATUS             RESTARTS   AGE</span><br><span class=\"line\">nginx-ingress-controller-5f94977665-xx5dh       1/1     Running            0          4h43m</span><br><span class=\"line\">nginx-ingress-default-backend-774bd49bf-mm56k   0/1     ImagePullBackOff   0          4h43m</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"然后我们通过kubectl-describe这个命令查看这个pod没有启动的原因\"><a href=\"#然后我们通过kubectl-describe这个命令查看这个pod没有启动的原因\" class=\"headerlink\" title=\"然后我们通过kubectl describe这个命令查看这个pod没有启动的原因\"></a>然后我们通过kubectl describe这个命令查看这个pod没有启动的原因</h2><p>[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl –namespace=ingress-nginx describe pod nginx-ingress-default-backend-774bd49bf-mm56k<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Name:         nginx-ingress-default-backend-774bd49bf-mm56k</span><br><span class=\"line\">Namespace:    ingress-nginx</span><br><span class=\"line\">Priority:     0</span><br><span class=\"line\">Node:         iz8vbbld8tet39uo7wyi2jz/172.26.139.97</span><br><span class=\"line\">Start Time:   Fri, 20 Dec 2019 19:49:53 +0800</span><br><span class=\"line\">Labels:       app=nginx-ingress</span><br><span class=\"line\">              component=default-backend</span><br><span class=\"line\">              pod-template-hash=774bd49bf</span><br><span class=\"line\">              release=nginx-ingress</span><br><span class=\"line\">Annotations:  &lt;none&gt;</span><br><span class=\"line\">Status:       Pending</span><br><span class=\"line\">IP:           10.244.0.6</span><br><span class=\"line\">IPs:</span><br><span class=\"line\">  IP:           10.244.0.6</span><br><span class=\"line\">Controlled By:  ReplicaSet/nginx-ingress-default-backend-774bd49bf</span><br><span class=\"line\">Containers:</span><br><span class=\"line\">  nginx-ingress-default-backend:</span><br><span class=\"line\">    Container ID:</span><br><span class=\"line\">    Image:          k8s.gcr.io/defaultbackend-amd64:1.5</span><br><span class=\"line\">    Image ID:</span><br><span class=\"line\">    Port:           8080/TCP</span><br><span class=\"line\">    Host Port:      0/TCP</span><br><span class=\"line\">    State:          Waiting</span><br><span class=\"line\">      Reason:       ImagePullBackOff</span><br><span class=\"line\">    Ready:          False</span><br><span class=\"line\">    Restart Count:  0</span><br><span class=\"line\">    Liveness:       http-get http://:8080/healthz delay=30s timeout=5s period=10s #success=1 #failure=3</span><br><span class=\"line\">    Readiness:      http-get http://:8080/healthz delay=0s timeout=5s period=5s #success=1 #failure=6</span><br><span class=\"line\">    Environment:    &lt;none&gt;</span><br><span class=\"line\">    Mounts:</span><br><span class=\"line\">      /var/run/secrets/kubernetes.io/serviceaccount from nginx-ingress-backend-token-ftx8j (ro)</span><br><span class=\"line\">Conditions:</span><br><span class=\"line\">  Type              Status</span><br><span class=\"line\">  Initialized       True</span><br><span class=\"line\">  Ready             False</span><br><span class=\"line\">  ContainersReady   False</span><br><span class=\"line\">  PodScheduled      True</span><br><span class=\"line\">Volumes:</span><br><span class=\"line\">  nginx-ingress-backend-token-ftx8j:</span><br><span class=\"line\">    Type:        Secret (a volume populated by a Secret)</span><br><span class=\"line\">    SecretName:  nginx-ingress-backend-token-ftx8j</span><br><span class=\"line\">    Optional:    false</span><br><span class=\"line\">QoS Class:       BestEffort</span><br><span class=\"line\">Node-Selectors:  node-role.kubernetes.io/edge=</span><br><span class=\"line\">Tolerations:     node-role.kubernetes.io/master:NoSchedule</span><br><span class=\"line\">                 node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class=\"line\">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class=\"line\">Events:</span><br><span class=\"line\">  Type     Reason  Age                     From                              Message</span><br><span class=\"line\">  ----     ------  ----                    ----                              -------</span><br><span class=\"line\">  Warning  Failed  58m (x17 over 3h58m)    kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ErrImagePull</span><br><span class=\"line\">  Warning  Failed  3m7s (x264 over 3h58m)  kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ImagePullBackOff</span><br></pre></td></tr></table></figure></p>\n<p>原来还是对应的image没有下载过来<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker pull registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5</span><br><span class=\"line\">docker tag googlecontainer/defaultbackend-amd64:1.1 k8s.gcr.io/defaultbackend-amd64:1.5</span><br><span class=\"line\">docker rmi registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5</span><br></pre></td></tr></table></figure></p>\n<p>然后我们确认下对应的pod和service是否启动成功<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get pods -n ingress-nginx</span><br><span class=\"line\">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class=\"line\">nginx-ingress-controller-5f94977665-xx5dh       1/1     Running   0          5h9m</span><br><span class=\"line\">nginx-ingress-default-backend-774bd49bf-mm56k   1/1     Running   0          5h9m</span><br><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get service -n ingress-nginx</span><br><span class=\"line\">NAME                            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class=\"line\">nginx-ingress-controller        LoadBalancer   10.96.96.226    &lt;pending&gt;     80:32074/TCP,443:32522/TCP   5h13m</span><br><span class=\"line\">nginx-ingress-default-backend   ClusterIP      10.96.228.114   &lt;none&gt;        80/TCP                       5h13m</span><br></pre></td></tr></table></figure></p>\n<p>然后访问下链接，测试是否链接成功<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# curl 172.26.139.97</span><br><span class=\"line\">default backend - 404</span><br></pre></td></tr></table></figure></p>\n<p>这样就可以了</p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://blog.frognew.com/2019/04/kubeadm-install-kubernetes-1.14.html#31-helm\" target=\"_blank\" rel=\"noopener\">使用kubeadm安装Kubernetes 1.14</a></li>\n<li><a href=\"https://www.jianshu.com/p/e30b06906b77\" target=\"_blank\" rel=\"noopener\">kubernetes 1.12.1 Ingress-nginx 部署使用</a></li>\n<li><a href=\"https://juejin.im/post/5d54f87ff265da03b1204581\" target=\"_blank\" rel=\"noopener\">Helm入门</a></li>\n<li><a href=\"https://blog.bwcxtech.com/posts/5c50d041/\" target=\"_blank\" rel=\"noopener\">K8s安装Ingress</a></li>\n</ul>\n"},{"title":"lnmp源码搭建","date":"2017-05-08T14:47:02.000Z","_content":"## mysql源码安装\n1.安装编译源码需要的包\n``` shell\nsudo apt-get install make cmake gcc g++ bison libncurses5-dev\n```\n2.下载相应源码包\n``` shell\n[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz\n[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz\n```\n3.新建MySQL用户和用户组\n``` shell\n[root@graychen ~]# groupadd -r mysql && useradd -r -g mysql -s /sbin/nologin -M mysql\n```\n4.预编译\n\n``` shell\n[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz\n[root@graychen data]# md5sum mysql-5.7.13.tar.gz \n8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz\n[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz\n[root@graychen data]# mkdir -p /data/mysql\n[root@graychen data]# cd mysql-5.7.13\n[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\n-DMYSQL_DATADIR=/data/mysql \\\n-DWITH_BOOST=../boost_1_59_0 \\\n-DSYSCONFDIR=/etc \\\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\n-DWITH_PARTITION_STORAGE_ENGINE=1 \\\n-DWITH_FEDERATED_STORAGE_ENGINE=1 \\\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\n-DWITH_MYISAM_STORAGE_ENGINE=1 \\\n-DENABLED_LOCAL_INFILE=1 \\\n-DENABLE_DTRACE=0 \\\n-DDEFAULT_CHARSET=utf8mb4 \\\n-DDEFAULT_COLLATION=utf8mb4_general_ci \\\n-DWITH_EMBEDDED_SERVER=1\n```\n5.编译安装\n\n<!--more-->\n``` shell\n[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`\n#编译很消耗系统资源，小内存可能编译通不过make install\n[root@graychen mysql-5.7.13]# make install\n```\n6.设置启动脚本，开机自启动\n\n``` shell\n[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql\n[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# systemctl enable mysqld\nmysqld.service is not a native service, redirecting to /sbin/chkconfig.\nExecuting /sbin/chkconfig mysqld on\n```\n7.配置文件\n\n``` shell\n/etc/my.cnf，仅供参考 \n[root@graychen mysql-5.7.13]# cat > /etc/my.cnf << EOF\n[client]\nport = 3306\nsocket = /dev/shm/mysql.sock\n[mysqld]\nport = 3306\nsocket = /dev/shm/mysql.sock\nbasedir = /usr/local/mysql\ndatadir = /data/mysql\npid-file = /data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\ninit-connect = 'SET NAMES utf8mb4'\ncharacter-set-server = utf8mb4\n#skip-name-resolve\n#skip-networking\nback_log = 300\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\nthread_cache_size = 8\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\nft_min_word_len = 4\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\nlog_error = /data/mysql/mysql-error.log\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /data/mysql/mysql-slow.log\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n#lower_case_table_names = 1\nskip-external-locking\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\ninteractive_timeout = 28800\nwait_timeout = 28800\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\nEOF\n```\n9.添加mysql的环境变量\n\n``` shell\n[root@graychen mysql-5.7.13]# echo -e '\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n' >> /etc/profile && source /etc/profile\n```\n10.初始化数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql\n```\n11.启动数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# systemctl start mysqld\n[root@graychen mysql-5.7.13]# systemctl status mysqld\n● mysqld.service - LSB: start and stop MySQL\nLoaded: loaded (/etc/rc.d/init.d/mysqld)\nActive: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago\nDocs: man:systemd-sysv-generator(8)\nProcess: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)\nCGroup: /system.slice/mysqld.service\n├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\n└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...\n\n7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...\n7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]\n7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.\n```\n12.查看MySQL服务进程和端口\n``` shell\n[root@graychen mysql-5.7.13]# ps -ef | grep mysql\nroot     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\nmysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306\n[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld\n```\n13.设置数据库root用户密码\n\nMySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！\n\n``` shell\n[root@graychen mysql-5.7.13]# mysql_secure_installation\n```\n## php源码安装\n\n1.安装编译源码\n``` shell\nwget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror\ntar jxvf php-7.1.4.tar.bz2 \nbzip2 -d php-7.1.4.tar.bz2 \ncd php-7.1.4/\n./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr\nsudo make test\nsudo make install\n```\n2.配置php.ini\n```\ncp php.ini-development /usr/local/php/etc/php.ini\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n3.配置php-fpm.conf\n```\ncd /usr/local/php/etc/\nmv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n4.配置php-fpm开机启动\n```\ncd ~/src/php-7.1.4/sapi/fpm\nsudo cp init.d.php-fpm /etc/init.d/php-fpm\nsudo chmod +x /etc/init.d/php-fpm \nchkconfig --add php-fpm\nsystemctl --add php-fpm\nsudo /sbin/chkconfig\nsudo vi /etc/init.d/php-fpm\nupdate-rc.d -f php-fpm defaults\nrunlevel\nsudo service php-fpm start\n```\n## nginx源码安装\n1.下载源码\n```\nwget http://nginx.org/download/nginx-1.11.2.tar.gz\ntar -xzvf nginx-1.11.2.tar.gz -C /usr/src\n```\n2.安装依赖\n```\nsudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev\n```\n3.编译安装源码\n```\ncd /usr/src/nginx-1.11.2\n# 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译\n./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module\n# make是生成在objs目录中，make install则安装到prefix所示的目录中\nmake && make install\n# 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。\n```\n>成功安装后，进入/usr/local/nginx，可以看到4个目录：\n```\nroot@graychen:/usr/local/nginx# ll\ntotal 44\ndrwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./\ndrwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/\n```\n其中，\n\n conf：放置nginx相关的配置文件，最核心的是nginx.conf\n html：默认的网站根目录\n logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)\n sbin：主程序(nginx)目录\n4.配置Nginx开机自启动\nUbuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下\n> * vi /etc/init.d/nginx ,其中具体的脚本展示如下：\n```\n[plain] view plain copy\n\n #!/bin/bash\n # nginx Startup script for the Nginx HTTP Server\n # it is v.0.0.2 version.\n # chkconfig: - 85 15\n # description: Nginx is a high-performance web and proxy server.\n #              It has a lot of features, but it's not for everyone.\n # processname: nginx\n # pidfile: /var/run/nginx.pid\n # config: /usr/local/nginx/conf/nginx.conf\n\n #注意：这里的三个变量需要根据具体的环境而做修改。\n nginxd=/opt/nginx/sbin/nginx\n nginx_config=/opt/nginx/conf/nginx.conf\n nginx_pid=/opt/nginx/logs/nginx.pid\n RETVAL=0\n prog=\"nginx\"\n\n # Check that networking is up.\n [ -x $nginxd  ] || exit 0\n # Start nginx daemons functions.\n start() {\n     if [ -e $nginx_pid  ];then\n        echo \"nginx already running....\"\n        exit 1\n     fi\n        echo -n $\"Starting $prog: \"\n        $nginxd -c ${nginx_config}\n        RETVAL=$?\n        echo\n        [ $RETVAL = 0  ]\n        return $RETVAL\n     \n}\n # Stop nginx daemons functions.\n stop() {\n       echo -n $\"Stopping $prog: \"\n       $nginxd -s stop\n       RETVAL=$?\n       echo\n       [ $RETVAL = 0  ] && rm -f /var/lock/subsys/nginx $nginx_pid\n     \n}\n # reload nginx service functions.\n reload() {\n       echo -n $\"Reloading $prog: \"\n       kill -HUP `cat ${nginx_pid}`\n       RETVAL=$?\n       echo\n     \n}\n # See how we were called.\n case \"$1\" in\n   start)\n           start\n           ;;\n   stop)\n           stop\n           ;;\n   reload)\n           reload\n           ;;\n   restart)\n           stop\n           start\n           ;;\n   status)\n           status $prog\n           RETVAL=$?\n           ;;\n   *)\n           echo $\"Usage: $prog {start|stop|restart|reload|status|help}\"\n           exit 1\n esac\n exit $RETVAL\n```\n> * sudo chmod a+x /etc/init.d/nginx\n> * 在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start\n最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。\n\n\n到这里整个LNMP已经安装完成.\n## nginx和php的关联\n下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:\n``` shell\ncp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development\ncp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf\nln -s /usr/local/php/bin/php /usr/bin/\n```\n配置php-fpm,编辑php-fpm.conf\n\n``` shell\nvi /usr/local/php/etc/php-fpm.conf\n```\n找到listen那一行,修改成如下内容:\n\n``` shell\nlisten = /var/run/php-fpm/php-fpm.sock   # 使用unix socket\n```\n启动php-fpm\n\n``` shell\nmkdir /var/run/php-fpm\n/usr/local/php/sbin/php-fpm\n```\n然后配置nginx,编辑nginx配置文件\n\n``` shell\nvi /usr/local/nginx/conf/nginx.conf\n```\n修改nginx配置文件支持php:\n``` shell\nserver {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.php index.html index.htm;         # 添加index.php的首页文件\n        }\n\n        # 添加下面内容\n        location ~ \\.php$ {\n            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;\n            fastcgi_index       index.php;\n            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;\n            include fastcgi_params;\n            include fastcgi.conf;\n}\n```\n修改完毕后保存退出重启nginx:\n\npkill -9 nignx\n/usr/local/nginx/sbin/nginx\n然后在/usr/local/nginx/html下创建index.php,\n\nvi /usr/local/nginx/html/index.php\n添加下面内容:\n``` php\n<?php\nphpinfo();\n?>\n} \n```\n保存退出后访问http://localhost/index.php,看到下面页面表示已经安装配置成功:\n\n![php页面](/assets/blogImg/php.png)\n\n\n","source":"_posts/lnmp源码搭建.md","raw":"---\ntitle: lnmp源码搭建\ndate: 2017-05-08 22:47:02\ncategories: 技术\n---\n## mysql源码安装\n1.安装编译源码需要的包\n``` shell\nsudo apt-get install make cmake gcc g++ bison libncurses5-dev\n```\n2.下载相应源码包\n``` shell\n[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz\n[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz\n```\n3.新建MySQL用户和用户组\n``` shell\n[root@graychen ~]# groupadd -r mysql && useradd -r -g mysql -s /sbin/nologin -M mysql\n```\n4.预编译\n\n``` shell\n[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz\n[root@graychen data]# md5sum mysql-5.7.13.tar.gz \n8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz\n[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz\n[root@graychen data]# mkdir -p /data/mysql\n[root@graychen data]# cd mysql-5.7.13\n[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\n-DMYSQL_DATADIR=/data/mysql \\\n-DWITH_BOOST=../boost_1_59_0 \\\n-DSYSCONFDIR=/etc \\\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\n-DWITH_PARTITION_STORAGE_ENGINE=1 \\\n-DWITH_FEDERATED_STORAGE_ENGINE=1 \\\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\n-DWITH_MYISAM_STORAGE_ENGINE=1 \\\n-DENABLED_LOCAL_INFILE=1 \\\n-DENABLE_DTRACE=0 \\\n-DDEFAULT_CHARSET=utf8mb4 \\\n-DDEFAULT_COLLATION=utf8mb4_general_ci \\\n-DWITH_EMBEDDED_SERVER=1\n```\n5.编译安装\n\n<!--more-->\n``` shell\n[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`\n#编译很消耗系统资源，小内存可能编译通不过make install\n[root@graychen mysql-5.7.13]# make install\n```\n6.设置启动脚本，开机自启动\n\n``` shell\n[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql\n[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# systemctl enable mysqld\nmysqld.service is not a native service, redirecting to /sbin/chkconfig.\nExecuting /sbin/chkconfig mysqld on\n```\n7.配置文件\n\n``` shell\n/etc/my.cnf，仅供参考 \n[root@graychen mysql-5.7.13]# cat > /etc/my.cnf << EOF\n[client]\nport = 3306\nsocket = /dev/shm/mysql.sock\n[mysqld]\nport = 3306\nsocket = /dev/shm/mysql.sock\nbasedir = /usr/local/mysql\ndatadir = /data/mysql\npid-file = /data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\ninit-connect = 'SET NAMES utf8mb4'\ncharacter-set-server = utf8mb4\n#skip-name-resolve\n#skip-networking\nback_log = 300\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\nthread_cache_size = 8\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\nft_min_word_len = 4\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\nlog_error = /data/mysql/mysql-error.log\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /data/mysql/mysql-slow.log\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n#lower_case_table_names = 1\nskip-external-locking\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\ninteractive_timeout = 28800\nwait_timeout = 28800\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\nEOF\n```\n9.添加mysql的环境变量\n\n``` shell\n[root@graychen mysql-5.7.13]# echo -e '\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n' >> /etc/profile && source /etc/profile\n```\n10.初始化数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql\n```\n11.启动数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# systemctl start mysqld\n[root@graychen mysql-5.7.13]# systemctl status mysqld\n● mysqld.service - LSB: start and stop MySQL\nLoaded: loaded (/etc/rc.d/init.d/mysqld)\nActive: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago\nDocs: man:systemd-sysv-generator(8)\nProcess: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)\nCGroup: /system.slice/mysqld.service\n├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\n└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...\n\n7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...\n7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]\n7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.\n```\n12.查看MySQL服务进程和端口\n``` shell\n[root@graychen mysql-5.7.13]# ps -ef | grep mysql\nroot     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\nmysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306\n[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld\n```\n13.设置数据库root用户密码\n\nMySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！\n\n``` shell\n[root@graychen mysql-5.7.13]# mysql_secure_installation\n```\n## php源码安装\n\n1.安装编译源码\n``` shell\nwget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror\ntar jxvf php-7.1.4.tar.bz2 \nbzip2 -d php-7.1.4.tar.bz2 \ncd php-7.1.4/\n./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr\nsudo make test\nsudo make install\n```\n2.配置php.ini\n```\ncp php.ini-development /usr/local/php/etc/php.ini\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n3.配置php-fpm.conf\n```\ncd /usr/local/php/etc/\nmv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n4.配置php-fpm开机启动\n```\ncd ~/src/php-7.1.4/sapi/fpm\nsudo cp init.d.php-fpm /etc/init.d/php-fpm\nsudo chmod +x /etc/init.d/php-fpm \nchkconfig --add php-fpm\nsystemctl --add php-fpm\nsudo /sbin/chkconfig\nsudo vi /etc/init.d/php-fpm\nupdate-rc.d -f php-fpm defaults\nrunlevel\nsudo service php-fpm start\n```\n## nginx源码安装\n1.下载源码\n```\nwget http://nginx.org/download/nginx-1.11.2.tar.gz\ntar -xzvf nginx-1.11.2.tar.gz -C /usr/src\n```\n2.安装依赖\n```\nsudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev\n```\n3.编译安装源码\n```\ncd /usr/src/nginx-1.11.2\n# 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译\n./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module\n# make是生成在objs目录中，make install则安装到prefix所示的目录中\nmake && make install\n# 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。\n```\n>成功安装后，进入/usr/local/nginx，可以看到4个目录：\n```\nroot@graychen:/usr/local/nginx# ll\ntotal 44\ndrwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./\ndrwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/\n```\n其中，\n\n conf：放置nginx相关的配置文件，最核心的是nginx.conf\n html：默认的网站根目录\n logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)\n sbin：主程序(nginx)目录\n4.配置Nginx开机自启动\nUbuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下\n> * vi /etc/init.d/nginx ,其中具体的脚本展示如下：\n```\n[plain] view plain copy\n\n #!/bin/bash\n # nginx Startup script for the Nginx HTTP Server\n # it is v.0.0.2 version.\n # chkconfig: - 85 15\n # description: Nginx is a high-performance web and proxy server.\n #              It has a lot of features, but it's not for everyone.\n # processname: nginx\n # pidfile: /var/run/nginx.pid\n # config: /usr/local/nginx/conf/nginx.conf\n\n #注意：这里的三个变量需要根据具体的环境而做修改。\n nginxd=/opt/nginx/sbin/nginx\n nginx_config=/opt/nginx/conf/nginx.conf\n nginx_pid=/opt/nginx/logs/nginx.pid\n RETVAL=0\n prog=\"nginx\"\n\n # Check that networking is up.\n [ -x $nginxd  ] || exit 0\n # Start nginx daemons functions.\n start() {\n     if [ -e $nginx_pid  ];then\n        echo \"nginx already running....\"\n        exit 1\n     fi\n        echo -n $\"Starting $prog: \"\n        $nginxd -c ${nginx_config}\n        RETVAL=$?\n        echo\n        [ $RETVAL = 0  ]\n        return $RETVAL\n     \n}\n # Stop nginx daemons functions.\n stop() {\n       echo -n $\"Stopping $prog: \"\n       $nginxd -s stop\n       RETVAL=$?\n       echo\n       [ $RETVAL = 0  ] && rm -f /var/lock/subsys/nginx $nginx_pid\n     \n}\n # reload nginx service functions.\n reload() {\n       echo -n $\"Reloading $prog: \"\n       kill -HUP `cat ${nginx_pid}`\n       RETVAL=$?\n       echo\n     \n}\n # See how we were called.\n case \"$1\" in\n   start)\n           start\n           ;;\n   stop)\n           stop\n           ;;\n   reload)\n           reload\n           ;;\n   restart)\n           stop\n           start\n           ;;\n   status)\n           status $prog\n           RETVAL=$?\n           ;;\n   *)\n           echo $\"Usage: $prog {start|stop|restart|reload|status|help}\"\n           exit 1\n esac\n exit $RETVAL\n```\n> * sudo chmod a+x /etc/init.d/nginx\n> * 在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start\n最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。\n\n\n到这里整个LNMP已经安装完成.\n## nginx和php的关联\n下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:\n``` shell\ncp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development\ncp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf\nln -s /usr/local/php/bin/php /usr/bin/\n```\n配置php-fpm,编辑php-fpm.conf\n\n``` shell\nvi /usr/local/php/etc/php-fpm.conf\n```\n找到listen那一行,修改成如下内容:\n\n``` shell\nlisten = /var/run/php-fpm/php-fpm.sock   # 使用unix socket\n```\n启动php-fpm\n\n``` shell\nmkdir /var/run/php-fpm\n/usr/local/php/sbin/php-fpm\n```\n然后配置nginx,编辑nginx配置文件\n\n``` shell\nvi /usr/local/nginx/conf/nginx.conf\n```\n修改nginx配置文件支持php:\n``` shell\nserver {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.php index.html index.htm;         # 添加index.php的首页文件\n        }\n\n        # 添加下面内容\n        location ~ \\.php$ {\n            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;\n            fastcgi_index       index.php;\n            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;\n            include fastcgi_params;\n            include fastcgi.conf;\n}\n```\n修改完毕后保存退出重启nginx:\n\npkill -9 nignx\n/usr/local/nginx/sbin/nginx\n然后在/usr/local/nginx/html下创建index.php,\n\nvi /usr/local/nginx/html/index.php\n添加下面内容:\n``` php\n<?php\nphpinfo();\n?>\n} \n```\n保存退出后访问http://localhost/index.php,看到下面页面表示已经安装配置成功:\n\n![php页面](/assets/blogImg/php.png)\n\n\n","slug":"lnmp源码搭建","published":1,"updated":"2018-05-27T09:59:36.026Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjm0015th8l72otjamd","content":"<h2 id=\"mysql源码安装\"><a href=\"#mysql源码安装\" class=\"headerlink\" title=\"mysql源码安装\"></a>mysql源码安装</h2><p>1.安装编译源码需要的包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install make cmake gcc g++ bison libncurses5-dev</span><br></pre></td></tr></table></figure></p>\n<p>2.下载相应源码包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz</span><br><span class=\"line\">[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz</span><br></pre></td></tr></table></figure></p>\n<p>3.新建MySQL用户和用户组<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen ~]# groupadd -r mysql &amp;&amp; useradd -r -g mysql -s /sbin/nologin -M mysql</span><br></pre></td></tr></table></figure></p>\n<p>4.预编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz</span><br><span class=\"line\">[root@graychen data]# md5sum mysql-5.7.13.tar.gz </span><br><span class=\"line\">8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz</span><br><span class=\"line\">[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz</span><br><span class=\"line\">[root@graychen data]# mkdir -p /data/mysql</span><br><span class=\"line\">[root@graychen data]# cd mysql-5.7.13</span><br><span class=\"line\">[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\</span><br><span class=\"line\">-DMYSQL_DATADIR=/data/mysql \\</span><br><span class=\"line\">-DWITH_BOOST=../boost_1_59_0 \\</span><br><span class=\"line\">-DSYSCONFDIR=/etc \\</span><br><span class=\"line\">-DWITH_INNOBASE_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_PARTITION_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_FEDERATED_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_MYISAM_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DENABLED_LOCAL_INFILE=1 \\</span><br><span class=\"line\">-DENABLE_DTRACE=0 \\</span><br><span class=\"line\">-DDEFAULT_CHARSET=utf8mb4 \\</span><br><span class=\"line\">-DDEFAULT_COLLATION=utf8mb4_general_ci \\</span><br><span class=\"line\">-DWITH_EMBEDDED_SERVER=1</span><br></pre></td></tr></table></figure>\n<p>5.编译安装</p>\n<a id=\"more\"></a>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">编译很消耗系统资源，小内存可能编译通不过make install</span></span><br><span class=\"line\">[root@graychen mysql-5.7.13]# make install</span><br></pre></td></tr></table></figure>\n<p>6.设置启动脚本，开机自启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# systemctl enable mysqld</span><br><span class=\"line\">mysqld.service is not a native service, redirecting to /sbin/chkconfig.</span><br><span class=\"line\">Executing /sbin/chkconfig mysqld on</span><br></pre></td></tr></table></figure>\n<p>7.配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/my.cnf，仅供参考 </span><br><span class=\"line\">[root@graychen mysql-5.7.13]# cat &gt; /etc/my.cnf &lt;&lt; EOF</span><br><span class=\"line\">[client]</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket = /dev/shm/mysql.sock</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket = /dev/shm/mysql.sock</span><br><span class=\"line\">basedir = /usr/local/mysql</span><br><span class=\"line\">datadir = /data/mysql</span><br><span class=\"line\">pid-file = /data/mysql/mysql.pid</span><br><span class=\"line\">user = mysql</span><br><span class=\"line\">bind-address = 0.0.0.0</span><br><span class=\"line\">server-id = 1</span><br><span class=\"line\">init-connect = 'SET NAMES utf8mb4'</span><br><span class=\"line\">character-set-server = utf8mb4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">skip-name-resolve</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">skip-networking</span></span><br><span class=\"line\">back_log = 300</span><br><span class=\"line\">max_connections = 1000</span><br><span class=\"line\">max_connect_errors = 6000</span><br><span class=\"line\">open_files_limit = 65535</span><br><span class=\"line\">table_open_cache = 128</span><br><span class=\"line\">max_allowed_packet = 4M</span><br><span class=\"line\">binlog_cache_size = 1M</span><br><span class=\"line\">max_heap_table_size = 8M</span><br><span class=\"line\">tmp_table_size = 16M</span><br><span class=\"line\">read_buffer_size = 2M</span><br><span class=\"line\">read_rnd_buffer_size = 8M</span><br><span class=\"line\">sort_buffer_size = 8M</span><br><span class=\"line\">join_buffer_size = 8M</span><br><span class=\"line\">key_buffer_size = 4M</span><br><span class=\"line\">thread_cache_size = 8</span><br><span class=\"line\">query_cache_type = 1</span><br><span class=\"line\">query_cache_size = 8M</span><br><span class=\"line\">query_cache_limit = 2M</span><br><span class=\"line\">ft_min_word_len = 4</span><br><span class=\"line\">log_bin = mysql-bin</span><br><span class=\"line\">binlog_format = mixed</span><br><span class=\"line\">expire_logs_days = 30</span><br><span class=\"line\">log_error = /data/mysql/mysql-error.log</span><br><span class=\"line\">slow_query_log = 1</span><br><span class=\"line\">long_query_time = 1</span><br><span class=\"line\">slow_query_log_file = /data/mysql/mysql-slow.log</span><br><span class=\"line\">performance_schema = 0</span><br><span class=\"line\">explicit_defaults_for_timestamp</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">lower_case_table_names = 1</span></span><br><span class=\"line\">skip-external-locking</span><br><span class=\"line\">default_storage_engine = InnoDB</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">default-storage-engine = MyISAM</span></span><br><span class=\"line\">innodb_file_per_table = 1</span><br><span class=\"line\">innodb_open_files = 500</span><br><span class=\"line\">innodb_buffer_pool_size = 64M</span><br><span class=\"line\">innodb_write_io_threads = 4</span><br><span class=\"line\">innodb_read_io_threads = 4</span><br><span class=\"line\">innodb_thread_concurrency = 0</span><br><span class=\"line\">innodb_purge_threads = 1</span><br><span class=\"line\">innodb_flush_log_at_trx_commit = 2</span><br><span class=\"line\">innodb_log_buffer_size = 2M</span><br><span class=\"line\">innodb_log_file_size = 32M</span><br><span class=\"line\">innodb_log_files_in_group = 3</span><br><span class=\"line\">innodb_max_dirty_pages_pct = 90</span><br><span class=\"line\">innodb_lock_wait_timeout = 120</span><br><span class=\"line\">bulk_insert_buffer_size = 8M</span><br><span class=\"line\">myisam_sort_buffer_size = 8M</span><br><span class=\"line\">myisam_max_sort_file_size = 10G</span><br><span class=\"line\">myisam_repair_threads = 1</span><br><span class=\"line\">interactive_timeout = 28800</span><br><span class=\"line\">wait_timeout = 28800</span><br><span class=\"line\">[mysqldump]</span><br><span class=\"line\">quick</span><br><span class=\"line\">max_allowed_packet = 16M</span><br><span class=\"line\">[myisamchk]</span><br><span class=\"line\">key_buffer_size = 8M</span><br><span class=\"line\">sort_buffer_size = 8M</span><br><span class=\"line\">read_buffer = 4M</span><br><span class=\"line\">write_buffer = 4M</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<p>9.添加mysql的环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# echo -e '\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n' &gt;&gt; /etc/profile &amp;&amp; source /etc/profile</span><br></pre></td></tr></table></figure>\n<p>10.初始化数据库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql</span><br></pre></td></tr></table></figure>\n<p>11.启动数据库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# systemctl start mysqld</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# systemctl status mysqld</span><br><span class=\"line\">● mysqld.service - LSB: start and stop MySQL</span><br><span class=\"line\">Loaded: loaded (/etc/rc.d/init.d/mysqld)</span><br><span class=\"line\">Active: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago</span><br><span class=\"line\">Docs: man:systemd-sysv-generator(8)</span><br><span class=\"line\">Process: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)</span><br><span class=\"line\">CGroup: /system.slice/mysqld.service</span><br><span class=\"line\">├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</span><br><span class=\"line\">└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...</span><br><span class=\"line\"></span><br><span class=\"line\">7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...</span><br><span class=\"line\">7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]</span><br><span class=\"line\">7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.</span><br></pre></td></tr></table></figure>\n<p>12.查看MySQL服务进程和端口<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# ps -ef | grep mysql</span><br><span class=\"line\">root     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</span><br><span class=\"line\">mysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306</span><br><span class=\"line\">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld</span><br></pre></td></tr></table></figure></p>\n<p>13.设置数据库root用户密码</p>\n<p>MySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# mysql_secure_installation</span><br></pre></td></tr></table></figure>\n<h2 id=\"php源码安装\"><a href=\"#php源码安装\" class=\"headerlink\" title=\"php源码安装\"></a>php源码安装</h2><p>1.安装编译源码<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror</span><br><span class=\"line\">tar jxvf php-7.1.4.tar.bz2 </span><br><span class=\"line\">bzip2 -d php-7.1.4.tar.bz2 </span><br><span class=\"line\">cd php-7.1.4/</span><br><span class=\"line\">./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr</span><br><span class=\"line\">sudo make test</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></p>\n<p>2.配置php.ini<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp php.ini-development /usr/local/php/etc/php.ini</span><br><span class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br></pre></td></tr></table></figure></p>\n<p>3.配置php-fpm.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/php/etc/</span><br><span class=\"line\">mv php-fpm.conf.default php-fpm.conf</span><br><span class=\"line\">sudo mv php-fpm.conf.default php-fpm.conf</span><br><span class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br></pre></td></tr></table></figure></p>\n<p>4.配置php-fpm开机启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/src/php-7.1.4/sapi/fpm</span><br><span class=\"line\">sudo cp init.d.php-fpm /etc/init.d/php-fpm</span><br><span class=\"line\">sudo chmod +x /etc/init.d/php-fpm </span><br><span class=\"line\">chkconfig --add php-fpm</span><br><span class=\"line\">systemctl --add php-fpm</span><br><span class=\"line\">sudo /sbin/chkconfig</span><br><span class=\"line\">sudo vi /etc/init.d/php-fpm</span><br><span class=\"line\">update-rc.d -f php-fpm defaults</span><br><span class=\"line\">runlevel</span><br><span class=\"line\">sudo service php-fpm start</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"nginx源码安装\"><a href=\"#nginx源码安装\" class=\"headerlink\" title=\"nginx源码安装\"></a>nginx源码安装</h2><p>1.下载源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nginx.org/download/nginx-1.11.2.tar.gz</span><br><span class=\"line\">tar -xzvf nginx-1.11.2.tar.gz -C /usr/src</span><br></pre></td></tr></table></figure></p>\n<p>2.安装依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev</span><br></pre></td></tr></table></figure></p>\n<p>3.编译安装源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/src/nginx-1.11.2</span><br><span class=\"line\"># 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译</span><br><span class=\"line\">./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module</span><br><span class=\"line\"># make是生成在objs目录中，make install则安装到prefix所示的目录中</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"># 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>成功安装后，进入/usr/local/nginx，可以看到4个目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@graychen:/usr/local/nginx# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">drwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./</span><br><span class=\"line\">drwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>其中，</p>\n<p> conf：放置nginx相关的配置文件，最核心的是nginx.conf<br> html：默认的网站根目录<br> logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)<br> sbin：主程序(nginx)目录<br>4.配置Nginx开机自启动<br>Ubuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下</p>\n<blockquote>\n<ul>\n<li>vi /etc/init.d/nginx ,其中具体的脚本展示如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[plain] view plain copy</span><br><span class=\"line\"></span><br><span class=\"line\"> #!/bin/bash</span><br><span class=\"line\"> # nginx Startup script for the Nginx HTTP Server</span><br><span class=\"line\"> # it is v.0.0.2 version.</span><br><span class=\"line\"> # chkconfig: - 85 15</span><br><span class=\"line\"> # description: Nginx is a high-performance web and proxy server.</span><br><span class=\"line\"> #              It has a lot of features, but it&apos;s not for everyone.</span><br><span class=\"line\"> # processname: nginx</span><br><span class=\"line\"> # pidfile: /var/run/nginx.pid</span><br><span class=\"line\"> # config: /usr/local/nginx/conf/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\"> #注意：这里的三个变量需要根据具体的环境而做修改。</span><br><span class=\"line\"> nginxd=/opt/nginx/sbin/nginx</span><br><span class=\"line\"> nginx_config=/opt/nginx/conf/nginx.conf</span><br><span class=\"line\"> nginx_pid=/opt/nginx/logs/nginx.pid</span><br><span class=\"line\"> RETVAL=0</span><br><span class=\"line\"> prog=&quot;nginx&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> # Check that networking is up.</span><br><span class=\"line\"> [ -x $nginxd  ] || exit 0</span><br><span class=\"line\"> # Start nginx daemons functions.</span><br><span class=\"line\"> start() &#123;</span><br><span class=\"line\">     if [ -e $nginx_pid  ];then</span><br><span class=\"line\">        echo &quot;nginx already running....&quot;</span><br><span class=\"line\">        exit 1</span><br><span class=\"line\">     fi</span><br><span class=\"line\">        echo -n $&quot;Starting $prog: &quot;</span><br><span class=\"line\">        $nginxd -c $&#123;nginx_config&#125;</span><br><span class=\"line\">        RETVAL=$?</span><br><span class=\"line\">        echo</span><br><span class=\"line\">        [ $RETVAL = 0  ]</span><br><span class=\"line\">        return $RETVAL</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> # Stop nginx daemons functions.</span><br><span class=\"line\"> stop() &#123;</span><br><span class=\"line\">       echo -n $&quot;Stopping $prog: &quot;</span><br><span class=\"line\">       $nginxd -s stop</span><br><span class=\"line\">       RETVAL=$?</span><br><span class=\"line\">       echo</span><br><span class=\"line\">       [ $RETVAL = 0  ] &amp;&amp; rm -f /var/lock/subsys/nginx $nginx_pid</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> # reload nginx service functions.</span><br><span class=\"line\"> reload() &#123;</span><br><span class=\"line\">       echo -n $&quot;Reloading $prog: &quot;</span><br><span class=\"line\">       kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class=\"line\">       RETVAL=$?</span><br><span class=\"line\">       echo</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> # See how we were called.</span><br><span class=\"line\"> case &quot;$1&quot; in</span><br><span class=\"line\">   start)</span><br><span class=\"line\">           start</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   stop)</span><br><span class=\"line\">           stop</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   reload)</span><br><span class=\"line\">           reload</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   restart)</span><br><span class=\"line\">           stop</span><br><span class=\"line\">           start</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   status)</span><br><span class=\"line\">           status $prog</span><br><span class=\"line\">           RETVAL=$?</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   *)</span><br><span class=\"line\">           echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class=\"line\">           exit 1</span><br><span class=\"line\"> esac</span><br><span class=\"line\"> exit $RETVAL</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>sudo chmod a+x /etc/init.d/nginx</li>\n<li>在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start<br>最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。</li>\n</ul>\n</blockquote>\n<p>到这里整个LNMP已经安装完成.</p>\n<h2 id=\"nginx和php的关联\"><a href=\"#nginx和php的关联\" class=\"headerlink\" title=\"nginx和php的关联\"></a>nginx和php的关联</h2><p>下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development</span><br><span class=\"line\">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</span><br><span class=\"line\">ln -s /usr/local/php/bin/php /usr/bin/</span><br></pre></td></tr></table></figure></p>\n<p>配置php-fpm,编辑php-fpm.conf</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/local/php/etc/php-fpm.conf</span><br></pre></td></tr></table></figure>\n<p>找到listen那一行,修改成如下内容:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen = /var/run/php-fpm/php-fpm.sock   # 使用unix socket</span><br></pre></td></tr></table></figure>\n<p>启动php-fpm</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /var/run/php-fpm</span><br><span class=\"line\">/usr/local/php/sbin/php-fpm</span><br></pre></td></tr></table></figure>\n<p>然后配置nginx,编辑nginx配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<p>修改nginx配置文件支持php:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.php index.html index.htm;         # 添加index.php的首页文件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 添加下面内容</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;</span><br><span class=\"line\">            fastcgi_index       index.php;</span><br><span class=\"line\">            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;</span><br><span class=\"line\">            include fastcgi_params;</span><br><span class=\"line\">            include fastcgi.conf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改完毕后保存退出重启nginx:</p>\n<p>pkill -9 nignx<br>/usr/local/nginx/sbin/nginx<br>然后在/usr/local/nginx/html下创建index.php,</p>\n<p>vi /usr/local/nginx/html/index.php<br>添加下面内容:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>保存退出后访问<a href=\"http://localhost/index.php,看到下面页面表示已经安装配置成功\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php,看到下面页面表示已经安装配置成功</a>:</p>\n<p><img src=\"/assets/blogImg/php.png\" alt=\"php页面\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"mysql源码安装\"><a href=\"#mysql源码安装\" class=\"headerlink\" title=\"mysql源码安装\"></a>mysql源码安装</h2><p>1.安装编译源码需要的包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install make cmake gcc g++ bison libncurses5-dev</span><br></pre></td></tr></table></figure></p>\n<p>2.下载相应源码包<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz</span><br><span class=\"line\">[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz</span><br></pre></td></tr></table></figure></p>\n<p>3.新建MySQL用户和用户组<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen ~]# groupadd -r mysql &amp;&amp; useradd -r -g mysql -s /sbin/nologin -M mysql</span><br></pre></td></tr></table></figure></p>\n<p>4.预编译</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz</span><br><span class=\"line\">[root@graychen data]# md5sum mysql-5.7.13.tar.gz </span><br><span class=\"line\">8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz</span><br><span class=\"line\">[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz</span><br><span class=\"line\">[root@graychen data]# mkdir -p /data/mysql</span><br><span class=\"line\">[root@graychen data]# cd mysql-5.7.13</span><br><span class=\"line\">[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\</span><br><span class=\"line\">-DMYSQL_DATADIR=/data/mysql \\</span><br><span class=\"line\">-DWITH_BOOST=../boost_1_59_0 \\</span><br><span class=\"line\">-DSYSCONFDIR=/etc \\</span><br><span class=\"line\">-DWITH_INNOBASE_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_PARTITION_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_FEDERATED_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DWITH_MYISAM_STORAGE_ENGINE=1 \\</span><br><span class=\"line\">-DENABLED_LOCAL_INFILE=1 \\</span><br><span class=\"line\">-DENABLE_DTRACE=0 \\</span><br><span class=\"line\">-DDEFAULT_CHARSET=utf8mb4 \\</span><br><span class=\"line\">-DDEFAULT_COLLATION=utf8mb4_general_ci \\</span><br><span class=\"line\">-DWITH_EMBEDDED_SERVER=1</span><br></pre></td></tr></table></figure>\n<p>5.编译安装</p>","more":"<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">编译很消耗系统资源，小内存可能编译通不过make install</span></span><br><span class=\"line\">[root@graychen mysql-5.7.13]# make install</span><br></pre></td></tr></table></figure>\n<p>6.设置启动脚本，开机自启动</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# systemctl enable mysqld</span><br><span class=\"line\">mysqld.service is not a native service, redirecting to /sbin/chkconfig.</span><br><span class=\"line\">Executing /sbin/chkconfig mysqld on</span><br></pre></td></tr></table></figure>\n<p>7.配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">/etc/my.cnf，仅供参考 </span><br><span class=\"line\">[root@graychen mysql-5.7.13]# cat &gt; /etc/my.cnf &lt;&lt; EOF</span><br><span class=\"line\">[client]</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket = /dev/shm/mysql.sock</span><br><span class=\"line\">[mysqld]</span><br><span class=\"line\">port = 3306</span><br><span class=\"line\">socket = /dev/shm/mysql.sock</span><br><span class=\"line\">basedir = /usr/local/mysql</span><br><span class=\"line\">datadir = /data/mysql</span><br><span class=\"line\">pid-file = /data/mysql/mysql.pid</span><br><span class=\"line\">user = mysql</span><br><span class=\"line\">bind-address = 0.0.0.0</span><br><span class=\"line\">server-id = 1</span><br><span class=\"line\">init-connect = 'SET NAMES utf8mb4'</span><br><span class=\"line\">character-set-server = utf8mb4</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">skip-name-resolve</span></span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">skip-networking</span></span><br><span class=\"line\">back_log = 300</span><br><span class=\"line\">max_connections = 1000</span><br><span class=\"line\">max_connect_errors = 6000</span><br><span class=\"line\">open_files_limit = 65535</span><br><span class=\"line\">table_open_cache = 128</span><br><span class=\"line\">max_allowed_packet = 4M</span><br><span class=\"line\">binlog_cache_size = 1M</span><br><span class=\"line\">max_heap_table_size = 8M</span><br><span class=\"line\">tmp_table_size = 16M</span><br><span class=\"line\">read_buffer_size = 2M</span><br><span class=\"line\">read_rnd_buffer_size = 8M</span><br><span class=\"line\">sort_buffer_size = 8M</span><br><span class=\"line\">join_buffer_size = 8M</span><br><span class=\"line\">key_buffer_size = 4M</span><br><span class=\"line\">thread_cache_size = 8</span><br><span class=\"line\">query_cache_type = 1</span><br><span class=\"line\">query_cache_size = 8M</span><br><span class=\"line\">query_cache_limit = 2M</span><br><span class=\"line\">ft_min_word_len = 4</span><br><span class=\"line\">log_bin = mysql-bin</span><br><span class=\"line\">binlog_format = mixed</span><br><span class=\"line\">expire_logs_days = 30</span><br><span class=\"line\">log_error = /data/mysql/mysql-error.log</span><br><span class=\"line\">slow_query_log = 1</span><br><span class=\"line\">long_query_time = 1</span><br><span class=\"line\">slow_query_log_file = /data/mysql/mysql-slow.log</span><br><span class=\"line\">performance_schema = 0</span><br><span class=\"line\">explicit_defaults_for_timestamp</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">lower_case_table_names = 1</span></span><br><span class=\"line\">skip-external-locking</span><br><span class=\"line\">default_storage_engine = InnoDB</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">default-storage-engine = MyISAM</span></span><br><span class=\"line\">innodb_file_per_table = 1</span><br><span class=\"line\">innodb_open_files = 500</span><br><span class=\"line\">innodb_buffer_pool_size = 64M</span><br><span class=\"line\">innodb_write_io_threads = 4</span><br><span class=\"line\">innodb_read_io_threads = 4</span><br><span class=\"line\">innodb_thread_concurrency = 0</span><br><span class=\"line\">innodb_purge_threads = 1</span><br><span class=\"line\">innodb_flush_log_at_trx_commit = 2</span><br><span class=\"line\">innodb_log_buffer_size = 2M</span><br><span class=\"line\">innodb_log_file_size = 32M</span><br><span class=\"line\">innodb_log_files_in_group = 3</span><br><span class=\"line\">innodb_max_dirty_pages_pct = 90</span><br><span class=\"line\">innodb_lock_wait_timeout = 120</span><br><span class=\"line\">bulk_insert_buffer_size = 8M</span><br><span class=\"line\">myisam_sort_buffer_size = 8M</span><br><span class=\"line\">myisam_max_sort_file_size = 10G</span><br><span class=\"line\">myisam_repair_threads = 1</span><br><span class=\"line\">interactive_timeout = 28800</span><br><span class=\"line\">wait_timeout = 28800</span><br><span class=\"line\">[mysqldump]</span><br><span class=\"line\">quick</span><br><span class=\"line\">max_allowed_packet = 16M</span><br><span class=\"line\">[myisamchk]</span><br><span class=\"line\">key_buffer_size = 8M</span><br><span class=\"line\">sort_buffer_size = 8M</span><br><span class=\"line\">read_buffer = 4M</span><br><span class=\"line\">write_buffer = 4M</span><br><span class=\"line\">EOF</span><br></pre></td></tr></table></figure>\n<p>9.添加mysql的环境变量</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# echo -e '\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n' &gt;&gt; /etc/profile &amp;&amp; source /etc/profile</span><br></pre></td></tr></table></figure>\n<p>10.初始化数据库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql</span><br></pre></td></tr></table></figure>\n<p>11.启动数据库</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# systemctl start mysqld</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# systemctl status mysqld</span><br><span class=\"line\">● mysqld.service - LSB: start and stop MySQL</span><br><span class=\"line\">Loaded: loaded (/etc/rc.d/init.d/mysqld)</span><br><span class=\"line\">Active: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago</span><br><span class=\"line\">Docs: man:systemd-sysv-generator(8)</span><br><span class=\"line\">Process: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)</span><br><span class=\"line\">CGroup: /system.slice/mysqld.service</span><br><span class=\"line\">├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</span><br><span class=\"line\">└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...</span><br><span class=\"line\"></span><br><span class=\"line\">7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...</span><br><span class=\"line\">7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]</span><br><span class=\"line\">7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.</span><br></pre></td></tr></table></figure>\n<p>12.查看MySQL服务进程和端口<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# ps -ef | grep mysql</span><br><span class=\"line\">root     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</span><br><span class=\"line\">mysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306</span><br><span class=\"line\">[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306</span><br><span class=\"line\">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld</span><br></pre></td></tr></table></figure></p>\n<p>13.设置数据库root用户密码</p>\n<p>MySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[root@graychen mysql-5.7.13]# mysql_secure_installation</span><br></pre></td></tr></table></figure>\n<h2 id=\"php源码安装\"><a href=\"#php源码安装\" class=\"headerlink\" title=\"php源码安装\"></a>php源码安装</h2><p>1.安装编译源码<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror</span><br><span class=\"line\">tar jxvf php-7.1.4.tar.bz2 </span><br><span class=\"line\">bzip2 -d php-7.1.4.tar.bz2 </span><br><span class=\"line\">cd php-7.1.4/</span><br><span class=\"line\">./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr</span><br><span class=\"line\">sudo make test</span><br><span class=\"line\">sudo make install</span><br></pre></td></tr></table></figure></p>\n<p>2.配置php.ini<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp php.ini-development /usr/local/php/etc/php.ini</span><br><span class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br></pre></td></tr></table></figure></p>\n<p>3.配置php-fpm.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/local/php/etc/</span><br><span class=\"line\">mv php-fpm.conf.default php-fpm.conf</span><br><span class=\"line\">sudo mv php-fpm.conf.default php-fpm.conf</span><br><span class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</span><br></pre></td></tr></table></figure></p>\n<p>4.配置php-fpm开机启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd ~/src/php-7.1.4/sapi/fpm</span><br><span class=\"line\">sudo cp init.d.php-fpm /etc/init.d/php-fpm</span><br><span class=\"line\">sudo chmod +x /etc/init.d/php-fpm </span><br><span class=\"line\">chkconfig --add php-fpm</span><br><span class=\"line\">systemctl --add php-fpm</span><br><span class=\"line\">sudo /sbin/chkconfig</span><br><span class=\"line\">sudo vi /etc/init.d/php-fpm</span><br><span class=\"line\">update-rc.d -f php-fpm defaults</span><br><span class=\"line\">runlevel</span><br><span class=\"line\">sudo service php-fpm start</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"nginx源码安装\"><a href=\"#nginx源码安装\" class=\"headerlink\" title=\"nginx源码安装\"></a>nginx源码安装</h2><p>1.下载源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">wget http://nginx.org/download/nginx-1.11.2.tar.gz</span><br><span class=\"line\">tar -xzvf nginx-1.11.2.tar.gz -C /usr/src</span><br></pre></td></tr></table></figure></p>\n<p>2.安装依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev</span><br></pre></td></tr></table></figure></p>\n<p>3.编译安装源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cd /usr/src/nginx-1.11.2</span><br><span class=\"line\"># 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译</span><br><span class=\"line\">./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module</span><br><span class=\"line\"># make是生成在objs目录中，make install则安装到prefix所示的目录中</span><br><span class=\"line\">make &amp;&amp; make install</span><br><span class=\"line\"># 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>成功安装后，进入/usr/local/nginx，可以看到4个目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">root@graychen:/usr/local/nginx# ll</span><br><span class=\"line\">total 44</span><br><span class=\"line\">drwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./</span><br><span class=\"line\">drwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/</span><br><span class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/</span><br></pre></td></tr></table></figure></p>\n</blockquote>\n<p>其中，</p>\n<p> conf：放置nginx相关的配置文件，最核心的是nginx.conf<br> html：默认的网站根目录<br> logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)<br> sbin：主程序(nginx)目录<br>4.配置Nginx开机自启动<br>Ubuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下</p>\n<blockquote>\n<ul>\n<li>vi /etc/init.d/nginx ,其中具体的脚本展示如下：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[plain] view plain copy</span><br><span class=\"line\"></span><br><span class=\"line\"> #!/bin/bash</span><br><span class=\"line\"> # nginx Startup script for the Nginx HTTP Server</span><br><span class=\"line\"> # it is v.0.0.2 version.</span><br><span class=\"line\"> # chkconfig: - 85 15</span><br><span class=\"line\"> # description: Nginx is a high-performance web and proxy server.</span><br><span class=\"line\"> #              It has a lot of features, but it&apos;s not for everyone.</span><br><span class=\"line\"> # processname: nginx</span><br><span class=\"line\"> # pidfile: /var/run/nginx.pid</span><br><span class=\"line\"> # config: /usr/local/nginx/conf/nginx.conf</span><br><span class=\"line\"></span><br><span class=\"line\"> #注意：这里的三个变量需要根据具体的环境而做修改。</span><br><span class=\"line\"> nginxd=/opt/nginx/sbin/nginx</span><br><span class=\"line\"> nginx_config=/opt/nginx/conf/nginx.conf</span><br><span class=\"line\"> nginx_pid=/opt/nginx/logs/nginx.pid</span><br><span class=\"line\"> RETVAL=0</span><br><span class=\"line\"> prog=&quot;nginx&quot;</span><br><span class=\"line\"></span><br><span class=\"line\"> # Check that networking is up.</span><br><span class=\"line\"> [ -x $nginxd  ] || exit 0</span><br><span class=\"line\"> # Start nginx daemons functions.</span><br><span class=\"line\"> start() &#123;</span><br><span class=\"line\">     if [ -e $nginx_pid  ];then</span><br><span class=\"line\">        echo &quot;nginx already running....&quot;</span><br><span class=\"line\">        exit 1</span><br><span class=\"line\">     fi</span><br><span class=\"line\">        echo -n $&quot;Starting $prog: &quot;</span><br><span class=\"line\">        $nginxd -c $&#123;nginx_config&#125;</span><br><span class=\"line\">        RETVAL=$?</span><br><span class=\"line\">        echo</span><br><span class=\"line\">        [ $RETVAL = 0  ]</span><br><span class=\"line\">        return $RETVAL</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> # Stop nginx daemons functions.</span><br><span class=\"line\"> stop() &#123;</span><br><span class=\"line\">       echo -n $&quot;Stopping $prog: &quot;</span><br><span class=\"line\">       $nginxd -s stop</span><br><span class=\"line\">       RETVAL=$?</span><br><span class=\"line\">       echo</span><br><span class=\"line\">       [ $RETVAL = 0  ] &amp;&amp; rm -f /var/lock/subsys/nginx $nginx_pid</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> # reload nginx service functions.</span><br><span class=\"line\"> reload() &#123;</span><br><span class=\"line\">       echo -n $&quot;Reloading $prog: &quot;</span><br><span class=\"line\">       kill -HUP `cat $&#123;nginx_pid&#125;`</span><br><span class=\"line\">       RETVAL=$?</span><br><span class=\"line\">       echo</span><br><span class=\"line\">     </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"> # See how we were called.</span><br><span class=\"line\"> case &quot;$1&quot; in</span><br><span class=\"line\">   start)</span><br><span class=\"line\">           start</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   stop)</span><br><span class=\"line\">           stop</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   reload)</span><br><span class=\"line\">           reload</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   restart)</span><br><span class=\"line\">           stop</span><br><span class=\"line\">           start</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   status)</span><br><span class=\"line\">           status $prog</span><br><span class=\"line\">           RETVAL=$?</span><br><span class=\"line\">           ;;</span><br><span class=\"line\">   *)</span><br><span class=\"line\">           echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</span><br><span class=\"line\">           exit 1</span><br><span class=\"line\"> esac</span><br><span class=\"line\"> exit $RETVAL</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n</blockquote>\n<blockquote>\n<ul>\n<li>sudo chmod a+x /etc/init.d/nginx</li>\n<li>在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start<br>最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。</li>\n</ul>\n</blockquote>\n<p>到这里整个LNMP已经安装完成.</p>\n<h2 id=\"nginx和php的关联\"><a href=\"#nginx和php的关联\" class=\"headerlink\" title=\"nginx和php的关联\"></a>nginx和php的关联</h2><p>下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development</span><br><span class=\"line\">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</span><br><span class=\"line\">ln -s /usr/local/php/bin/php /usr/bin/</span><br></pre></td></tr></table></figure></p>\n<p>配置php-fpm,编辑php-fpm.conf</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/local/php/etc/php-fpm.conf</span><br></pre></td></tr></table></figure>\n<p>找到listen那一行,修改成如下内容:</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">listen = /var/run/php-fpm/php-fpm.sock   # 使用unix socket</span><br></pre></td></tr></table></figure>\n<p>启动php-fpm</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mkdir /var/run/php-fpm</span><br><span class=\"line\">/usr/local/php/sbin/php-fpm</span><br></pre></td></tr></table></figure>\n<p>然后配置nginx,编辑nginx配置文件</p>\n<figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">vi /usr/local/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>\n<p>修改nginx配置文件支持php:<br><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server &#123;</span><br><span class=\"line\">        listen       80;</span><br><span class=\"line\">        server_name  localhost;</span><br><span class=\"line\"></span><br><span class=\"line\">        #charset koi8-r;</span><br><span class=\"line\"></span><br><span class=\"line\">        #access_log  logs/host.access.log  main;</span><br><span class=\"line\"></span><br><span class=\"line\">        location / &#123;</span><br><span class=\"line\">            root   html;</span><br><span class=\"line\">            index  index.php index.html index.htm;         # 添加index.php的首页文件</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        # 添加下面内容</span><br><span class=\"line\">        location ~ \\.php$ &#123;</span><br><span class=\"line\">            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;</span><br><span class=\"line\">            fastcgi_index       index.php;</span><br><span class=\"line\">            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;</span><br><span class=\"line\">            include fastcgi_params;</span><br><span class=\"line\">            include fastcgi.conf;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>修改完毕后保存退出重启nginx:</p>\n<p>pkill -9 nignx<br>/usr/local/nginx/sbin/nginx<br>然后在/usr/local/nginx/html下创建index.php,</p>\n<p>vi /usr/local/nginx/html/index.php<br>添加下面内容:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">phpinfo();</span><br><span class=\"line\"><span class=\"meta\">?&gt;</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>保存退出后访问<a href=\"http://localhost/index.php,看到下面页面表示已经安装配置成功\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php,看到下面页面表示已经安装配置成功</a>:</p>\n<p><img src=\"/assets/blogImg/php.png\" alt=\"php页面\"></p>"},{"title":"nginx配置优化","date":"2018-01-04T14:52:38.000Z","_content":"最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置\n首先我们看一份较简单的nginx.conf配置文件\n```\n#### 全局块开始 ####\nuser nobody nobody; #配置允许Nginx服务器的用户和用户组\nworker_processes 3; #配置Nginx进程生成的worker_processes数目\nerror_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径\npid nginx.pid; #配置Nginx服务允许时的错误日志存放路径\n#### 全局块结束 ####\n\n#### event开始 ####\nevents {\n        use epoll; #配置事件驱动模型\n        worker_connections 1024; #配置最大连接数\n}\n#### event结束 ####\n#### http块开始 ####\nhttp {\n        include mime.types; #定义MIME-TYPE\n        default_type application/octet-stream; \n        sendfile on; #配置允许使用sendfile方式传输\n        keepalive_timeout 65; #配置连接超时\n        log_format access.log #配置请求处理日志的分格\n        '$remote_addr-[$time_local]-\"$request\"-\"$http_user_agent\"'\n\n        gzip on; #gzip功能设置\n        gzip_min_length 1024; #响应页数据上限\n        gzip_buffers 4 16k; # 缓存空间大小\n        gzip_comp_level 2; # 压缩级别为2\n        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型\n        gzip_vary on #启用压缩标识\n        gzip_disable \"MISIE[1-6]\"; #ie1-6不开启压缩功能\n        gunzip_static no #检查预压缩文件\n        gzip_static on;\n        gzup_http_version 1.0;\n#### server块开始 ####\n        server { #配置虚拟主机1\n                listen 8081; \n                server_name myServer1; #监听端口和主机名称\n                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server1/location1 { #配置处理/server1/location1 请求的location\n                        root /myweb;\n                        index index.svr1-local.htm;\n                }\n                location /server2/location2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n        }\n        server { #配置虚拟主机2\n                listen 8082; \n                gzip off; #主机2关闭压缩\n                server_name 192.168.1.3; #监听端口和主机名称\n                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server2/location1 { #配置处理/server2/location1 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location /server2/loc2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location = /404.html {\n                        root /myweb/;\n                        index 404.html;\n                }\n        }\n#### server块结束 ####\n}\n#### http块结束 ####\n\n```\n通过这个我们认识了nginx配置的基本组成:\n- 全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入\n- event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数\n- http块：代理,缓存,日志定义,第三方模块的配置\n- server块：虚拟主机\n- location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制\n<!--more-->\n## Nginx如何处理请求\n> *同步和异步*：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。\n*阻塞和非阻塞*：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。\n\nNginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。\n## Nginx的事件驱动模型\nIO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。\n> *select*: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用--with-select_module和--without-select_module是否编译该库。\n*poll*: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。\n*epoll*: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。\n\n### 主进程:\n- 读取Nginx配置文件并验证其有效性和正确性\n- 建立，绑定和关闭Socket\n- 按照配置生成管理和结束进程\n- 接收外界指令，比如重启，升级及退出服务器等指令\n- 不中断服务，实现平滑重启，升级及退出服务\n- 开启日志文件，获取文件描述符\n- 编译和处理Perl脚本\n### 工作进程：\n- 接收客户端请求\n- 将请求一次送入各个功能模块进行过滤处理\n- IO调用，获取响应数据\n- 与后端服务器通信，接收后端服务器处理结果\n- 数据缓存，访问索引，查询和调用缓存数据\n- 发送请求结果，响应客户端请求\n- 接收主程序指令，比如重启升级和退出\n### 缓存索引重建及管理进程\n缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据\n魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期\n## 优化配置\n### 针对ipv4的内核参数配置优化\n在/etc/sysctl.conf中追加下面的参数,然后使用*/sbin/sysctl -p*命令使配置生效\n- net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目\n- net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题\n- net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击\n- net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持\n- net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 \n- net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量\n### 针对CPU的Nginx配置优化\n- worker_processes 4; #针对cpu核数\n- worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu\n### 与网络连接相关的配置\n- keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件\n- send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接\n- client_header_buffer_size 4k #客户端响应头部的缓冲区大小\n### 与事件驱动相关(event模块)\nuse epoll #事件驱动模型\nworker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2\nworker_rlimit_sigpending 1024 #Linux事件信号队列长度上限\n#### poll事件驱动\ndevpoll_change 32 #传递给内核的事件数\ndevpoll_events 32 #从内核获取事件数量\n#### kqueue事件驱动\nkqueue_changes 512 #传递给内核的事件数\nkqueue_events 512 #从内核获取事件数量\n#### epoll_events驱动\nepoll_changes 512 #发送和收到内核的事件数\n#### rtsig\nrtsig_signo signo\n###Gzip压缩(http模块)\n#### ngx_http_gip_module模块(适用于大文件下载)\ngzip on #开启压缩功能\ngzip_buffers 32 4k | 16 8k #number*size存储压缩空间\ngzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低\ngzip_disable MSIE [4-6]\\. #ie4-6不进行gzip压缩\ngzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本\ngzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩\ngzip_proxied on #开启对后端服务器返回结构的Gzip压缩\ngzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩\ngzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩\ngzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩\ngzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩\ngzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩\ngzip_proxied any #无条件开启对响应数据的压缩\ngzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能\ngzip_vary on #经过压缩处理的响应会在头部添加\"Vary:Accept-Encoding:gizp\"也可用add_header Vary Accept-Encoding gzip\n#### ngx_http_gzip_static_module模块(可确定数据长度)\n编译添加--with-http_gzip_static_module\ngzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件\ngzip_proxied no-cache no-store private auth;\n#### ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\n编译添加--with-http_gunzip_module\ngunzip_static on\ngunzip_buffers 32 4k | 16 8k\n\n\n\n\n\n\n\n\n","source":"_posts/nginx配置优化.md","raw":"---\ntitle: nginx配置优化\ndate: 2018-01-04 22:52:38\ntag: php\ncategories: 技术\n\n---\n最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置\n首先我们看一份较简单的nginx.conf配置文件\n```\n#### 全局块开始 ####\nuser nobody nobody; #配置允许Nginx服务器的用户和用户组\nworker_processes 3; #配置Nginx进程生成的worker_processes数目\nerror_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径\npid nginx.pid; #配置Nginx服务允许时的错误日志存放路径\n#### 全局块结束 ####\n\n#### event开始 ####\nevents {\n        use epoll; #配置事件驱动模型\n        worker_connections 1024; #配置最大连接数\n}\n#### event结束 ####\n#### http块开始 ####\nhttp {\n        include mime.types; #定义MIME-TYPE\n        default_type application/octet-stream; \n        sendfile on; #配置允许使用sendfile方式传输\n        keepalive_timeout 65; #配置连接超时\n        log_format access.log #配置请求处理日志的分格\n        '$remote_addr-[$time_local]-\"$request\"-\"$http_user_agent\"'\n\n        gzip on; #gzip功能设置\n        gzip_min_length 1024; #响应页数据上限\n        gzip_buffers 4 16k; # 缓存空间大小\n        gzip_comp_level 2; # 压缩级别为2\n        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型\n        gzip_vary on #启用压缩标识\n        gzip_disable \"MISIE[1-6]\"; #ie1-6不开启压缩功能\n        gunzip_static no #检查预压缩文件\n        gzip_static on;\n        gzup_http_version 1.0;\n#### server块开始 ####\n        server { #配置虚拟主机1\n                listen 8081; \n                server_name myServer1; #监听端口和主机名称\n                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server1/location1 { #配置处理/server1/location1 请求的location\n                        root /myweb;\n                        index index.svr1-local.htm;\n                }\n                location /server2/location2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n        }\n        server { #配置虚拟主机2\n                listen 8082; \n                gzip off; #主机2关闭压缩\n                server_name 192.168.1.3; #监听端口和主机名称\n                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server2/location1 { #配置处理/server2/location1 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location /server2/loc2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location = /404.html {\n                        root /myweb/;\n                        index 404.html;\n                }\n        }\n#### server块结束 ####\n}\n#### http块结束 ####\n\n```\n通过这个我们认识了nginx配置的基本组成:\n- 全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入\n- event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数\n- http块：代理,缓存,日志定义,第三方模块的配置\n- server块：虚拟主机\n- location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制\n<!--more-->\n## Nginx如何处理请求\n> *同步和异步*：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。\n*阻塞和非阻塞*：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。\n\nNginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。\n## Nginx的事件驱动模型\nIO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。\n> *select*: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用--with-select_module和--without-select_module是否编译该库。\n*poll*: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。\n*epoll*: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。\n\n### 主进程:\n- 读取Nginx配置文件并验证其有效性和正确性\n- 建立，绑定和关闭Socket\n- 按照配置生成管理和结束进程\n- 接收外界指令，比如重启，升级及退出服务器等指令\n- 不中断服务，实现平滑重启，升级及退出服务\n- 开启日志文件，获取文件描述符\n- 编译和处理Perl脚本\n### 工作进程：\n- 接收客户端请求\n- 将请求一次送入各个功能模块进行过滤处理\n- IO调用，获取响应数据\n- 与后端服务器通信，接收后端服务器处理结果\n- 数据缓存，访问索引，查询和调用缓存数据\n- 发送请求结果，响应客户端请求\n- 接收主程序指令，比如重启升级和退出\n### 缓存索引重建及管理进程\n缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据\n魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期\n## 优化配置\n### 针对ipv4的内核参数配置优化\n在/etc/sysctl.conf中追加下面的参数,然后使用*/sbin/sysctl -p*命令使配置生效\n- net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目\n- net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题\n- net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击\n- net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持\n- net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 \n- net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量\n### 针对CPU的Nginx配置优化\n- worker_processes 4; #针对cpu核数\n- worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu\n### 与网络连接相关的配置\n- keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件\n- send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接\n- client_header_buffer_size 4k #客户端响应头部的缓冲区大小\n### 与事件驱动相关(event模块)\nuse epoll #事件驱动模型\nworker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2\nworker_rlimit_sigpending 1024 #Linux事件信号队列长度上限\n#### poll事件驱动\ndevpoll_change 32 #传递给内核的事件数\ndevpoll_events 32 #从内核获取事件数量\n#### kqueue事件驱动\nkqueue_changes 512 #传递给内核的事件数\nkqueue_events 512 #从内核获取事件数量\n#### epoll_events驱动\nepoll_changes 512 #发送和收到内核的事件数\n#### rtsig\nrtsig_signo signo\n###Gzip压缩(http模块)\n#### ngx_http_gip_module模块(适用于大文件下载)\ngzip on #开启压缩功能\ngzip_buffers 32 4k | 16 8k #number*size存储压缩空间\ngzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低\ngzip_disable MSIE [4-6]\\. #ie4-6不进行gzip压缩\ngzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本\ngzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩\ngzip_proxied on #开启对后端服务器返回结构的Gzip压缩\ngzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩\ngzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩\ngzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩\ngzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩\ngzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩\ngzip_proxied any #无条件开启对响应数据的压缩\ngzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能\ngzip_vary on #经过压缩处理的响应会在头部添加\"Vary:Accept-Encoding:gizp\"也可用add_header Vary Accept-Encoding gzip\n#### ngx_http_gzip_static_module模块(可确定数据长度)\n编译添加--with-http_gzip_static_module\ngzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件\ngzip_proxied no-cache no-store private auth;\n#### ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\n编译添加--with-http_gunzip_module\ngunzip_static on\ngunzip_buffers 32 4k | 16 8k\n\n\n\n\n\n\n\n\n","slug":"nginx配置优化","published":1,"updated":"2018-05-27T09:59:36.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjn0016th8l8j267plz","content":"<p>最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置<br>首先我们看一份较简单的nginx.conf配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 全局块开始 ####</span><br><span class=\"line\">user nobody nobody; #配置允许Nginx服务器的用户和用户组</span><br><span class=\"line\">worker_processes 3; #配置Nginx进程生成的worker_processes数目</span><br><span class=\"line\">error_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径</span><br><span class=\"line\">pid nginx.pid; #配置Nginx服务允许时的错误日志存放路径</span><br><span class=\"line\">#### 全局块结束 ####</span><br><span class=\"line\"></span><br><span class=\"line\">#### event开始 ####</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">        use epoll; #配置事件驱动模型</span><br><span class=\"line\">        worker_connections 1024; #配置最大连接数</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#### event结束 ####</span><br><span class=\"line\">#### http块开始 ####</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">        include mime.types; #定义MIME-TYPE</span><br><span class=\"line\">        default_type application/octet-stream; </span><br><span class=\"line\">        sendfile on; #配置允许使用sendfile方式传输</span><br><span class=\"line\">        keepalive_timeout 65; #配置连接超时</span><br><span class=\"line\">        log_format access.log #配置请求处理日志的分格</span><br><span class=\"line\">        &apos;$remote_addr-[$time_local]-&quot;$request&quot;-&quot;$http_user_agent&quot;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">        gzip on; #gzip功能设置</span><br><span class=\"line\">        gzip_min_length 1024; #响应页数据上限</span><br><span class=\"line\">        gzip_buffers 4 16k; # 缓存空间大小</span><br><span class=\"line\">        gzip_comp_level 2; # 压缩级别为2</span><br><span class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型</span><br><span class=\"line\">        gzip_vary on #启用压缩标识</span><br><span class=\"line\">        gzip_disable &quot;MISIE[1-6]&quot;; #ie1-6不开启压缩功能</span><br><span class=\"line\">        gunzip_static no #检查预压缩文件</span><br><span class=\"line\">        gzip_static on;</span><br><span class=\"line\">        gzup_http_version 1.0;</span><br><span class=\"line\">#### server块开始 ####</span><br><span class=\"line\">        server &#123; #配置虚拟主机1</span><br><span class=\"line\">                listen 8081; </span><br><span class=\"line\">                server_name myServer1; #监听端口和主机名称</span><br><span class=\"line\">                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径</span><br><span class=\"line\">                error_page 404 /404.html; </span><br><span class=\"line\">                location /server1/location1 &#123; #配置处理/server1/location1 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr1-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                location /server2/location2 &#123; #配置处理/server2/location2 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr2-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        server &#123; #配置虚拟主机2</span><br><span class=\"line\">                listen 8082; </span><br><span class=\"line\">                gzip off; #主机2关闭压缩</span><br><span class=\"line\">                server_name 192.168.1.3; #监听端口和主机名称</span><br><span class=\"line\">                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径</span><br><span class=\"line\">                error_page 404 /404.html; </span><br><span class=\"line\">                location /server2/location1 &#123; #配置处理/server2/location1 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr2-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                location /server2/loc2 &#123; #配置处理/server2/location2 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr2-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                location = /404.html &#123;</span><br><span class=\"line\">                        root /myweb/;</span><br><span class=\"line\">                        index 404.html;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">#### server块结束 ####</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#### http块结束 ####</span><br></pre></td></tr></table></figure></p>\n<p>通过这个我们认识了nginx配置的基本组成:</p>\n<ul>\n<li>全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入</li>\n<li>event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数</li>\n<li>http块：代理,缓存,日志定义,第三方模块的配置</li>\n<li>server块：虚拟主机</li>\n<li>location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制<a id=\"more\"></a>\n<h2 id=\"Nginx如何处理请求\"><a href=\"#Nginx如何处理请求\" class=\"headerlink\" title=\"Nginx如何处理请求\"></a>Nginx如何处理请求</h2><blockquote>\n<p><em>同步和异步</em>：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。<br><em>阻塞和非阻塞</em>：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。</p>\n</blockquote>\n</li>\n</ul>\n<p>Nginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。</p>\n<h2 id=\"Nginx的事件驱动模型\"><a href=\"#Nginx的事件驱动模型\" class=\"headerlink\" title=\"Nginx的事件驱动模型\"></a>Nginx的事件驱动模型</h2><p>IO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。</p>\n<blockquote>\n<p><em>select</em>: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用–with-select_module和–without-select_module是否编译该库。<br><em>poll</em>: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。<br><em>epoll</em>: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。</p>\n</blockquote>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程:\"></a>主进程:</h3><ul>\n<li>读取Nginx配置文件并验证其有效性和正确性</li>\n<li>建立，绑定和关闭Socket</li>\n<li>按照配置生成管理和结束进程</li>\n<li>接收外界指令，比如重启，升级及退出服务器等指令</li>\n<li>不中断服务，实现平滑重启，升级及退出服务</li>\n<li>开启日志文件，获取文件描述符</li>\n<li>编译和处理Perl脚本<h3 id=\"工作进程：\"><a href=\"#工作进程：\" class=\"headerlink\" title=\"工作进程：\"></a>工作进程：</h3></li>\n<li>接收客户端请求</li>\n<li>将请求一次送入各个功能模块进行过滤处理</li>\n<li>IO调用，获取响应数据</li>\n<li>与后端服务器通信，接收后端服务器处理结果</li>\n<li>数据缓存，访问索引，查询和调用缓存数据</li>\n<li>发送请求结果，响应客户端请求</li>\n<li>接收主程序指令，比如重启升级和退出<h3 id=\"缓存索引重建及管理进程\"><a href=\"#缓存索引重建及管理进程\" class=\"headerlink\" title=\"缓存索引重建及管理进程\"></a>缓存索引重建及管理进程</h3>缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据<br>魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期<h2 id=\"优化配置\"><a href=\"#优化配置\" class=\"headerlink\" title=\"优化配置\"></a>优化配置</h2><h3 id=\"针对ipv4的内核参数配置优化\"><a href=\"#针对ipv4的内核参数配置优化\" class=\"headerlink\" title=\"针对ipv4的内核参数配置优化\"></a>针对ipv4的内核参数配置优化</h3>在/etc/sysctl.conf中追加下面的参数,然后使用<em>/sbin/sysctl -p</em>命令使配置生效</li>\n<li>net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目</li>\n<li>net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题</li>\n<li>net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击</li>\n<li>net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持</li>\n<li>net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 </li>\n<li>net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量<h3 id=\"针对CPU的Nginx配置优化\"><a href=\"#针对CPU的Nginx配置优化\" class=\"headerlink\" title=\"针对CPU的Nginx配置优化\"></a>针对CPU的Nginx配置优化</h3></li>\n<li>worker_processes 4; #针对cpu核数</li>\n<li>worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu<h3 id=\"与网络连接相关的配置\"><a href=\"#与网络连接相关的配置\" class=\"headerlink\" title=\"与网络连接相关的配置\"></a>与网络连接相关的配置</h3></li>\n<li>keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件</li>\n<li>send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接</li>\n<li>client_header_buffer_size 4k #客户端响应头部的缓冲区大小<h3 id=\"与事件驱动相关-event模块\"><a href=\"#与事件驱动相关-event模块\" class=\"headerlink\" title=\"与事件驱动相关(event模块)\"></a>与事件驱动相关(event模块)</h3>use epoll #事件驱动模型<br>worker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2<br>worker_rlimit_sigpending 1024 #Linux事件信号队列长度上限<h4 id=\"poll事件驱动\"><a href=\"#poll事件驱动\" class=\"headerlink\" title=\"poll事件驱动\"></a>poll事件驱动</h4>devpoll_change 32 #传递给内核的事件数<br>devpoll_events 32 #从内核获取事件数量<h4 id=\"kqueue事件驱动\"><a href=\"#kqueue事件驱动\" class=\"headerlink\" title=\"kqueue事件驱动\"></a>kqueue事件驱动</h4>kqueue_changes 512 #传递给内核的事件数<br>kqueue_events 512 #从内核获取事件数量<h4 id=\"epoll-events驱动\"><a href=\"#epoll-events驱动\" class=\"headerlink\" title=\"epoll_events驱动\"></a>epoll_events驱动</h4>epoll_changes 512 #发送和收到内核的事件数<h4 id=\"rtsig\"><a href=\"#rtsig\" class=\"headerlink\" title=\"rtsig\"></a>rtsig</h4>rtsig_signo signo<br>###Gzip压缩(http模块)<h4 id=\"ngx-http-gip-module模块-适用于大文件下载\"><a href=\"#ngx-http-gip-module模块-适用于大文件下载\" class=\"headerlink\" title=\"ngx_http_gip_module模块(适用于大文件下载)\"></a>ngx_http_gip_module模块(适用于大文件下载)</h4>gzip on #开启压缩功能<br>gzip_buffers 32 4k | 16 8k #number*size存储压缩空间<br>gzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低<br>gzip_disable MSIE [4-6]. #ie4-6不进行gzip压缩<br>gzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本<br>gzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩<br>gzip_proxied on #开启对后端服务器返回结构的Gzip压缩<br>gzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩<br>gzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩<br>gzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩<br>gzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩<br>gzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩<br>gzip_proxied any #无条件开启对响应数据的压缩<br>gzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能<br>gzip_vary on #经过压缩处理的响应会在头部添加”Vary:Accept-Encoding:gizp”也可用add_header Vary Accept-Encoding gzip<h4 id=\"ngx-http-gzip-static-module模块-可确定数据长度\"><a href=\"#ngx-http-gzip-static-module模块-可确定数据长度\" class=\"headerlink\" title=\"ngx_http_gzip_static_module模块(可确定数据长度)\"></a>ngx_http_gzip_static_module模块(可确定数据长度)</h4>编译添加–with-http_gzip_static_module<br>gzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件<br>gzip_proxied no-cache no-store private auth;<h4 id=\"ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\"><a href=\"#ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\" class=\"headerlink\" title=\"ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\"></a>ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)</h4>编译添加–with-http_gunzip_module<br>gunzip_static on<br>gunzip_buffers 32 4k | 16 8k</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置<br>首先我们看一份较简单的nginx.conf配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#### 全局块开始 ####</span><br><span class=\"line\">user nobody nobody; #配置允许Nginx服务器的用户和用户组</span><br><span class=\"line\">worker_processes 3; #配置Nginx进程生成的worker_processes数目</span><br><span class=\"line\">error_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径</span><br><span class=\"line\">pid nginx.pid; #配置Nginx服务允许时的错误日志存放路径</span><br><span class=\"line\">#### 全局块结束 ####</span><br><span class=\"line\"></span><br><span class=\"line\">#### event开始 ####</span><br><span class=\"line\">events &#123;</span><br><span class=\"line\">        use epoll; #配置事件驱动模型</span><br><span class=\"line\">        worker_connections 1024; #配置最大连接数</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#### event结束 ####</span><br><span class=\"line\">#### http块开始 ####</span><br><span class=\"line\">http &#123;</span><br><span class=\"line\">        include mime.types; #定义MIME-TYPE</span><br><span class=\"line\">        default_type application/octet-stream; </span><br><span class=\"line\">        sendfile on; #配置允许使用sendfile方式传输</span><br><span class=\"line\">        keepalive_timeout 65; #配置连接超时</span><br><span class=\"line\">        log_format access.log #配置请求处理日志的分格</span><br><span class=\"line\">        &apos;$remote_addr-[$time_local]-&quot;$request&quot;-&quot;$http_user_agent&quot;&apos;</span><br><span class=\"line\"></span><br><span class=\"line\">        gzip on; #gzip功能设置</span><br><span class=\"line\">        gzip_min_length 1024; #响应页数据上限</span><br><span class=\"line\">        gzip_buffers 4 16k; # 缓存空间大小</span><br><span class=\"line\">        gzip_comp_level 2; # 压缩级别为2</span><br><span class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型</span><br><span class=\"line\">        gzip_vary on #启用压缩标识</span><br><span class=\"line\">        gzip_disable &quot;MISIE[1-6]&quot;; #ie1-6不开启压缩功能</span><br><span class=\"line\">        gunzip_static no #检查预压缩文件</span><br><span class=\"line\">        gzip_static on;</span><br><span class=\"line\">        gzup_http_version 1.0;</span><br><span class=\"line\">#### server块开始 ####</span><br><span class=\"line\">        server &#123; #配置虚拟主机1</span><br><span class=\"line\">                listen 8081; </span><br><span class=\"line\">                server_name myServer1; #监听端口和主机名称</span><br><span class=\"line\">                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径</span><br><span class=\"line\">                error_page 404 /404.html; </span><br><span class=\"line\">                location /server1/location1 &#123; #配置处理/server1/location1 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr1-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                location /server2/location2 &#123; #配置处理/server2/location2 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr2-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        server &#123; #配置虚拟主机2</span><br><span class=\"line\">                listen 8082; </span><br><span class=\"line\">                gzip off; #主机2关闭压缩</span><br><span class=\"line\">                server_name 192.168.1.3; #监听端口和主机名称</span><br><span class=\"line\">                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径</span><br><span class=\"line\">                error_page 404 /404.html; </span><br><span class=\"line\">                location /server2/location1 &#123; #配置处理/server2/location1 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr2-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                location /server2/loc2 &#123; #配置处理/server2/location2 请求的location</span><br><span class=\"line\">                        root /myweb;</span><br><span class=\"line\">                        index index.svr2-local.htm;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                location = /404.html &#123;</span><br><span class=\"line\">                        root /myweb/;</span><br><span class=\"line\">                        index 404.html;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">#### server块结束 ####</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">#### http块结束 ####</span><br></pre></td></tr></table></figure></p>\n<p>通过这个我们认识了nginx配置的基本组成:</p>\n<ul>\n<li>全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入</li>\n<li>event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数</li>\n<li>http块：代理,缓存,日志定义,第三方模块的配置</li>\n<li>server块：虚拟主机</li>\n<li>location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制","more":"<h2 id=\"Nginx如何处理请求\"><a href=\"#Nginx如何处理请求\" class=\"headerlink\" title=\"Nginx如何处理请求\"></a>Nginx如何处理请求</h2><blockquote>\n<p><em>同步和异步</em>：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。<br><em>阻塞和非阻塞</em>：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。</p>\n</blockquote>\n</li>\n</ul>\n<p>Nginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。</p>\n<h2 id=\"Nginx的事件驱动模型\"><a href=\"#Nginx的事件驱动模型\" class=\"headerlink\" title=\"Nginx的事件驱动模型\"></a>Nginx的事件驱动模型</h2><p>IO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。</p>\n<blockquote>\n<p><em>select</em>: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用–with-select_module和–without-select_module是否编译该库。<br><em>poll</em>: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。<br><em>epoll</em>: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。</p>\n</blockquote>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程:\"></a>主进程:</h3><ul>\n<li>读取Nginx配置文件并验证其有效性和正确性</li>\n<li>建立，绑定和关闭Socket</li>\n<li>按照配置生成管理和结束进程</li>\n<li>接收外界指令，比如重启，升级及退出服务器等指令</li>\n<li>不中断服务，实现平滑重启，升级及退出服务</li>\n<li>开启日志文件，获取文件描述符</li>\n<li>编译和处理Perl脚本<h3 id=\"工作进程：\"><a href=\"#工作进程：\" class=\"headerlink\" title=\"工作进程：\"></a>工作进程：</h3></li>\n<li>接收客户端请求</li>\n<li>将请求一次送入各个功能模块进行过滤处理</li>\n<li>IO调用，获取响应数据</li>\n<li>与后端服务器通信，接收后端服务器处理结果</li>\n<li>数据缓存，访问索引，查询和调用缓存数据</li>\n<li>发送请求结果，响应客户端请求</li>\n<li>接收主程序指令，比如重启升级和退出<h3 id=\"缓存索引重建及管理进程\"><a href=\"#缓存索引重建及管理进程\" class=\"headerlink\" title=\"缓存索引重建及管理进程\"></a>缓存索引重建及管理进程</h3>缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据<br>魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期<h2 id=\"优化配置\"><a href=\"#优化配置\" class=\"headerlink\" title=\"优化配置\"></a>优化配置</h2><h3 id=\"针对ipv4的内核参数配置优化\"><a href=\"#针对ipv4的内核参数配置优化\" class=\"headerlink\" title=\"针对ipv4的内核参数配置优化\"></a>针对ipv4的内核参数配置优化</h3>在/etc/sysctl.conf中追加下面的参数,然后使用<em>/sbin/sysctl -p</em>命令使配置生效</li>\n<li>net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目</li>\n<li>net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题</li>\n<li>net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击</li>\n<li>net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持</li>\n<li>net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 </li>\n<li>net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量<h3 id=\"针对CPU的Nginx配置优化\"><a href=\"#针对CPU的Nginx配置优化\" class=\"headerlink\" title=\"针对CPU的Nginx配置优化\"></a>针对CPU的Nginx配置优化</h3></li>\n<li>worker_processes 4; #针对cpu核数</li>\n<li>worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu<h3 id=\"与网络连接相关的配置\"><a href=\"#与网络连接相关的配置\" class=\"headerlink\" title=\"与网络连接相关的配置\"></a>与网络连接相关的配置</h3></li>\n<li>keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件</li>\n<li>send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接</li>\n<li>client_header_buffer_size 4k #客户端响应头部的缓冲区大小<h3 id=\"与事件驱动相关-event模块\"><a href=\"#与事件驱动相关-event模块\" class=\"headerlink\" title=\"与事件驱动相关(event模块)\"></a>与事件驱动相关(event模块)</h3>use epoll #事件驱动模型<br>worker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2<br>worker_rlimit_sigpending 1024 #Linux事件信号队列长度上限<h4 id=\"poll事件驱动\"><a href=\"#poll事件驱动\" class=\"headerlink\" title=\"poll事件驱动\"></a>poll事件驱动</h4>devpoll_change 32 #传递给内核的事件数<br>devpoll_events 32 #从内核获取事件数量<h4 id=\"kqueue事件驱动\"><a href=\"#kqueue事件驱动\" class=\"headerlink\" title=\"kqueue事件驱动\"></a>kqueue事件驱动</h4>kqueue_changes 512 #传递给内核的事件数<br>kqueue_events 512 #从内核获取事件数量<h4 id=\"epoll-events驱动\"><a href=\"#epoll-events驱动\" class=\"headerlink\" title=\"epoll_events驱动\"></a>epoll_events驱动</h4>epoll_changes 512 #发送和收到内核的事件数<h4 id=\"rtsig\"><a href=\"#rtsig\" class=\"headerlink\" title=\"rtsig\"></a>rtsig</h4>rtsig_signo signo<br>###Gzip压缩(http模块)<h4 id=\"ngx-http-gip-module模块-适用于大文件下载\"><a href=\"#ngx-http-gip-module模块-适用于大文件下载\" class=\"headerlink\" title=\"ngx_http_gip_module模块(适用于大文件下载)\"></a>ngx_http_gip_module模块(适用于大文件下载)</h4>gzip on #开启压缩功能<br>gzip_buffers 32 4k | 16 8k #number*size存储压缩空间<br>gzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低<br>gzip_disable MSIE [4-6]. #ie4-6不进行gzip压缩<br>gzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本<br>gzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩<br>gzip_proxied on #开启对后端服务器返回结构的Gzip压缩<br>gzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩<br>gzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩<br>gzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩<br>gzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩<br>gzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩<br>gzip_proxied any #无条件开启对响应数据的压缩<br>gzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能<br>gzip_vary on #经过压缩处理的响应会在头部添加”Vary:Accept-Encoding:gizp”也可用add_header Vary Accept-Encoding gzip<h4 id=\"ngx-http-gzip-static-module模块-可确定数据长度\"><a href=\"#ngx-http-gzip-static-module模块-可确定数据长度\" class=\"headerlink\" title=\"ngx_http_gzip_static_module模块(可确定数据长度)\"></a>ngx_http_gzip_static_module模块(可确定数据长度)</h4>编译添加–with-http_gzip_static_module<br>gzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件<br>gzip_proxied no-cache no-store private auth;<h4 id=\"ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\"><a href=\"#ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\" class=\"headerlink\" title=\"ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\"></a>ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)</h4>编译添加–with-http_gunzip_module<br>gunzip_static on<br>gunzip_buffers 32 4k | 16 8k</li>\n</ul>"},{"title":"使用Prometheus+Grafana监控","date":"2017-12-10T10:09:37.000Z","_content":"## 简介\nPrometheus（普罗米修斯）是一套开源的监控&报警&时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。\nPrometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。\nPrometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。\n\n输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：https://github.com/prometheus。\n\n与其他监控系统相比，Prometheus的主要特点是：\n\n- 一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。\n- 非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。\n- 一种灵活的查询语言。\n- 不依赖分布式存储，单个服务器节点。\n- 时间集合通过HTTP上的PULL模型进行。\n- 通过中间网关支持推送时间。\n- 通过服务发现或静态配置发现目标。\n- 多种模式的图形和仪表板支持。\n\n## Prometheus架构概览\n\n该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：\n![Prometheus架构概览](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg)\n它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。\n\n- Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。\n\n- Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。\n\n- PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。\n\n## Prometheus的数据模型\n\nPrometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。\nmetrics name&label指标名称和标签\n\n每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。\n\n### 指标名称：\n一般是给监测对像起一名字，例如http_requests_total这样，它有一些命名规则，可以包字母数字_之类的的。通常是以应用名称开头_监测对像_数值类型_单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。\n\n### 标签：\n就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。\n\n记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。\n\n查询语句就可以跟据上面标签的组合来查询聚合结果了。\n\n如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。\n\n<!--more-->\n## Prometheus四种数据类型\n\n### Counter\nCounter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。\n\n例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。\n### Gauge\nGauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。\n\n例如： memory_usage_bytes{host=”master-01″} 100 < 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 < 抓取值。\n### Histogram\n\nHistogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。\n\n例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。\n### Summary\nSummary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。\n\n例如：count=7次，sum=7次的值求值。\n\n它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。\n## 配置文件解析\n###下面的例子以这个项目为例(promethes项目)[https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]\n\n``` yaml\n# docker-compose.yml\nversion: '2.0'\n\nservices:\n  prometheus: \n    image: prom/prometheus:v1.0.1\n    volumes:\n        - ./prometheus.yml:/etc/prometheus/prometheus.yml\n        - prometheus_data:/prometheus\n        - ./alert.rules:/etc/prometheus/alert.rules\n    command:\n        - '-config.file=/etc/prometheus/prometheus.yml'\n        - '-alertmanager.url=http://alertmanager:9093'\n    ports:\n        - '9090:9090'\n\n  grafana:\n    image: \"grafana/grafana:3.1.1\"\n    environment:\n        - GF_SECURITY_ADMIN_PASSWORD=pass\n    depends_on:\n        - prometheus\n    volumes:\n        - grafana_data:/var/lib/grafana\n        - ./alert.rules:/etc/prometheus/alert.rules\n    ports:\n        - \"3000:3000\"\n\n  alertmanager:\n    image: \"prom/alertmanager:v0.8.0\"\n    volumes:\n        - ./alertmanager.yml:/alertmanager.yml\n    command:\n        - '-config.file=/alertmanager.yml'\n    \nvolumes:\n  prometheus_data: {}\n  grafana_data: {}\n```\nPrometheus内置了一个web界面，我们可通过http://monitor_host:9090进行访问：\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg)\n但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg)\n\n在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。\n这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点\n或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。\n \n### cAdvisor 容器数据采集\n\n因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器\n \n```\ncadvisor:\n image: google/cadvisor\n volumes:\n   - /:/rootfs:ro\n   - /var/run:/var/run:rw\n   - /sys:/sys:ro\n   - /var/lib/docker/:/var/lib/docker:ro\n ports:\n     - \"8080:8080\"\n expose:\n     - \"8080\"\n```\n\n### prometheus.yaml 配置监听数据地址\n\nprometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址\n\n``` \n# my global config\nglobal:\n  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.\n  # scrape_timeout is set to the global default (10s).\n\n  # Attach these labels to any time series or alerts when communicating with\n  # external systems (federation, remote storage, Alertmanager).\n  external_labels:\n      monitor: 'codelab-monitor'\n\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n    - 'alert.rules'\n\n# A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Prometheus itself.\nscrape_configs:\n  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n    #scrape_interval: 5s\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: ['192.168.1.162:9090']\n        labels:\n          instance: prometheus\n\n  - job_name: 'docker-online'\n    #scrape_interval: 5s\n    #scheme: http\n    static_configs:\n      - targets: ['192.168.1.162:8080']\n        labels:\n         group: 'port'\n```\n\n### Alertmanager报警组件\n\nAlertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。\n要查看所有可用的命令行flag，运行alertmanager -h。\nAlertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。\n配置文件\n要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。\n```\nglobal:\n  # ResolveTimeout is the time after which an alert is declared resolved\n  # if it has not been updated.\n  [ resolve_timeout: <duration> | default = 5m ]\n\n  # The default SMTP From header field.\n  [ smtp_from: <tmpl_string> ]\n  # The default SMTP smarthost used for sending emails.\n  [ smtp_smarthost: <string> ]\n\n  # The API URL to use for Slack notifications.\n  [ slack_api_url: <string> ]\n\n  [ pagerduty_url: <string> | default = \"https://events.pagerduty.com/generic/2010-04-15/create_event.json\" ]\n  [ opsgenie_api_host: <string> | default = \"https://api.opsgenie.com/\" ]\n\n# Files from which custom notification template definitions are read.\n# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.\ntemplates:\n  [ - <filepath> ... ]\n\n# The root node of the routing tree.\nroute: <route>\n\n# A list of notification receivers.\nreceivers:\n  - <receiver> ...\n\n# A list of inhibition rules.\ninhibit_rules:\n  [ - <inhibit_rule> ... ]\n```\n\n路由 route\n路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。\n每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。\n路由配置格式\n\n```\n[ receiver: <string> ]\n[ group_by: '[' <labelname>, ... ']' ]\n\n# Whether an alert should continue matching subsequent sibling nodes.\n[ continue: <boolean> | default = false ]\n\n# A set of equality matchers an alert has to fulfill to match the node.\nmatch:\n  [ <labelname>: <labelvalue>, ... ]\n\n# A set of regex-matchers an alert has to fulfill to match the node.\nmatch_re:\n  [ <labelname>: <regex>, ... ]\n\n# How long to initially wait to send a notification for a group\n# of alerts. Allows to wait for an inhibiting alert to arrive or collect\n# more initial alerts for the same group. (Usually ~0s to few minutes.)\n[ group_wait: <duration> ]\n\n# How long to wait before sending notification about new alerts that are\n# in are added to a group of alerts for which an initial notification\n# has already been sent. (Usually ~5min or more.)\n[ group_interval: <duration> ]\n\n# How long to wait before sending a notification again if it has already\n# been sent successfully for an alert. (Usually ~3h or more).\n[ repeat_interval: <duration> ]\n\n# Zero or more child routes.\nroutes:\n  [ - <route> ... ]\n```\n\n在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：\n\n``` yaml  \nroute:\n    receiver: 'slack'\nreceivers:\n    - name: 'slack'\n      slack_configs:\n          - send_resolved: true\n            username: 'Prometheus'\n            channel: '#random'\n            api_url: 'https://hooks.slack.com/services/<your>/<stuff>/<here>'\n```\n\n### 报警规则\n\n报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。\n报警规则通过以下格式定义：\n\n```\nALERT <alert name>\n  IF <expression>\n  [ FOR <duration> ]\n  [ LABELS <label set> ]\n  [ ANNOTATIONS <label set> ]\n```\n\nFOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。\nLABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。\nANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。\n示例：\n\n```\n# alert.rules\nALERT service_down\n  IF up == 0\nALERT high_load\n  IF node_load1 > 0.5\n  ANNOTATIONS {\n      summary = \"Instance {{ $labels.instance }} under high load\",\n      description = \"{{ $labels.instance }} of job {{ $labels.job }} is under highload.\",\n  }\n```\n\n## 参考资料\n\n+ [prometheus](https://prometheus.io)\n+ [grafana](http://grafana.org)\n+ [Prometheus监控 - Alertmanager报警模块](https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html)\n+ [Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center](https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/)\n+ [使用Prometheus+Grafana监控MySQL实践 – 运维那点事](http://www.ywnds.com/?p=9656)\n+ [使用Prometheus监控服务器](http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html)\n+ [Prometheus在Kubernetes下的监控实践](http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/)\n+ [通过Prometheus，Grafana和Docker进行监控](https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1)\n","source":"_posts/使用Prometheus-Grafana监控.md","raw":"---\ntitle: 使用Prometheus+Grafana监控\ndate: 2017-12-10 18:09:37\ntags: devops\n---\n## 简介\nPrometheus（普罗米修斯）是一套开源的监控&报警&时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。\nPrometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。\nPrometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。\n\n输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：https://github.com/prometheus。\n\n与其他监控系统相比，Prometheus的主要特点是：\n\n- 一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。\n- 非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。\n- 一种灵活的查询语言。\n- 不依赖分布式存储，单个服务器节点。\n- 时间集合通过HTTP上的PULL模型进行。\n- 通过中间网关支持推送时间。\n- 通过服务发现或静态配置发现目标。\n- 多种模式的图形和仪表板支持。\n\n## Prometheus架构概览\n\n该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：\n![Prometheus架构概览](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg)\n它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。\n\n- Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。\n\n- Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。\n\n- PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。\n\n## Prometheus的数据模型\n\nPrometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。\nmetrics name&label指标名称和标签\n\n每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。\n\n### 指标名称：\n一般是给监测对像起一名字，例如http_requests_total这样，它有一些命名规则，可以包字母数字_之类的的。通常是以应用名称开头_监测对像_数值类型_单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。\n\n### 标签：\n就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。\n\n记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。\n\n查询语句就可以跟据上面标签的组合来查询聚合结果了。\n\n如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。\n\n<!--more-->\n## Prometheus四种数据类型\n\n### Counter\nCounter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。\n\n例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。\n### Gauge\nGauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。\n\n例如： memory_usage_bytes{host=”master-01″} 100 < 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 < 抓取值。\n### Histogram\n\nHistogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。\n\n例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。\n### Summary\nSummary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。\n\n例如：count=7次，sum=7次的值求值。\n\n它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。\n## 配置文件解析\n###下面的例子以这个项目为例(promethes项目)[https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]\n\n``` yaml\n# docker-compose.yml\nversion: '2.0'\n\nservices:\n  prometheus: \n    image: prom/prometheus:v1.0.1\n    volumes:\n        - ./prometheus.yml:/etc/prometheus/prometheus.yml\n        - prometheus_data:/prometheus\n        - ./alert.rules:/etc/prometheus/alert.rules\n    command:\n        - '-config.file=/etc/prometheus/prometheus.yml'\n        - '-alertmanager.url=http://alertmanager:9093'\n    ports:\n        - '9090:9090'\n\n  grafana:\n    image: \"grafana/grafana:3.1.1\"\n    environment:\n        - GF_SECURITY_ADMIN_PASSWORD=pass\n    depends_on:\n        - prometheus\n    volumes:\n        - grafana_data:/var/lib/grafana\n        - ./alert.rules:/etc/prometheus/alert.rules\n    ports:\n        - \"3000:3000\"\n\n  alertmanager:\n    image: \"prom/alertmanager:v0.8.0\"\n    volumes:\n        - ./alertmanager.yml:/alertmanager.yml\n    command:\n        - '-config.file=/alertmanager.yml'\n    \nvolumes:\n  prometheus_data: {}\n  grafana_data: {}\n```\nPrometheus内置了一个web界面，我们可通过http://monitor_host:9090进行访问：\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg)\n但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg)\n\n在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。\n这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点\n或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。\n \n### cAdvisor 容器数据采集\n\n因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器\n \n```\ncadvisor:\n image: google/cadvisor\n volumes:\n   - /:/rootfs:ro\n   - /var/run:/var/run:rw\n   - /sys:/sys:ro\n   - /var/lib/docker/:/var/lib/docker:ro\n ports:\n     - \"8080:8080\"\n expose:\n     - \"8080\"\n```\n\n### prometheus.yaml 配置监听数据地址\n\nprometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址\n\n``` \n# my global config\nglobal:\n  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.\n  # scrape_timeout is set to the global default (10s).\n\n  # Attach these labels to any time series or alerts when communicating with\n  # external systems (federation, remote storage, Alertmanager).\n  external_labels:\n      monitor: 'codelab-monitor'\n\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n    - 'alert.rules'\n\n# A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Prometheus itself.\nscrape_configs:\n  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n    #scrape_interval: 5s\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: ['192.168.1.162:9090']\n        labels:\n          instance: prometheus\n\n  - job_name: 'docker-online'\n    #scrape_interval: 5s\n    #scheme: http\n    static_configs:\n      - targets: ['192.168.1.162:8080']\n        labels:\n         group: 'port'\n```\n\n### Alertmanager报警组件\n\nAlertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。\n要查看所有可用的命令行flag，运行alertmanager -h。\nAlertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。\n配置文件\n要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。\n```\nglobal:\n  # ResolveTimeout is the time after which an alert is declared resolved\n  # if it has not been updated.\n  [ resolve_timeout: <duration> | default = 5m ]\n\n  # The default SMTP From header field.\n  [ smtp_from: <tmpl_string> ]\n  # The default SMTP smarthost used for sending emails.\n  [ smtp_smarthost: <string> ]\n\n  # The API URL to use for Slack notifications.\n  [ slack_api_url: <string> ]\n\n  [ pagerduty_url: <string> | default = \"https://events.pagerduty.com/generic/2010-04-15/create_event.json\" ]\n  [ opsgenie_api_host: <string> | default = \"https://api.opsgenie.com/\" ]\n\n# Files from which custom notification template definitions are read.\n# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.\ntemplates:\n  [ - <filepath> ... ]\n\n# The root node of the routing tree.\nroute: <route>\n\n# A list of notification receivers.\nreceivers:\n  - <receiver> ...\n\n# A list of inhibition rules.\ninhibit_rules:\n  [ - <inhibit_rule> ... ]\n```\n\n路由 route\n路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。\n每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。\n路由配置格式\n\n```\n[ receiver: <string> ]\n[ group_by: '[' <labelname>, ... ']' ]\n\n# Whether an alert should continue matching subsequent sibling nodes.\n[ continue: <boolean> | default = false ]\n\n# A set of equality matchers an alert has to fulfill to match the node.\nmatch:\n  [ <labelname>: <labelvalue>, ... ]\n\n# A set of regex-matchers an alert has to fulfill to match the node.\nmatch_re:\n  [ <labelname>: <regex>, ... ]\n\n# How long to initially wait to send a notification for a group\n# of alerts. Allows to wait for an inhibiting alert to arrive or collect\n# more initial alerts for the same group. (Usually ~0s to few minutes.)\n[ group_wait: <duration> ]\n\n# How long to wait before sending notification about new alerts that are\n# in are added to a group of alerts for which an initial notification\n# has already been sent. (Usually ~5min or more.)\n[ group_interval: <duration> ]\n\n# How long to wait before sending a notification again if it has already\n# been sent successfully for an alert. (Usually ~3h or more).\n[ repeat_interval: <duration> ]\n\n# Zero or more child routes.\nroutes:\n  [ - <route> ... ]\n```\n\n在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：\n\n``` yaml  \nroute:\n    receiver: 'slack'\nreceivers:\n    - name: 'slack'\n      slack_configs:\n          - send_resolved: true\n            username: 'Prometheus'\n            channel: '#random'\n            api_url: 'https://hooks.slack.com/services/<your>/<stuff>/<here>'\n```\n\n### 报警规则\n\n报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。\n报警规则通过以下格式定义：\n\n```\nALERT <alert name>\n  IF <expression>\n  [ FOR <duration> ]\n  [ LABELS <label set> ]\n  [ ANNOTATIONS <label set> ]\n```\n\nFOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。\nLABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。\nANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。\n示例：\n\n```\n# alert.rules\nALERT service_down\n  IF up == 0\nALERT high_load\n  IF node_load1 > 0.5\n  ANNOTATIONS {\n      summary = \"Instance {{ $labels.instance }} under high load\",\n      description = \"{{ $labels.instance }} of job {{ $labels.job }} is under highload.\",\n  }\n```\n\n## 参考资料\n\n+ [prometheus](https://prometheus.io)\n+ [grafana](http://grafana.org)\n+ [Prometheus监控 - Alertmanager报警模块](https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html)\n+ [Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center](https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/)\n+ [使用Prometheus+Grafana监控MySQL实践 – 运维那点事](http://www.ywnds.com/?p=9656)\n+ [使用Prometheus监控服务器](http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html)\n+ [Prometheus在Kubernetes下的监控实践](http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/)\n+ [通过Prometheus，Grafana和Docker进行监控](https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1)\n","slug":"使用Prometheus-Grafana监控","published":1,"updated":"2018-05-27T09:59:36.034Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjo0019th8lgjrwssri","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Prometheus（普罗米修斯）是一套开源的监控&amp;报警&amp;时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。<br>Prometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。<br>Prometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。</p>\n<p>输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：<a href=\"https://github.com/prometheus。\" target=\"_blank\" rel=\"noopener\">https://github.com/prometheus。</a></p>\n<p>与其他监控系统相比，Prometheus的主要特点是：</p>\n<ul>\n<li>一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。</li>\n<li>非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。</li>\n<li>一种灵活的查询语言。</li>\n<li>不依赖分布式存储，单个服务器节点。</li>\n<li>时间集合通过HTTP上的PULL模型进行。</li>\n<li>通过中间网关支持推送时间。</li>\n<li>通过服务发现或静态配置发现目标。</li>\n<li>多种模式的图形和仪表板支持。</li>\n</ul>\n<h2 id=\"Prometheus架构概览\"><a href=\"#Prometheus架构概览\" class=\"headerlink\" title=\"Prometheus架构概览\"></a>Prometheus架构概览</h2><p>该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg\" alt=\"Prometheus架构概览\"><br>它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。</p>\n<ul>\n<li><p>Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。</p>\n</li>\n<li><p>Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</p>\n</li>\n<li><p>PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</p>\n</li>\n</ul>\n<h2 id=\"Prometheus的数据模型\"><a href=\"#Prometheus的数据模型\" class=\"headerlink\" title=\"Prometheus的数据模型\"></a>Prometheus的数据模型</h2><p>Prometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。<br>metrics name&amp;label指标名称和标签</p>\n<p>每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。</p>\n<h3 id=\"指标名称：\"><a href=\"#指标名称：\" class=\"headerlink\" title=\"指标名称：\"></a>指标名称：</h3><p>一般是给监测对像起一名字，例如http_requests_total这样，它有一些命名规则，可以包字母数字<em>之类的的。通常是以应用名称开头</em>监测对像<em>数值类型</em>单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。</p>\n<h3 id=\"标签：\"><a href=\"#标签：\" class=\"headerlink\" title=\"标签：\"></a>标签：</h3><p>就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。</p>\n<p>记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。</p>\n<p>查询语句就可以跟据上面标签的组合来查询聚合结果了。</p>\n<p>如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。</p>\n<a id=\"more\"></a>\n<h2 id=\"Prometheus四种数据类型\"><a href=\"#Prometheus四种数据类型\" class=\"headerlink\" title=\"Prometheus四种数据类型\"></a>Prometheus四种数据类型</h2><h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>Counter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。</p>\n<p>例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。</p>\n<h3 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h3><p>Gauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。</p>\n<p>例如： memory_usage_bytes{host=”master-01″} 100 &lt; 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 &lt; 抓取值。</p>\n<h3 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h3><p>Histogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。</p>\n<p>例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>Summary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。</p>\n<p>例如：count=7次，sum=7次的值求值。</p>\n<p>它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。</p>\n<h2 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h2><p>###下面的例子以这个项目为例(promethes项目)[<a href=\"https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]\" target=\"_blank\" rel=\"noopener\">https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]</a></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker-compose.yml</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2.0'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  prometheus:</span> </span><br><span class=\"line\"><span class=\"attr\">    image:</span> prom/prometheus:v1<span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class=\"line\"><span class=\"attr\">        - prometheus_data:</span>/prometheus</span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</span><br><span class=\"line\"><span class=\"attr\">    command:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/etc/prometheus/prometheus.yml'</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-alertmanager.url=http://alertmanager:9093'</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'9090:9090'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  grafana:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"grafana/grafana:3.1.1\"</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> GF_SECURITY_ADMIN_PASSWORD=pass</span><br><span class=\"line\"><span class=\"attr\">    depends_on:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> prometheus</span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"attr\">        - grafana_data:</span>/var/lib/grafana</span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">\"3000:3000\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  alertmanager:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"prom/alertmanager:v0.8.0\"</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./alertmanager.yml:/alertmanager.yml</span><br><span class=\"line\"><span class=\"attr\">    command:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/alertmanager.yml'</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  prometheus_data:</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"attr\">  grafana_data:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>Prometheus内置了一个web界面，我们可通过<a href=\"http://monitor_host:9090进行访问：\" target=\"_blank\" rel=\"noopener\">http://monitor_host:9090进行访问：</a><br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg\" alt><br>但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg\" alt></p>\n<p>在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。<br>这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点<br>或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。</p>\n<h3 id=\"cAdvisor-容器数据采集\"><a href=\"#cAdvisor-容器数据采集\" class=\"headerlink\" title=\"cAdvisor 容器数据采集\"></a>cAdvisor 容器数据采集</h3><p>因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cadvisor:</span><br><span class=\"line\"> image: google/cadvisor</span><br><span class=\"line\"> volumes:</span><br><span class=\"line\">   - /:/rootfs:ro</span><br><span class=\"line\">   - /var/run:/var/run:rw</span><br><span class=\"line\">   - /sys:/sys:ro</span><br><span class=\"line\">   - /var/lib/docker/:/var/lib/docker:ro</span><br><span class=\"line\"> ports:</span><br><span class=\"line\">     - &quot;8080:8080&quot;</span><br><span class=\"line\"> expose:</span><br><span class=\"line\">     - &quot;8080&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"prometheus-yaml-配置监听数据地址\"><a href=\"#prometheus-yaml-配置监听数据地址\" class=\"headerlink\" title=\"prometheus.yaml 配置监听数据地址\"></a>prometheus.yaml 配置监听数据地址</h3><p>prometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># my global config</span><br><span class=\"line\">global:</span><br><span class=\"line\">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class=\"line\">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class=\"line\">  # scrape_timeout is set to the global default (10s).</span><br><span class=\"line\"></span><br><span class=\"line\">  # Attach these labels to any time series or alerts when communicating with</span><br><span class=\"line\">  # external systems (federation, remote storage, Alertmanager).</span><br><span class=\"line\">  external_labels:</span><br><span class=\"line\">      monitor: &apos;codelab-monitor&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</span><br><span class=\"line\">rule_files:</span><br><span class=\"line\">    - &apos;alert.rules&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class=\"line\"># Here it&apos;s Prometheus itself.</span><br><span class=\"line\">scrape_configs:</span><br><span class=\"line\">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class=\"line\">  - job_name: &apos;prometheus&apos;</span><br><span class=\"line\">    #scrape_interval: 5s</span><br><span class=\"line\">    # metrics_path defaults to &apos;/metrics&apos;</span><br><span class=\"line\">    # scheme defaults to &apos;http&apos;.</span><br><span class=\"line\"></span><br><span class=\"line\">    static_configs:</span><br><span class=\"line\">      - targets: [&apos;192.168.1.162:9090&apos;]</span><br><span class=\"line\">        labels:</span><br><span class=\"line\">          instance: prometheus</span><br><span class=\"line\"></span><br><span class=\"line\">  - job_name: &apos;docker-online&apos;</span><br><span class=\"line\">    #scrape_interval: 5s</span><br><span class=\"line\">    #scheme: http</span><br><span class=\"line\">    static_configs:</span><br><span class=\"line\">      - targets: [&apos;192.168.1.162:8080&apos;]</span><br><span class=\"line\">        labels:</span><br><span class=\"line\">         group: &apos;port&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Alertmanager报警组件\"><a href=\"#Alertmanager报警组件\" class=\"headerlink\" title=\"Alertmanager报警组件\"></a>Alertmanager报警组件</h3><p>Alertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。<br>要查看所有可用的命令行flag，运行alertmanager -h。<br>Alertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。<br>配置文件<br>要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global:</span><br><span class=\"line\">  # ResolveTimeout is the time after which an alert is declared resolved</span><br><span class=\"line\">  # if it has not been updated.</span><br><span class=\"line\">  [ resolve_timeout: &lt;duration&gt; | default = 5m ]</span><br><span class=\"line\"></span><br><span class=\"line\">  # The default SMTP From header field.</span><br><span class=\"line\">  [ smtp_from: &lt;tmpl_string&gt; ]</span><br><span class=\"line\">  # The default SMTP smarthost used for sending emails.</span><br><span class=\"line\">  [ smtp_smarthost: &lt;string&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\">  # The API URL to use for Slack notifications.</span><br><span class=\"line\">  [ slack_api_url: &lt;string&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\">  [ pagerduty_url: &lt;string&gt; | default = &quot;https://events.pagerduty.com/generic/2010-04-15/create_event.json&quot; ]</span><br><span class=\"line\">  [ opsgenie_api_host: &lt;string&gt; | default = &quot;https://api.opsgenie.com/&quot; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Files from which custom notification template definitions are read.</span><br><span class=\"line\"># The last component may use a wildcard matcher, e.g. &apos;templates/*.tmpl&apos;.</span><br><span class=\"line\">templates:</span><br><span class=\"line\">  [ - &lt;filepath&gt; ... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># The root node of the routing tree.</span><br><span class=\"line\">route: &lt;route&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># A list of notification receivers.</span><br><span class=\"line\">receivers:</span><br><span class=\"line\">  - &lt;receiver&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\"># A list of inhibition rules.</span><br><span class=\"line\">inhibit_rules:</span><br><span class=\"line\">  [ - &lt;inhibit_rule&gt; ... ]</span><br></pre></td></tr></table></figure></p>\n<p>路由 route<br>路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。<br>每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。<br>路由配置格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ receiver: &lt;string&gt; ]</span><br><span class=\"line\">[ group_by: &apos;[&apos; &lt;labelname&gt;, ... &apos;]&apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Whether an alert should continue matching subsequent sibling nodes.</span><br><span class=\"line\">[ continue: &lt;boolean&gt; | default = false ]</span><br><span class=\"line\"></span><br><span class=\"line\"># A set of equality matchers an alert has to fulfill to match the node.</span><br><span class=\"line\">match:</span><br><span class=\"line\">  [ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># A set of regex-matchers an alert has to fulfill to match the node.</span><br><span class=\"line\">match_re:</span><br><span class=\"line\">  [ &lt;labelname&gt;: &lt;regex&gt;, ... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># How long to initially wait to send a notification for a group</span><br><span class=\"line\"># of alerts. Allows to wait for an inhibiting alert to arrive or collect</span><br><span class=\"line\"># more initial alerts for the same group. (Usually ~0s to few minutes.)</span><br><span class=\"line\">[ group_wait: &lt;duration&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># How long to wait before sending notification about new alerts that are</span><br><span class=\"line\"># in are added to a group of alerts for which an initial notification</span><br><span class=\"line\"># has already been sent. (Usually ~5min or more.)</span><br><span class=\"line\">[ group_interval: &lt;duration&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># How long to wait before sending a notification again if it has already</span><br><span class=\"line\"># been sent successfully for an alert. (Usually ~3h or more).</span><br><span class=\"line\">[ repeat_interval: &lt;duration&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Zero or more child routes.</span><br><span class=\"line\">routes:</span><br><span class=\"line\">  [ - &lt;route&gt; ... ]</span><br></pre></td></tr></table></figure>\n<p>在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">route:</span></span><br><span class=\"line\"><span class=\"attr\">    receiver:</span> <span class=\"string\">'slack'</span></span><br><span class=\"line\"><span class=\"attr\">receivers:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">'slack'</span></span><br><span class=\"line\"><span class=\"attr\">      slack_configs:</span></span><br><span class=\"line\"><span class=\"attr\">          - send_resolved:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">'Prometheus'</span></span><br><span class=\"line\"><span class=\"attr\">            channel:</span> <span class=\"string\">'#random'</span></span><br><span class=\"line\"><span class=\"attr\">            api_url:</span> <span class=\"string\">'https://hooks.slack.com/services/&lt;your&gt;/&lt;stuff&gt;/&lt;here&gt;'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"报警规则\"><a href=\"#报警规则\" class=\"headerlink\" title=\"报警规则\"></a>报警规则</h3><p>报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。<br>报警规则通过以下格式定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALERT &lt;alert name&gt;</span><br><span class=\"line\">  IF &lt;expression&gt;</span><br><span class=\"line\">  [ FOR &lt;duration&gt; ]</span><br><span class=\"line\">  [ LABELS &lt;label set&gt; ]</span><br><span class=\"line\">  [ ANNOTATIONS &lt;label set&gt; ]</span><br></pre></td></tr></table></figure>\n<p>FOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。<br>LABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。<br>ANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。<br>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># alert.rules</span><br><span class=\"line\">ALERT service_down</span><br><span class=\"line\">  IF up == 0</span><br><span class=\"line\">ALERT high_load</span><br><span class=\"line\">  IF node_load1 &gt; 0.5</span><br><span class=\"line\">  ANNOTATIONS &#123;</span><br><span class=\"line\">      summary = &quot;Instance &#123;&#123; $labels.instance &#125;&#125; under high load&quot;,</span><br><span class=\"line\">      description = &quot;&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; is under highload.&quot;,</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://prometheus.io\" target=\"_blank\" rel=\"noopener\">prometheus</a></li>\n<li><a href=\"http://grafana.org\" target=\"_blank\" rel=\"noopener\">grafana</a></li>\n<li><a href=\"https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html\" target=\"_blank\" rel=\"noopener\">Prometheus监控 - Alertmanager报警模块</a></li>\n<li><a href=\"https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/\" target=\"_blank\" rel=\"noopener\">Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center</a></li>\n<li><a href=\"http://www.ywnds.com/?p=9656\" target=\"_blank\" rel=\"noopener\">使用Prometheus+Grafana监控MySQL实践 – 运维那点事</a></li>\n<li><a href=\"http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html\" target=\"_blank\" rel=\"noopener\">使用Prometheus监控服务器</a></li>\n<li><a href=\"http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/\" target=\"_blank\" rel=\"noopener\">Prometheus在Kubernetes下的监控实践</a></li>\n<li><a href=\"https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1\" target=\"_blank\" rel=\"noopener\">通过Prometheus，Grafana和Docker进行监控</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Prometheus（普罗米修斯）是一套开源的监控&amp;报警&amp;时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。<br>Prometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。<br>Prometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。</p>\n<p>输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：<a href=\"https://github.com/prometheus。\" target=\"_blank\" rel=\"noopener\">https://github.com/prometheus。</a></p>\n<p>与其他监控系统相比，Prometheus的主要特点是：</p>\n<ul>\n<li>一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。</li>\n<li>非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。</li>\n<li>一种灵活的查询语言。</li>\n<li>不依赖分布式存储，单个服务器节点。</li>\n<li>时间集合通过HTTP上的PULL模型进行。</li>\n<li>通过中间网关支持推送时间。</li>\n<li>通过服务发现或静态配置发现目标。</li>\n<li>多种模式的图形和仪表板支持。</li>\n</ul>\n<h2 id=\"Prometheus架构概览\"><a href=\"#Prometheus架构概览\" class=\"headerlink\" title=\"Prometheus架构概览\"></a>Prometheus架构概览</h2><p>该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg\" alt=\"Prometheus架构概览\"><br>它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。</p>\n<ul>\n<li><p>Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。</p>\n</li>\n<li><p>Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</p>\n</li>\n<li><p>PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</p>\n</li>\n</ul>\n<h2 id=\"Prometheus的数据模型\"><a href=\"#Prometheus的数据模型\" class=\"headerlink\" title=\"Prometheus的数据模型\"></a>Prometheus的数据模型</h2><p>Prometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。<br>metrics name&amp;label指标名称和标签</p>\n<p>每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。</p>\n<h3 id=\"指标名称：\"><a href=\"#指标名称：\" class=\"headerlink\" title=\"指标名称：\"></a>指标名称：</h3><p>一般是给监测对像起一名字，例如http_requests_total这样，它有一些命名规则，可以包字母数字<em>之类的的。通常是以应用名称开头</em>监测对像<em>数值类型</em>单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。</p>\n<h3 id=\"标签：\"><a href=\"#标签：\" class=\"headerlink\" title=\"标签：\"></a>标签：</h3><p>就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。</p>\n<p>记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。</p>\n<p>查询语句就可以跟据上面标签的组合来查询聚合结果了。</p>\n<p>如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。</p>","more":"<h2 id=\"Prometheus四种数据类型\"><a href=\"#Prometheus四种数据类型\" class=\"headerlink\" title=\"Prometheus四种数据类型\"></a>Prometheus四种数据类型</h2><h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>Counter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。</p>\n<p>例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。</p>\n<h3 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h3><p>Gauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。</p>\n<p>例如： memory_usage_bytes{host=”master-01″} 100 &lt; 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 &lt; 抓取值。</p>\n<h3 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h3><p>Histogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。</p>\n<p>例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>Summary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。</p>\n<p>例如：count=7次，sum=7次的值求值。</p>\n<p>它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。</p>\n<h2 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h2><p>###下面的例子以这个项目为例(promethes项目)[<a href=\"https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]\" target=\"_blank\" rel=\"noopener\">https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]</a></p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># docker-compose.yml</span></span><br><span class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2.0'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">services:</span></span><br><span class=\"line\"><span class=\"attr\">  prometheus:</span> </span><br><span class=\"line\"><span class=\"attr\">    image:</span> prom/prometheus:v1<span class=\"number\">.0</span><span class=\"number\">.1</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./prometheus.yml:/etc/prometheus/prometheus.yml</span><br><span class=\"line\"><span class=\"attr\">        - prometheus_data:</span>/prometheus</span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</span><br><span class=\"line\"><span class=\"attr\">    command:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/etc/prometheus/prometheus.yml'</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-alertmanager.url=http://alertmanager:9093'</span></span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'9090:9090'</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  grafana:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"grafana/grafana:3.1.1\"</span></span><br><span class=\"line\"><span class=\"attr\">    environment:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> GF_SECURITY_ADMIN_PASSWORD=pass</span><br><span class=\"line\"><span class=\"attr\">    depends_on:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> prometheus</span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"attr\">        - grafana_data:</span>/var/lib/grafana</span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</span><br><span class=\"line\"><span class=\"attr\">    ports:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">\"3000:3000\"</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">  alertmanager:</span></span><br><span class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"prom/alertmanager:v0.8.0\"</span></span><br><span class=\"line\"><span class=\"attr\">    volumes:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> ./alertmanager.yml:/alertmanager.yml</span><br><span class=\"line\"><span class=\"attr\">    command:</span></span><br><span class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/alertmanager.yml'</span></span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"attr\">volumes:</span></span><br><span class=\"line\"><span class=\"attr\">  prometheus_data:</span> &#123;&#125;</span><br><span class=\"line\"><span class=\"attr\">  grafana_data:</span> &#123;&#125;</span><br></pre></td></tr></table></figure>\n<p>Prometheus内置了一个web界面，我们可通过<a href=\"http://monitor_host:9090进行访问：\" target=\"_blank\" rel=\"noopener\">http://monitor_host:9090进行访问：</a><br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg\" alt><br>但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg\" alt></p>\n<p>在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。<br>这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点<br>或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。</p>\n<h3 id=\"cAdvisor-容器数据采集\"><a href=\"#cAdvisor-容器数据采集\" class=\"headerlink\" title=\"cAdvisor 容器数据采集\"></a>cAdvisor 容器数据采集</h3><p>因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cadvisor:</span><br><span class=\"line\"> image: google/cadvisor</span><br><span class=\"line\"> volumes:</span><br><span class=\"line\">   - /:/rootfs:ro</span><br><span class=\"line\">   - /var/run:/var/run:rw</span><br><span class=\"line\">   - /sys:/sys:ro</span><br><span class=\"line\">   - /var/lib/docker/:/var/lib/docker:ro</span><br><span class=\"line\"> ports:</span><br><span class=\"line\">     - &quot;8080:8080&quot;</span><br><span class=\"line\"> expose:</span><br><span class=\"line\">     - &quot;8080&quot;</span><br></pre></td></tr></table></figure>\n<h3 id=\"prometheus-yaml-配置监听数据地址\"><a href=\"#prometheus-yaml-配置监听数据地址\" class=\"headerlink\" title=\"prometheus.yaml 配置监听数据地址\"></a>prometheus.yaml 配置监听数据地址</h3><p>prometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># my global config</span><br><span class=\"line\">global:</span><br><span class=\"line\">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</span><br><span class=\"line\">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</span><br><span class=\"line\">  # scrape_timeout is set to the global default (10s).</span><br><span class=\"line\"></span><br><span class=\"line\">  # Attach these labels to any time series or alerts when communicating with</span><br><span class=\"line\">  # external systems (federation, remote storage, Alertmanager).</span><br><span class=\"line\">  external_labels:</span><br><span class=\"line\">      monitor: &apos;codelab-monitor&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</span><br><span class=\"line\">rule_files:</span><br><span class=\"line\">    - &apos;alert.rules&apos;</span><br><span class=\"line\"></span><br><span class=\"line\"># A scrape configuration containing exactly one endpoint to scrape:</span><br><span class=\"line\"># Here it&apos;s Prometheus itself.</span><br><span class=\"line\">scrape_configs:</span><br><span class=\"line\">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</span><br><span class=\"line\">  - job_name: &apos;prometheus&apos;</span><br><span class=\"line\">    #scrape_interval: 5s</span><br><span class=\"line\">    # metrics_path defaults to &apos;/metrics&apos;</span><br><span class=\"line\">    # scheme defaults to &apos;http&apos;.</span><br><span class=\"line\"></span><br><span class=\"line\">    static_configs:</span><br><span class=\"line\">      - targets: [&apos;192.168.1.162:9090&apos;]</span><br><span class=\"line\">        labels:</span><br><span class=\"line\">          instance: prometheus</span><br><span class=\"line\"></span><br><span class=\"line\">  - job_name: &apos;docker-online&apos;</span><br><span class=\"line\">    #scrape_interval: 5s</span><br><span class=\"line\">    #scheme: http</span><br><span class=\"line\">    static_configs:</span><br><span class=\"line\">      - targets: [&apos;192.168.1.162:8080&apos;]</span><br><span class=\"line\">        labels:</span><br><span class=\"line\">         group: &apos;port&apos;</span><br></pre></td></tr></table></figure>\n<h3 id=\"Alertmanager报警组件\"><a href=\"#Alertmanager报警组件\" class=\"headerlink\" title=\"Alertmanager报警组件\"></a>Alertmanager报警组件</h3><p>Alertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。<br>要查看所有可用的命令行flag，运行alertmanager -h。<br>Alertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。<br>配置文件<br>要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">global:</span><br><span class=\"line\">  # ResolveTimeout is the time after which an alert is declared resolved</span><br><span class=\"line\">  # if it has not been updated.</span><br><span class=\"line\">  [ resolve_timeout: &lt;duration&gt; | default = 5m ]</span><br><span class=\"line\"></span><br><span class=\"line\">  # The default SMTP From header field.</span><br><span class=\"line\">  [ smtp_from: &lt;tmpl_string&gt; ]</span><br><span class=\"line\">  # The default SMTP smarthost used for sending emails.</span><br><span class=\"line\">  [ smtp_smarthost: &lt;string&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\">  # The API URL to use for Slack notifications.</span><br><span class=\"line\">  [ slack_api_url: &lt;string&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\">  [ pagerduty_url: &lt;string&gt; | default = &quot;https://events.pagerduty.com/generic/2010-04-15/create_event.json&quot; ]</span><br><span class=\"line\">  [ opsgenie_api_host: &lt;string&gt; | default = &quot;https://api.opsgenie.com/&quot; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Files from which custom notification template definitions are read.</span><br><span class=\"line\"># The last component may use a wildcard matcher, e.g. &apos;templates/*.tmpl&apos;.</span><br><span class=\"line\">templates:</span><br><span class=\"line\">  [ - &lt;filepath&gt; ... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># The root node of the routing tree.</span><br><span class=\"line\">route: &lt;route&gt;</span><br><span class=\"line\"></span><br><span class=\"line\"># A list of notification receivers.</span><br><span class=\"line\">receivers:</span><br><span class=\"line\">  - &lt;receiver&gt; ...</span><br><span class=\"line\"></span><br><span class=\"line\"># A list of inhibition rules.</span><br><span class=\"line\">inhibit_rules:</span><br><span class=\"line\">  [ - &lt;inhibit_rule&gt; ... ]</span><br></pre></td></tr></table></figure></p>\n<p>路由 route<br>路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。<br>每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。<br>路由配置格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">[ receiver: &lt;string&gt; ]</span><br><span class=\"line\">[ group_by: &apos;[&apos; &lt;labelname&gt;, ... &apos;]&apos; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Whether an alert should continue matching subsequent sibling nodes.</span><br><span class=\"line\">[ continue: &lt;boolean&gt; | default = false ]</span><br><span class=\"line\"></span><br><span class=\"line\"># A set of equality matchers an alert has to fulfill to match the node.</span><br><span class=\"line\">match:</span><br><span class=\"line\">  [ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># A set of regex-matchers an alert has to fulfill to match the node.</span><br><span class=\"line\">match_re:</span><br><span class=\"line\">  [ &lt;labelname&gt;: &lt;regex&gt;, ... ]</span><br><span class=\"line\"></span><br><span class=\"line\"># How long to initially wait to send a notification for a group</span><br><span class=\"line\"># of alerts. Allows to wait for an inhibiting alert to arrive or collect</span><br><span class=\"line\"># more initial alerts for the same group. (Usually ~0s to few minutes.)</span><br><span class=\"line\">[ group_wait: &lt;duration&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># How long to wait before sending notification about new alerts that are</span><br><span class=\"line\"># in are added to a group of alerts for which an initial notification</span><br><span class=\"line\"># has already been sent. (Usually ~5min or more.)</span><br><span class=\"line\">[ group_interval: &lt;duration&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># How long to wait before sending a notification again if it has already</span><br><span class=\"line\"># been sent successfully for an alert. (Usually ~3h or more).</span><br><span class=\"line\">[ repeat_interval: &lt;duration&gt; ]</span><br><span class=\"line\"></span><br><span class=\"line\"># Zero or more child routes.</span><br><span class=\"line\">routes:</span><br><span class=\"line\">  [ - &lt;route&gt; ... ]</span><br></pre></td></tr></table></figure>\n<p>在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">route:</span></span><br><span class=\"line\"><span class=\"attr\">    receiver:</span> <span class=\"string\">'slack'</span></span><br><span class=\"line\"><span class=\"attr\">receivers:</span></span><br><span class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">'slack'</span></span><br><span class=\"line\"><span class=\"attr\">      slack_configs:</span></span><br><span class=\"line\"><span class=\"attr\">          - send_resolved:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">'Prometheus'</span></span><br><span class=\"line\"><span class=\"attr\">            channel:</span> <span class=\"string\">'#random'</span></span><br><span class=\"line\"><span class=\"attr\">            api_url:</span> <span class=\"string\">'https://hooks.slack.com/services/&lt;your&gt;/&lt;stuff&gt;/&lt;here&gt;'</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"报警规则\"><a href=\"#报警规则\" class=\"headerlink\" title=\"报警规则\"></a>报警规则</h3><p>报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。<br>报警规则通过以下格式定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ALERT &lt;alert name&gt;</span><br><span class=\"line\">  IF &lt;expression&gt;</span><br><span class=\"line\">  [ FOR &lt;duration&gt; ]</span><br><span class=\"line\">  [ LABELS &lt;label set&gt; ]</span><br><span class=\"line\">  [ ANNOTATIONS &lt;label set&gt; ]</span><br></pre></td></tr></table></figure>\n<p>FOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。<br>LABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。<br>ANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。<br>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># alert.rules</span><br><span class=\"line\">ALERT service_down</span><br><span class=\"line\">  IF up == 0</span><br><span class=\"line\">ALERT high_load</span><br><span class=\"line\">  IF node_load1 &gt; 0.5</span><br><span class=\"line\">  ANNOTATIONS &#123;</span><br><span class=\"line\">      summary = &quot;Instance &#123;&#123; $labels.instance &#125;&#125; under high load&quot;,</span><br><span class=\"line\">      description = &quot;&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; is under highload.&quot;,</span><br><span class=\"line\">  &#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://prometheus.io\" target=\"_blank\" rel=\"noopener\">prometheus</a></li>\n<li><a href=\"http://grafana.org\" target=\"_blank\" rel=\"noopener\">grafana</a></li>\n<li><a href=\"https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html\" target=\"_blank\" rel=\"noopener\">Prometheus监控 - Alertmanager报警模块</a></li>\n<li><a href=\"https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/\" target=\"_blank\" rel=\"noopener\">Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center</a></li>\n<li><a href=\"http://www.ywnds.com/?p=9656\" target=\"_blank\" rel=\"noopener\">使用Prometheus+Grafana监控MySQL实践 – 运维那点事</a></li>\n<li><a href=\"http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html\" target=\"_blank\" rel=\"noopener\">使用Prometheus监控服务器</a></li>\n<li><a href=\"http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/\" target=\"_blank\" rel=\"noopener\">Prometheus在Kubernetes下的监控实践</a></li>\n<li><a href=\"https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1\" target=\"_blank\" rel=\"noopener\">通过Prometheus，Grafana和Docker进行监控</a></li>\n</ul>"},{"title":"Codeception测试框架如何编写测试","date":"2017-06-18T05:38:51.000Z","_content":"## 如何编写测试\nYii2高级应用程序使用Codeception作为其主要测试框架。\n### 搭建测试环境\n为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：\n``` php\ncomposer global require \"codeception/codeception=2.1.*\"\ncomposer global require \"codeception/specify=*\"\ncomposer global require \"codeception/verify=*\"\n```\n创建测试目录\n```\ncodecept bootstrap \n```\n构建测试套件：\n``` php\ncodecept build\n```\n如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：\n``` php\n./yii_test migrate\n```\n\n<!--more-->\n然后所有的样例测试可以通过运行如下代码：\n```\ncodecept run\n```\ndocker环境下运行搭建并运行测试：\n```\ndocker exec -it health_web_1 ./vendor/bin/codecept boostrap\ndocker exec -it health_web_1 ./vendor/bin/./yii_test migrate\ndocker exec -it health_web_1 ./vendor/bin/codecept build\ndocker exec -it health_web_1 ./vendor/bin/codecept run\n```\n测试套件描述：\n\n- unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。\n- api ⇒ api接口测试(主要)。\n- functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。\n- acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。\n\n## 启动测试\n\n\n``` bash\n docker exec -it usercenter_web_1 bash\n//或者\n docker exec -it health_web_1 /bin/sh\n./vendor/bin/codecept run -c tests\n```\n-c 指定目录\napi测试需要启动一个web服务器\n``` bash\nphp -S localhost:80 --docroot api/tests &>/dev/null&\n```\n\n## 搭建测试环境\n目录结构\n\n``` bash\n├── codeception\n│   ├── api  //api测试\n│   ├── api.suite.yml  //api测试配置\n│   ├── _bootstrap.php\n│   ├── _data\n│   │   └── dump.sql  //初始化sql\n│   ├── _output  //日志\n│   ├── _support                                                    \n│   ├── unit\n│   │   ├── _bootstrap.php   //依赖文件\n│   │   ├── models\n│   │   │   ├── ActivityConfigTest.php  //单元测试\n│   │   └── UnitTester.php\n│   └── unit.suite.yml  //单元测试配置文件\n├── codeception.yml\n├── _envs\n├── _output\n└── _support\n    └── _generated\n```\n\n在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件\n### api测试详解\nAPI测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件\n``` bash\n./vendor/bin/codecept g:suite api\n```\n您将需要启用REST，Yii2模块tests/api.suite.yml：\n``` bash\nclass_name: ApiTester\nmodules:\n    enabled:\n        - REST:\n            url: /api/v1\n            depends: Yii2\n        - \\ApiBundle\\Helper\\Api\n    config:\n        - Yii2\n```\nYii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。\n\n[继续执行REST API测试指南»](http://codeception.com/docs/10-WebServices#REST)\n### 单位测试详解\n单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。\n\n每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：\n``` bash\nmodules:\n    enabled:\n      - Yii2:\n            part: [orm, email]\n```\n该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。\n\n通过访问测试用例中的$this->tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：\n```\n<?php\n// insert records in database\n$this->tester->haveRecord('app/model/User', ['username' => 'davert']);\n// check records in database\n$this->tester->seeRecord('app/model/User', ['username' => 'davert']);\n// test email was sent\n$this->tester->seeEmailIsSent();\n// get a last sent emails\n$this->tester->grabLastSentEmail();\n```\n如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：\n```\n<?php\n// load fixtures\n$this->tester->haveFixtures([\n    'user' => [\n        'class' => UserFixture::className(),\n        // fixture data located in tests/_data/user.php\n        'dataFile' => codecept_data_dir() . 'user.php'\n    ]\n]);\n// get first user from fixtures\n$this->tester->grabFixture('user', 0);\n```\n如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。\n\n \n[继续进行单元测试指南»](http://codeception.com/docs/05-UnitTests)\n### 功能测试\n当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：\n```\n<?php\n$I->amOnPage(['site/contact']);\n$I->submitForm('#contact-form', []);\n$I->expectTo('see validations errors');\n$I->see('Contact', 'h1');\n$I->see('Name cannot be blank');\n$I->see('Email cannot be blank');\n$I->see('Subject cannot be blank');\n$I->see('Body cannot be blank');\n```\n这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。\n\n功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：\n\n./vendor/bin/codecept g:cest functional MyNewScenarioCest\n 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。\n\n[继续进行功能测试指南»](http://codeception.com/docs/04-FunctionalTests)\n\n### 验收测试\n从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。\n\n默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml\n```\nmv tests/acceptance.suite.yml.example tests/acceptance.suite.yml\n基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。\n```\n那么您将需要在测试模式下启动应用服务器：\n```\n./tests/bin/yii serve\n```\n并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：\n```\n# config at tests/acceptance.yml\nmodules:\n    enabled:\n        - WebDriver:\n            url: http://127.0.0.1:8080/\n            browser: firefox\n        - Yii2:\n            part: [orm, fixtures] # allow to use AR methods\n            cleanup: false # don't wrap test in transaction\n            entryScript: index-test.php\n```\n正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。\n\n与功能测试类似，建议使用Cest格式进行验收测试：\n```\n./vendor/bin/codecept g:cest acceptance MyNewScenarioCest\n```\n\n[继续验收测试指南»](http://codeception.com/docs/03-AcceptanceTests)\n\n\n### 手动设置&&配置\n要开始，您需要通过Composer安装Codeception\n```\ncomposer require \"codeception/codeception\" --dev\n```\n创建基本的测试套件\n```\n./vendor/bin/codecept bootstrap\n```\n启用模块Yii2进行功能测试functional.suite.yml：\n```\n# functional.suite.yml\nmodules:\n    enabled:\n        - Yii2:\n            configFile: #insert path to config file\n```\nYii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：\n```\n<?php\n// config/test.php\n$config =  yii\\helpers\\ArrayHelper::merge(\n    require(__DIR__ . '/main.php'),\n    require(__DIR__ . '/main-local.php'),\n    [\n        'id' => 'app-tests',\n        'components' => [\n            'db' => [\n                'dsn' => 'mysql:host=localhost;dbname=yii_app_test',\n            ]\n        ]        \n    ]\n);\nreturn $config;\n```\n测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。\n\n还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。\n\n一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。\n\n在基础和高级应用程序模板configFile中定义了全局配置文件：\n```\n# inside codeception.yml\nmodules:\n    config:\n        Yii2:\n            configFile: 'config/test.php'\n```\n这样我们不需要为每个定义的套件提供测试配置。\n### 伪数据生成器\n安装\n```\ncomposer require fzaninotto/faker\n```\n使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。\n```\n<?php\n// require the Faker autoloader\nrequire_once '/path/to/Faker/src/autoload.php';\n// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)\n\n// use the factory to create a Faker\\Generator instance\n$faker = Faker\\Factory::create();\n\n// generate data by accessing properties\necho $faker->name;\n  // 'Lucy Cechtelar';\necho $faker->address;\n  // \"426 Jordy Lodge\n  // Cartwrightshire, SC 88120-6700\"\necho $faker->text;\n  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit\n  // et sit et mollitia sed.\n  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium\n  // sit minima sint.\n```\n\n\n","source":"_posts/如何编写测试.md","raw":"---\ntitle: Codeception测试框架如何编写测试\ndate: 2017-06-18 13:38:51\ntags: php\ncategories: 技术\n\n---\n## 如何编写测试\nYii2高级应用程序使用Codeception作为其主要测试框架。\n### 搭建测试环境\n为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：\n``` php\ncomposer global require \"codeception/codeception=2.1.*\"\ncomposer global require \"codeception/specify=*\"\ncomposer global require \"codeception/verify=*\"\n```\n创建测试目录\n```\ncodecept bootstrap \n```\n构建测试套件：\n``` php\ncodecept build\n```\n如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：\n``` php\n./yii_test migrate\n```\n\n<!--more-->\n然后所有的样例测试可以通过运行如下代码：\n```\ncodecept run\n```\ndocker环境下运行搭建并运行测试：\n```\ndocker exec -it health_web_1 ./vendor/bin/codecept boostrap\ndocker exec -it health_web_1 ./vendor/bin/./yii_test migrate\ndocker exec -it health_web_1 ./vendor/bin/codecept build\ndocker exec -it health_web_1 ./vendor/bin/codecept run\n```\n测试套件描述：\n\n- unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。\n- api ⇒ api接口测试(主要)。\n- functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。\n- acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。\n\n## 启动测试\n\n\n``` bash\n docker exec -it usercenter_web_1 bash\n//或者\n docker exec -it health_web_1 /bin/sh\n./vendor/bin/codecept run -c tests\n```\n-c 指定目录\napi测试需要启动一个web服务器\n``` bash\nphp -S localhost:80 --docroot api/tests &>/dev/null&\n```\n\n## 搭建测试环境\n目录结构\n\n``` bash\n├── codeception\n│   ├── api  //api测试\n│   ├── api.suite.yml  //api测试配置\n│   ├── _bootstrap.php\n│   ├── _data\n│   │   └── dump.sql  //初始化sql\n│   ├── _output  //日志\n│   ├── _support                                                    \n│   ├── unit\n│   │   ├── _bootstrap.php   //依赖文件\n│   │   ├── models\n│   │   │   ├── ActivityConfigTest.php  //单元测试\n│   │   └── UnitTester.php\n│   └── unit.suite.yml  //单元测试配置文件\n├── codeception.yml\n├── _envs\n├── _output\n└── _support\n    └── _generated\n```\n\n在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件\n### api测试详解\nAPI测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件\n``` bash\n./vendor/bin/codecept g:suite api\n```\n您将需要启用REST，Yii2模块tests/api.suite.yml：\n``` bash\nclass_name: ApiTester\nmodules:\n    enabled:\n        - REST:\n            url: /api/v1\n            depends: Yii2\n        - \\ApiBundle\\Helper\\Api\n    config:\n        - Yii2\n```\nYii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。\n\n[继续执行REST API测试指南»](http://codeception.com/docs/10-WebServices#REST)\n### 单位测试详解\n单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。\n\n每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：\n``` bash\nmodules:\n    enabled:\n      - Yii2:\n            part: [orm, email]\n```\n该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。\n\n通过访问测试用例中的$this->tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：\n```\n<?php\n// insert records in database\n$this->tester->haveRecord('app/model/User', ['username' => 'davert']);\n// check records in database\n$this->tester->seeRecord('app/model/User', ['username' => 'davert']);\n// test email was sent\n$this->tester->seeEmailIsSent();\n// get a last sent emails\n$this->tester->grabLastSentEmail();\n```\n如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：\n```\n<?php\n// load fixtures\n$this->tester->haveFixtures([\n    'user' => [\n        'class' => UserFixture::className(),\n        // fixture data located in tests/_data/user.php\n        'dataFile' => codecept_data_dir() . 'user.php'\n    ]\n]);\n// get first user from fixtures\n$this->tester->grabFixture('user', 0);\n```\n如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。\n\n \n[继续进行单元测试指南»](http://codeception.com/docs/05-UnitTests)\n### 功能测试\n当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：\n```\n<?php\n$I->amOnPage(['site/contact']);\n$I->submitForm('#contact-form', []);\n$I->expectTo('see validations errors');\n$I->see('Contact', 'h1');\n$I->see('Name cannot be blank');\n$I->see('Email cannot be blank');\n$I->see('Subject cannot be blank');\n$I->see('Body cannot be blank');\n```\n这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。\n\n功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：\n\n./vendor/bin/codecept g:cest functional MyNewScenarioCest\n 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。\n\n[继续进行功能测试指南»](http://codeception.com/docs/04-FunctionalTests)\n\n### 验收测试\n从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。\n\n默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml\n```\nmv tests/acceptance.suite.yml.example tests/acceptance.suite.yml\n基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。\n```\n那么您将需要在测试模式下启动应用服务器：\n```\n./tests/bin/yii serve\n```\n并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：\n```\n# config at tests/acceptance.yml\nmodules:\n    enabled:\n        - WebDriver:\n            url: http://127.0.0.1:8080/\n            browser: firefox\n        - Yii2:\n            part: [orm, fixtures] # allow to use AR methods\n            cleanup: false # don't wrap test in transaction\n            entryScript: index-test.php\n```\n正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。\n\n与功能测试类似，建议使用Cest格式进行验收测试：\n```\n./vendor/bin/codecept g:cest acceptance MyNewScenarioCest\n```\n\n[继续验收测试指南»](http://codeception.com/docs/03-AcceptanceTests)\n\n\n### 手动设置&&配置\n要开始，您需要通过Composer安装Codeception\n```\ncomposer require \"codeception/codeception\" --dev\n```\n创建基本的测试套件\n```\n./vendor/bin/codecept bootstrap\n```\n启用模块Yii2进行功能测试functional.suite.yml：\n```\n# functional.suite.yml\nmodules:\n    enabled:\n        - Yii2:\n            configFile: #insert path to config file\n```\nYii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：\n```\n<?php\n// config/test.php\n$config =  yii\\helpers\\ArrayHelper::merge(\n    require(__DIR__ . '/main.php'),\n    require(__DIR__ . '/main-local.php'),\n    [\n        'id' => 'app-tests',\n        'components' => [\n            'db' => [\n                'dsn' => 'mysql:host=localhost;dbname=yii_app_test',\n            ]\n        ]        \n    ]\n);\nreturn $config;\n```\n测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。\n\n还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。\n\n一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。\n\n在基础和高级应用程序模板configFile中定义了全局配置文件：\n```\n# inside codeception.yml\nmodules:\n    config:\n        Yii2:\n            configFile: 'config/test.php'\n```\n这样我们不需要为每个定义的套件提供测试配置。\n### 伪数据生成器\n安装\n```\ncomposer require fzaninotto/faker\n```\n使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。\n```\n<?php\n// require the Faker autoloader\nrequire_once '/path/to/Faker/src/autoload.php';\n// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)\n\n// use the factory to create a Faker\\Generator instance\n$faker = Faker\\Factory::create();\n\n// generate data by accessing properties\necho $faker->name;\n  // 'Lucy Cechtelar';\necho $faker->address;\n  // \"426 Jordy Lodge\n  // Cartwrightshire, SC 88120-6700\"\necho $faker->text;\n  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit\n  // et sit et mollitia sed.\n  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium\n  // sit minima sint.\n```\n\n\n","slug":"如何编写测试","published":1,"updated":"2018-05-27T09:59:36.037Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjp001ath8l2pdovcjo","content":"<h2 id=\"如何编写测试\"><a href=\"#如何编写测试\" class=\"headerlink\" title=\"如何编写测试\"></a>如何编写测试</h2><p>Yii2高级应用程序使用Codeception作为其主要测试框架。</p>\n<h3 id=\"搭建测试环境\"><a href=\"#搭建测试环境\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h3><p>为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/codeception=2.1.*\"</span></span><br><span class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/specify=*\"</span></span><br><span class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/verify=*\"</span></span><br></pre></td></tr></table></figure></p>\n<p>创建测试目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codecept bootstrap</span><br></pre></td></tr></table></figure></p>\n<p>构建测试套件：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codecept build</span><br></pre></td></tr></table></figure></p>\n<p>如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./yii_test migrate</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>然后所有的样例测试可以通过运行如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codecept run</span><br></pre></td></tr></table></figure></p>\n<p>docker环境下运行搭建并运行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept boostrap</span><br><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/./yii_test migrate</span><br><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept build</span><br><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept run</span><br></pre></td></tr></table></figure></p>\n<p>测试套件描述：</p>\n<ul>\n<li>unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。</li>\n<li>api ⇒ api接口测试(主要)。</li>\n<li>functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。</li>\n<li>acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。</li>\n</ul>\n<h2 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> docker <span class=\"built_in\">exec</span> -it usercenter_web_1 bash</span><br><span class=\"line\">//或者</span><br><span class=\"line\"> docker <span class=\"built_in\">exec</span> -it health_web_1 /bin/sh</span><br><span class=\"line\">./vendor/bin/codecept run -c tests</span><br></pre></td></tr></table></figure>\n<p>-c 指定目录<br>api测试需要启动一个web服务器<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -S localhost:80 --docroot api/tests &amp;&gt;/dev/null&amp;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"搭建测试环境-1\"><a href=\"#搭建测试环境-1\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h2><p>目录结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── codeception</span><br><span class=\"line\">│   ├── api  //api测试</span><br><span class=\"line\">│   ├── api.suite.yml  //api测试配置</span><br><span class=\"line\">│   ├── _bootstrap.php</span><br><span class=\"line\">│   ├── _data</span><br><span class=\"line\">│   │   └── dump.sql  //初始化sql</span><br><span class=\"line\">│   ├── _output  //日志</span><br><span class=\"line\">│   ├── _support                                                    </span><br><span class=\"line\">│   ├── unit</span><br><span class=\"line\">│   │   ├── _bootstrap.php   //依赖文件</span><br><span class=\"line\">│   │   ├── models</span><br><span class=\"line\">│   │   │   ├── ActivityConfigTest.php  //单元测试</span><br><span class=\"line\">│   │   └── UnitTester.php</span><br><span class=\"line\">│   └── unit.suite.yml  //单元测试配置文件</span><br><span class=\"line\">├── codeception.yml</span><br><span class=\"line\">├── _envs</span><br><span class=\"line\">├── _output</span><br><span class=\"line\">└── _support</span><br><span class=\"line\">    └── _generated</span><br></pre></td></tr></table></figure>\n<p>在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件</p>\n<h3 id=\"api测试详解\"><a href=\"#api测试详解\" class=\"headerlink\" title=\"api测试详解\"></a>api测试详解</h3><p>API测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./vendor/bin/codecept g:suite api</span><br></pre></td></tr></table></figure></p>\n<p>您将需要启用REST，Yii2模块tests/api.suite.yml：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class_name: ApiTester</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">        - REST:</span><br><span class=\"line\">            url: /api/v1</span><br><span class=\"line\">            depends: Yii2</span><br><span class=\"line\">        - \\ApiBundle\\Helper\\Api</span><br><span class=\"line\">    config:</span><br><span class=\"line\">        - Yii2</span><br></pre></td></tr></table></figure></p>\n<p>Yii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。</p>\n<p><a href=\"http://codeception.com/docs/10-WebServices#REST\" target=\"_blank\" rel=\"noopener\">继续执行REST API测试指南»</a></p>\n<h3 id=\"单位测试详解\"><a href=\"#单位测试详解\" class=\"headerlink\" title=\"单位测试详解\"></a>单位测试详解</h3><p>单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。</p>\n<p>每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">      - Yii2:</span><br><span class=\"line\">            part: [orm, email]</span><br></pre></td></tr></table></figure></p>\n<p>该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。</p>\n<p>通过访问测试用例中的$this-&gt;tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// insert records in database</span><br><span class=\"line\">$this-&gt;tester-&gt;haveRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</span><br><span class=\"line\">// check records in database</span><br><span class=\"line\">$this-&gt;tester-&gt;seeRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</span><br><span class=\"line\">// test email was sent</span><br><span class=\"line\">$this-&gt;tester-&gt;seeEmailIsSent();</span><br><span class=\"line\">// get a last sent emails</span><br><span class=\"line\">$this-&gt;tester-&gt;grabLastSentEmail();</span><br></pre></td></tr></table></figure></p>\n<p>如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// load fixtures</span><br><span class=\"line\">$this-&gt;tester-&gt;haveFixtures([</span><br><span class=\"line\">    &apos;user&apos; =&gt; [</span><br><span class=\"line\">        &apos;class&apos; =&gt; UserFixture::className(),</span><br><span class=\"line\">        // fixture data located in tests/_data/user.php</span><br><span class=\"line\">        &apos;dataFile&apos; =&gt; codecept_data_dir() . &apos;user.php&apos;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]);</span><br><span class=\"line\">// get first user from fixtures</span><br><span class=\"line\">$this-&gt;tester-&gt;grabFixture(&apos;user&apos;, 0);</span><br></pre></td></tr></table></figure></p>\n<p>如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。</p>\n<p><a href=\"http://codeception.com/docs/05-UnitTests\" target=\"_blank\" rel=\"noopener\">继续进行单元测试指南»</a></p>\n<h3 id=\"功能测试\"><a href=\"#功能测试\" class=\"headerlink\" title=\"功能测试\"></a>功能测试</h3><p>当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$I-&gt;amOnPage([&apos;site/contact&apos;]);</span><br><span class=\"line\">$I-&gt;submitForm(&apos;#contact-form&apos;, []);</span><br><span class=\"line\">$I-&gt;expectTo(&apos;see validations errors&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Contact&apos;, &apos;h1&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Name cannot be blank&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Email cannot be blank&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Subject cannot be blank&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Body cannot be blank&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。</p>\n<p>功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：</p>\n<p>./vendor/bin/codecept g:cest functional MyNewScenarioCest<br> 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。</p>\n<p><a href=\"http://codeception.com/docs/04-FunctionalTests\" target=\"_blank\" rel=\"noopener\">继续进行功能测试指南»</a></p>\n<h3 id=\"验收测试\"><a href=\"#验收测试\" class=\"headerlink\" title=\"验收测试\"></a>验收测试</h3><p>从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。</p>\n<p>默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv tests/acceptance.suite.yml.example tests/acceptance.suite.yml</span><br><span class=\"line\">基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。</span><br></pre></td></tr></table></figure></p>\n<p>那么您将需要在测试模式下启动应用服务器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./tests/bin/yii serve</span><br></pre></td></tr></table></figure></p>\n<p>并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># config at tests/acceptance.yml</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">        - WebDriver:</span><br><span class=\"line\">            url: http://127.0.0.1:8080/</span><br><span class=\"line\">            browser: firefox</span><br><span class=\"line\">        - Yii2:</span><br><span class=\"line\">            part: [orm, fixtures] # allow to use AR methods</span><br><span class=\"line\">            cleanup: false # don&apos;t wrap test in transaction</span><br><span class=\"line\">            entryScript: index-test.php</span><br></pre></td></tr></table></figure></p>\n<p>正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。</p>\n<p>与功能测试类似，建议使用Cest格式进行验收测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./vendor/bin/codecept g:cest acceptance MyNewScenarioCest</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://codeception.com/docs/03-AcceptanceTests\" target=\"_blank\" rel=\"noopener\">继续验收测试指南»</a></p>\n<h3 id=\"手动设置-amp-amp-配置\"><a href=\"#手动设置-amp-amp-配置\" class=\"headerlink\" title=\"手动设置&amp;&amp;配置\"></a>手动设置&amp;&amp;配置</h3><p>要开始，您需要通过Composer安装Codeception<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require &quot;codeception/codeception&quot; --dev</span><br></pre></td></tr></table></figure></p>\n<p>创建基本的测试套件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./vendor/bin/codecept bootstrap</span><br></pre></td></tr></table></figure></p>\n<p>启用模块Yii2进行功能测试functional.suite.yml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># functional.suite.yml</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">        - Yii2:</span><br><span class=\"line\">            configFile: #insert path to config file</span><br></pre></td></tr></table></figure></p>\n<p>Yii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// config/test.php</span><br><span class=\"line\">$config =  yii\\helpers\\ArrayHelper::merge(</span><br><span class=\"line\">    require(__DIR__ . &apos;/main.php&apos;),</span><br><span class=\"line\">    require(__DIR__ . &apos;/main-local.php&apos;),</span><br><span class=\"line\">    [</span><br><span class=\"line\">        &apos;id&apos; =&gt; &apos;app-tests&apos;,</span><br><span class=\"line\">        &apos;components&apos; =&gt; [</span><br><span class=\"line\">            &apos;db&apos; =&gt; [</span><br><span class=\"line\">                &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yii_app_test&apos;,</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        ]        </span><br><span class=\"line\">    ]</span><br><span class=\"line\">);</span><br><span class=\"line\">return $config;</span><br></pre></td></tr></table></figure></p>\n<p>测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。</p>\n<p>还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。</p>\n<p>一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。</p>\n<p>在基础和高级应用程序模板configFile中定义了全局配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># inside codeception.yml</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">        Yii2:</span><br><span class=\"line\">            configFile: &apos;config/test.php&apos;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们不需要为每个定义的套件提供测试配置。</p>\n<h3 id=\"伪数据生成器\"><a href=\"#伪数据生成器\" class=\"headerlink\" title=\"伪数据生成器\"></a>伪数据生成器</h3><p>安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require fzaninotto/faker</span><br></pre></td></tr></table></figure></p>\n<p>使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// require the Faker autoloader</span><br><span class=\"line\">require_once &apos;/path/to/Faker/src/autoload.php&apos;;</span><br><span class=\"line\">// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)</span><br><span class=\"line\"></span><br><span class=\"line\">// use the factory to create a Faker\\Generator instance</span><br><span class=\"line\">$faker = Faker\\Factory::create();</span><br><span class=\"line\"></span><br><span class=\"line\">// generate data by accessing properties</span><br><span class=\"line\">echo $faker-&gt;name;</span><br><span class=\"line\">  // &apos;Lucy Cechtelar&apos;;</span><br><span class=\"line\">echo $faker-&gt;address;</span><br><span class=\"line\">  // &quot;426 Jordy Lodge</span><br><span class=\"line\">  // Cartwrightshire, SC 88120-6700&quot;</span><br><span class=\"line\">echo $faker-&gt;text;</span><br><span class=\"line\">  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit</span><br><span class=\"line\">  // et sit et mollitia sed.</span><br><span class=\"line\">  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium</span><br><span class=\"line\">  // sit minima sint.</span><br></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何编写测试\"><a href=\"#如何编写测试\" class=\"headerlink\" title=\"如何编写测试\"></a>如何编写测试</h2><p>Yii2高级应用程序使用Codeception作为其主要测试框架。</p>\n<h3 id=\"搭建测试环境\"><a href=\"#搭建测试环境\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h3><p>为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/codeception=2.1.*\"</span></span><br><span class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/specify=*\"</span></span><br><span class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/verify=*\"</span></span><br></pre></td></tr></table></figure></p>\n<p>创建测试目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codecept bootstrap</span><br></pre></td></tr></table></figure></p>\n<p>构建测试套件：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codecept build</span><br></pre></td></tr></table></figure></p>\n<p>如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./yii_test migrate</span><br></pre></td></tr></table></figure></p>","more":"<p>然后所有的样例测试可以通过运行如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">codecept run</span><br></pre></td></tr></table></figure></p>\n<p>docker环境下运行搭建并运行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept boostrap</span><br><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/./yii_test migrate</span><br><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept build</span><br><span class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept run</span><br></pre></td></tr></table></figure></p>\n<p>测试套件描述：</p>\n<ul>\n<li>unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。</li>\n<li>api ⇒ api接口测试(主要)。</li>\n<li>functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。</li>\n<li>acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。</li>\n</ul>\n<h2 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> docker <span class=\"built_in\">exec</span> -it usercenter_web_1 bash</span><br><span class=\"line\">//或者</span><br><span class=\"line\"> docker <span class=\"built_in\">exec</span> -it health_web_1 /bin/sh</span><br><span class=\"line\">./vendor/bin/codecept run -c tests</span><br></pre></td></tr></table></figure>\n<p>-c 指定目录<br>api测试需要启动一个web服务器<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">php -S localhost:80 --docroot api/tests &amp;&gt;/dev/null&amp;</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"搭建测试环境-1\"><a href=\"#搭建测试环境-1\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h2><p>目录结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">├── codeception</span><br><span class=\"line\">│   ├── api  //api测试</span><br><span class=\"line\">│   ├── api.suite.yml  //api测试配置</span><br><span class=\"line\">│   ├── _bootstrap.php</span><br><span class=\"line\">│   ├── _data</span><br><span class=\"line\">│   │   └── dump.sql  //初始化sql</span><br><span class=\"line\">│   ├── _output  //日志</span><br><span class=\"line\">│   ├── _support                                                    </span><br><span class=\"line\">│   ├── unit</span><br><span class=\"line\">│   │   ├── _bootstrap.php   //依赖文件</span><br><span class=\"line\">│   │   ├── models</span><br><span class=\"line\">│   │   │   ├── ActivityConfigTest.php  //单元测试</span><br><span class=\"line\">│   │   └── UnitTester.php</span><br><span class=\"line\">│   └── unit.suite.yml  //单元测试配置文件</span><br><span class=\"line\">├── codeception.yml</span><br><span class=\"line\">├── _envs</span><br><span class=\"line\">├── _output</span><br><span class=\"line\">└── _support</span><br><span class=\"line\">    └── _generated</span><br></pre></td></tr></table></figure>\n<p>在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件</p>\n<h3 id=\"api测试详解\"><a href=\"#api测试详解\" class=\"headerlink\" title=\"api测试详解\"></a>api测试详解</h3><p>API测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./vendor/bin/codecept g:suite api</span><br></pre></td></tr></table></figure></p>\n<p>您将需要启用REST，Yii2模块tests/api.suite.yml：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class_name: ApiTester</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">        - REST:</span><br><span class=\"line\">            url: /api/v1</span><br><span class=\"line\">            depends: Yii2</span><br><span class=\"line\">        - \\ApiBundle\\Helper\\Api</span><br><span class=\"line\">    config:</span><br><span class=\"line\">        - Yii2</span><br></pre></td></tr></table></figure></p>\n<p>Yii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。</p>\n<p><a href=\"http://codeception.com/docs/10-WebServices#REST\" target=\"_blank\" rel=\"noopener\">继续执行REST API测试指南»</a></p>\n<h3 id=\"单位测试详解\"><a href=\"#单位测试详解\" class=\"headerlink\" title=\"单位测试详解\"></a>单位测试详解</h3><p>单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。</p>\n<p>每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">      - Yii2:</span><br><span class=\"line\">            part: [orm, email]</span><br></pre></td></tr></table></figure></p>\n<p>该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。</p>\n<p>通过访问测试用例中的$this-&gt;tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// insert records in database</span><br><span class=\"line\">$this-&gt;tester-&gt;haveRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</span><br><span class=\"line\">// check records in database</span><br><span class=\"line\">$this-&gt;tester-&gt;seeRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</span><br><span class=\"line\">// test email was sent</span><br><span class=\"line\">$this-&gt;tester-&gt;seeEmailIsSent();</span><br><span class=\"line\">// get a last sent emails</span><br><span class=\"line\">$this-&gt;tester-&gt;grabLastSentEmail();</span><br></pre></td></tr></table></figure></p>\n<p>如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// load fixtures</span><br><span class=\"line\">$this-&gt;tester-&gt;haveFixtures([</span><br><span class=\"line\">    &apos;user&apos; =&gt; [</span><br><span class=\"line\">        &apos;class&apos; =&gt; UserFixture::className(),</span><br><span class=\"line\">        // fixture data located in tests/_data/user.php</span><br><span class=\"line\">        &apos;dataFile&apos; =&gt; codecept_data_dir() . &apos;user.php&apos;</span><br><span class=\"line\">    ]</span><br><span class=\"line\">]);</span><br><span class=\"line\">// get first user from fixtures</span><br><span class=\"line\">$this-&gt;tester-&gt;grabFixture(&apos;user&apos;, 0);</span><br></pre></td></tr></table></figure></p>\n<p>如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。</p>\n<p><a href=\"http://codeception.com/docs/05-UnitTests\" target=\"_blank\" rel=\"noopener\">继续进行单元测试指南»</a></p>\n<h3 id=\"功能测试\"><a href=\"#功能测试\" class=\"headerlink\" title=\"功能测试\"></a>功能测试</h3><p>当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">$I-&gt;amOnPage([&apos;site/contact&apos;]);</span><br><span class=\"line\">$I-&gt;submitForm(&apos;#contact-form&apos;, []);</span><br><span class=\"line\">$I-&gt;expectTo(&apos;see validations errors&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Contact&apos;, &apos;h1&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Name cannot be blank&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Email cannot be blank&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Subject cannot be blank&apos;);</span><br><span class=\"line\">$I-&gt;see(&apos;Body cannot be blank&apos;);</span><br></pre></td></tr></table></figure></p>\n<p>这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。</p>\n<p>功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：</p>\n<p>./vendor/bin/codecept g:cest functional MyNewScenarioCest<br> 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。</p>\n<p><a href=\"http://codeception.com/docs/04-FunctionalTests\" target=\"_blank\" rel=\"noopener\">继续进行功能测试指南»</a></p>\n<h3 id=\"验收测试\"><a href=\"#验收测试\" class=\"headerlink\" title=\"验收测试\"></a>验收测试</h3><p>从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。</p>\n<p>默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mv tests/acceptance.suite.yml.example tests/acceptance.suite.yml</span><br><span class=\"line\">基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。</span><br></pre></td></tr></table></figure></p>\n<p>那么您将需要在测试模式下启动应用服务器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./tests/bin/yii serve</span><br></pre></td></tr></table></figure></p>\n<p>并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># config at tests/acceptance.yml</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">        - WebDriver:</span><br><span class=\"line\">            url: http://127.0.0.1:8080/</span><br><span class=\"line\">            browser: firefox</span><br><span class=\"line\">        - Yii2:</span><br><span class=\"line\">            part: [orm, fixtures] # allow to use AR methods</span><br><span class=\"line\">            cleanup: false # don&apos;t wrap test in transaction</span><br><span class=\"line\">            entryScript: index-test.php</span><br></pre></td></tr></table></figure></p>\n<p>正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。</p>\n<p>与功能测试类似，建议使用Cest格式进行验收测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./vendor/bin/codecept g:cest acceptance MyNewScenarioCest</span><br></pre></td></tr></table></figure></p>\n<p><a href=\"http://codeception.com/docs/03-AcceptanceTests\" target=\"_blank\" rel=\"noopener\">继续验收测试指南»</a></p>\n<h3 id=\"手动设置-amp-amp-配置\"><a href=\"#手动设置-amp-amp-配置\" class=\"headerlink\" title=\"手动设置&amp;&amp;配置\"></a>手动设置&amp;&amp;配置</h3><p>要开始，您需要通过Composer安装Codeception<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require &quot;codeception/codeception&quot; --dev</span><br></pre></td></tr></table></figure></p>\n<p>创建基本的测试套件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">./vendor/bin/codecept bootstrap</span><br></pre></td></tr></table></figure></p>\n<p>启用模块Yii2进行功能测试functional.suite.yml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># functional.suite.yml</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    enabled:</span><br><span class=\"line\">        - Yii2:</span><br><span class=\"line\">            configFile: #insert path to config file</span><br></pre></td></tr></table></figure></p>\n<p>Yii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// config/test.php</span><br><span class=\"line\">$config =  yii\\helpers\\ArrayHelper::merge(</span><br><span class=\"line\">    require(__DIR__ . &apos;/main.php&apos;),</span><br><span class=\"line\">    require(__DIR__ . &apos;/main-local.php&apos;),</span><br><span class=\"line\">    [</span><br><span class=\"line\">        &apos;id&apos; =&gt; &apos;app-tests&apos;,</span><br><span class=\"line\">        &apos;components&apos; =&gt; [</span><br><span class=\"line\">            &apos;db&apos; =&gt; [</span><br><span class=\"line\">                &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yii_app_test&apos;,</span><br><span class=\"line\">            ]</span><br><span class=\"line\">        ]        </span><br><span class=\"line\">    ]</span><br><span class=\"line\">);</span><br><span class=\"line\">return $config;</span><br></pre></td></tr></table></figure></p>\n<p>测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。</p>\n<p>还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。</p>\n<p>一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。</p>\n<p>在基础和高级应用程序模板configFile中定义了全局配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"># inside codeception.yml</span><br><span class=\"line\">modules:</span><br><span class=\"line\">    config:</span><br><span class=\"line\">        Yii2:</span><br><span class=\"line\">            configFile: &apos;config/test.php&apos;</span><br></pre></td></tr></table></figure></p>\n<p>这样我们不需要为每个定义的套件提供测试配置。</p>\n<h3 id=\"伪数据生成器\"><a href=\"#伪数据生成器\" class=\"headerlink\" title=\"伪数据生成器\"></a>伪数据生成器</h3><p>安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">composer require fzaninotto/faker</span><br></pre></td></tr></table></figure></p>\n<p>使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;?php</span><br><span class=\"line\">// require the Faker autoloader</span><br><span class=\"line\">require_once &apos;/path/to/Faker/src/autoload.php&apos;;</span><br><span class=\"line\">// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)</span><br><span class=\"line\"></span><br><span class=\"line\">// use the factory to create a Faker\\Generator instance</span><br><span class=\"line\">$faker = Faker\\Factory::create();</span><br><span class=\"line\"></span><br><span class=\"line\">// generate data by accessing properties</span><br><span class=\"line\">echo $faker-&gt;name;</span><br><span class=\"line\">  // &apos;Lucy Cechtelar&apos;;</span><br><span class=\"line\">echo $faker-&gt;address;</span><br><span class=\"line\">  // &quot;426 Jordy Lodge</span><br><span class=\"line\">  // Cartwrightshire, SC 88120-6700&quot;</span><br><span class=\"line\">echo $faker-&gt;text;</span><br><span class=\"line\">  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit</span><br><span class=\"line\">  // et sit et mollitia sed.</span><br><span class=\"line\">  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium</span><br><span class=\"line\">  // sit minima sint.</span><br></pre></td></tr></table></figure></p>"},{"title":"探索php中的变量zval结构体","date":"2017-06-18T15:03:30.000Z","_content":"## 变量的类型\nphp是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.\n注意这个php的版本是5.4,最新的php7结构体已经变更\nPHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：\n``` c\n\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc;\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n\n//在Zend/zend_types.h里定义的：\ntypedef unsigned int zend_uint;\ntypedef unsigned char zend_uchar;\n\n```\n\n<!--more-->\n保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：\n``` c\ntypedef union _zvalue_value {\n        long lval;                  /* long value */\n        double dval;                /* double value */\n        struct {\n                char *val;\n                int len;\n        } str;\n        HashTable *ht;              /* hash table value */\n        zend_object_value obj;\n} zvalue_value;\n\n```\n\n> PHP中常见的变量类型有：\n1. 整型/浮点/长整型/bool值 等等\n2. 字符串\n3. 数组/关联数组\n4. 对象\n5. 资源\n\n\nPHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:\n\n``` c\n      zval.type = IS_LONG;//整形\n      zval.type = IS_BOOL;//布尔值\n```\n\n就去取zval.value.lval,对于bool值来说lval∈(0|1);\n如果是双精度，或者float则会去取zval.value的dval。\n而如果是字符串，那么:\n\n``` c\n         zval.type = IS_STRING\n```\n\n这个时候，就会取:\n\n``` c \n         zval.value.str\n```\n\n而这个也是个结构，存有C分格的字符串和字符串的长度。\n而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj\n比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:\n\n``` c\n            type = IS_RESOURCE\n```\n## 变量类型的实现\n在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：\n\n| 常量名称： |  解释 |\n| :--------  |  :---:|\n| IS_NULL    | 第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。|\n| IS_BOOL    | 布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。|\n| IS_LONG    | PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。| \n| IS_DOUBLE  | PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011....。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333.....，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0. |\n| IS_STRING  | PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。|\n| IS_ARRAY   | 数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。\n| IS_OBJECT  | 和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！\n| IS_RESOURCE| 有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。\n\n\nzval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。\n如果要我们检测一个变量的类型\n``` c\nvoid describe_zval(zval *foo)\n{\n        if ( Z_TYPE_P(foo) == IS_NULL  )\n        {\n                    php_printf(\"这个变量的数据类型是： NULL\");\n                        \n        }\n        else\n        {\n                    php_printf(\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\", Z_TYPE_P(foo));\n                        \n        }\n\n}\n```\n\n以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。\n\n``` c\n//开始定义php语言中的函数gettype\nPHP_FUNCTION(gettype)\n{\n    //arg间接指向调用gettype函数时所传递的参数。是一个zval**结构\n    //所以我们要对他使用__PP后缀的宏。\n    zval **arg;\n\n    //这个if的操作主要是让arg指向参数～\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &arg) == FAILURE) {\n                return;\n    }\n                    \n    //调用Z_TYPE_PP宏来获取arg指向zval的类型。\n    //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值\n    switch (Z_TYPE_PP(arg)) {\n        case IS_NULL:\n            RETVAL_STRING(\"NULL\", 1);\n            break;\n        case IS_BOOL:\n            RETVAL_STRING(\"boolean\", 1);\n            break;\n        case IS_LONG:\n            RETVAL_STRING(\"integer\", 1);\n            break;\n        case IS_DOUBLE:\n            RETVAL_STRING(\"double\", 1);\n            break;\n        case IS_STRING:\n            RETVAL_STRING(\"string\", 1);\n            break;\n        case IS_ARRAY:\n            RETVAL_STRING(\"array\", 1);\n            break;\n        case IS_OBJECT:\n            RETVAL_STRING(\"object\", 1);\n            break;\n        case IS_RESOURCE:\n        {\n            char *type_name;\n            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);\n            if (type_name) {\n                RETVAL_STRING(\"resource\", 1);\n                break;\n            }\n        }\n        default:\n                    RETVAL_STRING(\"unknown type\", 1);\n    }\n}       \n```\n以上三个宏的定义在Zend/zend_operators.h里，定义分别是：\n\n#define Z_TYPE(zval)        (zval).type\n#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)\n#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)\n\n## 变量值的实现\nPHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.\n内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:\n``` c\nvoid display_value(zval zv,zval *zv_p,zval **zv_pp)\n{\n    if( Z_TYPE(zv) == IS_NULL)\n    {\n                php_printf(\"类型是 IS_NULL!\\n\");\n    }\n    if( Z_TYPE_P(zv_p) == IS_LONG)\n    {\n                php_printf(\"类型是 IS_LONG，值是：%ld\" , Z_LVAL_P(zv_p));\n    }\n    if(Z_TYPE_PP(zv_pp) == IS_DOUBLE)\n    {\n                php_printf(\"类型是 IS_DOUBLE,值是：%f\" , Z_DVAL_PP(zv_pp) );\n    }\n}   \n```\nstring型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。\n``` c\nvoid display_string(zval *zstr)\n{\n    if (Z_TYPE_P(zstr) != IS_STRING) {\n        php_printf(\"这个变量不是字符串!\\n\");\n        return;\n    }\n    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));\n    //这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。\n}       \n ```       \nArray型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。\n对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。\n资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。\n有关值操作的宏都定义在./Zend/zend_operators.h文件里：\n``` c\n//操作整数的\n#define Z_LVAL(zval)            (zval).value.lval\n#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)\n#define Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)\n\n//操作IS_BOOL布尔型的\n#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)\n#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)\n#define Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)\n\n//操作浮点数的\n#define Z_DVAL(zval)            (zval).value.dval\n#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)\n#define Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)\n\n//操作字符串的值和长度的\n#define Z_STRVAL(zval)          (zval).value.str.val\n#define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)\n#define Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)\n\n#define Z_STRLEN(zval)          (zval).value.str.len\n#define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)\n#define Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)\n\n#define Z_ARRVAL(zval)          (zval).value.ht\n#define Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)\n#define Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)\n\n//操作对象的\n#define Z_OBJVAL(zval)          (zval).value.obj\n#define Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)\n#define Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)\n\n#define Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle\n#define Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)\n#define Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)\n\n#define Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers\n#define Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)\n#define Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)\n\n#define Z_OBJCE(zval)           zend_get_class_entry(&(zval) TSRMLS_CC)\n#define Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)\n#define Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)\n\n#define Z_OBJPROP(zval)         Z_OBJ_HT((zval))->get_properties(&(zval) TSRMLS_CC)\n#define Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)\n#define Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)\n\n#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))->hf\n#define Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)\n#define Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)\n\n#define Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\\n                        Z_OBJ_HANDLER((zval),get_debug_info)(&(zval),&is_tmp TSRMLS_CC): \\\n                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) \n#define Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) \n#define Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)\n\n//操作资源的\n#define Z_RESVAL(zval)          (zval).value.lval\n#define Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)\n#define Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)\n```     \n## php的类型转换\nphp内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()\n``` c\n//将任意类型的zval转换成字符串\nvoid change_zval_to_string(zval *value)\n{\n        convert_to_string(value);\n}\n\n//其它基本的类型转换函数\nZEND_API void convert_to_long(zval *op);\nZEND_API void convert_to_double(zval *op);\nZEND_API void convert_to_null(zval *op);\nZEND_API void convert_to_boolean(zval *op);\nZEND_API void convert_to_array(zval *op);\nZEND_API void convert_to_object(zval *op);\n\nZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);\n#define convert_to_string(op) if ((op)->type != IS_STRING) { _convert_to_string((op) ZEND_FILE_LINE_CC);  }\n```\n这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。\n注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。\n\n\n\n","source":"_posts/探索php中的变量zval结构体.md","raw":"---\ntitle: 探索php中的变量zval结构体\ndate: 2017-06-18 23:03:30\ntags: php php扩展 c\ncategories: 技术\n\n---\n## 变量的类型\nphp是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.\n注意这个php的版本是5.4,最新的php7结构体已经变更\nPHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：\n``` c\n\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc;\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n\n//在Zend/zend_types.h里定义的：\ntypedef unsigned int zend_uint;\ntypedef unsigned char zend_uchar;\n\n```\n\n<!--more-->\n保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：\n``` c\ntypedef union _zvalue_value {\n        long lval;                  /* long value */\n        double dval;                /* double value */\n        struct {\n                char *val;\n                int len;\n        } str;\n        HashTable *ht;              /* hash table value */\n        zend_object_value obj;\n} zvalue_value;\n\n```\n\n> PHP中常见的变量类型有：\n1. 整型/浮点/长整型/bool值 等等\n2. 字符串\n3. 数组/关联数组\n4. 对象\n5. 资源\n\n\nPHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:\n\n``` c\n      zval.type = IS_LONG;//整形\n      zval.type = IS_BOOL;//布尔值\n```\n\n就去取zval.value.lval,对于bool值来说lval∈(0|1);\n如果是双精度，或者float则会去取zval.value的dval。\n而如果是字符串，那么:\n\n``` c\n         zval.type = IS_STRING\n```\n\n这个时候，就会取:\n\n``` c \n         zval.value.str\n```\n\n而这个也是个结构，存有C分格的字符串和字符串的长度。\n而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj\n比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:\n\n``` c\n            type = IS_RESOURCE\n```\n## 变量类型的实现\n在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：\n\n| 常量名称： |  解释 |\n| :--------  |  :---:|\n| IS_NULL    | 第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。|\n| IS_BOOL    | 布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。|\n| IS_LONG    | PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。| \n| IS_DOUBLE  | PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011....。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333.....，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0. |\n| IS_STRING  | PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。|\n| IS_ARRAY   | 数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。\n| IS_OBJECT  | 和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！\n| IS_RESOURCE| 有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。\n\n\nzval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。\n如果要我们检测一个变量的类型\n``` c\nvoid describe_zval(zval *foo)\n{\n        if ( Z_TYPE_P(foo) == IS_NULL  )\n        {\n                    php_printf(\"这个变量的数据类型是： NULL\");\n                        \n        }\n        else\n        {\n                    php_printf(\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\", Z_TYPE_P(foo));\n                        \n        }\n\n}\n```\n\n以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。\n\n``` c\n//开始定义php语言中的函数gettype\nPHP_FUNCTION(gettype)\n{\n    //arg间接指向调用gettype函数时所传递的参数。是一个zval**结构\n    //所以我们要对他使用__PP后缀的宏。\n    zval **arg;\n\n    //这个if的操作主要是让arg指向参数～\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &arg) == FAILURE) {\n                return;\n    }\n                    \n    //调用Z_TYPE_PP宏来获取arg指向zval的类型。\n    //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值\n    switch (Z_TYPE_PP(arg)) {\n        case IS_NULL:\n            RETVAL_STRING(\"NULL\", 1);\n            break;\n        case IS_BOOL:\n            RETVAL_STRING(\"boolean\", 1);\n            break;\n        case IS_LONG:\n            RETVAL_STRING(\"integer\", 1);\n            break;\n        case IS_DOUBLE:\n            RETVAL_STRING(\"double\", 1);\n            break;\n        case IS_STRING:\n            RETVAL_STRING(\"string\", 1);\n            break;\n        case IS_ARRAY:\n            RETVAL_STRING(\"array\", 1);\n            break;\n        case IS_OBJECT:\n            RETVAL_STRING(\"object\", 1);\n            break;\n        case IS_RESOURCE:\n        {\n            char *type_name;\n            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);\n            if (type_name) {\n                RETVAL_STRING(\"resource\", 1);\n                break;\n            }\n        }\n        default:\n                    RETVAL_STRING(\"unknown type\", 1);\n    }\n}       \n```\n以上三个宏的定义在Zend/zend_operators.h里，定义分别是：\n\n#define Z_TYPE(zval)        (zval).type\n#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)\n#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)\n\n## 变量值的实现\nPHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.\n内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:\n``` c\nvoid display_value(zval zv,zval *zv_p,zval **zv_pp)\n{\n    if( Z_TYPE(zv) == IS_NULL)\n    {\n                php_printf(\"类型是 IS_NULL!\\n\");\n    }\n    if( Z_TYPE_P(zv_p) == IS_LONG)\n    {\n                php_printf(\"类型是 IS_LONG，值是：%ld\" , Z_LVAL_P(zv_p));\n    }\n    if(Z_TYPE_PP(zv_pp) == IS_DOUBLE)\n    {\n                php_printf(\"类型是 IS_DOUBLE,值是：%f\" , Z_DVAL_PP(zv_pp) );\n    }\n}   \n```\nstring型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。\n``` c\nvoid display_string(zval *zstr)\n{\n    if (Z_TYPE_P(zstr) != IS_STRING) {\n        php_printf(\"这个变量不是字符串!\\n\");\n        return;\n    }\n    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));\n    //这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。\n}       \n ```       \nArray型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。\n对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。\n资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。\n有关值操作的宏都定义在./Zend/zend_operators.h文件里：\n``` c\n//操作整数的\n#define Z_LVAL(zval)            (zval).value.lval\n#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)\n#define Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)\n\n//操作IS_BOOL布尔型的\n#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)\n#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)\n#define Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)\n\n//操作浮点数的\n#define Z_DVAL(zval)            (zval).value.dval\n#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)\n#define Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)\n\n//操作字符串的值和长度的\n#define Z_STRVAL(zval)          (zval).value.str.val\n#define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)\n#define Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)\n\n#define Z_STRLEN(zval)          (zval).value.str.len\n#define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)\n#define Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)\n\n#define Z_ARRVAL(zval)          (zval).value.ht\n#define Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)\n#define Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)\n\n//操作对象的\n#define Z_OBJVAL(zval)          (zval).value.obj\n#define Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)\n#define Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)\n\n#define Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle\n#define Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)\n#define Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)\n\n#define Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers\n#define Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)\n#define Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)\n\n#define Z_OBJCE(zval)           zend_get_class_entry(&(zval) TSRMLS_CC)\n#define Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)\n#define Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)\n\n#define Z_OBJPROP(zval)         Z_OBJ_HT((zval))->get_properties(&(zval) TSRMLS_CC)\n#define Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)\n#define Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)\n\n#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))->hf\n#define Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)\n#define Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)\n\n#define Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\\n                        Z_OBJ_HANDLER((zval),get_debug_info)(&(zval),&is_tmp TSRMLS_CC): \\\n                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) \n#define Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) \n#define Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)\n\n//操作资源的\n#define Z_RESVAL(zval)          (zval).value.lval\n#define Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)\n#define Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)\n```     \n## php的类型转换\nphp内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()\n``` c\n//将任意类型的zval转换成字符串\nvoid change_zval_to_string(zval *value)\n{\n        convert_to_string(value);\n}\n\n//其它基本的类型转换函数\nZEND_API void convert_to_long(zval *op);\nZEND_API void convert_to_double(zval *op);\nZEND_API void convert_to_null(zval *op);\nZEND_API void convert_to_boolean(zval *op);\nZEND_API void convert_to_array(zval *op);\nZEND_API void convert_to_object(zval *op);\n\nZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);\n#define convert_to_string(op) if ((op)->type != IS_STRING) { _convert_to_string((op) ZEND_FILE_LINE_CC);  }\n```\n这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。\n注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。\n\n\n\n","slug":"探索php中的变量zval结构体","published":1,"updated":"2018-05-27T09:59:36.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjr001dth8llh7tp6vp","content":"<h2 id=\"变量的类型\"><a href=\"#变量的类型\" class=\"headerlink\" title=\"变量的类型\"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</span><br><span class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></span><br><span class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></span><br><span class=\"line\">        zend_uint refcount__gc;</span><br><span class=\"line\">        zend_uchar is_ref__gc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在Zend/zend_types.h里定义的：</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> zend_uint;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> zend_uchar;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zvalue_value &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lval;                  <span class=\"comment\">/* long value */</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> dval;                <span class=\"comment\">/* double value */</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *val;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">        &#125; str;</span><br><span class=\"line\">        HashTable *ht;              <span class=\"comment\">/* hash table value */</span></span><br><span class=\"line\">        zend_object_value obj;</span><br><span class=\"line\">&#125; zvalue_value;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>PHP中常见的变量类型有：</p>\n<ol>\n<li>整型/浮点/长整型/bool值 等等</li>\n<li>字符串</li>\n<li>数组/关联数组</li>\n<li>对象</li>\n<li>资源</li>\n</ol>\n</blockquote>\n<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval.type = IS_LONG;<span class=\"comment\">//整形</span></span><br><span class=\"line\">zval.type = IS_BOOL;<span class=\"comment\">//布尔值</span></span><br></pre></td></tr></table></figure>\n<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval.type = IS_STRING</span><br></pre></td></tr></table></figure>\n<p>这个时候，就会取:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval.value.str</span><br></pre></td></tr></table></figure>\n<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type = IS_RESOURCE</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量类型的实现\"><a href=\"#变量类型的实现\" class=\"headerlink\" title=\"变量类型的实现\"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常量名称：</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IS_NULL</td>\n<td style=\"text-align:center\">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_BOOL</td>\n<td style=\"text-align:center\">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_LONG</td>\n<td style=\"text-align:center\">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_DOUBLE</td>\n<td style=\"text-align:center\">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_STRING</td>\n<td style=\"text-align:center\">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_ARRAY</td>\n<td style=\"text-align:center\">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_OBJECT</td>\n<td style=\"text-align:center\">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_RESOURCE</td>\n<td style=\"text-align:center\">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>\n</tr>\n</tbody>\n</table>\n<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">describe_zval</span><span class=\"params\">(zval *foo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型是： NULL\"</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\"</span>, Z_TYPE_P(foo));</span><br><span class=\"line\">                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开始定义php语言中的函数gettype</span></span><br><span class=\"line\">PHP_FUNCTION(gettype)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></span><br><span class=\"line\">    <span class=\"comment\">//所以我们要对他使用__PP后缀的宏。</span></span><br><span class=\"line\">    zval **arg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个if的操作主要是让arg指向参数～</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class=\"string\">\"Z\"</span>, &amp;arg) == FAILURE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">    <span class=\"comment\">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></span><br><span class=\"line\">    <span class=\"comment\">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (Z_TYPE_PP(arg)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_NULL:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"NULL\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_BOOL:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"boolean\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_LONG:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"integer\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_DOUBLE:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"double\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_STRING:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"string\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_ARRAY:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"array\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_OBJECT:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"object\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_RESOURCE:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> *type_name;</span><br><span class=\"line\">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (type_name) &#123;</span><br><span class=\"line\">                RETVAL_STRING(<span class=\"string\">\"resource\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    RETVAL_STRING(<span class=\"string\">\"unknown type\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>\n<p>#define Z_TYPE(zval)        (zval).type</p>\n<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>\n<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>\n<h2 id=\"变量值的实现\"><a href=\"#变量值的实现\" class=\"headerlink\" title=\"变量值的实现\"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_value</span><span class=\"params\">(zval zv,zval *zv_p,zval **zv_pp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE(zv) == IS_NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_NULL!\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_LONG，值是：%ld\"</span> , Z_LVAL_P(zv_p));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_DOUBLE,值是：%f\"</span> , Z_DVAL_PP(zv_pp) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_string</span><span class=\"params\">(zval *zstr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</span><br><span class=\"line\">        php_printf(<span class=\"string\">\"这个变量不是字符串!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</span><br><span class=\"line\">    <span class=\"comment\">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"> ```       </span><br><span class=\"line\">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</span><br><span class=\"line\">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</span><br><span class=\"line\">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</span><br><span class=\"line\">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</span><br><span class=\"line\">``` c</span><br><span class=\"line\"><span class=\"comment\">//操作整数的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL(zval)            (zval).value.lval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作IS_BOOL布尔型的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作浮点数的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL(zval)            (zval).value.dval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作字符串的值和长度的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作对象的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\</span></span><br><span class=\"line\">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \\</span><br><span class=\"line\">                                                (is_tmp=<span class=\"number\">0</span>,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):<span class=\"literal\">NULL</span>)) </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作资源的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL(zval)          (zval).value.lval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></span><br><span class=\"line\">```     </span><br><span class=\"line\">#<span class=\"meta\"># php的类型转换</span></span><br><span class=\"line\">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</span><br><span class=\"line\">``` c</span><br><span class=\"line\"><span class=\"comment\">//将任意类型的zval转换成字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_zval_to_string</span><span class=\"params\">(zval *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        convert_to_string(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其它基本的类型转换函数</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_long</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_double</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_null</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_boolean</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_array</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_object</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ZEND_API <span class=\"keyword\">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> convert_to_string(op) <span class=\"meta-keyword\">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"变量的类型\"><a href=\"#变量的类型\" class=\"headerlink\" title=\"变量的类型\"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</span><br><span class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></span><br><span class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></span><br><span class=\"line\">        zend_uint refcount__gc;</span><br><span class=\"line\">        zend_uchar is_ref__gc;</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//在Zend/zend_types.h里定义的：</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> zend_uint;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> zend_uchar;</span><br></pre></td></tr></table></figure></p>","more":"<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zvalue_value &#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> lval;                  <span class=\"comment\">/* long value */</span></span><br><span class=\"line\">        <span class=\"keyword\">double</span> dval;                <span class=\"comment\">/* double value */</span></span><br><span class=\"line\">        <span class=\"keyword\">struct</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">char</span> *val;</span><br><span class=\"line\">                <span class=\"keyword\">int</span> len;</span><br><span class=\"line\">        &#125; str;</span><br><span class=\"line\">        HashTable *ht;              <span class=\"comment\">/* hash table value */</span></span><br><span class=\"line\">        zend_object_value obj;</span><br><span class=\"line\">&#125; zvalue_value;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>PHP中常见的变量类型有：</p>\n<ol>\n<li>整型/浮点/长整型/bool值 等等</li>\n<li>字符串</li>\n<li>数组/关联数组</li>\n<li>对象</li>\n<li>资源</li>\n</ol>\n</blockquote>\n<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval.type = IS_LONG;<span class=\"comment\">//整形</span></span><br><span class=\"line\">zval.type = IS_BOOL;<span class=\"comment\">//布尔值</span></span><br></pre></td></tr></table></figure>\n<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval.type = IS_STRING</span><br></pre></td></tr></table></figure>\n<p>这个时候，就会取:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zval.value.str</span><br></pre></td></tr></table></figure>\n<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type = IS_RESOURCE</span><br></pre></td></tr></table></figure>\n<h2 id=\"变量类型的实现\"><a href=\"#变量类型的实现\" class=\"headerlink\" title=\"变量类型的实现\"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常量名称：</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IS_NULL</td>\n<td style=\"text-align:center\">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_BOOL</td>\n<td style=\"text-align:center\">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_LONG</td>\n<td style=\"text-align:center\">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_DOUBLE</td>\n<td style=\"text-align:center\">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_STRING</td>\n<td style=\"text-align:center\">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_ARRAY</td>\n<td style=\"text-align:center\">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_OBJECT</td>\n<td style=\"text-align:center\">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_RESOURCE</td>\n<td style=\"text-align:center\">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>\n</tr>\n</tbody>\n</table>\n<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">describe_zval</span><span class=\"params\">(zval *foo)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型是： NULL\"</span>);</span><br><span class=\"line\">                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\"</span>, Z_TYPE_P(foo));</span><br><span class=\"line\">                        </span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//开始定义php语言中的函数gettype</span></span><br><span class=\"line\">PHP_FUNCTION(gettype)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"comment\">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></span><br><span class=\"line\">    <span class=\"comment\">//所以我们要对他使用__PP后缀的宏。</span></span><br><span class=\"line\">    zval **arg;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这个if的操作主要是让arg指向参数～</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class=\"string\">\"Z\"</span>, &amp;arg) == FAILURE) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">                    </span><br><span class=\"line\">    <span class=\"comment\">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></span><br><span class=\"line\">    <span class=\"comment\">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></span><br><span class=\"line\">    <span class=\"keyword\">switch</span> (Z_TYPE_PP(arg)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_NULL:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"NULL\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_BOOL:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"boolean\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_LONG:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"integer\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_DOUBLE:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"double\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_STRING:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"string\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_ARRAY:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"array\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_OBJECT:</span><br><span class=\"line\">            RETVAL_STRING(<span class=\"string\">\"object\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        <span class=\"keyword\">case</span> IS_RESOURCE:</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">char</span> *type_name;</span><br><span class=\"line\">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (type_name) &#123;</span><br><span class=\"line\">                RETVAL_STRING(<span class=\"string\">\"resource\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">default</span>:</span><br><span class=\"line\">                    RETVAL_STRING(<span class=\"string\">\"unknown type\"</span>, <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>\n<p>#define Z_TYPE(zval)        (zval).type</p>\n<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>\n<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>\n<h2 id=\"变量值的实现\"><a href=\"#变量值的实现\" class=\"headerlink\" title=\"变量值的实现\"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_value</span><span class=\"params\">(zval zv,zval *zv_p,zval **zv_pp)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE(zv) == IS_NULL)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_NULL!\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_LONG，值是：%ld\"</span> , Z_LVAL_P(zv_p));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_DOUBLE,值是：%f\"</span> , Z_DVAL_PP(zv_pp) );</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_string</span><span class=\"params\">(zval *zstr)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</span><br><span class=\"line\">        php_printf(<span class=\"string\">\"这个变量不是字符串!\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</span><br><span class=\"line\">    <span class=\"comment\">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></span><br><span class=\"line\">&#125;       </span><br><span class=\"line\"> ```       </span><br><span class=\"line\">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</span><br><span class=\"line\">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</span><br><span class=\"line\">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</span><br><span class=\"line\">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</span><br><span class=\"line\">``` c</span><br><span class=\"line\"><span class=\"comment\">//操作整数的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL(zval)            (zval).value.lval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作IS_BOOL布尔型的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作浮点数的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL(zval)            (zval).value.dval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作字符串的值和长度的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作对象的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\</span></span><br><span class=\"line\">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \\</span><br><span class=\"line\">                                                (is_tmp=<span class=\"number\">0</span>,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):<span class=\"literal\">NULL</span>)) </span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//操作资源的</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL(zval)          (zval).value.lval</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></span><br><span class=\"line\">```     </span><br><span class=\"line\">#<span class=\"meta\"># php的类型转换</span></span><br><span class=\"line\">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</span><br><span class=\"line\">``` c</span><br><span class=\"line\"><span class=\"comment\">//将任意类型的zval转换成字符串</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_zval_to_string</span><span class=\"params\">(zval *value)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        convert_to_string(value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//其它基本的类型转换函数</span></span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_long</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_double</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_null</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_boolean</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_array</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_object</span><span class=\"params\">(zval *op)</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">ZEND_API <span class=\"keyword\">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> convert_to_string(op) <span class=\"meta-keyword\">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></span><br></pre></td></tr></table></figure></p>\n<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>"},{"title":"php的并发io","date":"2017-06-25T15:04:46.000Z","_content":"\n计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。\n## 多进程/多线程同步阻塞\n最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。\n ![\"我是傲娇的效果图\"](/assets/blogImg/manyporcess.png)\n因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。\n``` php\n\n$serv = stream_socket_server(\"tcp://0.0.0.0.8000\",$errno,$errstr) or die(\"create server failed\");\nwhile(1) {\n        $conn = stream_socket_accept($serv);\n        if(pcntl_fork() ==0) {\n                $request = fread($conn);\n                fwite($repose);\n                fclose($conn);\n                exit(0);\n        }\n}\n\n```\n<!--more-->\n## 多进程/线程模型的流程\n1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现\n2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket\n3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。\n4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。\n5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。\n**这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。**\n``` php\n\n<?php\n$serv = stream_socket_server(\"tcp://0.0.0.0:8000\",$error,$errstr) or die(\"create server failed\");\nfor($i=0; $i< 32;$i++){\n        if (pcntl_fork() == 0 ){\n                while(1) {\n                        $conn = stream_socket_accept($serv);\n                        if($conn == false) continue;\n                        $request = fread($conn);\n                        fwrite($reponse);\n                        fclose($conn);\n                }\n                exit(0);\n        }\n}\n\n```\n他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。\n优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM\n缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。\n还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。\n\n有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。\n## IO复用/事件循环/异步非阻塞\n其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。\n直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。\nIO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。\n ![\"我是傲娇的效果图\"](/assets/blogImg/reactor.png)\n Reactor有4个核心的操作：\n add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等\n set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。\n del从reactor中移除，不再监听事件\n callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。\n Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：\n ``` php\n <?php\n $reactor=new Reactor();\n $svr_sock=stream_socket_server('tcp://127.0.0.1:9501');\n $reactor->add($svr_sock,EV_READ,function() use ($svr_sock,$reactor){\n         $cli_sock = stream_socket_accept($svr_sock);\n         $reactor->add($cli_sock,EV_READ,function() use ($cli_sock,$reactor){\n                 $request = fread($cli_sock,8192);\n                 $reactor->add($cli_sock,EV_WRITE,function() use ($cli_sock,$request,$reactor){\n                         fwrite($cli_sock,\"hello world\\n\");\n                         $reactor->del($cli_sock);\n                         fclose($cli_sock);\n                 });\n         });\n});\n \n ```\n > Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如\n Nginx：多进程Reactor\n Nginx+Lua：多进程Reactor+协程\n Golang：单线程Reactor+多线程协程\n Swoole：多线程Reactor+多进程Worker\n\n 协程是什么\n 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在\n\n 参考文章:\n-------------------\n[PHP并发IO编程之路](http://rango.swoole.com/archives/508)\n\n\n\n\n\n\n\n\n","source":"_posts/php的并发io.md","raw":"---\ntitle: php的并发io\ndate: 2017-06-25 23:04:46\ntag: php\ncategories: 技术\n\n---\n\n计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。\n## 多进程/多线程同步阻塞\n最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。\n ![\"我是傲娇的效果图\"](/assets/blogImg/manyporcess.png)\n因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。\n``` php\n\n$serv = stream_socket_server(\"tcp://0.0.0.0.8000\",$errno,$errstr) or die(\"create server failed\");\nwhile(1) {\n        $conn = stream_socket_accept($serv);\n        if(pcntl_fork() ==0) {\n                $request = fread($conn);\n                fwite($repose);\n                fclose($conn);\n                exit(0);\n        }\n}\n\n```\n<!--more-->\n## 多进程/线程模型的流程\n1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现\n2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket\n3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。\n4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。\n5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。\n**这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。**\n``` php\n\n<?php\n$serv = stream_socket_server(\"tcp://0.0.0.0:8000\",$error,$errstr) or die(\"create server failed\");\nfor($i=0; $i< 32;$i++){\n        if (pcntl_fork() == 0 ){\n                while(1) {\n                        $conn = stream_socket_accept($serv);\n                        if($conn == false) continue;\n                        $request = fread($conn);\n                        fwrite($reponse);\n                        fclose($conn);\n                }\n                exit(0);\n        }\n}\n\n```\n他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。\n优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM\n缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。\n还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。\n\n有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。\n## IO复用/事件循环/异步非阻塞\n其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。\n直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。\nIO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。\n ![\"我是傲娇的效果图\"](/assets/blogImg/reactor.png)\n Reactor有4个核心的操作：\n add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等\n set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。\n del从reactor中移除，不再监听事件\n callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。\n Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：\n ``` php\n <?php\n $reactor=new Reactor();\n $svr_sock=stream_socket_server('tcp://127.0.0.1:9501');\n $reactor->add($svr_sock,EV_READ,function() use ($svr_sock,$reactor){\n         $cli_sock = stream_socket_accept($svr_sock);\n         $reactor->add($cli_sock,EV_READ,function() use ($cli_sock,$reactor){\n                 $request = fread($cli_sock,8192);\n                 $reactor->add($cli_sock,EV_WRITE,function() use ($cli_sock,$request,$reactor){\n                         fwrite($cli_sock,\"hello world\\n\");\n                         $reactor->del($cli_sock);\n                         fclose($cli_sock);\n                 });\n         });\n});\n \n ```\n > Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如\n Nginx：多进程Reactor\n Nginx+Lua：多进程Reactor+协程\n Golang：单线程Reactor+多线程协程\n Swoole：多线程Reactor+多进程Worker\n\n 协程是什么\n 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在\n\n 参考文章:\n-------------------\n[PHP并发IO编程之路](http://rango.swoole.com/archives/508)\n\n\n\n\n\n\n\n\n","slug":"php的并发io","published":1,"updated":"2018-05-27T09:59:36.031Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjs001eth8l26otca7h","content":"<p>计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。</p>\n<h2 id=\"多进程-多线程同步阻塞\"><a href=\"#多进程-多线程同步阻塞\" class=\"headerlink\" title=\"多进程/多线程同步阻塞\"></a>多进程/多线程同步阻塞</h2><p>最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。<br> <img src=\"/assets/blogImg/manyporcess.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0.8000\"</span>,$errno,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        $conn = stream_socket_accept($serv);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pcntl_fork() ==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                $request = fread($conn);</span><br><span class=\"line\">                fwite($repose);</span><br><span class=\"line\">                fclose($conn);</span><br><span class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"多进程-线程模型的流程\"><a href=\"#多进程-线程模型的流程\" class=\"headerlink\" title=\"多进程/线程模型的流程\"></a>多进程/线程模型的流程</h2><p>1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现<br>2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket<br>3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。<br>4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。<br>5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。<br><strong>这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0:8000\"</span>,$error,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>($i=<span class=\"number\">0</span>; $i&lt; <span class=\"number\">32</span>;$i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pcntl_fork() == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        $conn = stream_socket_accept($serv);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>($conn == <span class=\"keyword\">false</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        $request = fread($conn);</span><br><span class=\"line\">                        fwrite($reponse);</span><br><span class=\"line\">                        fclose($conn);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。<br>优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM<br>缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。<br>还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。</p>\n<p>有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。</p>\n<h2 id=\"IO复用-事件循环-异步非阻塞\"><a href=\"#IO复用-事件循环-异步非阻塞\" class=\"headerlink\" title=\"IO复用/事件循环/异步非阻塞\"></a>IO复用/事件循环/异步非阻塞</h2><p>其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。<br>直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。<br>IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。<br> <img src=\"/assets/blogImg/reactor.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> Reactor有4个核心的操作：<br> add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等<br> set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。<br> del从reactor中移除，不再监听事件<br> callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。<br> Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：<br> <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"> $reactor=<span class=\"keyword\">new</span> Reactor();</span><br><span class=\"line\"> $svr_sock=stream_socket_server(<span class=\"string\">'tcp://127.0.0.1:9501'</span>);</span><br><span class=\"line\"> $reactor-&gt;add($svr_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($svr_sock,$reactor)</span></span>&#123;</span><br><span class=\"line\">         $cli_sock = stream_socket_accept($svr_sock);</span><br><span class=\"line\">         $reactor-&gt;add($cli_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$reactor)</span></span>&#123;</span><br><span class=\"line\">                 $request = fread($cli_sock,<span class=\"number\">8192</span>);</span><br><span class=\"line\">                 $reactor-&gt;add($cli_sock,EV_WRITE,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$request,$reactor)</span></span>&#123;</span><br><span class=\"line\">                         fwrite($cli_sock,<span class=\"string\">\"hello world\\n\"</span>);</span><br><span class=\"line\">                         $reactor-&gt;del($cli_sock);</span><br><span class=\"line\">                         fclose($cli_sock);</span><br><span class=\"line\">                 &#125;);</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如<br> Nginx：多进程Reactor<br> Nginx+Lua：多进程Reactor+协程<br> Golang：单线程Reactor+多线程协程<br> Swoole：多线程Reactor+多进程Worker</p>\n</blockquote>\n<p> 协程是什么<br> 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"http://rango.swoole.com/archives/508\" target=\"_blank\" rel=\"noopener\">PHP并发IO编程之路</a></p>\n","site":{"data":{}},"excerpt":"<p>计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。</p>\n<h2 id=\"多进程-多线程同步阻塞\"><a href=\"#多进程-多线程同步阻塞\" class=\"headerlink\" title=\"多进程/多线程同步阻塞\"></a>多进程/多线程同步阻塞</h2><p>最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。<br> <img src=\"/assets/blogImg/manyporcess.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0.8000\"</span>,$errno,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">        $conn = stream_socket_accept($serv);</span><br><span class=\"line\">        <span class=\"keyword\">if</span>(pcntl_fork() ==<span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                $request = fread($conn);</span><br><span class=\"line\">                fwite($repose);</span><br><span class=\"line\">                fclose($conn);</span><br><span class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>","more":"<h2 id=\"多进程-线程模型的流程\"><a href=\"#多进程-线程模型的流程\" class=\"headerlink\" title=\"多进程/线程模型的流程\"></a>多进程/线程模型的流程</h2><p>1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现<br>2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket<br>3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。<br>4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。<br>5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。<br><strong>这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">&lt;?php</span></span><br><span class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0:8000\"</span>,$error,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>($i=<span class=\"number\">0</span>; $i&lt; <span class=\"number\">32</span>;$i++)&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pcntl_fork() == <span class=\"number\">0</span> )&#123;</span><br><span class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">                        $conn = stream_socket_accept($serv);</span><br><span class=\"line\">                        <span class=\"keyword\">if</span>($conn == <span class=\"keyword\">false</span>) <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">                        $request = fread($conn);</span><br><span class=\"line\">                        fwrite($reponse);</span><br><span class=\"line\">                        fclose($conn);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<p>他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。<br>优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM<br>缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。<br>还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。</p>\n<p>有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。</p>\n<h2 id=\"IO复用-事件循环-异步非阻塞\"><a href=\"#IO复用-事件循环-异步非阻塞\" class=\"headerlink\" title=\"IO复用/事件循环/异步非阻塞\"></a>IO复用/事件循环/异步非阻塞</h2><p>其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。<br>直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。<br>IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。<br> <img src=\"/assets/blogImg/reactor.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> Reactor有4个核心的操作：<br> add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等<br> set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。<br> del从reactor中移除，不再监听事件<br> callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。<br> Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：<br> <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> <span class=\"meta\">&lt;?php</span></span><br><span class=\"line\"> $reactor=<span class=\"keyword\">new</span> Reactor();</span><br><span class=\"line\"> $svr_sock=stream_socket_server(<span class=\"string\">'tcp://127.0.0.1:9501'</span>);</span><br><span class=\"line\"> $reactor-&gt;add($svr_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($svr_sock,$reactor)</span></span>&#123;</span><br><span class=\"line\">         $cli_sock = stream_socket_accept($svr_sock);</span><br><span class=\"line\">         $reactor-&gt;add($cli_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$reactor)</span></span>&#123;</span><br><span class=\"line\">                 $request = fread($cli_sock,<span class=\"number\">8192</span>);</span><br><span class=\"line\">                 $reactor-&gt;add($cli_sock,EV_WRITE,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$request,$reactor)</span></span>&#123;</span><br><span class=\"line\">                         fwrite($cli_sock,<span class=\"string\">\"hello world\\n\"</span>);</span><br><span class=\"line\">                         $reactor-&gt;del($cli_sock);</span><br><span class=\"line\">                         fclose($cli_sock);</span><br><span class=\"line\">                 &#125;);</span><br><span class=\"line\">         &#125;);</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如<br> Nginx：多进程Reactor<br> Nginx+Lua：多进程Reactor+协程<br> Golang：单线程Reactor+多线程协程<br> Swoole：多线程Reactor+多进程Worker</p>\n</blockquote>\n<p> 协程是什么<br> 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"http://rango.swoole.com/archives/508\" target=\"_blank\" rel=\"noopener\">PHP并发IO编程之路</a></p>"},{"title":"谈谈进程和线程","date":"2017-06-17T15:27:02.000Z","_content":"最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下\n## 多任务\n现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。\n什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。\n现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？\n答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。\n真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。\n## 进程的概念\n对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。\n## 进程的本质\ncpu的单次运算\n## 线程的概念\n有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。\n## 线程的本质\n由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。\n## 线程的特点\n由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：\n文件描述符表\n每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）\n当前工作目录\n用户id和组id\n但有些资源是每个线程各有一份的：\n线程id\n<!--more-->\n上下文，包括各种寄存器的值、程序计数器和栈指针\n栈空间\nerrno变量\n信号屏蔽字\n调度优先级\n\n\n## 进程的通信\n每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。\n图 30.6. 进程间通信\n进程间通信\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.png)\n###  管道\n管道是一种最基本的IPC机制，由pipe函数创建：\n``` c\n#include <unistd.h>\nint pipe(int filedes[2]);\n\n\n```\n调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。\n\n开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。\n1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。\n2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。\n3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.pipe.png)\n ``` c\n#include <stdlib.h>\n#include <unistd.h>\n#define MAXLINE 80\n\n int main(void)\n{\n        int n;\n        int fd[2];\n        pid_t pid;\n        char line[MAXLINE];\n\n        if (pipe(fd) < 0) {\n                perror(\"pipe\");\n                exit(1);\n        }\n        if ((pid = fork()) < 0) {\n                perror(\"fork\");\n                exit(1);\n        }\n        if (pid > 0) { /* parent */\n                close(fd[0]);\n                write(fd[1], \"hello world\\n\", 12);\n                wait(NULL);\n         } else {       /* child */\n                close(fd[1]);\n                n = read(fd[0], line, MAXLINE);\n                write(STDOUT_FILENO, line, n);\n         }\n}\n```\n> 使用管道有一些限制：\n两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？\n管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。\n使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：\n如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。\n如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。\n如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。\n如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。\n\n 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：\n-父进程通过fork可以将打开文件的描述符传递给子进程\n-子进程结束时，父进程调用wait可以得到子进程的终止信息\n-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步\n-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能\n-管道\n-FIFO\n-mmap函数，几个进程可以映射同一内存区\n-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃\n-UNIX Domain Socket，目前最广泛使用的IPC机制\n\n\n## 线程的通信\n多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：\n1.从内存读变量值到寄存器\n2.寄存器的值加1\n3.将寄存器的值写回内存\n假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。\n ![\"我是傲娇的效果图\"](/assets/blogImg/thread.corrupt.png)\n 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。\n pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：\n``` c\n#include <pthread.h>\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n返回值：成功返回0，失败返回错误号。\n一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。\n如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。\nMutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：\nlock:\n``` c\nif(mutex > 0){\n        mutex = 0;\n        return 0;\n} else\n        //挂起等待;\n        goto lock;\nunlock:\n        mutex = 1;\n        //唤醒等待Mutex的线程;\n        return 0;\n        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。\n```\n## 死锁\n1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。\n2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。\n\n 参考文章:\n-------------------\n[线程](https://akaedu.github.io/book/ch35s04.html)\n[进程间通信](https://akaedu.github.io/book/ch30s04.html)\n[进程和线程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000)\n\n\n\n\n\n\n","source":"_posts/谈谈进程和线程.md","raw":"---\ntitle: 谈谈进程和线程\ndate: 2017-06-17 23:27:02\ntags: linux基础 \ncategories: 技术\n\n---\n最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下\n## 多任务\n现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。\n什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。\n现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？\n答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。\n真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。\n## 进程的概念\n对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。\n## 进程的本质\ncpu的单次运算\n## 线程的概念\n有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。\n## 线程的本质\n由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。\n## 线程的特点\n由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：\n文件描述符表\n每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）\n当前工作目录\n用户id和组id\n但有些资源是每个线程各有一份的：\n线程id\n<!--more-->\n上下文，包括各种寄存器的值、程序计数器和栈指针\n栈空间\nerrno变量\n信号屏蔽字\n调度优先级\n\n\n## 进程的通信\n每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。\n图 30.6. 进程间通信\n进程间通信\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.png)\n###  管道\n管道是一种最基本的IPC机制，由pipe函数创建：\n``` c\n#include <unistd.h>\nint pipe(int filedes[2]);\n\n\n```\n调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。\n\n开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。\n1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。\n2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。\n3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.pipe.png)\n ``` c\n#include <stdlib.h>\n#include <unistd.h>\n#define MAXLINE 80\n\n int main(void)\n{\n        int n;\n        int fd[2];\n        pid_t pid;\n        char line[MAXLINE];\n\n        if (pipe(fd) < 0) {\n                perror(\"pipe\");\n                exit(1);\n        }\n        if ((pid = fork()) < 0) {\n                perror(\"fork\");\n                exit(1);\n        }\n        if (pid > 0) { /* parent */\n                close(fd[0]);\n                write(fd[1], \"hello world\\n\", 12);\n                wait(NULL);\n         } else {       /* child */\n                close(fd[1]);\n                n = read(fd[0], line, MAXLINE);\n                write(STDOUT_FILENO, line, n);\n         }\n}\n```\n> 使用管道有一些限制：\n两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？\n管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。\n使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：\n如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。\n如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。\n如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。\n如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。\n\n 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：\n-父进程通过fork可以将打开文件的描述符传递给子进程\n-子进程结束时，父进程调用wait可以得到子进程的终止信息\n-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步\n-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能\n-管道\n-FIFO\n-mmap函数，几个进程可以映射同一内存区\n-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃\n-UNIX Domain Socket，目前最广泛使用的IPC机制\n\n\n## 线程的通信\n多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：\n1.从内存读变量值到寄存器\n2.寄存器的值加1\n3.将寄存器的值写回内存\n假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。\n ![\"我是傲娇的效果图\"](/assets/blogImg/thread.corrupt.png)\n 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。\n pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：\n``` c\n#include <pthread.h>\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n返回值：成功返回0，失败返回错误号。\n一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。\n如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。\nMutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：\nlock:\n``` c\nif(mutex > 0){\n        mutex = 0;\n        return 0;\n} else\n        //挂起等待;\n        goto lock;\nunlock:\n        mutex = 1;\n        //唤醒等待Mutex的线程;\n        return 0;\n        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。\n```\n## 死锁\n1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。\n2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。\n\n 参考文章:\n-------------------\n[线程](https://akaedu.github.io/book/ch35s04.html)\n[进程间通信](https://akaedu.github.io/book/ch30s04.html)\n[进程和线程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000)\n\n\n\n\n\n\n","slug":"谈谈进程和线程","published":1,"updated":"2018-05-27T09:59:36.036Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sjt001hth8ltr8t6qoh","content":"<p>最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下</p>\n<h2 id=\"多任务\"><a href=\"#多任务\" class=\"headerlink\" title=\"多任务\"></a>多任务</h2><p>现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。<br>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>\n<h2 id=\"进程的概念\"><a href=\"#进程的概念\" class=\"headerlink\" title=\"进程的概念\"></a>进程的概念</h2><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>\n<h2 id=\"进程的本质\"><a href=\"#进程的本质\" class=\"headerlink\" title=\"进程的本质\"></a>进程的本质</h2><p>cpu的单次运算</p>\n<h2 id=\"线程的概念\"><a href=\"#线程的概念\" class=\"headerlink\" title=\"线程的概念\"></a>线程的概念</h2><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>\n<h2 id=\"线程的本质\"><a href=\"#线程的本质\" class=\"headerlink\" title=\"线程的本质\"></a>线程的本质</h2><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>\n<h2 id=\"线程的特点\"><a href=\"#线程的特点\" class=\"headerlink\" title=\"线程的特点\"></a>线程的特点</h2><p>由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br>文件描述符表<br>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）<br>当前工作目录<br>用户id和组id<br>但有些资源是每个线程各有一份的：<br>线程id<br><a id=\"more\"></a><br>上下文，包括各种寄存器的值、程序计数器和栈指针<br>栈空间<br>errno变量<br>信号屏蔽字<br>调度优先级</p>\n<h2 id=\"进程的通信\"><a href=\"#进程的通信\" class=\"headerlink\" title=\"进程的通信\"></a>进程的通信</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。<br>图 30.6. 进程间通信<br>进程间通信<br> <img src=\"/assets/blogImg/process.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。</p>\n<p>开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。<br>1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。<br>2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br>3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。<br> <img src=\"/assets/blogImg/process.pipe.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 80</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> line[MAXLINE];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pipe(fd) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                perror(<span class=\"string\">\"pipe\"</span>);</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                perror(<span class=\"string\">\"fork\"</span>);</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">/* parent */</span></span><br><span class=\"line\">                close(fd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                write(fd[<span class=\"number\">1</span>], <span class=\"string\">\"hello world\\n\"</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">                wait(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;       <span class=\"comment\">/* child */</span></span><br><span class=\"line\">                close(fd[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                n = read(fd[<span class=\"number\">0</span>], line, MAXLINE);</span><br><span class=\"line\">                write(STDOUT_FILENO, line, n);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用管道有一些限制：<br>两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？<br>管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。<br>使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：<br>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<br>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。<br>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。<br>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>\n</blockquote>\n<p> 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：<br>-父进程通过fork可以将打开文件的描述符传递给子进程<br>-子进程结束时，父进程调用wait可以得到子进程的终止信息<br>-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步<br>-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能<br>-管道<br>-FIFO<br>-mmap函数，几个进程可以映射同一内存区<br>-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃<br>-UNIX Domain Socket，目前最广泛使用的IPC机制</p>\n<h2 id=\"线程的通信\"><a href=\"#线程的通信\" class=\"headerlink\" title=\"线程的通信\"></a>线程的通信</h2><p>多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：<br>1.从内存读变量值到寄存器<br>2.寄存器的值加1<br>3.将寄存器的值写回内存<br>假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。<br> <img src=\"/assets/blogImg/thread.corrupt.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br> pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>返回值：成功返回0，失败返回错误号。<br>一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br>如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。<br>Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：<br>lock:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mutex &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        mutex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">//挂起等待;</span></span><br><span class=\"line\">        <span class=\"keyword\">goto</span> lock;</span><br><span class=\"line\">unlock:</span><br><span class=\"line\">        mutex = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//唤醒等待Mutex的线程;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://akaedu.github.io/book/ch35s04.html\" target=\"_blank\" rel=\"noopener\">线程</a><br><a href=\"https://akaedu.github.io/book/ch30s04.html\" target=\"_blank\" rel=\"noopener\">进程间通信</a><br><a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000\" target=\"_blank\" rel=\"noopener\">进程和线程</a></p>\n","site":{"data":{}},"excerpt":"<p>最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下</p>\n<h2 id=\"多任务\"><a href=\"#多任务\" class=\"headerlink\" title=\"多任务\"></a>多任务</h2><p>现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。<br>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>\n<h2 id=\"进程的概念\"><a href=\"#进程的概念\" class=\"headerlink\" title=\"进程的概念\"></a>进程的概念</h2><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>\n<h2 id=\"进程的本质\"><a href=\"#进程的本质\" class=\"headerlink\" title=\"进程的本质\"></a>进程的本质</h2><p>cpu的单次运算</p>\n<h2 id=\"线程的概念\"><a href=\"#线程的概念\" class=\"headerlink\" title=\"线程的概念\"></a>线程的概念</h2><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>\n<h2 id=\"线程的本质\"><a href=\"#线程的本质\" class=\"headerlink\" title=\"线程的本质\"></a>线程的本质</h2><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>\n<h2 id=\"线程的特点\"><a href=\"#线程的特点\" class=\"headerlink\" title=\"线程的特点\"></a>线程的特点</h2><p>由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br>文件描述符表<br>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）<br>当前工作目录<br>用户id和组id<br>但有些资源是每个线程各有一份的：<br>线程id<br>","more":"<br>上下文，包括各种寄存器的值、程序计数器和栈指针<br>栈空间<br>errno变量<br>信号屏蔽字<br>调度优先级</p>\n<h2 id=\"进程的通信\"><a href=\"#进程的通信\" class=\"headerlink\" title=\"进程的通信\"></a>进程的通信</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。<br>图 30.6. 进程间通信<br>进程间通信<br> <img src=\"/assets/blogImg/process.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes[<span class=\"number\">2</span>])</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。</p>\n<p>开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。<br>1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。<br>2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br>3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。<br> <img src=\"/assets/blogImg/process.pipe.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 80</span></span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>];</span><br><span class=\"line\">        <span class=\"keyword\">pid_t</span> pid;</span><br><span class=\"line\">        <span class=\"keyword\">char</span> line[MAXLINE];</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pipe(fd) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                perror(<span class=\"string\">\"pipe\"</span>);</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                perror(<span class=\"string\">\"fork\"</span>);</span><br><span class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">/* parent */</span></span><br><span class=\"line\">                close(fd[<span class=\"number\">0</span>]);</span><br><span class=\"line\">                write(fd[<span class=\"number\">1</span>], <span class=\"string\">\"hello world\\n\"</span>, <span class=\"number\">12</span>);</span><br><span class=\"line\">                wait(<span class=\"literal\">NULL</span>);</span><br><span class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;       <span class=\"comment\">/* child */</span></span><br><span class=\"line\">                close(fd[<span class=\"number\">1</span>]);</span><br><span class=\"line\">                n = read(fd[<span class=\"number\">0</span>], line, MAXLINE);</span><br><span class=\"line\">                write(STDOUT_FILENO, line, n);</span><br><span class=\"line\">         &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用管道有一些限制：<br>两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？<br>管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。<br>使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：<br>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<br>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。<br>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。<br>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>\n</blockquote>\n<p> 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：<br>-父进程通过fork可以将打开文件的描述符传递给子进程<br>-子进程结束时，父进程调用wait可以得到子进程的终止信息<br>-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步<br>-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能<br>-管道<br>-FIFO<br>-mmap函数，几个进程可以映射同一内存区<br>-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃<br>-UNIX Domain Socket，目前最广泛使用的IPC机制</p>\n<h2 id=\"线程的通信\"><a href=\"#线程的通信\" class=\"headerlink\" title=\"线程的通信\"></a>线程的通信</h2><p>多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：<br>1.从内存读变量值到寄存器<br>2.寄存器的值加1<br>3.将寄存器的值写回内存<br>假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。<br> <img src=\"/assets/blogImg/thread.corrupt.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br> pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</span><br></pre></td></tr></table></figure></p>\n<p>返回值：成功返回0，失败返回错误号。<br>一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br>如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。<br>Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：<br>lock:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">if</span>(mutex &gt; <span class=\"number\">0</span>)&#123;</span><br><span class=\"line\">        mutex = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125; <span class=\"keyword\">else</span></span><br><span class=\"line\">        <span class=\"comment\">//挂起等待;</span></span><br><span class=\"line\">        <span class=\"keyword\">goto</span> lock;</span><br><span class=\"line\">unlock:</span><br><span class=\"line\">        mutex = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"comment\">//唤醒等待Mutex的线程;</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://akaedu.github.io/book/ch35s04.html\" target=\"_blank\" rel=\"noopener\">线程</a><br><a href=\"https://akaedu.github.io/book/ch30s04.html\" target=\"_blank\" rel=\"noopener\">进程间通信</a><br><a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000\" target=\"_blank\" rel=\"noopener\">进程和线程</a></p>"},{"title":"集群的nginx配置","date":"2018-01-14T16:01:54.000Z","_content":"\n这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。\n按照上篇的惯例，我们先亮出集群nginx配置文件\n## 实例\n``` shell\nuser nobody nobody;\nworker_process 2;\nerror_log /usr/local/webserver/nginx/logs/nginx_error.log crit;\npid /usr/local/webserver/nginx/nginx/pid;\nworker_rlimit_nofile 65535;\nevents\n{\n        use epoll;\n        woreker_connections 65535;\n}\nhttp\n{\n        include mime.types;\n        default_type application/octet-stream;\n        charset utf-8;\n        sendfile on;\n        tcp_nopush on;\n        keepalive_timeout 60;\n        tcp_nodelay on;\n        client_body_buffer_size 512k;\n        proxy_connect_timeout 5;\n        proxy_read_timeout 60;\n        proxy_send_timeout 5;\n        proxy_buffer_size 16k;\n        proxy_buffers 4 16k;\n        proxy_busy_buffers_size 128k;\n        proxy_temp_file_write_size 128k;\n        gzip on;\n        gzip_min_length 1k;\n        gzip_buffers 4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types text/plain application/x-javascript text/css application/xml;\n        gzip_vary on;\n#设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB\n        proxy_temp_file_path /data0/proxy_temp_dir;\n        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m\n        inactive=1d max_size=30g;\n        upstream backend {\n                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;\n        }\n        server\n        {\n                listen 80;\n                server_name myweb;\n                index index.html index.htm;\n                root /data0/htdocs/www;\n                location /\n                {\n                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。\n                        proxy_next_upstream http_502 http_504 error timeout invalid_header;\n                        proxy_cache cache_one;\n                        #针对不同HTTP状态设置不同的缓存时间\n                        proxy_cache_key $host$uri$is_args$args;\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend_server;\n                        expires 1d;\n                }\n                #配置缓存清楚功能\n                location ~ /purge(/.*)\n                {\n                        allow 127.0.0.1;\n                        allow 192.168.0.0/16;\n                        deny all;                \n                        proxy_cache_purge cache_one $host$1$is_args$args;\n                }\n                #配置数据不缓存\n                location ~ .*\\.(php|jpg|cgi)?$\n                {\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend;\n                }\n        }\n}\n```\n<!--more-->\n## 后端服务器组\n### upstream \nupstream backend\n{\n        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高\n        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态\n        server 127.0.0.1:8081 backup; #备用服务器 \n        server 127.0.0.1:8082 down; #永久无效状态 \n        server unix:/tmp/backend3; \n}\nupstream backend2\n{\n        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用\n        server myback1.proxy.com;\n        server myback2.proxy.com;\n        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量\n        last_conn;#选择当前网络连接最少的服务器\n}\n## rewrite功能配置\n### ngx_http_rewrite_module模块\n> 用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求\n\nlast：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行\nlocation / {\n     rewrite ^(/myweb/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last;\n     rewrite ^(/myweb/.*)/audio/(.*)\\.*$ $1/mp3/$2.ra last;\n}\n### 域名跳转\n```\nserver\n{\n        listen 80;\n        server_name jump.myweb.name;\n        rewrite ^ http://www.myweb.info/;#域名跳转\n}\nserver\n{\n        listen 80;\n        server_name jump.myweb.name jump.myweb.info\n        if($host ^ myweb.\\info) #.用\\转义\n        {\n                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转\n        }\n}\nserver\n{\n        listen 80;       \n        server_name jump1.myweb.name jump2.myweb.name;\n        if($http_host ~* ^(.*)\\.myweb\\.name$)\n        {\n                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转\n                break;\n        }\n}\n```\n### 域名镜像\n```\nserver\n{\n        listen 80;\n        server_name mirror1.myweb.name;\n        rewrite ^(.*) http://jump1.myweb.name$1 last;\n}\nserver\n{\n        listen 81;\n        server_name mirror2.myweb.name;\n        rewrite ^(.*) http://jump2.myweb.name$1 last;\n}\n\n```\n### 独立域名\n当一个网站包含多个板块时，可以为某些板块设置独立域名\n```\nserver\n{\n        listen 80;\n        server_name bbs.myweb.name;\n        rewrite ^(.*) http://www.myweb.com/bbs$1 last;\n}\n\n```\n### 防盗链\n```\nlocation ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*\n{\n        valid_referers none blocked server_name *. myweb.name;\n        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片\n        {\n                rewrite ^/ http://www.myweb.com/images/forbidden.png;\n        }\n}\n```\n## 反向代理\n> 局域网向Internet提供局域网内的资源，设置一个代理服务器\n\nproxy_pass URL 设置被代理的服务器\n```\nupstream proxy_svrs\n{\n        ...\n}\nserver\n{\n...\n        location /\n        {\n                proxy_pass proxy_svrs;\n        }\n}\n```\n- proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息\n- proxy_pass_header field;#设置需要发送的头域信息\n- proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器\n- proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器\n- proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器\n- proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器\n- proxy_bind; #强制将代理主机的连接绑定到指定的IP地址\n- proxy_connect_timeout time;#与被代理服务器的连接超时时间\n- proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间\n- proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 \n- proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本\n- proxy_method;#nginx 和代理服务器组的请求方法\n- proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求\n- proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域\n- proxy_redirect; #修改被代理服务器组的Location域和Refresh域\n- proxy_intercept_errors off; #直接返回代理服务器的http状态码\n- proxy_hash_max_size 512; #http报头文的容量上限\n- proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小\n- proxy_next_upstream status;#遵循upstream指令的轮询规则\n- proxy_ssl_session_reuse on;#开启ssl代理间协议\n#### Proxy Buffer\n- proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)\n- proxy_buffers 8 4k; #buffer个数 每个大小\n- proxy_busy_buffers_size 16kb; #busy状态下buffer总大小\n- proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录\n- proxy_max_temp_file_size 1024MB #临时文件总体积上限值\n- proxy_temp_file_write_size 8kb; #数据量总大小限值\n#### Proxy Cache(对已有数据在内存中建立缓存数据)\n- proxy_cache zone | off #设置存放缓存内存区域名字\n- proxy_cache_bypass #向客户端发送数据时不从缓存中获取\n- proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字\n- proxy_cache_lock on#缓存中的数据同时只能被一条请求读取\n- proxy_cache_lock_timeout 5s; #缓存锁的超时时间\n- proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存\n- proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小\n- proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存\n- proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟\n- proxy_store on;#开启本地磁盘缓存数据\n- proxy_store_access user:rw group:rw all:r #配置缓存权限\n### 负载均衡\n> 将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间\n\nupstream backend\n{\n  server 192.168.1.2:80 weight=5 #权限最高\n  server 192.168.1.3:80 weight=2\n  server 192.168.1.4:80          #默认1\n}\n\n\n\n\n\n","source":"_posts/集群的nginx配置.md","raw":"---\ntitle: 集群的nginx配置\ndate: 2018-01-15 00:01:54\ntag: php\ncategories: 技术\n\n---\n\n这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。\n按照上篇的惯例，我们先亮出集群nginx配置文件\n## 实例\n``` shell\nuser nobody nobody;\nworker_process 2;\nerror_log /usr/local/webserver/nginx/logs/nginx_error.log crit;\npid /usr/local/webserver/nginx/nginx/pid;\nworker_rlimit_nofile 65535;\nevents\n{\n        use epoll;\n        woreker_connections 65535;\n}\nhttp\n{\n        include mime.types;\n        default_type application/octet-stream;\n        charset utf-8;\n        sendfile on;\n        tcp_nopush on;\n        keepalive_timeout 60;\n        tcp_nodelay on;\n        client_body_buffer_size 512k;\n        proxy_connect_timeout 5;\n        proxy_read_timeout 60;\n        proxy_send_timeout 5;\n        proxy_buffer_size 16k;\n        proxy_buffers 4 16k;\n        proxy_busy_buffers_size 128k;\n        proxy_temp_file_write_size 128k;\n        gzip on;\n        gzip_min_length 1k;\n        gzip_buffers 4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types text/plain application/x-javascript text/css application/xml;\n        gzip_vary on;\n#设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB\n        proxy_temp_file_path /data0/proxy_temp_dir;\n        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m\n        inactive=1d max_size=30g;\n        upstream backend {\n                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;\n        }\n        server\n        {\n                listen 80;\n                server_name myweb;\n                index index.html index.htm;\n                root /data0/htdocs/www;\n                location /\n                {\n                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。\n                        proxy_next_upstream http_502 http_504 error timeout invalid_header;\n                        proxy_cache cache_one;\n                        #针对不同HTTP状态设置不同的缓存时间\n                        proxy_cache_key $host$uri$is_args$args;\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend_server;\n                        expires 1d;\n                }\n                #配置缓存清楚功能\n                location ~ /purge(/.*)\n                {\n                        allow 127.0.0.1;\n                        allow 192.168.0.0/16;\n                        deny all;                \n                        proxy_cache_purge cache_one $host$1$is_args$args;\n                }\n                #配置数据不缓存\n                location ~ .*\\.(php|jpg|cgi)?$\n                {\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend;\n                }\n        }\n}\n```\n<!--more-->\n## 后端服务器组\n### upstream \nupstream backend\n{\n        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高\n        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态\n        server 127.0.0.1:8081 backup; #备用服务器 \n        server 127.0.0.1:8082 down; #永久无效状态 \n        server unix:/tmp/backend3; \n}\nupstream backend2\n{\n        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用\n        server myback1.proxy.com;\n        server myback2.proxy.com;\n        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量\n        last_conn;#选择当前网络连接最少的服务器\n}\n## rewrite功能配置\n### ngx_http_rewrite_module模块\n> 用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求\n\nlast：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行\nlocation / {\n     rewrite ^(/myweb/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last;\n     rewrite ^(/myweb/.*)/audio/(.*)\\.*$ $1/mp3/$2.ra last;\n}\n### 域名跳转\n```\nserver\n{\n        listen 80;\n        server_name jump.myweb.name;\n        rewrite ^ http://www.myweb.info/;#域名跳转\n}\nserver\n{\n        listen 80;\n        server_name jump.myweb.name jump.myweb.info\n        if($host ^ myweb.\\info) #.用\\转义\n        {\n                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转\n        }\n}\nserver\n{\n        listen 80;       \n        server_name jump1.myweb.name jump2.myweb.name;\n        if($http_host ~* ^(.*)\\.myweb\\.name$)\n        {\n                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转\n                break;\n        }\n}\n```\n### 域名镜像\n```\nserver\n{\n        listen 80;\n        server_name mirror1.myweb.name;\n        rewrite ^(.*) http://jump1.myweb.name$1 last;\n}\nserver\n{\n        listen 81;\n        server_name mirror2.myweb.name;\n        rewrite ^(.*) http://jump2.myweb.name$1 last;\n}\n\n```\n### 独立域名\n当一个网站包含多个板块时，可以为某些板块设置独立域名\n```\nserver\n{\n        listen 80;\n        server_name bbs.myweb.name;\n        rewrite ^(.*) http://www.myweb.com/bbs$1 last;\n}\n\n```\n### 防盗链\n```\nlocation ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*\n{\n        valid_referers none blocked server_name *. myweb.name;\n        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片\n        {\n                rewrite ^/ http://www.myweb.com/images/forbidden.png;\n        }\n}\n```\n## 反向代理\n> 局域网向Internet提供局域网内的资源，设置一个代理服务器\n\nproxy_pass URL 设置被代理的服务器\n```\nupstream proxy_svrs\n{\n        ...\n}\nserver\n{\n...\n        location /\n        {\n                proxy_pass proxy_svrs;\n        }\n}\n```\n- proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息\n- proxy_pass_header field;#设置需要发送的头域信息\n- proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器\n- proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器\n- proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器\n- proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器\n- proxy_bind; #强制将代理主机的连接绑定到指定的IP地址\n- proxy_connect_timeout time;#与被代理服务器的连接超时时间\n- proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间\n- proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 \n- proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本\n- proxy_method;#nginx 和代理服务器组的请求方法\n- proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求\n- proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域\n- proxy_redirect; #修改被代理服务器组的Location域和Refresh域\n- proxy_intercept_errors off; #直接返回代理服务器的http状态码\n- proxy_hash_max_size 512; #http报头文的容量上限\n- proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小\n- proxy_next_upstream status;#遵循upstream指令的轮询规则\n- proxy_ssl_session_reuse on;#开启ssl代理间协议\n#### Proxy Buffer\n- proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)\n- proxy_buffers 8 4k; #buffer个数 每个大小\n- proxy_busy_buffers_size 16kb; #busy状态下buffer总大小\n- proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录\n- proxy_max_temp_file_size 1024MB #临时文件总体积上限值\n- proxy_temp_file_write_size 8kb; #数据量总大小限值\n#### Proxy Cache(对已有数据在内存中建立缓存数据)\n- proxy_cache zone | off #设置存放缓存内存区域名字\n- proxy_cache_bypass #向客户端发送数据时不从缓存中获取\n- proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字\n- proxy_cache_lock on#缓存中的数据同时只能被一条请求读取\n- proxy_cache_lock_timeout 5s; #缓存锁的超时时间\n- proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存\n- proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小\n- proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存\n- proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟\n- proxy_store on;#开启本地磁盘缓存数据\n- proxy_store_access user:rw group:rw all:r #配置缓存权限\n### 负载均衡\n> 将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间\n\nupstream backend\n{\n  server 192.168.1.2:80 weight=5 #权限最高\n  server 192.168.1.3:80 weight=2\n  server 192.168.1.4:80          #默认1\n}\n\n\n\n\n\n","slug":"集群的nginx配置","published":1,"updated":"2018-05-27T09:59:36.028Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ck4f00sju001ith8lt1mohik4","content":"<p>这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。<br>按照上篇的惯例，我们先亮出集群nginx配置文件</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user nobody nobody;</span><br><span class=\"line\">worker_process 2;</span><br><span class=\"line\">error_log /usr/local/webserver/nginx/logs/nginx_error.log crit;</span><br><span class=\"line\">pid /usr/local/webserver/nginx/nginx/pid;</span><br><span class=\"line\">worker_rlimit_nofile 65535;</span><br><span class=\"line\">events</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        use epoll;</span><br><span class=\"line\">        woreker_connections 65535;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        include mime.types;</span><br><span class=\"line\">        default_type application/octet-stream;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        sendfile on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        keepalive_timeout 60;</span><br><span class=\"line\">        tcp_nodelay on;</span><br><span class=\"line\">        client_body_buffer_size 512k;</span><br><span class=\"line\">        proxy_connect_timeout 5;</span><br><span class=\"line\">        proxy_read_timeout 60;</span><br><span class=\"line\">        proxy_send_timeout 5;</span><br><span class=\"line\">        proxy_buffer_size 16k;</span><br><span class=\"line\">        proxy_buffers 4 16k;</span><br><span class=\"line\">        proxy_busy_buffers_size 128k;</span><br><span class=\"line\">        proxy_temp_file_write_size 128k;</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        gzip_min_length 1k;</span><br><span class=\"line\">        gzip_buffers 4 16k;</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        gzip_comp_level 2;</span><br><span class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class=\"line\">        gzip_vary on;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB</span></span><br><span class=\"line\">        proxy_temp_file_path /data0/proxy_temp_dir;</span><br><span class=\"line\">        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m</span><br><span class=\"line\">        inactive=1d max_size=30g;</span><br><span class=\"line\">        upstream backend &#123;</span><br><span class=\"line\">                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class=\"line\">                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class=\"line\">                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        server</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                listen 80;</span><br><span class=\"line\">                server_name myweb;</span><br><span class=\"line\">                index index.html index.htm;</span><br><span class=\"line\">                root /data0/htdocs/www;</span><br><span class=\"line\">                location /</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。</span><br><span class=\"line\">                        proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class=\"line\">                        proxy_cache cache_one;</span><br><span class=\"line\">                        #针对不同HTTP状态设置不同的缓存时间</span><br><span class=\"line\">                        proxy_cache_key $host$uri$is_args$args;</span><br><span class=\"line\">                        proxy_set_header Host $host;</span><br><span class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">                        proxy_pass http://backend_server;</span><br><span class=\"line\">                        expires 1d;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                #配置缓存清楚功能</span><br><span class=\"line\">                location ~ /purge(/.*)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        allow 127.0.0.1;</span><br><span class=\"line\">                        allow 192.168.0.0/16;</span><br><span class=\"line\">                        deny all;                </span><br><span class=\"line\">                        proxy_cache_purge cache_one $host$1$is_args$args;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                #配置数据不缓存</span><br><span class=\"line\">                location ~ .*\\.(php|jpg|cgi)?$</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        proxy_set_header Host $host;</span><br><span class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">                        proxy_pass http://backend;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"后端服务器组\"><a href=\"#后端服务器组\" class=\"headerlink\" title=\"后端服务器组\"></a>后端服务器组</h2><h3 id=\"upstream\"><a href=\"#upstream\" class=\"headerlink\" title=\"upstream\"></a>upstream</h3><p>upstream backend<br>{<br>        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高<br>        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态<br>        server 127.0.0.1:8081 backup; #备用服务器<br>        server 127.0.0.1:8082 down; #永久无效状态<br>        server unix:/tmp/backend3;<br>}<br>upstream backend2<br>{<br>        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用<br>        server myback1.proxy.com;<br>        server myback2.proxy.com;<br>        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量<br>        last_conn;#选择当前网络连接最少的服务器<br>}</p>\n<h2 id=\"rewrite功能配置\"><a href=\"#rewrite功能配置\" class=\"headerlink\" title=\"rewrite功能配置\"></a>rewrite功能配置</h2><h3 id=\"ngx-http-rewrite-module模块\"><a href=\"#ngx-http-rewrite-module模块\" class=\"headerlink\" title=\"ngx_http_rewrite_module模块\"></a>ngx_http_rewrite_module模块</h3><blockquote>\n<p>用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求</p>\n</blockquote>\n<p>last：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行<br>location / {<br>     rewrite ^(/myweb/.<em>)/media/(.</em>)..<em>$ $1/mp3/$2.mp3 last;<br>     rewrite ^(/myweb/.</em>)/audio/(.<em>).</em>$ $1/mp3/$2.ra last;<br>}</p>\n<h3 id=\"域名跳转\"><a href=\"#域名跳转\" class=\"headerlink\" title=\"域名跳转\"></a>域名跳转</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name jump.myweb.name;</span><br><span class=\"line\">        rewrite ^ http://www.myweb.info/;#域名跳转</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name jump.myweb.name jump.myweb.info</span><br><span class=\"line\">        if($host ^ myweb.\\info) #.用\\转义</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;       </span><br><span class=\"line\">        server_name jump1.myweb.name jump2.myweb.name;</span><br><span class=\"line\">        if($http_host ~* ^(.*)\\.myweb\\.name$)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"域名镜像\"><a href=\"#域名镜像\" class=\"headerlink\" title=\"域名镜像\"></a>域名镜像</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name mirror1.myweb.name;</span><br><span class=\"line\">        rewrite ^(.*) http://jump1.myweb.name$1 last;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 81;</span><br><span class=\"line\">        server_name mirror2.myweb.name;</span><br><span class=\"line\">        rewrite ^(.*) http://jump2.myweb.name$1 last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"独立域名\"><a href=\"#独立域名\" class=\"headerlink\" title=\"独立域名\"></a>独立域名</h3><p>当一个网站包含多个板块时，可以为某些板块设置独立域名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name bbs.myweb.name;</span><br><span class=\"line\">        rewrite ^(.*) http://www.myweb.com/bbs$1 last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        valid_referers none blocked server_name *. myweb.name;</span><br><span class=\"line\">        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                rewrite ^/ http://www.myweb.com/images/forbidden.png;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><blockquote>\n<p>局域网向Internet提供局域网内的资源，设置一个代理服务器</p>\n</blockquote>\n<p>proxy_pass URL 设置被代理的服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream proxy_svrs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">        location /</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                proxy_pass proxy_svrs;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息</li>\n<li>proxy_pass_header field;#设置需要发送的头域信息</li>\n<li>proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器</li>\n<li>proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器</li>\n<li>proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器</li>\n<li>proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器</li>\n<li>proxy_bind; #强制将代理主机的连接绑定到指定的IP地址</li>\n<li>proxy_connect_timeout time;#与被代理服务器的连接超时时间</li>\n<li>proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间</li>\n<li>proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 </li>\n<li>proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本</li>\n<li>proxy_method;#nginx 和代理服务器组的请求方法</li>\n<li>proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求</li>\n<li>proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域</li>\n<li>proxy_redirect; #修改被代理服务器组的Location域和Refresh域</li>\n<li>proxy_intercept_errors off; #直接返回代理服务器的http状态码</li>\n<li>proxy_hash_max_size 512; #http报头文的容量上限</li>\n<li>proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小</li>\n<li>proxy_next_upstream status;#遵循upstream指令的轮询规则</li>\n<li>proxy_ssl_session_reuse on;#开启ssl代理间协议<h4 id=\"Proxy-Buffer\"><a href=\"#Proxy-Buffer\" class=\"headerlink\" title=\"Proxy Buffer\"></a>Proxy Buffer</h4></li>\n<li>proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)</li>\n<li>proxy_buffers 8 4k; #buffer个数 每个大小</li>\n<li>proxy_busy_buffers_size 16kb; #busy状态下buffer总大小</li>\n<li>proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录</li>\n<li>proxy_max_temp_file_size 1024MB #临时文件总体积上限值</li>\n<li>proxy_temp_file_write_size 8kb; #数据量总大小限值<h4 id=\"Proxy-Cache-对已有数据在内存中建立缓存数据\"><a href=\"#Proxy-Cache-对已有数据在内存中建立缓存数据\" class=\"headerlink\" title=\"Proxy Cache(对已有数据在内存中建立缓存数据)\"></a>Proxy Cache(对已有数据在内存中建立缓存数据)</h4></li>\n<li>proxy_cache zone | off #设置存放缓存内存区域名字</li>\n<li>proxy_cache_bypass #向客户端发送数据时不从缓存中获取</li>\n<li>proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字</li>\n<li>proxy_cache_lock on#缓存中的数据同时只能被一条请求读取</li>\n<li>proxy_cache_lock_timeout 5s; #缓存锁的超时时间</li>\n<li>proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存</li>\n<li>proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小</li>\n<li>proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存</li>\n<li>proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟</li>\n<li>proxy_store on;#开启本地磁盘缓存数据</li>\n<li>proxy_store_access user:rw group:rw all:r #配置缓存权限<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><blockquote>\n<p>将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间</p>\n</blockquote>\n</li>\n</ul>\n<p>upstream backend<br>{<br>  server 192.168.1.2:80 weight=5 #权限最高<br>  server 192.168.1.3:80 weight=2<br>  server 192.168.1.4:80          #默认1<br>}</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。<br>按照上篇的惯例，我们先亮出集群nginx配置文件</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight shell\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">user nobody nobody;</span><br><span class=\"line\">worker_process 2;</span><br><span class=\"line\">error_log /usr/local/webserver/nginx/logs/nginx_error.log crit;</span><br><span class=\"line\">pid /usr/local/webserver/nginx/nginx/pid;</span><br><span class=\"line\">worker_rlimit_nofile 65535;</span><br><span class=\"line\">events</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        use epoll;</span><br><span class=\"line\">        woreker_connections 65535;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">http</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        include mime.types;</span><br><span class=\"line\">        default_type application/octet-stream;</span><br><span class=\"line\">        charset utf-8;</span><br><span class=\"line\">        sendfile on;</span><br><span class=\"line\">        tcp_nopush on;</span><br><span class=\"line\">        keepalive_timeout 60;</span><br><span class=\"line\">        tcp_nodelay on;</span><br><span class=\"line\">        client_body_buffer_size 512k;</span><br><span class=\"line\">        proxy_connect_timeout 5;</span><br><span class=\"line\">        proxy_read_timeout 60;</span><br><span class=\"line\">        proxy_send_timeout 5;</span><br><span class=\"line\">        proxy_buffer_size 16k;</span><br><span class=\"line\">        proxy_buffers 4 16k;</span><br><span class=\"line\">        proxy_busy_buffers_size 128k;</span><br><span class=\"line\">        proxy_temp_file_write_size 128k;</span><br><span class=\"line\">        gzip on;</span><br><span class=\"line\">        gzip_min_length 1k;</span><br><span class=\"line\">        gzip_buffers 4 16k;</span><br><span class=\"line\">        gzip_http_version 1.1;</span><br><span class=\"line\">        gzip_comp_level 2;</span><br><span class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml;</span><br><span class=\"line\">        gzip_vary on;</span><br><span class=\"line\"><span class=\"meta\">#</span><span class=\"bash\">设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB</span></span><br><span class=\"line\">        proxy_temp_file_path /data0/proxy_temp_dir;</span><br><span class=\"line\">        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m</span><br><span class=\"line\">        inactive=1d max_size=30g;</span><br><span class=\"line\">        upstream backend &#123;</span><br><span class=\"line\">                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class=\"line\">                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class=\"line\">                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        server</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                listen 80;</span><br><span class=\"line\">                server_name myweb;</span><br><span class=\"line\">                index index.html index.htm;</span><br><span class=\"line\">                root /data0/htdocs/www;</span><br><span class=\"line\">                location /</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。</span><br><span class=\"line\">                        proxy_next_upstream http_502 http_504 error timeout invalid_header;</span><br><span class=\"line\">                        proxy_cache cache_one;</span><br><span class=\"line\">                        #针对不同HTTP状态设置不同的缓存时间</span><br><span class=\"line\">                        proxy_cache_key $host$uri$is_args$args;</span><br><span class=\"line\">                        proxy_set_header Host $host;</span><br><span class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">                        proxy_pass http://backend_server;</span><br><span class=\"line\">                        expires 1d;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                #配置缓存清楚功能</span><br><span class=\"line\">                location ~ /purge(/.*)</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        allow 127.0.0.1;</span><br><span class=\"line\">                        allow 192.168.0.0/16;</span><br><span class=\"line\">                        deny all;                </span><br><span class=\"line\">                        proxy_cache_purge cache_one $host$1$is_args$args;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                #配置数据不缓存</span><br><span class=\"line\">                location ~ .*\\.(php|jpg|cgi)?$</span><br><span class=\"line\">                &#123;</span><br><span class=\"line\">                        proxy_set_header Host $host;</span><br><span class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</span><br><span class=\"line\">                        proxy_pass http://backend;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","more":"<h2 id=\"后端服务器组\"><a href=\"#后端服务器组\" class=\"headerlink\" title=\"后端服务器组\"></a>后端服务器组</h2><h3 id=\"upstream\"><a href=\"#upstream\" class=\"headerlink\" title=\"upstream\"></a>upstream</h3><p>upstream backend<br>{<br>        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高<br>        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态<br>        server 127.0.0.1:8081 backup; #备用服务器<br>        server 127.0.0.1:8082 down; #永久无效状态<br>        server unix:/tmp/backend3;<br>}<br>upstream backend2<br>{<br>        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用<br>        server myback1.proxy.com;<br>        server myback2.proxy.com;<br>        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量<br>        last_conn;#选择当前网络连接最少的服务器<br>}</p>\n<h2 id=\"rewrite功能配置\"><a href=\"#rewrite功能配置\" class=\"headerlink\" title=\"rewrite功能配置\"></a>rewrite功能配置</h2><h3 id=\"ngx-http-rewrite-module模块\"><a href=\"#ngx-http-rewrite-module模块\" class=\"headerlink\" title=\"ngx_http_rewrite_module模块\"></a>ngx_http_rewrite_module模块</h3><blockquote>\n<p>用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求</p>\n</blockquote>\n<p>last：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行<br>location / {<br>     rewrite ^(/myweb/.<em>)/media/(.</em>)..<em>$ $1/mp3/$2.mp3 last;<br>     rewrite ^(/myweb/.</em>)/audio/(.<em>).</em>$ $1/mp3/$2.ra last;<br>}</p>\n<h3 id=\"域名跳转\"><a href=\"#域名跳转\" class=\"headerlink\" title=\"域名跳转\"></a>域名跳转</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name jump.myweb.name;</span><br><span class=\"line\">        rewrite ^ http://www.myweb.info/;#域名跳转</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name jump.myweb.name jump.myweb.info</span><br><span class=\"line\">        if($host ^ myweb.\\info) #.用\\转义</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;       </span><br><span class=\"line\">        server_name jump1.myweb.name jump2.myweb.name;</span><br><span class=\"line\">        if($http_host ~* ^(.*)\\.myweb\\.name$)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转</span><br><span class=\"line\">                break;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"域名镜像\"><a href=\"#域名镜像\" class=\"headerlink\" title=\"域名镜像\"></a>域名镜像</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name mirror1.myweb.name;</span><br><span class=\"line\">        rewrite ^(.*) http://jump1.myweb.name$1 last;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 81;</span><br><span class=\"line\">        server_name mirror2.myweb.name;</span><br><span class=\"line\">        rewrite ^(.*) http://jump2.myweb.name$1 last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"独立域名\"><a href=\"#独立域名\" class=\"headerlink\" title=\"独立域名\"></a>独立域名</h3><p>当一个网站包含多个板块时，可以为某些板块设置独立域名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        listen 80;</span><br><span class=\"line\">        server_name bbs.myweb.name;</span><br><span class=\"line\">        rewrite ^(.*) http://www.myweb.com/bbs$1 last;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<h3 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        valid_referers none blocked server_name *. myweb.name;</span><br><span class=\"line\">        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                rewrite ^/ http://www.myweb.com/images/forbidden.png;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><blockquote>\n<p>局域网向Internet提供局域网内的资源，设置一个代理服务器</p>\n</blockquote>\n<p>proxy_pass URL 设置被代理的服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">upstream proxy_svrs</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">        ...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">server</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">...</span><br><span class=\"line\">        location /</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">                proxy_pass proxy_svrs;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息</li>\n<li>proxy_pass_header field;#设置需要发送的头域信息</li>\n<li>proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器</li>\n<li>proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器</li>\n<li>proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器</li>\n<li>proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器</li>\n<li>proxy_bind; #强制将代理主机的连接绑定到指定的IP地址</li>\n<li>proxy_connect_timeout time;#与被代理服务器的连接超时时间</li>\n<li>proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间</li>\n<li>proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 </li>\n<li>proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本</li>\n<li>proxy_method;#nginx 和代理服务器组的请求方法</li>\n<li>proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求</li>\n<li>proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域</li>\n<li>proxy_redirect; #修改被代理服务器组的Location域和Refresh域</li>\n<li>proxy_intercept_errors off; #直接返回代理服务器的http状态码</li>\n<li>proxy_hash_max_size 512; #http报头文的容量上限</li>\n<li>proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小</li>\n<li>proxy_next_upstream status;#遵循upstream指令的轮询规则</li>\n<li>proxy_ssl_session_reuse on;#开启ssl代理间协议<h4 id=\"Proxy-Buffer\"><a href=\"#Proxy-Buffer\" class=\"headerlink\" title=\"Proxy Buffer\"></a>Proxy Buffer</h4></li>\n<li>proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)</li>\n<li>proxy_buffers 8 4k; #buffer个数 每个大小</li>\n<li>proxy_busy_buffers_size 16kb; #busy状态下buffer总大小</li>\n<li>proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录</li>\n<li>proxy_max_temp_file_size 1024MB #临时文件总体积上限值</li>\n<li>proxy_temp_file_write_size 8kb; #数据量总大小限值<h4 id=\"Proxy-Cache-对已有数据在内存中建立缓存数据\"><a href=\"#Proxy-Cache-对已有数据在内存中建立缓存数据\" class=\"headerlink\" title=\"Proxy Cache(对已有数据在内存中建立缓存数据)\"></a>Proxy Cache(对已有数据在内存中建立缓存数据)</h4></li>\n<li>proxy_cache zone | off #设置存放缓存内存区域名字</li>\n<li>proxy_cache_bypass #向客户端发送数据时不从缓存中获取</li>\n<li>proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字</li>\n<li>proxy_cache_lock on#缓存中的数据同时只能被一条请求读取</li>\n<li>proxy_cache_lock_timeout 5s; #缓存锁的超时时间</li>\n<li>proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存</li>\n<li>proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小</li>\n<li>proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存</li>\n<li>proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟</li>\n<li>proxy_store on;#开启本地磁盘缓存数据</li>\n<li>proxy_store_access user:rw group:rw all:r #配置缓存权限<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><blockquote>\n<p>将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间</p>\n</blockquote>\n</li>\n</ul>\n<p>upstream backend<br>{<br>  server 192.168.1.2:80 weight=5 #权限最高<br>  server 192.168.1.3:80 weight=2<br>  server 192.168.1.4:80          #默认1<br>}</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"ck4f00si20001th8lhmxu8dnr","category_id":"ck4f00sjk0013th8lyf31kbhc","_id":"ck4f00skj002rth8l2d8gufku"},{"post_id":"ck4f00si30002th8l9pikmgqn","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skj002tth8lhufnw22n"},{"post_id":"ck4f00si70006th8lvo8czcea","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skk002vth8lkluwoonm"},{"post_id":"ck4f00sic000bth8l4vieu049","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skk002xth8lokpjkpbr"},{"post_id":"ck4f00sie000eth8l8dk6o7yh","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skk002zth8l4dvrsbus"},{"post_id":"ck4f00sig000fth8l928r5oqi","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skk0031th8lrdwvikcn"},{"post_id":"ck4f00sih000gth8l700zn1y2","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skk0033th8lfw7ztjl6"},{"post_id":"ck4f00sij000ith8lrdxq3zvw","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skk0035th8lws7qwlgm"},{"post_id":"ck4f00sik000kth8ldsbgsynk","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skl0037th8l4zf8yscj"},{"post_id":"ck4f00sil000lth8l9mq0a85y","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skl0039th8l0jf66g0l"},{"post_id":"ck4f00sim000mth8lzr09mluk","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skl003bth8lb9of3pue"},{"post_id":"ck4f00sio000rth8l4sti5ku4","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skl003dth8lio1i50pv"},{"post_id":"ck4f00sip000tth8lzqwz4puy","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skl003fth8lucz2i9ix"},{"post_id":"ck4f00siq000uth8lzjh4w4i7","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skl003hth8l1d4adgmt"},{"post_id":"ck4f00sir000wth8lm3d9tnsf","category_id":"ck4f00sk50023th8lh4xlreth","_id":"ck4f00skm003jth8l7icncwtj"},{"post_id":"ck4f00siu0010th8lpg1mbu73","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skm003lth8l2uqmeyv4"},{"post_id":"ck4f00sjm0015th8l72otjamd","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skm003nth8l5a0m6ud2"},{"post_id":"ck4f00sjn0016th8l8j267plz","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skm003pth8lh8lxvix0"},{"post_id":"ck4f00sjp001ath8l2pdovcjo","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skm003rth8lumec06rn"},{"post_id":"ck4f00sjr001dth8llh7tp6vp","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skm003tth8lwrjvz0gp"},{"post_id":"ck4f00sjs001eth8l26otca7h","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skm003vth8luq9zzbc9"},{"post_id":"ck4f00sjt001hth8ltr8t6qoh","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skn003xth8l5nz6mbgc"},{"post_id":"ck4f00sju001ith8lt1mohik4","category_id":"ck4f00sjo0018th8lnj7pfliw","_id":"ck4f00skn003zth8lzyfspptg"}],"PostTag":[{"post_id":"ck4f00shp0000th8lizsk7kpg","tag_id":"ck4f00sja0012th8l52falbgh","_id":"ck4f00skj002qth8lwimrbcb6"},{"post_id":"ck4f00si20001th8lhmxu8dnr","tag_id":"ck4f00sjn0017th8l5py4vast","_id":"ck4f00skj002sth8l6edc8j6q"},{"post_id":"ck4f00si30002th8l9pikmgqn","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00skj002uth8ljytvtezw"},{"post_id":"ck4f00si40003th8l8zizjghf","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skk002wth8l8yw9nfdv"},{"post_id":"ck4f00si50004th8l4kta20mu","tag_id":"ck4f00sjv001kth8ljjwty2mc","_id":"ck4f00skk002yth8l8jqz6gut"},{"post_id":"ck4f00si60005th8lzbmdi58p","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skk0030th8lfbbqrnzf"},{"post_id":"ck4f00si70006th8lvo8czcea","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00skk0032th8lgz6e4l37"},{"post_id":"ck4f00si80008th8lk6ifrt7l","tag_id":"ck4f00sjv001kth8ljjwty2mc","_id":"ck4f00skk0034th8lk10u2kfi"},{"post_id":"ck4f00si90009th8lo45jv2j4","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skl0036th8lt4cc1ym4"},{"post_id":"ck4f00sib000ath8lx7l9gj3r","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skl0038th8l7zmkp2nk"},{"post_id":"ck4f00sic000cth8laniocnd7","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skl003ath8ll70xszbo"},{"post_id":"ck4f00sie000dth8lxmuvxck4","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skl003cth8lli7mcmgv"},{"post_id":"ck4f00sie000eth8l8dk6o7yh","tag_id":"ck4f00sk40020th8lu5sszyn9","_id":"ck4f00skl003eth8lkl69qoiq"},{"post_id":"ck4f00sig000fth8l928r5oqi","tag_id":"ck4f00sk50022th8lo7bzao8d","_id":"ck4f00skl003gth8lrvls5pgd"},{"post_id":"ck4f00sih000gth8l700zn1y2","tag_id":"ck4f00sk50024th8lrnmfsdqk","_id":"ck4f00skl003ith8lknv45ps0"},{"post_id":"ck4f00sii000hth8lsf5wh301","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skm003kth8lp2ymq4i5"},{"post_id":"ck4f00sij000ith8lrdxq3zvw","tag_id":"ck4f00sk50024th8lrnmfsdqk","_id":"ck4f00skm003mth8l87subpbm"},{"post_id":"ck4f00sij000jth8lw164sovj","tag_id":"ck4f00sk70028th8l7c9bcnj7","_id":"ck4f00skm003oth8l3lesfzjl"},{"post_id":"ck4f00sik000kth8ldsbgsynk","tag_id":"ck4f00sk70029th8lflcwx5kf","_id":"ck4f00skm003qth8llrrrmmzd"},{"post_id":"ck4f00sil000lth8l9mq0a85y","tag_id":"ck4f00sk7002ath8ln8t68fkd","_id":"ck4f00skm003sth8lgag17t4t"},{"post_id":"ck4f00sim000mth8lzr09mluk","tag_id":"ck4f00sk50022th8lo7bzao8d","_id":"ck4f00skm003uth8l8l12hlni"},{"post_id":"ck4f00sim000nth8l0qlsxiwj","tag_id":"ck4f00sk70029th8lflcwx5kf","_id":"ck4f00skn003wth8lre754ko7"},{"post_id":"ck4f00sin000oth8lhuajn27t","tag_id":"ck4f00sja0012th8l52falbgh","_id":"ck4f00skn003yth8lo8hs7pra"},{"post_id":"ck4f00sin000pth8l289u3qwh","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skn0040th8lnserua6u"},{"post_id":"ck4f00sio000qth8lgbpd9t7a","tag_id":"ck4f00sk70029th8lflcwx5kf","_id":"ck4f00skn0041th8lmzldiw6d"},{"post_id":"ck4f00sio000rth8l4sti5ku4","tag_id":"ck4f00sk7002ath8ln8t68fkd","_id":"ck4f00skn0042th8li6g86uj2"},{"post_id":"ck4f00sip000sth8lp9stt1na","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00skn0043th8l0ukg33ut"},{"post_id":"ck4f00sip000tth8lzqwz4puy","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00skn0044th8l23n3544j"},{"post_id":"ck4f00siq000uth8lzjh4w4i7","tag_id":"ck4f00sk7002ath8ln8t68fkd","_id":"ck4f00skn0045th8lhfkok4us"},{"post_id":"ck4f00sir000wth8lm3d9tnsf","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00skn0046th8lhfchpkhy"},{"post_id":"ck4f00sis000xth8lg9ti8nui","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00sko0047th8ls599qk1v"},{"post_id":"ck4f00sit000yth8llenny9hb","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00sko0048th8ll2ac6z9n"},{"post_id":"ck4f00sit000zth8loo18tuxu","tag_id":"ck4f00sjt001gth8lh44kbdgz","_id":"ck4f00sko0049th8l69fl22mf"},{"post_id":"ck4f00siu0010th8lpg1mbu73","tag_id":"ck4f00skd002oth8liyb73yo6","_id":"ck4f00sko004ath8lw225rckt"},{"post_id":"ck4f00siv0011th8lxi2t4sd3","tag_id":"ck4f00ske002pth8l8xmrznje","_id":"ck4f00sko004bth8lewlu26cv"},{"post_id":"ck4f00sjk0014th8lymfy8pa5","tag_id":"ck4f00sk70029th8lflcwx5kf","_id":"ck4f00sko004cth8lq7qo36zr"},{"post_id":"ck4f00sjn0016th8l8j267plz","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00sko004dth8lf4jvtzay"},{"post_id":"ck4f00sjo0019th8lgjrwssri","tag_id":"ck4f00sk70029th8lflcwx5kf","_id":"ck4f00sko004eth8lgvrz1kut"},{"post_id":"ck4f00sjp001ath8l2pdovcjo","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00sko004fth8l5o6ch7oa"},{"post_id":"ck4f00sjr001dth8llh7tp6vp","tag_id":"ck4f00sk7002ath8ln8t68fkd","_id":"ck4f00skp004gth8lhi8vkhh3"},{"post_id":"ck4f00sjs001eth8l26otca7h","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00skp004hth8ledttfu0k"},{"post_id":"ck4f00sjt001hth8ltr8t6qoh","tag_id":"ck4f00skd002oth8liyb73yo6","_id":"ck4f00skp004ith8luio4tqnr"},{"post_id":"ck4f00sju001ith8lt1mohik4","tag_id":"ck4f00sjp001bth8l0bo4283b","_id":"ck4f00skp004jth8lxi6vt13s"}],"Tag":[{"name":"DevOps","_id":"ck4f00sja0012th8l52falbgh"},{"name":"错误日志","_id":"ck4f00sjn0017th8l5py4vast"},{"name":"php","_id":"ck4f00sjp001bth8l0bo4283b"},{"name":"技术","_id":"ck4f00sjt001gth8lh44kbdgz"},{"name":"技术 php","_id":"ck4f00sjv001kth8ljjwty2mc"},{"name":"工具","_id":"ck4f00sk40020th8lu5sszyn9"},{"name":"linux","_id":"ck4f00sk50022th8lo7bzao8d"},{"name":"编辑器","_id":"ck4f00sk50024th8lrnmfsdqk"},{"name":"个人感悟","_id":"ck4f00sk70028th8l7c9bcnj7"},{"name":"devops","_id":"ck4f00sk70029th8lflcwx5kf"},{"name":"php php扩展 c","_id":"ck4f00sk7002ath8ln8t68fkd"},{"name":"linux基础","_id":"ck4f00skd002oth8liyb73yo6"},{"name":"docker","_id":"ck4f00ske002pth8l8xmrznje"}]}}