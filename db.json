{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/avatar.jpg","path":"images/avatar.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/avatar.jpg","path":"assets/blogImg/avatar.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/images.jpg","path":"assets/blogImg/images.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/is_ref1.jpg","path":"assets/blogImg/is_ref1.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/is_ref2.jpg","path":"assets/blogImg/is_ref2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/onepiece.png","path":"assets/blogImg/onepiece.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/process.png","path":"assets/blogImg/process.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/process.pipe.png","path":"assets/blogImg/process.pipe.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/reactor.png","path":"assets/blogImg/reactor.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/thread.corrupt.png","path":"assets/blogImg/thread.corrupt.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/zend_manage.jpg","path":"assets/blogImg/zend_manage.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/女神.jpg","path":"assets/blogImg/女神.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/女神2.jpg","path":"assets/blogImg/女神2.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/终端截图.png","path":"assets/blogImg/终端截图.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/选择主题.png","path":"assets/blogImg/选择主题.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/coderwall.png","path":"img/coderwall.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/delicious.png","path":"img/delicious.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/douban.png","path":"img/douban.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/facebook.png","path":"img/facebook.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/github.png","path":"img/github.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/google.png","path":"img/google.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/img-err.png","path":"img/img-err.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/img-loading.png","path":"img/img-loading.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/linkedin.png","path":"img/linkedin.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/mail.png","path":"img/mail.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/pinboard.png","path":"img/pinboard.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/pinterest.png","path":"img/pinterest.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/rss.png","path":"img/rss.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","path":"img/scrollbar_arrow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/stackoverflow.png","path":"img/stackoverflow.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/twitter.png","path":"img/twitter.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/weibo.png","path":"img/weibo.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/img/zhihu.png","path":"img/zhihu.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/instagram.js","path":"js/instagram.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/jquery.lazyload.js","path":"js/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/mobile.js","path":"js/mobile.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/js/pc.js","path":"js/pc.js","modified":1,"renderable":1},{"_id":"source/assets/blogImg/1350027313170.jpg","path":"assets/blogImg/1350027313170.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/manyporcess.png","path":"assets/blogImg/manyporcess.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/p478446624 (1).jpg","path":"assets/blogImg/p478446624 (1).jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/php.png","path":"assets/blogImg/php.png","modified":1,"renderable":0},{"_id":"themes/yilia/source/assets/blogImg/litten.png","path":"assets/blogImg/litten.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","path":"css/fonts/fontawesome-webfont.svgz","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"source/assets/blogImg/Packagist.gif","path":"assets/blogImg/Packagist.gif","modified":1,"renderable":0},{"_id":"source/assets/blogImg/631283.jpg","path":"assets/blogImg/631283.jpg","modified":1,"renderable":0},{"_id":"source/assets/blogImg/Graychen-Container.gif","path":"assets/blogImg/Graychen-Container.gif","modified":1,"renderable":0},{"_id":"source/assets/blogImg/多窗终端.png","path":"assets/blogImg/多窗终端.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/桌面带终端效果图.png","path":"assets/blogImg/桌面带终端效果图.png","modified":1,"renderable":0},{"_id":"source/assets/blogImg/桌面效果图.png","path":"assets/blogImg/桌面效果图.png","modified":1,"renderable":0}],"Cache":[{"_id":"themes/yilia/test","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1512909506764},{"_id":"themes/yilia/README.md","hash":"dd311f8e8696bd89cf1790328d12b49d0e6b36da","modified":1512909506684},{"_id":"themes/yilia/_config.yml","hash":"814d20eb95ba70ef59498695c2ed2a4850048d6f","modified":1512911976825},{"_id":"themes/yilia/package.json","hash":"00357ef6f24eb049074da81809e98f973f528cca","modified":1512909506732},{"_id":"source/_posts/Webpack595错误.md","hash":"bb04a359e7fcf380a45a73723aac914c4dd97ac5","modified":1512909526140},{"_id":"source/_posts/composer包是怎样炼成的.md","hash":"a5c219635e316a9c8a77284ab2301b9116c97afc","modified":1512909526148},{"_id":"source/_posts/docker中使用supervisor.md","hash":"6c4a858c6006c3624e852b81951b2d92763a18a6","modified":1512909526148},{"_id":"source/_posts/github自动化测试.md","hash":"b4bd459a29c53e5b56a2dd1b8fd71691808e902d","modified":1518453572391},{"_id":"source/_posts/github自动化测试.md~","hash":"5dd3009d63f9197e4a87f6a20ecb619d7d123756","modified":1512909526180},{"_id":"source/_posts/git使用规范.md","hash":"313f465389fef4159718d82a8679de19c0f0ddc7","modified":1518360256550},{"_id":"source/_posts/gitlab-ci由浅入深.md","hash":"e263e6814c0a7031914a95924a5686c845d01842","modified":1518450865586},{"_id":"source/_posts/lnmp源码搭建.md","hash":"35ca9a8664378911a52eb35a18d71383a0dc22dd","modified":1512909526156},{"_id":"source/_posts/nginx配置优化.md","hash":"df9b44962951127232e3f5d25d467b569ab17aca","modified":1515945820850},{"_id":"source/_posts/php的并发io.md","hash":"4c378d1632c9ef700a78bc16c787beb04ba79280","modified":1515945779190},{"_id":"source/_posts/ubuntu下lnmp快速搭建.md","hash":"9cbef1b6c4a35c137ebdd44bb853b262be2f2f40","modified":1512909526164},{"_id":"source/_posts/vichrome像vi一样操作你的chrome浏览器.md","hash":"dafc407767b17d9389ffd8a35c0bcdd7d7ca3214","modified":1512909526164},{"_id":"source/_posts/vi的使用总结.md","hash":"5d15a3c9c535469c9b6d7844a3a52914ada6eb24","modified":1512909526164},{"_id":"source/_posts/websocket结合swoole进行wss访问.md","hash":"a628e59a948dc72e3fd8943a59ce1b34f890cf0e","modified":1514992810123},{"_id":"source/_posts/websocket结合swoole进行wss访问.md~","hash":"b7f9991df7f5ae02732e6cac8f437b7e389aa917","modified":1514992366344},{"_id":"source/_posts/yii2-queue队列的使用说明.md","hash":"2eb2f3df8b6d5e17b575b0097be2becdedb17490","modified":1512909526176},{"_id":"source/_posts/使用Prometheus-Grafana监控.md","hash":"41663d61bd039d625a0f44f57103091651b450ae","modified":1512909526108},{"_id":"source/_posts/使用Prometheus-Grafana监控.md~","hash":"ea9319ac5e034f40d7b1ebe0ddb80a84cfcd7457","modified":1512909526100},{"_id":"source/_posts/利用gitlab进行持续部署.md","hash":"d5ba74422934edeb040c18a00eda5579c74efb6a","modified":1518453758744},{"_id":"source/_posts/压力测试，压力山大.md","hash":"063b2d68945137c37f475490b027b2bef80c5993","modified":1512909526176},{"_id":"source/_posts/变身吧！我的linux配置环境.md","hash":"95bf3a0048d0624c2ac28dd94179e9cca7b6e80f","modified":1512909526176},{"_id":"source/_posts/如何编写测试.md","hash":"942f52e2cb16e1744eced69d65df3a129e796282","modified":1512909526180},{"_id":"source/_posts/如何编写测试.md~","hash":"8a4f42980196fcf3face3acc70a744d606060d0c","modified":1512909526180},{"_id":"source/_posts/探索php中的变量zval结构体.md","hash":"7cb2d15eb60e648beb03a9acad38fc64e3bdf344","modified":1512909526180},{"_id":"source/_posts/探索php中的变量zval结构体二.md","hash":"97298831fcdfa29137804f2e10d25b44e42d2e7f","modified":1512909526180},{"_id":"source/_posts/深入解析php的容器模式.md","hash":"8489ea19652ec00c9c60f1d88ba695257eda18e9","modified":1512909526180},{"_id":"source/_posts/解析php的内存管理.md","hash":"3b9196f6ad1dc8519e2227c1144b0826a4393342","modified":1512909526180},{"_id":"source/_posts/计划虽然不酷，但是很有用.md","hash":"22d6321f9b7158bc2c9144276590ac888f601d6f","modified":1512909526180},{"_id":"source/_posts/谈谈进程和线程.md","hash":"3bfb88c54e5bc536a12db6919e3a73428a21648c","modified":1518242025434},{"_id":"source/_posts/集中式日志管理elk搭建.md","hash":"9ff012646d43008f879078ca1881083ae6eeb83e","modified":1518255583180},{"_id":"source/_posts/集群的nginx配置.md","hash":"7423c715f21d18a8f3ae8390985a23441970d9c9","modified":1518257737607},{"_id":"source/images/avatar.jpg","hash":"f88f6b513f90be947234de853271119eda312d64","modified":1512909526348},{"_id":"themes/yilia/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1512909506732},{"_id":"themes/yilia/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1512909506732},{"_id":"themes/yilia/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1512909506732},{"_id":"themes/yilia/layout/layout.ejs","hash":"4a5566f704f3246f5ef77badddf18d2e16750328","modified":1512909506732},{"_id":"themes/yilia/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1512909506732},{"_id":"themes/yilia/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1512909506732},{"_id":"themes/yilia/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1512909506732},{"_id":"themes/yilia/languages/de.yml","hash":"ecb13af8af81ccc033ae7494cb2f94f84f6466ad","modified":1512909506712},{"_id":"themes/yilia/languages/default.yml","hash":"9e59cd11b290be84909612beb12d0f93ce737f53","modified":1512909506712},{"_id":"themes/yilia/languages/en.yml","hash":"8fa0a7482188ca56fd3cf19c4a87320f85a76846","modified":1512909506712},{"_id":"themes/yilia/languages/fr-FR.yml","hash":"12cfa96dc412ecb6f8bf4de2690575929464906e","modified":1512909506712},{"_id":"themes/yilia/languages/ru.yml","hash":"9997425292031ee8a58a93346ac6d3f38f18e566","modified":1512909506712},{"_id":"themes/yilia/languages/zh-Hans.yml","hash":"0d7e8da60fd5e5db217e1733ac273ae00fd752ea","modified":1512909506716},{"_id":"themes/yilia/languages/zh-hk.yml","hash":"606dfb34d3fec1d7895a654ff7a5a1de0c6a5c55","modified":1512909506716},{"_id":"themes/yilia/languages/zh-tw.yml","hash":"9e4034870b57d2bb3063c91f8d206a6c4d7b3789","modified":1512909506716},{"_id":"source/assets/blogImg/avatar.jpg","hash":"b899370064d7289319e837799a3df29e60d8b72c","modified":1512909526224},{"_id":"source/assets/blogImg/images.jpg","hash":"5ce42d8035ef434ab24089309e1a3233b639fb39","modified":1512909526224},{"_id":"source/assets/blogImg/is_ref1.jpg","hash":"39f05155141aad6b6e0e0a57e01a013b60275816","modified":1512909526224},{"_id":"source/assets/blogImg/is_ref2.jpg","hash":"4a63cde5a0d53f662b8975ac0802987c7c7747dc","modified":1512909526224},{"_id":"source/assets/blogImg/onepiece.png","hash":"ee8123247a0342cbe097dbad2eef320392bc97ca","modified":1512909526224},{"_id":"source/assets/blogImg/process.png","hash":"c83f60f8e9d0419c8fcb651c71916eec8b8d097a","modified":1512909526252},{"_id":"source/assets/blogImg/process.pipe.png","hash":"7705f38c0a5a22839de67b191f2f8f50397ba6d1","modified":1512909526252},{"_id":"source/assets/blogImg/reactor.png","hash":"04d20800c2ec2bc2c3966a3d3fa9abeef9583655","modified":1512909526264},{"_id":"source/assets/blogImg/thread.corrupt.png","hash":"98962544fee729ddfe671d051fb619ac26822d14","modified":1512909526264},{"_id":"source/assets/blogImg/zend_manage.jpg","hash":"3922f45adbe6aa941cdd6f9549714aeadcbba7ba","modified":1512909526264},{"_id":"source/assets/blogImg/女神.jpg","hash":"bdcdc004db6bbf439d3695c67c0b27ac6eac705c","modified":1512909526276},{"_id":"source/assets/blogImg/女神2.jpg","hash":"b3c333fca3dec309251423fa2a02180555791271","modified":1512909526276},{"_id":"source/assets/blogImg/终端截图.png","hash":"2dd559ffae900981a00a560119a1e9bb2c14dca8","modified":1512909526336},{"_id":"source/assets/blogImg/选择主题.png","hash":"b5d7347639b85bcb7e3063aca3289f49e8e2eaa6","modified":1512909526344},{"_id":"themes/yilia/layout/_partial/after-footer.ejs","hash":"a33f073cf85def0d0a26180167507eaf8e660767","modified":1512909506716},{"_id":"themes/yilia/layout/_partial/archive-post.ejs","hash":"8dfb6d68aa8a0661d26c32ce1ce1f45815364c3a","modified":1512909506720},{"_id":"themes/yilia/layout/_partial/archive.ejs","hash":"a6e94061ac55b9eb55275f87b608d62f6ea35659","modified":1512909506720},{"_id":"themes/yilia/layout/_partial/article.ejs","hash":"d6306cd897683c25184a50b29931aa1fa18d119c","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/footer.ejs","hash":"f2994e0acd1d606ebf4680afc4fa652e148ccf4e","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/head.ejs","hash":"4ddbfcced6533d1b2a695c65e19ed8791f4634da","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/header.ejs","hash":"6387a93dad7c3d778eb91e3821852fbf6813880c","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/left-col.ejs","hash":"b4bfac250b2791efc8a33c759ee3e13a8f00f98c","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/mathjax.ejs","hash":"54fab4d3d64cb937d6baec7324ffabf9f202b883","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/mobile-nav.ejs","hash":"e525570c39e9a1b46e58c33860dbb83d7e16c6ce","modified":1512909506728},{"_id":"themes/yilia/source/css/.DS_Store","hash":"fc5a428fe40854a0ba66b4cea196c6700a57cae7","modified":1512909506732},{"_id":"themes/yilia/source/css/_extend.styl","hash":"8ab1ad313bd6707d248c5ca1ee9a5eab8d815e42","modified":1512909506732},{"_id":"themes/yilia/source/css/_variables.styl","hash":"b1e1116c01604fa87ae264a39c488ba69ca178cd","modified":1512909506740},{"_id":"themes/yilia/source/css/style.styl","hash":"456e8cfe3b0b0371e81848ea9b0bc7ffd5360921","modified":1512909506752},{"_id":"themes/yilia/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1512909506752},{"_id":"themes/yilia/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1512909506752},{"_id":"themes/yilia/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1512909506752},{"_id":"themes/yilia/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.css","hash":"b6aa6692c2e5f8bd74d96827b78570f0c5683c20","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.js","hash":"a82597493d75ea989ca586e09173cff332efe41e","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1512909506756},{"_id":"themes/yilia/source/img/coderwall.png","hash":"fa84676c4d654e040e51fd34bfcd9f9348cd5331","modified":1512909506756},{"_id":"themes/yilia/source/img/delicious.png","hash":"9553a5f5189e4a953e04a58a49dbfa74b86b73dd","modified":1512909506760},{"_id":"themes/yilia/source/img/douban.png","hash":"e2ade003ffadd5826ee66ec23901c2d6e8607e4e","modified":1512909506760},{"_id":"themes/yilia/source/img/facebook.png","hash":"d19ad7a0903daf26817afd8753cd97e0cc714f54","modified":1512909506760},{"_id":"themes/yilia/source/img/github.png","hash":"b84d03b32fa388dcbf149296ebd16dce6223d48d","modified":1512909506760},{"_id":"themes/yilia/source/img/google.png","hash":"61a21fec7346fa3400b747ac9a201cf3d5bc013d","modified":1512909506760},{"_id":"themes/yilia/source/img/img-err.png","hash":"23a63ea26eb3c1d5e677d9883cf36cc1a1a1228b","modified":1512909506760},{"_id":"themes/yilia/source/img/img-loading.png","hash":"a9cd5cd11866824f31e3d1c5e23badfeb3f73031","modified":1512909506760},{"_id":"themes/yilia/source/img/linkedin.png","hash":"e203138fb53c257cb214e97f4e30091b9c568d2c","modified":1512909506760},{"_id":"themes/yilia/source/img/mail.png","hash":"fca8199cc77fdbd700a45bf56d091c82f4a67fe7","modified":1512909506760},{"_id":"themes/yilia/source/img/pinboard.png","hash":"0891fbb6d092fa012bf936019923383d84c6aeb0","modified":1512909506760},{"_id":"themes/yilia/source/img/pinterest.png","hash":"9c72917f8779c083157c6ce7a5d62ed4874f0630","modified":1512909506760},{"_id":"themes/yilia/source/img/rss.png","hash":"430fd47340e75214c081abd05cd7410cf7c71b86","modified":1512909506760},{"_id":"themes/yilia/source/img/scrollbar_arrow.png","hash":"d64a33c4ddfbdb89deeb6f4e3d36eb84dc4777c0","modified":1512909506760},{"_id":"themes/yilia/source/img/stackoverflow.png","hash":"da5dfe9043055c95e479d49c78cd3b020de608f2","modified":1512909506760},{"_id":"themes/yilia/source/img/twitter.png","hash":"14dbb8e62d056525253bc0de13acd1723da7a934","modified":1512909506760},{"_id":"themes/yilia/source/img/weibo.png","hash":"280dae3fd38086158b4a1b57edb94c06b1a5014b","modified":1512909506764},{"_id":"themes/yilia/source/img/zhihu.png","hash":"a6d6ef65e9ac82e613a311810391ebb90d9b1c1d","modified":1512909506764},{"_id":"themes/yilia/source/js/instagram.js","hash":"81e13cacf4947118ed1920e59b04ccf6beef6b86","modified":1512909506764},{"_id":"themes/yilia/source/js/jquery.lazyload.js","hash":"0654e5d7429bdd0665c94182ef17514c831586eb","modified":1512909506764},{"_id":"themes/yilia/source/js/main.js","hash":"9da8d0386bf0902582f9c5e4e2cfc8cbaa0d55e4","modified":1512909506764},{"_id":"themes/yilia/source/js/mobile.js","hash":"b68cc01d24e80973c48205f551da87f3f3427644","modified":1512909506764},{"_id":"themes/yilia/source/js/pc.js","hash":"a5397d34a04084ee089b4b1e26457ab46ecea63e","modified":1512909506764},{"_id":"source/assets/blogImg/1350027313170.jpg","hash":"837368703355d0cb5561c2cc25b0f8da0780a782","modified":1512909526192},{"_id":"source/assets/blogImg/manyporcess.png","hash":"2cb5c1cc4be9ec117a59c7bd23c956a416b2bb9d","modified":1512909526224},{"_id":"source/assets/blogImg/p478446624 (1).jpg","hash":"806f0fa94f9f3ddf0ef8ac0bf103e0ce8f6a2711","modified":1512909526236},{"_id":"source/assets/blogImg/php.png","hash":"a0d9d3836acd748a53ad3d718a104dc2b9cfb349","modified":1512909526236},{"_id":"themes/yilia/layout/_partial/post/category.ejs","hash":"d4f0e36f9a2167e91082dbd7d52425a06d2bebbf","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/post/date.ejs","hash":"c0c988334e857a77ba455a056dfa21809e7e76a5","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/post/duoshuo.ejs","hash":"e8399025ed3b980aedb821c92855889f5f12fd5b","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/post/nav.ejs","hash":"d19dee2082528e1844bed3aa4e4bd59f15fd7a7a","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/post/share_addthis.ejs","hash":"0ac35bd92e58983c189ac0c35df404ebc6ee826e","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/post/share_jia.ejs","hash":"924744aa3c1bce9056ba03cec02e19e095009126","modified":1512909506728},{"_id":"themes/yilia/layout/_partial/post/tag.ejs","hash":"78612cfc091d7d861a70455a0dc8c3036e460879","modified":1512909506732},{"_id":"themes/yilia/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1512909506732},{"_id":"themes/yilia/source/assets/blogImg/litten.png","hash":"f88f6b513f90be947234de853271119eda312d64","modified":1512909506732},{"_id":"themes/yilia/source/css/_partial/archive.styl","hash":"8b349f1605024dcdae054e04f02d71a2e84957c2","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/article.styl","hash":"872fc4e63509fef885c939e5fd70e6ed439beced","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/footer.styl","hash":"7ca837a4cc34db1c35f01baec85eb10ccc64ea86","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/header.styl","hash":"67e59feb18eee6026717cb440d86ab9551782628","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/highlight.styl","hash":"08d3205dde3235f3e6881126268e6c473f46a8ac","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/instagram.styl","hash":"8a7b07bf5ea2d3588c0019f722c245bb1a8696af","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/main.styl","hash":"712e809ddeaa8c6bf172286ccf81d005edbf1afd","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/mobile-slider.styl","hash":"e19c7fae6968ad3ea6cfc110900a991f9b5fce31","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/mobile.styl","hash":"3a03b04ef8ac305aa5dbf7b9db99cd9377d07383","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/page.styl","hash":"720b5b169bc28ccba3794efce9b7cd39f243dec7","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/scroll.styl","hash":"5539a38f9acd603d453a0ea0d8ce10893cf83d22","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/share.styl","hash":"22697b9a9877ab9f018364feb57aeea4a8313c9a","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/tagcloud.styl","hash":"af0115de5c6455f899a2e09225b50224982c039d","modified":1512909506736},{"_id":"themes/yilia/source/css/_partial/wheelmenu.styl","hash":"74630c56944e27bef53ef0c0e391611a2eec2ed0","modified":1512909506736},{"_id":"themes/yilia/source/css/_util/grid.styl","hash":"1aa883ab432d9e4139c89dcbd40ae2bd1528d029","modified":1512909506740},{"_id":"themes/yilia/source/css/_util/mixin.styl","hash":"429bad87fc156eacf226c5e35b0eafc277f2504b","modified":1512909506740},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.eot","hash":"3ce87b82c7a4ffdf65e96765c2ffda10b1a283c6","modified":1512909506740},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svgz","hash":"4bfdd33ed702e32ae01399fcc2652377f78e7626","modified":1512909506752},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.ttf","hash":"1480b8101b02da9bc4c60341b5e185e63e585064","modified":1512909506752},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.woff","hash":"cafc4ac5761a0a252d33dce4ea3952cf9a38d832","modified":1512909506752},{"_id":"themes/yilia/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1512909506756},{"_id":"themes/yilia/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1512909506756},{"_id":"themes/yilia/source/css/fonts/fontawesome-webfont.svg","hash":"ba13657479b46daecb6336bfe376f84cef3ae58b","modified":1512909506752},{"_id":"source/assets/blogImg/Packagist.gif","hash":"b0744949057774ef4364b195a11b2958003070d7","modified":1512909526224},{"_id":"source/assets/blogImg/631283.jpg","hash":"d3439ed0c38b481b6f0caeab3c672c6e1662a66c","modified":1512909526208},{"_id":"source/assets/blogImg/Graychen-Container.gif","hash":"38bd85eaaa94bafc1857313a5df2c0bb17683b3b","modified":1512909526216},{"_id":"source/assets/blogImg/多窗终端.png","hash":"f9b4e6565694fe37667fb36297a6e72b51661236","modified":1512909526276},{"_id":"source/assets/blogImg/桌面带终端效果图.png","hash":"12e66fac2eb3b201e740f7329996ef51733dd648","modified":1512909526304},{"_id":"source/assets/blogImg/桌面效果图.png","hash":"e510b8bffd661e1e5ddd64809513f823ccd09782","modified":1512909526332}],"Category":[{"name":"错误日志","_id":"cjdkg6q0h0002to7y463n4y0p"},{"name":"技术","_id":"cjdkg6q100007to7ycetl75yh"},{"name":"随笔","_id":"cjdkg6q3s001zto7yewtd16q8"}],"Data":[],"Page":[],"Post":[{"title":"Webpack595错误","date":"2017-05-13T15:39:40.000Z","_content":"## 错误情况\nMix incompatible with Webpack 2.3.0? #595\n## 错误原因\n这是laravel5.4的错误webpack依赖包兼容问题\n## 解决方法\n在package,json 修改\"aravel-mix\": \"^0.10.0\" 修复这个错误\n<!--more-->\n\n","source":"_posts/Webpack595错误.md","raw":"---\ntitle: Webpack595错误\ndate: 2017-05-13 23:39:40\ncategory: 错误日志\ntag: 错误日志\n\n---\n## 错误情况\nMix incompatible with Webpack 2.3.0? #595\n## 错误原因\n这是laravel5.4的错误webpack依赖包兼容问题\n## 解决方法\n在package,json 修改\"aravel-mix\": \"^0.10.0\" 修复这个错误\n<!--more-->\n\n","slug":"Webpack595错误","published":1,"updated":"2017-12-10T12:38:46.140Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6pzt0000to7yt33k4pji","content":"<h2 id=\"错误情况\"><a href=\"#错误情况\" class=\"headerlink\" title=\"错误情况\"></a>错误情况</h2><p>Mix incompatible with Webpack 2.3.0? #595</p>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h2><p>这是laravel5.4的错误webpack依赖包兼容问题</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在package,json 修改”aravel-mix”: “^0.10.0” 修复这个错误<br><a id=\"more\"></a></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"错误情况\"><a href=\"#错误情况\" class=\"headerlink\" title=\"错误情况\"></a>错误情况</h2><p>Mix incompatible with Webpack 2.3.0? #595</p>\n<h2 id=\"错误原因\"><a href=\"#错误原因\" class=\"headerlink\" title=\"错误原因\"></a>错误原因</h2><p>这是laravel5.4的错误webpack依赖包兼容问题</p>\n<h2 id=\"解决方法\"><a href=\"#解决方法\" class=\"headerlink\" title=\"解决方法\"></a>解决方法</h2><p>在package,json 修改”aravel-mix”: “^0.10.0” 修复这个错误<br>","more":"</p>"},{"title":"Composer包是怎样炼成的","date":"2016-10-19T03:20:43.000Z","_content":"\n>**Composer**是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 --[Composer中文网](http://www.phpcomposer.com/)\n\n关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到[packgist](https://packagist.org/)\n\n## 创建组件\n### 产商名称和包名\n在设置命名空间之前，先要确定产商名称和包名，类似于**laravel/framework**,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。\n### 文件系统结构\n- **src**:这个目录用于存放组件的源码   \n- **tests**:这个目录用于存放测试代码   \n- **composer.json**:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   \n- **README.md**:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   \n- **CONTRIBUTING.md**:这个Markdown文件告知别人如何为这个组件做贡献  \n- **LICENSE**：纯文本文件，声明组件的软件许可证\n- **CHANGELOG.md**：Markdown文件，列出组件在每个版本中引入的改动\n\n### 文件系统结构\n我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：\ncomposer init\n\n<!--more-->\n然后在终端会让我们按照提示向导一步步填写composer.json内容：\n最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：\n``` javascript\n{\n    \"name\": \"graychen/container\",\n    \"description\": \"a container for interface and container\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Graychen\",\n            \"email\": \"13780185250@sina.cn\"\n        }\n    ],\n    \"minimum-stability\": \"dev\",\n    \"require\": {},\n    \"require-dev\": {\n            \"phpunit/phpunit\" : \"~4.3\" \n        },\n    \"autoload\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\\" : \"src\"\n        }\n    },\n    \"autoload-dev\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\Tests\\\\\":\"tests/\"\n        }\n    }\n}\n\n```\n我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：\n\n- name：组件的厂商名和包名，也是Packagist中的组件名\n- description：简要说明组件\n- keywords：描述属性的关键字\n- homepage：组件网站URL\n- license：PHP组件采用的软件许可证（更多软件许可证参考：http://choosealicense.com/）\n- authors：作者信息数组\n- support：组件用户获取技术支持的方式\n- require：组件自身依赖的组件\n- require-dev：开发这个组件所需的依赖\n- suggest：建议安装的组件\n- autoload：告诉Composer自动加载器如何自动加载这个组件\n\nREADEME.md\n\n通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：\n- 组件的名称和描述\n- 安装说明\n- 使用说明\n- 测试说明\n- 贡献方式\n- 支持资源\n- 作者信息\n- 软件许可证\n\n实现组件\n\n开始之前我们使用如下命令安装依赖：\n``` php\ncomposer install\n```\n该命令会把依赖组件安装到vendor目录并生成自动加载器。\n安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。\n``` php\n<?php\nnamespace container;\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n    private $_bindings = [];//服务列表\n    private $_instances= [];//已经实例化的服务\n    //获取服务\n    public function get($name,$params=[]){\n        //先从实例化的列表中查找\n        if(isset($this->$_instances[$name])){\n            return $this->$_instances[$name]; \n        }\n        //检测有没有注册该服务\n        if(!isset($this->$_bindings[$name])){\n            return null;\n        }\n        $concrete = $this->$_bindings[$name]['class'];//对象具体注册内容\n        $obj = null;\n        if($concrete instanceof \\Closure){ //匿名函数方式\n            $obj = call_user_func_array($concrete,$params);\n        }elseif(is_string($concrete)){     //字符串方式\n            if(empty($params)){\n                $obj = new $concrete;\n            }else{\n                //带参数的类实例化,使用反射\n                $class = new \\reflectionClass($concrete);\n                $obj = $class->newInstanceArgs($params);\n            }\n        }\n        //如果是共享服务，则写入_instances列表，下次直接取回\n        if($this->_bindings[$name]['shared']==true && $ojb){\n            $this->_instances[$name]=$obj;\n        }\n        return $obj;\n    } \n    //检测是否已经绑定\n    public function has($name){\n        return isset($this->_bindings[$name]) or isset($this->_instances[$name]);\n    }\n    //卸载服务\n    public function remove($name){\n        unset($this->_bindings[$name],$this->_instances[$name]);\n    }\n    //设置服务\n    public function set($name,$class){\n        $this->_registerService($name,$class);\n    }\n    //设置共享服务\n    public function setShared($name,$class){\n        $this->_registerService($name,$class,true);\n    }\n    //注册服务\n    private function _registerService($name,$class,$shared=false){\n        $this->remove($name);\n        if(!($class instanceof \\Closure) && is_object($class)){\n            $this->_instances[$name]=$class;\n        }else{\n            $this->_bindings[$name]=array(\"class\"=>$class,\"shared\"=>$shared); \n        }\n    }\n    //ArrayAccess接口，检测服务是否存在\n    public function offsetExists($offset){\n        return $this->has($offset);\n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetGet($offset){\n       return $this->get($offset); \n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetSet($offset,$value){\n        return $this->set($offset,$value);\n    }\n    //卸载服务\n    public function offsetUnset($offset){\n        return $this->remove($offset);\n    }\n} \n```\n### 提交到packglist\n我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：\n``` git\ngit init\ngit remote add origin https://github.com/nonfu/urlscanner.git\ngit add .\ngit commit -m “urlscanner\"\ngit pull origin master\ngit push origin master\n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/Graychen-Container.gif)\n 然后在Packagist中通过GitHub账户登录，通过https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\n check成功后点击submit即可将组件提交到Packagist：\n ![\"我是傲娇的效果图\"](/assets/blogImg/Packagist.gif)\n## 使用组件\n 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：\n\n composer require graychen/container dev-master\n","source":"_posts/composer包是怎样炼成的.md","raw":"---\ntitle: Composer包是怎样炼成的\ndate: 2016-10-19 11:20:43\ntag: php\ncategories: 技术\n\n---\n\n>**Composer**是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 --[Composer中文网](http://www.phpcomposer.com/)\n\n关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到[packgist](https://packagist.org/)\n\n## 创建组件\n### 产商名称和包名\n在设置命名空间之前，先要确定产商名称和包名，类似于**laravel/framework**,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。\n### 文件系统结构\n- **src**:这个目录用于存放组件的源码   \n- **tests**:这个目录用于存放测试代码   \n- **composer.json**:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   \n- **README.md**:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   \n- **CONTRIBUTING.md**:这个Markdown文件告知别人如何为这个组件做贡献  \n- **LICENSE**：纯文本文件，声明组件的软件许可证\n- **CHANGELOG.md**：Markdown文件，列出组件在每个版本中引入的改动\n\n### 文件系统结构\n我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：\ncomposer init\n\n<!--more-->\n然后在终端会让我们按照提示向导一步步填写composer.json内容：\n最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：\n``` javascript\n{\n    \"name\": \"graychen/container\",\n    \"description\": \"a container for interface and container\",\n    \"license\": \"MIT\",\n    \"authors\": [\n        {\n            \"name\": \"Graychen\",\n            \"email\": \"13780185250@sina.cn\"\n        }\n    ],\n    \"minimum-stability\": \"dev\",\n    \"require\": {},\n    \"require-dev\": {\n            \"phpunit/phpunit\" : \"~4.3\" \n        },\n    \"autoload\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\\" : \"src\"\n        }\n    },\n    \"autoload-dev\":{\n        \"psr-4\":{\n            \"graychen\\\\container\\\\Tests\\\\\":\"tests/\"\n        }\n    }\n}\n\n```\n我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：\n\n- name：组件的厂商名和包名，也是Packagist中的组件名\n- description：简要说明组件\n- keywords：描述属性的关键字\n- homepage：组件网站URL\n- license：PHP组件采用的软件许可证（更多软件许可证参考：http://choosealicense.com/）\n- authors：作者信息数组\n- support：组件用户获取技术支持的方式\n- require：组件自身依赖的组件\n- require-dev：开发这个组件所需的依赖\n- suggest：建议安装的组件\n- autoload：告诉Composer自动加载器如何自动加载这个组件\n\nREADEME.md\n\n通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：\n- 组件的名称和描述\n- 安装说明\n- 使用说明\n- 测试说明\n- 贡献方式\n- 支持资源\n- 作者信息\n- 软件许可证\n\n实现组件\n\n开始之前我们使用如下命令安装依赖：\n``` php\ncomposer install\n```\n该命令会把依赖组件安装到vendor目录并生成自动加载器。\n安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。\n``` php\n<?php\nnamespace container;\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n    private $_bindings = [];//服务列表\n    private $_instances= [];//已经实例化的服务\n    //获取服务\n    public function get($name,$params=[]){\n        //先从实例化的列表中查找\n        if(isset($this->$_instances[$name])){\n            return $this->$_instances[$name]; \n        }\n        //检测有没有注册该服务\n        if(!isset($this->$_bindings[$name])){\n            return null;\n        }\n        $concrete = $this->$_bindings[$name]['class'];//对象具体注册内容\n        $obj = null;\n        if($concrete instanceof \\Closure){ //匿名函数方式\n            $obj = call_user_func_array($concrete,$params);\n        }elseif(is_string($concrete)){     //字符串方式\n            if(empty($params)){\n                $obj = new $concrete;\n            }else{\n                //带参数的类实例化,使用反射\n                $class = new \\reflectionClass($concrete);\n                $obj = $class->newInstanceArgs($params);\n            }\n        }\n        //如果是共享服务，则写入_instances列表，下次直接取回\n        if($this->_bindings[$name]['shared']==true && $ojb){\n            $this->_instances[$name]=$obj;\n        }\n        return $obj;\n    } \n    //检测是否已经绑定\n    public function has($name){\n        return isset($this->_bindings[$name]) or isset($this->_instances[$name]);\n    }\n    //卸载服务\n    public function remove($name){\n        unset($this->_bindings[$name],$this->_instances[$name]);\n    }\n    //设置服务\n    public function set($name,$class){\n        $this->_registerService($name,$class);\n    }\n    //设置共享服务\n    public function setShared($name,$class){\n        $this->_registerService($name,$class,true);\n    }\n    //注册服务\n    private function _registerService($name,$class,$shared=false){\n        $this->remove($name);\n        if(!($class instanceof \\Closure) && is_object($class)){\n            $this->_instances[$name]=$class;\n        }else{\n            $this->_bindings[$name]=array(\"class\"=>$class,\"shared\"=>$shared); \n        }\n    }\n    //ArrayAccess接口，检测服务是否存在\n    public function offsetExists($offset){\n        return $this->has($offset);\n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetGet($offset){\n       return $this->get($offset); \n    }\n    //ArrayAccess接口,以$di[$name]方式获取服务\n    public function offsetSet($offset,$value){\n        return $this->set($offset,$value);\n    }\n    //卸载服务\n    public function offsetUnset($offset){\n        return $this->remove($offset);\n    }\n} \n```\n### 提交到packglist\n我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：\n``` git\ngit init\ngit remote add origin https://github.com/nonfu/urlscanner.git\ngit add .\ngit commit -m “urlscanner\"\ngit pull origin master\ngit push origin master\n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/Graychen-Container.gif)\n 然后在Packagist中通过GitHub账户登录，通过https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\n check成功后点击submit即可将组件提交到Packagist：\n ![\"我是傲娇的效果图\"](/assets/blogImg/Packagist.gif)\n## 使用组件\n 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：\n\n composer require graychen/container dev-master\n","slug":"composer包是怎样炼成的","published":1,"updated":"2017-12-10T12:38:46.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q060001to7yshqg0xs8","content":"<blockquote>\n<p><strong>Composer</strong>是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 –<a href=\"http://www.phpcomposer.com/\" target=\"_blank\" rel=\"noopener\">Composer中文网</a></p>\n</blockquote>\n<p>关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到<a href=\"https://packagist.org/\" target=\"_blank\" rel=\"noopener\">packgist</a></p>\n<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><h3 id=\"产商名称和包名\"><a href=\"#产商名称和包名\" class=\"headerlink\" title=\"产商名称和包名\"></a>产商名称和包名</h3><p>在设置命名空间之前，先要确定产商名称和包名，类似于<strong>laravel/framework</strong>,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。</p>\n<h3 id=\"文件系统结构\"><a href=\"#文件系统结构\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><ul>\n<li><strong>src</strong>:这个目录用于存放组件的源码   </li>\n<li><strong>tests</strong>:这个目录用于存放测试代码   </li>\n<li><strong>composer.json</strong>:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   </li>\n<li><strong>README.md</strong>:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   </li>\n<li><strong>CONTRIBUTING.md</strong>:这个Markdown文件告知别人如何为这个组件做贡献  </li>\n<li><strong>LICENSE</strong>：纯文本文件，声明组件的软件许可证</li>\n<li><strong>CHANGELOG.md</strong>：Markdown文件，列出组件在每个版本中引入的改动</li>\n</ul>\n<h3 id=\"文件系统结构-1\"><a href=\"#文件系统结构-1\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><p>我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：<br>composer init</p>\n<a id=\"more\"></a>\n<p>然后在终端会让我们按照提示向导一步步填写composer.json内容：<br>最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"graychen/container\"</span>,</div><div class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"a container for interface and container\"</span>,</div><div class=\"line\">    <span class=\"string\">\"license\"</span>: <span class=\"string\">\"MIT\"</span>,</div><div class=\"line\">    <span class=\"string\">\"authors\"</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Graychen\"</span>,</div><div class=\"line\">            <span class=\"string\">\"email\"</span>: <span class=\"string\">\"13780185250@sina.cn\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"string\">\"minimum-stability\"</span>: <span class=\"string\">\"dev\"</span>,</div><div class=\"line\">    <span class=\"string\">\"require\"</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"string\">\"require-dev\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"phpunit/phpunit\"</span> : <span class=\"string\">\"~4.3\"</span> </div><div class=\"line\">        &#125;,</div><div class=\"line\">    <span class=\"string\">\"autoload\"</span>:&#123;</div><div class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</div><div class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\\"</span> : <span class=\"string\">\"src\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"autoload-dev\"</span>:&#123;</div><div class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</div><div class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\Tests\\\\\"</span>:<span class=\"string\">\"tests/\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：</p>\n<ul>\n<li>name：组件的厂商名和包名，也是Packagist中的组件名</li>\n<li>description：简要说明组件</li>\n<li>keywords：描述属性的关键字</li>\n<li>homepage：组件网站URL</li>\n<li>license：PHP组件采用的软件许可证（更多软件许可证参考：<a href=\"http://choosealicense.com/）\" target=\"_blank\" rel=\"noopener\">http://choosealicense.com/）</a></li>\n<li>authors：作者信息数组</li>\n<li>support：组件用户获取技术支持的方式</li>\n<li>require：组件自身依赖的组件</li>\n<li>require-dev：开发这个组件所需的依赖</li>\n<li>suggest：建议安装的组件</li>\n<li>autoload：告诉Composer自动加载器如何自动加载这个组件</li>\n</ul>\n<p>READEME.md</p>\n<p>通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：</p>\n<ul>\n<li>组件的名称和描述</li>\n<li>安装说明</li>\n<li>使用说明</li>\n<li>测试说明</li>\n<li>贡献方式</li>\n<li>支持资源</li>\n<li>作者信息</li>\n<li>软件许可证</li>\n</ul>\n<p>实现组件</p>\n<p>开始之前我们使用如下命令安装依赖：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer install</div></pre></td></tr></table></figure></p>\n<p>该命令会把依赖组件安装到vendor目录并生成自动加载器。<br>安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">container</span>;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> 服务容器</div><div class=\"line\">* author Graychen</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> $_bindings = [];<span class=\"comment\">//服务列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></div><div class=\"line\">    <span class=\"comment\">//获取服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</div><div class=\"line\">        <span class=\"comment\">//先从实例化的列表中查找</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_instances[$name]))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;$_instances[$name]; </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//检测有没有注册该服务</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_bindings[$name]))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        $concrete = <span class=\"keyword\">$this</span>-&gt;$_bindings[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></div><div class=\"line\">        $obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">            $obj = call_user_func_array($concrete,$params);</div><div class=\"line\">        &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123;     <span class=\"comment\">//字符串方式</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">                $obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                <span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">                $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">                $obj = $class-&gt;newInstanceArgs($params);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</div><div class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> $obj;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">//检测是否已经绑定</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//卸载服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//设置服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//设置共享服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//注册服务</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;remove($name);</div><div class=\"line\">        <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</div><div class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_bindings[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared); </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset); </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//卸载服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"提交到packglist\"><a href=\"#提交到packglist\" class=\"headerlink\" title=\"提交到packglist\"></a>提交到packglist</h3><p>我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">git init</div><div class=\"line\">git remote add origin https://github.com/nonfu/urlscanner.git</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m “urlscanner&quot;</div><div class=\"line\">git pull origin master</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/Graychen-Container.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 然后在Packagist中通过GitHub账户登录，通过<a href=\"https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\" target=\"_blank\" rel=\"noopener\">https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：</a><br> check成功后点击submit即可将组件提交到Packagist：<br> <img src=\"/assets/blogImg/Packagist.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"使用组件\"><a href=\"#使用组件\" class=\"headerlink\" title=\"使用组件\"></a>使用组件</h2><p> 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：</p>\n<p> composer require graychen/container dev-master</p>\n","site":{"data":{}},"excerpt":"<blockquote>\n<p><strong>Composer</strong>是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 –<a href=\"http://www.phpcomposer.com/\" target=\"_blank\" rel=\"noopener\">Composer中文网</a></p>\n</blockquote>\n<p>关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到<a href=\"https://packagist.org/\" target=\"_blank\" rel=\"noopener\">packgist</a></p>\n<h2 id=\"创建组件\"><a href=\"#创建组件\" class=\"headerlink\" title=\"创建组件\"></a>创建组件</h2><h3 id=\"产商名称和包名\"><a href=\"#产商名称和包名\" class=\"headerlink\" title=\"产商名称和包名\"></a>产商名称和包名</h3><p>在设置命名空间之前，先要确定产商名称和包名，类似于<strong>laravel/framework</strong>,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。</p>\n<h3 id=\"文件系统结构\"><a href=\"#文件系统结构\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><ul>\n<li><strong>src</strong>:这个目录用于存放组件的源码   </li>\n<li><strong>tests</strong>:这个目录用于存放测试代码   </li>\n<li><strong>composer.json</strong>:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   </li>\n<li><strong>README.md</strong>:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   </li>\n<li><strong>CONTRIBUTING.md</strong>:这个Markdown文件告知别人如何为这个组件做贡献  </li>\n<li><strong>LICENSE</strong>：纯文本文件，声明组件的软件许可证</li>\n<li><strong>CHANGELOG.md</strong>：Markdown文件，列出组件在每个版本中引入的改动</li>\n</ul>\n<h3 id=\"文件系统结构-1\"><a href=\"#文件系统结构-1\" class=\"headerlink\" title=\"文件系统结构\"></a>文件系统结构</h3><p>我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：<br>composer init</p>","more":"<p>然后在终端会让我们按照提示向导一步步填写composer.json内容：<br>最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：<br><figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"string\">\"name\"</span>: <span class=\"string\">\"graychen/container\"</span>,</div><div class=\"line\">    <span class=\"string\">\"description\"</span>: <span class=\"string\">\"a container for interface and container\"</span>,</div><div class=\"line\">    <span class=\"string\">\"license\"</span>: <span class=\"string\">\"MIT\"</span>,</div><div class=\"line\">    <span class=\"string\">\"authors\"</span>: [</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"string\">\"name\"</span>: <span class=\"string\">\"Graychen\"</span>,</div><div class=\"line\">            <span class=\"string\">\"email\"</span>: <span class=\"string\">\"13780185250@sina.cn\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    ],</div><div class=\"line\">    <span class=\"string\">\"minimum-stability\"</span>: <span class=\"string\">\"dev\"</span>,</div><div class=\"line\">    <span class=\"string\">\"require\"</span>: &#123;&#125;,</div><div class=\"line\">    <span class=\"string\">\"require-dev\"</span>: &#123;</div><div class=\"line\">            <span class=\"string\">\"phpunit/phpunit\"</span> : <span class=\"string\">\"~4.3\"</span> </div><div class=\"line\">        &#125;,</div><div class=\"line\">    <span class=\"string\">\"autoload\"</span>:&#123;</div><div class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</div><div class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\\"</span> : <span class=\"string\">\"src\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;,</div><div class=\"line\">    <span class=\"string\">\"autoload-dev\"</span>:&#123;</div><div class=\"line\">        <span class=\"string\">\"psr-4\"</span>:&#123;</div><div class=\"line\">            <span class=\"string\">\"graychen\\\\container\\\\Tests\\\\\"</span>:<span class=\"string\">\"tests/\"</span></div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：</p>\n<ul>\n<li>name：组件的厂商名和包名，也是Packagist中的组件名</li>\n<li>description：简要说明组件</li>\n<li>keywords：描述属性的关键字</li>\n<li>homepage：组件网站URL</li>\n<li>license：PHP组件采用的软件许可证（更多软件许可证参考：<a href=\"http://choosealicense.com/）\" target=\"_blank\" rel=\"noopener\">http://choosealicense.com/）</a></li>\n<li>authors：作者信息数组</li>\n<li>support：组件用户获取技术支持的方式</li>\n<li>require：组件自身依赖的组件</li>\n<li>require-dev：开发这个组件所需的依赖</li>\n<li>suggest：建议安装的组件</li>\n<li>autoload：告诉Composer自动加载器如何自动加载这个组件</li>\n</ul>\n<p>READEME.md</p>\n<p>通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：</p>\n<ul>\n<li>组件的名称和描述</li>\n<li>安装说明</li>\n<li>使用说明</li>\n<li>测试说明</li>\n<li>贡献方式</li>\n<li>支持资源</li>\n<li>作者信息</li>\n<li>软件许可证</li>\n</ul>\n<p>实现组件</p>\n<p>开始之前我们使用如下命令安装依赖：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer install</div></pre></td></tr></table></figure></p>\n<p>该命令会把依赖组件安装到vendor目录并生成自动加载器。<br>安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">container</span>;</div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> 服务容器</div><div class=\"line\">* author Graychen</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> $_bindings = [];<span class=\"comment\">//服务列表</span></div><div class=\"line\">    <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></div><div class=\"line\">    <span class=\"comment\">//获取服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</div><div class=\"line\">        <span class=\"comment\">//先从实例化的列表中查找</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_instances[$name]))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;$_instances[$name]; </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//检测有没有注册该服务</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;$_bindings[$name]))&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">        $concrete = <span class=\"keyword\">$this</span>-&gt;$_bindings[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></div><div class=\"line\">        $obj = <span class=\"keyword\">null</span>;</div><div class=\"line\">        <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">            $obj = call_user_func_array($concrete,$params);</div><div class=\"line\">        &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123;     <span class=\"comment\">//字符串方式</span></div><div class=\"line\">            <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">                $obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">            &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">                <span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">                $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">                $obj = $class-&gt;newInstanceArgs($params);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class=\"line\">        <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</div><div class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">return</span> $obj;</div><div class=\"line\">    &#125; </div><div class=\"line\">    <span class=\"comment\">//检测是否已经绑定</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//卸载服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_bindings[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//设置服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//设置共享服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//注册服务</span></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;remove($name);</div><div class=\"line\">        <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</div><div class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</div><div class=\"line\">        &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">            <span class=\"keyword\">$this</span>-&gt;_bindings[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared); </div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset); </div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//ArrayAccess接口,以$di[$name]方式获取服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"comment\">//卸载服务</span></div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"提交到packglist\"><a href=\"#提交到packglist\" class=\"headerlink\" title=\"提交到packglist\"></a>提交到packglist</h3><p>我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">git init</div><div class=\"line\">git remote add origin https://github.com/nonfu/urlscanner.git</div><div class=\"line\">git add .</div><div class=\"line\">git commit -m “urlscanner&quot;</div><div class=\"line\">git pull origin master</div><div class=\"line\">git push origin master</div></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/Graychen-Container.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 然后在Packagist中通过GitHub账户登录，通过<a href=\"https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：\" target=\"_blank\" rel=\"noopener\">https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：</a><br> check成功后点击submit即可将组件提交到Packagist：<br> <img src=\"/assets/blogImg/Packagist.gif\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"使用组件\"><a href=\"#使用组件\" class=\"headerlink\" title=\"使用组件\"></a>使用组件</h2><p> 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：</p>\n<p> composer require graychen/container dev-master</p>"},{"title":"docker中使用supervisor管理队列","date":"2017-07-25T15:04:46.000Z","_content":"\n## 简介\nSupervisor[链接](http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。\n## 安装\nSupervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor\n 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加\n``` bash\nRUN apk add supervisor\n```\n这样容器就可以安装superviosr\n## 配置\n然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件\n<!--more-->\n#\n``` \n[supervisord]\nnodaemon=true\n[program:mqtt-server]\ndirectory = /var/www/html ;\ncommand = php yii queue/listen\nautostart = true\nstartsecs = 5\nautorestart = true\nstartretries = 10\nredirect_stderr=true\nstdout_logfile = /var/www/html/yii-queue-worker.log\n```\n然后在Dockerfile-web-volumes里面添加\n\n<!--more-->\n```\n- ./services/supervisor:/etc/supervisor/conf.d\n```\n\n以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件\n## 运行\n> 本来我的想法是在Dockerfile里面直接添加`ENTRYPOINT ['/usr/bin/supervisord','-c','/etc/supervisor/conf.d']`,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。`注意，如果队列基于其它driver的可以这样直接运行的`\n\n折中的方案是在.gitlab-ci.yml文件中的**testing-server:**-> **script:**和**staging-server:**->**script:**下分别添加\n```\n- ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &>/dev/null&\"\n```\n\n这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了\n然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/docker中使用supervisor.md","raw":"---\ntitle: docker中使用supervisor管理队列\ndate: 2017-07-25 23:04:46\ntag: php\ncategories: 技术\n\n---\n\n## 简介\nSupervisor[链接](http://supervisord.org) 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。\n## 安装\nSupervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor\n 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加\n``` bash\nRUN apk add supervisor\n```\n这样容器就可以安装superviosr\n## 配置\n然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件\n<!--more-->\n#\n``` \n[supervisord]\nnodaemon=true\n[program:mqtt-server]\ndirectory = /var/www/html ;\ncommand = php yii queue/listen\nautostart = true\nstartsecs = 5\nautorestart = true\nstartretries = 10\nredirect_stderr=true\nstdout_logfile = /var/www/html/yii-queue-worker.log\n```\n然后在Dockerfile-web-volumes里面添加\n\n<!--more-->\n```\n- ./services/supervisor:/etc/supervisor/conf.d\n```\n\n以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件\n## 运行\n> 本来我的想法是在Dockerfile里面直接添加`ENTRYPOINT ['/usr/bin/supervisord','-c','/etc/supervisor/conf.d']`,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。`注意，如果队列基于其它driver的可以这样直接运行的`\n\n折中的方案是在.gitlab-ci.yml文件中的**testing-server:**-> **script:**和**staging-server:**->**script:**下分别添加\n```\n- ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &>/dev/null&\"\n```\n\n这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了\n然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"docker中使用supervisor","published":1,"updated":"2017-12-10T12:38:46.148Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q0n0004to7yl2c0wbj4","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Supervisor<a href=\"http://supervisord.org\" target=\"_blank\" rel=\"noopener\">链接</a> 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor<br> 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RUN apk add supervisor</div></pre></td></tr></table></figure></p>\n<p>这样容器就可以安装superviosr</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件<br><a id=\"more\"></a><br>#<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[supervisord]</div><div class=\"line\">nodaemon=true</div><div class=\"line\">[program:mqtt-server]</div><div class=\"line\">directory = /var/www/html ;</div><div class=\"line\">command = php yii queue/listen</div><div class=\"line\">autostart = true</div><div class=\"line\">startsecs = 5</div><div class=\"line\">autorestart = true</div><div class=\"line\">startretries = 10</div><div class=\"line\">redirect_stderr=true</div><div class=\"line\">stdout_logfile = /var/www/html/yii-queue-worker.log</div></pre></td></tr></table></figure></p>\n<p>然后在Dockerfile-web-volumes里面添加</p>\n<!--more-->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- ./services/supervisor:/etc/supervisor/conf.d</div></pre></td></tr></table></figure>\n<p>以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><blockquote>\n<p>本来我的想法是在Dockerfile里面直接添加<code>ENTRYPOINT [&#39;/usr/bin/supervisord&#39;,&#39;-c&#39;,&#39;/etc/supervisor/conf.d&#39;]</code>,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。<code>注意，如果队列基于其它driver的可以这样直接运行的</code></p>\n</blockquote>\n<p>折中的方案是在.gitlab-ci.yml文件中的<strong>testing-server:</strong>-&gt; <strong>script:</strong>和<strong>staging-server:</strong>-&gt;<strong>script:</strong>下分别添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &amp;&gt;/dev/null&amp;&quot;</div></pre></td></tr></table></figure></p>\n<p>这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了<br>然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Supervisor<a href=\"http://supervisord.org\" target=\"_blank\" rel=\"noopener\">链接</a> 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor<br> 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">RUN apk add supervisor</div></pre></td></tr></table></figure></p>\n<p>这样容器就可以安装superviosr</p>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件<br>","more":"<br>#<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">[supervisord]</div><div class=\"line\">nodaemon=true</div><div class=\"line\">[program:mqtt-server]</div><div class=\"line\">directory = /var/www/html ;</div><div class=\"line\">command = php yii queue/listen</div><div class=\"line\">autostart = true</div><div class=\"line\">startsecs = 5</div><div class=\"line\">autorestart = true</div><div class=\"line\">startretries = 10</div><div class=\"line\">redirect_stderr=true</div><div class=\"line\">stdout_logfile = /var/www/html/yii-queue-worker.log</div></pre></td></tr></table></figure></p>\n<p>然后在Dockerfile-web-volumes里面添加</p>\n<!--more-->\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- ./services/supervisor:/etc/supervisor/conf.d</div></pre></td></tr></table></figure>\n<p>以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件</p>\n<h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><blockquote>\n<p>本来我的想法是在Dockerfile里面直接添加<code>ENTRYPOINT [&#39;/usr/bin/supervisord&#39;,&#39;-c&#39;,&#39;/etc/supervisor/conf.d&#39;]</code>,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。<code>注意，如果队列基于其它driver的可以这样直接运行的</code></p>\n</blockquote>\n<p>折中的方案是在.gitlab-ci.yml文件中的<strong>testing-server:</strong>-&gt; <strong>script:</strong>和<strong>staging-server:</strong>-&gt;<strong>script:</strong>下分别添加<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">- ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &amp;&gt;/dev/null&amp;&quot;</div></pre></td></tr></table></figure></p>\n<p>这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了<br>然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面</p>"},{"title":"github上composer自动化测试","date":"2017-09-27T14:39:54.000Z","_content":"前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，\n使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\n## Style CI(php格式检查)\n在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：\n```\npreset: psr2\n```\n打开 https://styleci.io/ ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，\n每次提交代码，都会看到检测结果\n如果没有找到自己的项目，打开 https://styleci.io/account#repos 点击 Sync With GitHub 同步，就会看到\n## Travis-CI(自动化测试)\n### 配置单元测试\n1先引入phpunit单元测试包,\n```\ncomposer require --dev phpunit/phpunit ^6.2\n```\n2编写配置文件phpunit.xml.dist,放到根根根目录\n白名单是你要测试的目录文件，用于生成代码覆盖率\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"./tests/bootstrap.php\"\n         colors=\"true\"\n         verbose=\"true\"\n         convertErrorsToExceptions=\"true\"\n         convertNoticesToExceptions=\"true\"\n         convertWarningsToExceptions=\"true\"\n         processIsolation=\"false\"\n         stopOnFailure=\"false\">\n    <testsuites>\n        <testsuite name=\"Test Suite\">\n            <directory>./tests</directory>\n        </testsuite>\n    </testsuites>\n    <filter>\n        <whitelist>\n            <directory suffix=\".php\">./src</directory>\n        </whitelist>\n    </filter>\n</phpunit>\n```\n\n<!--more-->\n3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件\n``` php\n<?php\n// ensure we get report on all possible php errors\nerror_reporting(-1);\nrequire_once(__DIR__ . '/../vendor/autoload.php');\n```\n4composerjson.json文件里自动载入,否则找不到tests里面的TestCase\n``` \n \"autoload-dev\": {\n        \"psr-4\": {\n            \"graychen\\\\Test\\\\\": \"tests/\"\n        }\n    },\n```\n\n5编写.travil.yml文件(在https://travis-ci.com/ 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)\n\n``` \n\nphp:\n  - 5.6\n\n  - 7.1\n\n # cache vendor dirs\ncache:\n  directories:\n    - $HOME/.composer/cache\n    - vendor\n\n#安装依赖\ninstall:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --prefer-dist --no-interaction\n\n\nbefore_script:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --no-interaction --prefer-source --dev\n\n#单元测试\nscript:\n\n  - phpunit --coverage-text --coverage-clover=coverage.clover --debug\n\n#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目\nafter_script:\n\n  - wget https://scrutinizer-ci.com/ocular.phar\n\n  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover\n```\n\n\n## Scrutinizer （单元测试覆盖率）\nScrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。\n\n1.Scrutinizer测试以后会有三个指标供我们对代码来改进\n\nCode Quality\n\n   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等. \nCode Coverage\n\n  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行\nBuild Status\n\n  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）\n  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析\n  excluded_dependencies:\n                         - phpunit/php-timer\n                         - or-another/package-name\n  \n2.基本配置文件\n\n   #测试项目根目录创建.scrutinizer.yml文件\n```\n   imports:\n         - php\n    tools:\n        external_code_coverage:\n            timeout: 1800 # Timeout in seconds.\n        # disable copy paste detector and similarity analyzer as they have no real value\n        # and a huge bunch of false-positives\n        php_sim: false\n        php_cpd: false\n```\n参考文档地址https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\n## Codeclimate简介及使用 (漏洞排查)\nCode Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：\n\n重复的代码，它们可能存在于同一个类或不同类中\n不一致或没有标识性的对象、变量或方法命名\n过长的代码段\n让人费解的布尔表达式\n过于复杂的逻辑判断\n对象错误地暴露其内部状态\n遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码\n\n### 使用\n\n首先在项目中添加配置文件 。codeclimate.yml配置如下:\n```\nengines:\n  duplication:\n    enabled: true\n    config:\n      languages:\n      - php\n  eslint:\n    enabled: true\n  fixme:\n    enabled: true\n  phpmd:\n    enabled: true\n    config:\n    checks:\n      UnusedLocalVariable:\n        enabled: false\nratings:\n  paths:\n  - \"**.php\"\nexclude_paths:\n- tests/\n```\n配置分析\n\n引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。\n\nengines:\n  some-engine:\n    enabled: true\n    channel: \"new-hotness\"\nGithub 集成\n1首先登录[climatecode网站]https://codeclimate.com/dashboard \n2 添加仓库 \n3入库\n4显示成功,这些是分析数据\n## github徽章 (测试保证)\n修改README.md 在工具页面找这些徽章\n[![Latest Stable Version](https://poser.pugx.org/graychen/geolocation/version)](https://packagist.org/packages/graychen/geolocation)\n[![Total Downloads](https://poser.pugx.org/graychen/geolocation/downloads)](https://packagist.org/packages/graychen/geolocation)\n[![License](https://poser.pugx.org/graychen/geolocation/license)](https://packagist.org/packages/graychen/geolocation)\n[![StyleCI](https://styleci.io/repos/92368125/shield?branch=master)](https://styleci.io/repos/92368125)\n[![Build Status](https://travis-ci.org/Graychen/yii2-post.svg?branch=master)](https://travis-ci.org/Graychen/yii2-post)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Code Coverage](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Build Status](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master)\n\n\n","source":"_posts/github自动化测试.md","raw":"---\ntitle: github上composer自动化测试\ndate: 2017-09-27 22:39:54\ntags: 技术 php\n\n---\n前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，\n使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\n## Style CI(php格式检查)\n在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：\n```\npreset: psr2\n```\n打开 https://styleci.io/ ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，\n每次提交代码，都会看到检测结果\n如果没有找到自己的项目，打开 https://styleci.io/account#repos 点击 Sync With GitHub 同步，就会看到\n## Travis-CI(自动化测试)\n### 配置单元测试\n1先引入phpunit单元测试包,\n```\ncomposer require --dev phpunit/phpunit ^6.2\n```\n2编写配置文件phpunit.xml.dist,放到根根根目录\n白名单是你要测试的目录文件，用于生成代码覆盖率\n```\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n<phpunit bootstrap=\"./tests/bootstrap.php\"\n         colors=\"true\"\n         verbose=\"true\"\n         convertErrorsToExceptions=\"true\"\n         convertNoticesToExceptions=\"true\"\n         convertWarningsToExceptions=\"true\"\n         processIsolation=\"false\"\n         stopOnFailure=\"false\">\n    <testsuites>\n        <testsuite name=\"Test Suite\">\n            <directory>./tests</directory>\n        </testsuite>\n    </testsuites>\n    <filter>\n        <whitelist>\n            <directory suffix=\".php\">./src</directory>\n        </whitelist>\n    </filter>\n</phpunit>\n```\n\n<!--more-->\n3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件\n``` php\n<?php\n// ensure we get report on all possible php errors\nerror_reporting(-1);\nrequire_once(__DIR__ . '/../vendor/autoload.php');\n```\n4composerjson.json文件里自动载入,否则找不到tests里面的TestCase\n``` \n \"autoload-dev\": {\n        \"psr-4\": {\n            \"graychen\\\\Test\\\\\": \"tests/\"\n        }\n    },\n```\n\n5编写.travil.yml文件(在https://travis-ci.com/ 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)\n\n``` \n\nphp:\n  - 5.6\n\n  - 7.1\n\n # cache vendor dirs\ncache:\n  directories:\n    - $HOME/.composer/cache\n    - vendor\n\n#安装依赖\ninstall:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --prefer-dist --no-interaction\n\n\nbefore_script:\n\n  - travis_retry composer self-update\n\n  - travis_retry composer install --no-interaction --prefer-source --dev\n\n#单元测试\nscript:\n\n  - phpunit --coverage-text --coverage-clover=coverage.clover --debug\n\n#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目\nafter_script:\n\n  - wget https://scrutinizer-ci.com/ocular.phar\n\n  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover\n```\n\n\n## Scrutinizer （单元测试覆盖率）\nScrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。\n\n1.Scrutinizer测试以后会有三个指标供我们对代码来改进\n\nCode Quality\n\n   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等. \nCode Coverage\n\n  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行\nBuild Status\n\n  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）\n  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析\n  excluded_dependencies:\n                         - phpunit/php-timer\n                         - or-another/package-name\n  \n2.基本配置文件\n\n   #测试项目根目录创建.scrutinizer.yml文件\n```\n   imports:\n         - php\n    tools:\n        external_code_coverage:\n            timeout: 1800 # Timeout in seconds.\n        # disable copy paste detector and similarity analyzer as they have no real value\n        # and a huge bunch of false-positives\n        php_sim: false\n        php_cpd: false\n```\n参考文档地址https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\n## Codeclimate简介及使用 (漏洞排查)\nCode Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：\n\n重复的代码，它们可能存在于同一个类或不同类中\n不一致或没有标识性的对象、变量或方法命名\n过长的代码段\n让人费解的布尔表达式\n过于复杂的逻辑判断\n对象错误地暴露其内部状态\n遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码\n\n### 使用\n\n首先在项目中添加配置文件 。codeclimate.yml配置如下:\n```\nengines:\n  duplication:\n    enabled: true\n    config:\n      languages:\n      - php\n  eslint:\n    enabled: true\n  fixme:\n    enabled: true\n  phpmd:\n    enabled: true\n    config:\n    checks:\n      UnusedLocalVariable:\n        enabled: false\nratings:\n  paths:\n  - \"**.php\"\nexclude_paths:\n- tests/\n```\n配置分析\n\n引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。\n\nengines:\n  some-engine:\n    enabled: true\n    channel: \"new-hotness\"\nGithub 集成\n1首先登录[climatecode网站]https://codeclimate.com/dashboard \n2 添加仓库 \n3入库\n4显示成功,这些是分析数据\n## github徽章 (测试保证)\n修改README.md 在工具页面找这些徽章\n[![Latest Stable Version](https://poser.pugx.org/graychen/geolocation/version)](https://packagist.org/packages/graychen/geolocation)\n[![Total Downloads](https://poser.pugx.org/graychen/geolocation/downloads)](https://packagist.org/packages/graychen/geolocation)\n[![License](https://poser.pugx.org/graychen/geolocation/license)](https://packagist.org/packages/graychen/geolocation)\n[![StyleCI](https://styleci.io/repos/92368125/shield?branch=master)](https://styleci.io/repos/92368125)\n[![Build Status](https://travis-ci.org/Graychen/yii2-post.svg?branch=master)](https://travis-ci.org/Graychen/yii2-post)\n[![Scrutinizer Code Quality](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Code Coverage](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master)\n[![Build Status](https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master)](https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master)\n\n\n","slug":"github自动化测试","published":1,"updated":"2018-02-12T16:39:32.391Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q0q0005to7y5q7evq0s","content":"<p>前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，<br>使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[<a href=\"https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\" target=\"_blank\" rel=\"noopener\">https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。</a></p>\n<h2 id=\"Style-CI-php格式检查\"><a href=\"#Style-CI-php格式检查\" class=\"headerlink\" title=\"Style CI(php格式检查)\"></a>Style CI(php格式检查)</h2><p>在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">preset: psr2</div></pre></td></tr></table></figure></p>\n<p>打开 <a href=\"https://styleci.io/\" target=\"_blank\" rel=\"noopener\">https://styleci.io/</a> ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，<br>每次提交代码，都会看到检测结果<br>如果没有找到自己的项目，打开 <a href=\"https://styleci.io/account#repos\" target=\"_blank\" rel=\"noopener\">https://styleci.io/account#repos</a> 点击 Sync With GitHub 同步，就会看到</p>\n<h2 id=\"Travis-CI-自动化测试\"><a href=\"#Travis-CI-自动化测试\" class=\"headerlink\" title=\"Travis-CI(自动化测试)\"></a>Travis-CI(自动化测试)</h2><h3 id=\"配置单元测试\"><a href=\"#配置单元测试\" class=\"headerlink\" title=\"配置单元测试\"></a>配置单元测试</h3><p>1先引入phpunit单元测试包,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer require --dev phpunit/phpunit ^6.2</div></pre></td></tr></table></figure></p>\n<p>2编写配置文件phpunit.xml.dist,放到根根根目录<br>白名单是你要测试的目录文件，用于生成代码覆盖率<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class=\"line\">&lt;phpunit bootstrap=&quot;./tests/bootstrap.php&quot;</div><div class=\"line\">         colors=&quot;true&quot;</div><div class=\"line\">         verbose=&quot;true&quot;</div><div class=\"line\">         convertErrorsToExceptions=&quot;true&quot;</div><div class=\"line\">         convertNoticesToExceptions=&quot;true&quot;</div><div class=\"line\">         convertWarningsToExceptions=&quot;true&quot;</div><div class=\"line\">         processIsolation=&quot;false&quot;</div><div class=\"line\">         stopOnFailure=&quot;false&quot;&gt;</div><div class=\"line\">    &lt;testsuites&gt;</div><div class=\"line\">        &lt;testsuite name=&quot;Test Suite&quot;&gt;</div><div class=\"line\">            &lt;directory&gt;./tests&lt;/directory&gt;</div><div class=\"line\">        &lt;/testsuite&gt;</div><div class=\"line\">    &lt;/testsuites&gt;</div><div class=\"line\">    &lt;filter&gt;</div><div class=\"line\">        &lt;whitelist&gt;</div><div class=\"line\">            &lt;directory suffix=&quot;.php&quot;&gt;./src&lt;/directory&gt;</div><div class=\"line\">        &lt;/whitelist&gt;</div><div class=\"line\">    &lt;/filter&gt;</div><div class=\"line\">&lt;/phpunit&gt;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"comment\">// ensure we get report on all possible php errors</span></div><div class=\"line\">error_reporting(<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"keyword\">__DIR__</span> . <span class=\"string\">'/../vendor/autoload.php'</span>);</div></pre></td></tr></table></figure></p>\n<p>4composerjson.json文件里自动载入,否则找不到tests里面的TestCase<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;autoload-dev&quot;: &#123;</div><div class=\"line\">       &quot;psr-4&quot;: &#123;</div><div class=\"line\">           &quot;graychen\\\\Test\\\\&quot;: &quot;tests/&quot;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;,</div></pre></td></tr></table></figure></p>\n<p>5编写.travil.yml文件(在<a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">https://travis-ci.com/</a> 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">php:</div><div class=\"line\">  - 5.6</div><div class=\"line\"></div><div class=\"line\">  - 7.1</div><div class=\"line\"></div><div class=\"line\"> # cache vendor dirs</div><div class=\"line\">cache:</div><div class=\"line\">  directories:</div><div class=\"line\">    - $HOME/.composer/cache</div><div class=\"line\">    - vendor</div><div class=\"line\"></div><div class=\"line\">#安装依赖</div><div class=\"line\">install:</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer self-update</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer install --prefer-dist --no-interaction</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">before_script:</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer self-update</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer install --no-interaction --prefer-source --dev</div><div class=\"line\"></div><div class=\"line\">#单元测试</div><div class=\"line\">script:</div><div class=\"line\"></div><div class=\"line\">  - phpunit --coverage-text --coverage-clover=coverage.clover --debug</div><div class=\"line\"></div><div class=\"line\">#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目</div><div class=\"line\">after_script:</div><div class=\"line\"></div><div class=\"line\">  - wget https://scrutinizer-ci.com/ocular.phar</div><div class=\"line\"></div><div class=\"line\">  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover</div></pre></td></tr></table></figure>\n<h2 id=\"Scrutinizer-（单元测试覆盖率）\"><a href=\"#Scrutinizer-（单元测试覆盖率）\" class=\"headerlink\" title=\"Scrutinizer （单元测试覆盖率）\"></a>Scrutinizer （单元测试覆盖率）</h2><p>Scrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。</p>\n<p>1.Scrutinizer测试以后会有三个指标供我们对代码来改进</p>\n<p>Code Quality</p>\n<p>   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等.<br>Code Coverage</p>\n<p>  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行<br>Build Status</p>\n<p>  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）<br>  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析<br>  excluded_dependencies:</p>\n<pre><code>- phpunit/php-timer\n- or-another/package-name\n</code></pre><p>2.基本配置文件</p>\n<p>   #测试项目根目录创建.scrutinizer.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">imports:</div><div class=\"line\">      - php</div><div class=\"line\"> tools:</div><div class=\"line\">     external_code_coverage:</div><div class=\"line\">         timeout: 1800 # Timeout in seconds.</div><div class=\"line\">     # disable copy paste detector and similarity analyzer as they have no real value</div><div class=\"line\">     # and a huge bunch of false-positives</div><div class=\"line\">     php_sim: false</div><div class=\"line\">     php_cpd: false</div></pre></td></tr></table></figure></p>\n<p>参考文档地址<a href=\"https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\" target=\"_blank\" rel=\"noopener\">https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews</a></p>\n<h2 id=\"Codeclimate简介及使用-漏洞排查\"><a href=\"#Codeclimate简介及使用-漏洞排查\" class=\"headerlink\" title=\"Codeclimate简介及使用 (漏洞排查)\"></a>Codeclimate简介及使用 (漏洞排查)</h2><p>Code Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：</p>\n<p>重复的代码，它们可能存在于同一个类或不同类中<br>不一致或没有标识性的对象、变量或方法命名<br>过长的代码段<br>让人费解的布尔表达式<br>过于复杂的逻辑判断<br>对象错误地暴露其内部状态<br>遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>首先在项目中添加配置文件 。codeclimate.yml配置如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">engines:</div><div class=\"line\">  duplication:</div><div class=\"line\">    enabled: true</div><div class=\"line\">    config:</div><div class=\"line\">      languages:</div><div class=\"line\">      - php</div><div class=\"line\">  eslint:</div><div class=\"line\">    enabled: true</div><div class=\"line\">  fixme:</div><div class=\"line\">    enabled: true</div><div class=\"line\">  phpmd:</div><div class=\"line\">    enabled: true</div><div class=\"line\">    config:</div><div class=\"line\">    checks:</div><div class=\"line\">      UnusedLocalVariable:</div><div class=\"line\">        enabled: false</div><div class=\"line\">ratings:</div><div class=\"line\">  paths:</div><div class=\"line\">  - &quot;**.php&quot;</div><div class=\"line\">exclude_paths:</div><div class=\"line\">- tests/</div></pre></td></tr></table></figure></p>\n<p>配置分析</p>\n<p>引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。</p>\n<p>engines:<br>  some-engine:<br>    enabled: true<br>    channel: “new-hotness”<br>Github 集成<br>1首先登录[climatecode网站]<a href=\"https://codeclimate.com/dashboard\" target=\"_blank\" rel=\"noopener\">https://codeclimate.com/dashboard</a><br>2 添加仓库<br>3入库<br>4显示成功,这些是分析数据</p>\n<h2 id=\"github徽章-测试保证\"><a href=\"#github徽章-测试保证\" class=\"headerlink\" title=\"github徽章 (测试保证)\"></a>github徽章 (测试保证)</h2><p>修改README.md 在工具页面找这些徽章<br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/version\" alt=\"Latest Stable Version\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/downloads\" alt=\"Total Downloads\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/license\" alt=\"License\"></a><br><a href=\"https://styleci.io/repos/92368125\" target=\"_blank\" rel=\"noopener\"><img src=\"https://styleci.io/repos/92368125/shield?branch=master\" alt=\"StyleCI\"></a><br><a href=\"https://travis-ci.org/Graychen/yii2-post\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/Graychen/yii2-post.svg?branch=master\" alt=\"Build Status\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master\" alt=\"Scrutinizer Code Quality\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master\" alt=\"Code Coverage\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master\" alt=\"Build Status\"></a></p>\n","site":{"data":{}},"excerpt":"<p>前段时间我们组对项目进行重构，将多个项目中例如log，app的更新这些重复的内容抽出来做了composer包，为了保证这些composer包的代码质量，<br>使用了github上的一些工具。下面我以自己的一个利用经纬度查询地理位置的composer包geolocation[<a href=\"https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。\" target=\"_blank\" rel=\"noopener\">https://github.com/Graychen/geolocation/tree/master/tests]为例来详细描述下我们的做法。</a></p>\n<h2 id=\"Style-CI-php格式检查\"><a href=\"#Style-CI-php格式检查\" class=\"headerlink\" title=\"Style CI(php格式检查)\"></a>Style CI(php格式检查)</h2><p>在项目根目录，新建.styleci.yml 配置文件，并编写配置内容：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">preset: psr2</div></pre></td></tr></table></figure></p>\n<p>打开 <a href=\"https://styleci.io/\" target=\"_blank\" rel=\"noopener\">https://styleci.io/</a> ，使用Gitlab账号登录，找到对应的项目，点击右侧的 ENABLE STYLECI 启用按钮，即可使用，<br>每次提交代码，都会看到检测结果<br>如果没有找到自己的项目，打开 <a href=\"https://styleci.io/account#repos\" target=\"_blank\" rel=\"noopener\">https://styleci.io/account#repos</a> 点击 Sync With GitHub 同步，就会看到</p>\n<h2 id=\"Travis-CI-自动化测试\"><a href=\"#Travis-CI-自动化测试\" class=\"headerlink\" title=\"Travis-CI(自动化测试)\"></a>Travis-CI(自动化测试)</h2><h3 id=\"配置单元测试\"><a href=\"#配置单元测试\" class=\"headerlink\" title=\"配置单元测试\"></a>配置单元测试</h3><p>1先引入phpunit单元测试包,<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer require --dev phpunit/phpunit ^6.2</div></pre></td></tr></table></figure></p>\n<p>2编写配置文件phpunit.xml.dist,放到根根根目录<br>白名单是你要测试的目录文件，用于生成代码覆盖率<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</div><div class=\"line\">&lt;phpunit bootstrap=&quot;./tests/bootstrap.php&quot;</div><div class=\"line\">         colors=&quot;true&quot;</div><div class=\"line\">         verbose=&quot;true&quot;</div><div class=\"line\">         convertErrorsToExceptions=&quot;true&quot;</div><div class=\"line\">         convertNoticesToExceptions=&quot;true&quot;</div><div class=\"line\">         convertWarningsToExceptions=&quot;true&quot;</div><div class=\"line\">         processIsolation=&quot;false&quot;</div><div class=\"line\">         stopOnFailure=&quot;false&quot;&gt;</div><div class=\"line\">    &lt;testsuites&gt;</div><div class=\"line\">        &lt;testsuite name=&quot;Test Suite&quot;&gt;</div><div class=\"line\">            &lt;directory&gt;./tests&lt;/directory&gt;</div><div class=\"line\">        &lt;/testsuite&gt;</div><div class=\"line\">    &lt;/testsuites&gt;</div><div class=\"line\">    &lt;filter&gt;</div><div class=\"line\">        &lt;whitelist&gt;</div><div class=\"line\">            &lt;directory suffix=&quot;.php&quot;&gt;./src&lt;/directory&gt;</div><div class=\"line\">        &lt;/whitelist&gt;</div><div class=\"line\">    &lt;/filter&gt;</div><div class=\"line\">&lt;/phpunit&gt;</div></pre></td></tr></table></figure></p>","more":"<p>3然后建立测试目录test，并在里面建立bootstrap.php来引入composer中的引导文件<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"comment\">// ensure we get report on all possible php errors</span></div><div class=\"line\">error_reporting(<span class=\"number\">-1</span>);</div><div class=\"line\"><span class=\"keyword\">require_once</span>(<span class=\"keyword\">__DIR__</span> . <span class=\"string\">'/../vendor/autoload.php'</span>);</div></pre></td></tr></table></figure></p>\n<p>4composerjson.json文件里自动载入,否则找不到tests里面的TestCase<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">&quot;autoload-dev&quot;: &#123;</div><div class=\"line\">       &quot;psr-4&quot;: &#123;</div><div class=\"line\">           &quot;graychen\\\\Test\\\\&quot;: &quot;tests/&quot;</div><div class=\"line\">       &#125;</div><div class=\"line\">   &#125;,</div></pre></td></tr></table></figure></p>\n<p>5编写.travil.yml文件(在<a href=\"https://travis-ci.com/\" target=\"_blank\" rel=\"noopener\">https://travis-ci.com/</a> 注册账号,然后在github添加service,这样每次提交代码就会自动同步到travis)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">php:</div><div class=\"line\">  - 5.6</div><div class=\"line\"></div><div class=\"line\">  - 7.1</div><div class=\"line\"></div><div class=\"line\"> # cache vendor dirs</div><div class=\"line\">cache:</div><div class=\"line\">  directories:</div><div class=\"line\">    - $HOME/.composer/cache</div><div class=\"line\">    - vendor</div><div class=\"line\"></div><div class=\"line\">#安装依赖</div><div class=\"line\">install:</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer self-update</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer install --prefer-dist --no-interaction</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">before_script:</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer self-update</div><div class=\"line\"></div><div class=\"line\">  - travis_retry composer install --no-interaction --prefer-source --dev</div><div class=\"line\"></div><div class=\"line\">#单元测试</div><div class=\"line\">script:</div><div class=\"line\"></div><div class=\"line\">  - phpunit --coverage-text --coverage-clover=coverage.clover --debug</div><div class=\"line\"></div><div class=\"line\">#需要在https://scrutinizer-ci.com注册账号 并绑定github账号同步github项目</div><div class=\"line\">after_script:</div><div class=\"line\"></div><div class=\"line\">  - wget https://scrutinizer-ci.com/ocular.phar</div><div class=\"line\"></div><div class=\"line\">  - php ocular.phar code-coverage:upload  --format=php-clover coverage.clover</div></pre></td></tr></table></figure>\n<h2 id=\"Scrutinizer-（单元测试覆盖率）\"><a href=\"#Scrutinizer-（单元测试覆盖率）\" class=\"headerlink\" title=\"Scrutinizer （单元测试覆盖率）\"></a>Scrutinizer （单元测试覆盖率）</h2><p>Scrutinizer具有可用于PHP代码的最先进的静态分析引擎。 它能跟踪数据如何流经我们的应用程序以检测代码安全，错误，未使用的代码等。默认情况下，Scrutinizer将分析项目中以.php结尾的所有文件。</p>\n<p>1.Scrutinizer测试以后会有三个指标供我们对代码来改进</p>\n<p>Code Quality</p>\n<p>   代码质量评测来源主要是代码耦合度,代码的复杂度,冗余,未使用变量等.<br>Code Coverage</p>\n<p>  提高单元测试覆盖率， 如果方法里有多个条件分支，尽可能传递不同参数或者使用其它方法让每一行都执行<br>Build Status</p>\n<p>  这一项由代码分析来决定，比如依赖是否可以加载，测试报告是否接收到（travis-ci提供）<br>  如果travis-ci已经build成功，Scrutinizer中却因为某些依赖无法加载可通过以下配置来过滤依赖分析<br>  excluded_dependencies:</p>\n<pre><code>- phpunit/php-timer\n- or-another/package-name\n</code></pre><p>2.基本配置文件</p>\n<p>   #测试项目根目录创建.scrutinizer.yml文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">imports:</div><div class=\"line\">      - php</div><div class=\"line\"> tools:</div><div class=\"line\">     external_code_coverage:</div><div class=\"line\">         timeout: 1800 # Timeout in seconds.</div><div class=\"line\">     # disable copy paste detector and similarity analyzer as they have no real value</div><div class=\"line\">     # and a huge bunch of false-positives</div><div class=\"line\">     php_sim: false</div><div class=\"line\">     php_cpd: false</div></pre></td></tr></table></figure></p>\n<p>参考文档地址<a href=\"https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews\" target=\"_blank\" rel=\"noopener\">https://scrutinizer-ci.com/docs/guides/php/automated-code-reviews</a></p>\n<h2 id=\"Codeclimate简介及使用-漏洞排查\"><a href=\"#Codeclimate简介及使用-漏洞排查\" class=\"headerlink\" title=\"Codeclimate简介及使用 (漏洞排查)\"></a>Codeclimate简介及使用 (漏洞排查)</h2><p>Code Climate可以看作是开发团队的云机器人，无需执行代码就可对代码进行标准化测试，为项目提供静态分析功能，与GitHub集成可以进行漏洞排查工作 每个人都可能用正确的风格写出质量低下的代码，这其中可能包括：</p>\n<p>重复的代码，它们可能存在于同一个类或不同类中<br>不一致或没有标识性的对象、变量或方法命名<br>过长的代码段<br>让人费解的布尔表达式<br>过于复杂的逻辑判断<br>对象错误地暴露其内部状态<br>遭废弃但没有删除的类或方法 Code Climate可以帮我们 Review 这部分代码</p>\n<h3 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h3><p>首先在项目中添加配置文件 。codeclimate.yml配置如下:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">engines:</div><div class=\"line\">  duplication:</div><div class=\"line\">    enabled: true</div><div class=\"line\">    config:</div><div class=\"line\">      languages:</div><div class=\"line\">      - php</div><div class=\"line\">  eslint:</div><div class=\"line\">    enabled: true</div><div class=\"line\">  fixme:</div><div class=\"line\">    enabled: true</div><div class=\"line\">  phpmd:</div><div class=\"line\">    enabled: true</div><div class=\"line\">    config:</div><div class=\"line\">    checks:</div><div class=\"line\">      UnusedLocalVariable:</div><div class=\"line\">        enabled: false</div><div class=\"line\">ratings:</div><div class=\"line\">  paths:</div><div class=\"line\">  - &quot;**.php&quot;</div><div class=\"line\">exclude_paths:</div><div class=\"line\">- tests/</div></pre></td></tr></table></figure></p>\n<p>配置分析</p>\n<p>引擎通道将您的分析映射到引擎的特定发行版本。例如，发动机可具有四个可用信道：stable，alpha，v1，和v2。未指定，分析运行发动机的稳定通道。</p>\n<p>engines:<br>  some-engine:<br>    enabled: true<br>    channel: “new-hotness”<br>Github 集成<br>1首先登录[climatecode网站]<a href=\"https://codeclimate.com/dashboard\" target=\"_blank\" rel=\"noopener\">https://codeclimate.com/dashboard</a><br>2 添加仓库<br>3入库<br>4显示成功,这些是分析数据</p>\n<h2 id=\"github徽章-测试保证\"><a href=\"#github徽章-测试保证\" class=\"headerlink\" title=\"github徽章 (测试保证)\"></a>github徽章 (测试保证)</h2><p>修改README.md 在工具页面找这些徽章<br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/version\" alt=\"Latest Stable Version\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/downloads\" alt=\"Total Downloads\"></a><br><a href=\"https://packagist.org/packages/graychen/geolocation\" target=\"_blank\" rel=\"noopener\"><img src=\"https://poser.pugx.org/graychen/geolocation/license\" alt=\"License\"></a><br><a href=\"https://styleci.io/repos/92368125\" target=\"_blank\" rel=\"noopener\"><img src=\"https://styleci.io/repos/92368125/shield?branch=master\" alt=\"StyleCI\"></a><br><a href=\"https://travis-ci.org/Graychen/yii2-post\" target=\"_blank\" rel=\"noopener\"><img src=\"https://travis-ci.org/Graychen/yii2-post.svg?branch=master\" alt=\"Build Status\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/quality-score.png?b=master\" alt=\"Scrutinizer Code Quality\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/?branch=master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/coverage.png?b=master\" alt=\"Code Coverage\"></a><br><a href=\"https://scrutinizer-ci.com/g/Graychen/geolocation/build-status/master\" target=\"_blank\" rel=\"noopener\"><img src=\"https://scrutinizer-ci.com/g/Graychen/geolocation/badges/build.png?b=master\" alt=\"Build Status\"></a></p>"},{"title":"git使用规范","date":"2018-02-11T14:30:54.000Z","_content":"# Git工作流程\n\n## 分支\n\n- master: 用于生产环境部署, 只接受合并请求, 不直接提交\n- testing: 用于测试环境测试\n- develop: 用于日常开发主线, 其他分支只能合并到 develop 分支\n- feature-xxx: 用于增加一个新功能\n- hotfix-xxx: 用于修复一个紧急bug\n每次开发新功能，都应该新建一个单独的分支\n## 工作流\n\n- 如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码\n- Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发\n- 开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息\n- 开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库\n## Commit message 和 Change log 编写指南\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从[ Angular 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n### 安装 Commitizen 来格式化 commit , 使其遵循以上规范\n\n首先注意将package.json和node_modules加入.gitignore文件\n全局安装commitizen: `npm install -g commitizen`\n在项目根目录初始化package.json: `npm init --yes`\n项目根目录运行 `commitizen init cz-conventional-changelog --save --save-exact`\n每次提交代码时, 用 `git cz` 代替` git commit`\n<!-- more -->\n## 自动生成 Change log\n\n安装 `npm install -g conventional-changelog-cli`\n使用`conventional-changelog`生成日志: `conventional-changelog -p angular -i CHANGELOG.md -s -r 0`\n## 版本号使用规范\n\n版本号遵循语义化版本规范.\n\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n\n主版本号：当你做了不兼容的 API 修改，\n次版本号：当你做了向下兼容的功能性新增，\n修订号：当你做了向下兼容的问题修正。\n先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n更多内容参见 [语义化版本](http://semver.org/lang/zh-CN/)\n\n## 参考资料\n\n[Git 使用规范流程](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)\n[Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n[Git commit message 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n","source":"_posts/git使用规范.md","raw":"---\ntitle: git使用规范\ndate: 2018-02-11 22:30:54\ntags: 技术 php\n---\n# Git工作流程\n\n## 分支\n\n- master: 用于生产环境部署, 只接受合并请求, 不直接提交\n- testing: 用于测试环境测试\n- develop: 用于日常开发主线, 其他分支只能合并到 develop 分支\n- feature-xxx: 用于增加一个新功能\n- hotfix-xxx: 用于修复一个紧急bug\n每次开发新功能，都应该新建一个单独的分支\n## 工作流\n\n- 如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码\n- Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发\n- 开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息\n- 开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库\n## Commit message 和 Change log 编写指南\n\nGit 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从[ Angular 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n### 安装 Commitizen 来格式化 commit , 使其遵循以上规范\n\n首先注意将package.json和node_modules加入.gitignore文件\n全局安装commitizen: `npm install -g commitizen`\n在项目根目录初始化package.json: `npm init --yes`\n项目根目录运行 `commitizen init cz-conventional-changelog --save --save-exact`\n每次提交代码时, 用 `git cz` 代替` git commit`\n<!-- more -->\n## 自动生成 Change log\n\n安装 `npm install -g conventional-changelog-cli`\n使用`conventional-changelog`生成日志: `conventional-changelog -p angular -i CHANGELOG.md -s -r 0`\n## 版本号使用规范\n\n版本号遵循语义化版本规范.\n\n版本格式：主版本号.次版本号.修订号，版本号递增规则如下：\n\n主版本号：当你做了不兼容的 API 修改，\n次版本号：当你做了向下兼容的功能性新增，\n修订号：当你做了向下兼容的问题修正。\n先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。\n\n更多内容参见 [语义化版本](http://semver.org/lang/zh-CN/)\n\n## 参考资料\n\n[Git 使用规范流程](http://www.ruanyifeng.com/blog/2015/08/git-use-process.html)\n[Commit message 和 Change log 编写指南](http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html)\n[Git commit message 规范](http://blog.cheenwe.cn/2016-04-18/git-commit-message/)\n","slug":"git使用规范","published":1,"updated":"2018-02-11T14:44:16.550Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q0y0006to7yprl5ty7z","content":"<h1 id=\"Git工作流程\"><a href=\"#Git工作流程\" class=\"headerlink\" title=\"Git工作流程\"></a>Git工作流程</h1><h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><ul>\n<li>master: 用于生产环境部署, 只接受合并请求, 不直接提交</li>\n<li>testing: 用于测试环境测试</li>\n<li>develop: 用于日常开发主线, 其他分支只能合并到 develop 分支</li>\n<li>feature-xxx: 用于增加一个新功能</li>\n<li><p>hotfix-xxx: 用于修复一个紧急bug<br>每次开发新功能，都应该新建一个单独的分支</p>\n<h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2></li>\n<li><p>如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码</p>\n</li>\n<li>Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发</li>\n<li>开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息</li>\n<li>开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库<h2 id=\"Commit-message-和-Change-log-编写指南\"><a href=\"#Commit-message-和-Change-log-编写指南\" class=\"headerlink\" title=\"Commit message 和 Change log 编写指南\"></a>Commit message 和 Change log 编写指南</h2></li>\n</ul>\n<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从<a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\"> Angular 规范</a></p>\n<h3 id=\"安装-Commitizen-来格式化-commit-使其遵循以上规范\"><a href=\"#安装-Commitizen-来格式化-commit-使其遵循以上规范\" class=\"headerlink\" title=\"安装 Commitizen 来格式化 commit , 使其遵循以上规范\"></a>安装 Commitizen 来格式化 commit , 使其遵循以上规范</h3><p>首先注意将package.json和node_modules加入.gitignore文件<br>全局安装commitizen: <code>npm install -g commitizen</code><br>在项目根目录初始化package.json: <code>npm init --yes</code><br>项目根目录运行 <code>commitizen init cz-conventional-changelog --save --save-exact</code><br>每次提交代码时, 用 <code>git cz</code> 代替<code>git commit</code><br><a id=\"more\"></a></p>\n<h2 id=\"自动生成-Change-log\"><a href=\"#自动生成-Change-log\" class=\"headerlink\" title=\"自动生成 Change log\"></a>自动生成 Change log</h2><p>安装 <code>npm install -g conventional-changelog-cli</code><br>使用<code>conventional-changelog</code>生成日志: <code>conventional-changelog -p angular -i CHANGELOG.md -s -r 0</code></p>\n<h2 id=\"版本号使用规范\"><a href=\"#版本号使用规范\" class=\"headerlink\" title=\"版本号使用规范\"></a>版本号使用规范</h2><p>版本号遵循语义化版本规范.</p>\n<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>\n<p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n<p>更多内容参见 <a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义化版本</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.ruanyifeng.com/blog/2015/08/git-use-process.html\" target=\"_blank\" rel=\"noopener\">Git 使用规范流程</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">Commit message 和 Change log 编写指南</a><br><a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\">Git commit message 规范</a></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"Git工作流程\"><a href=\"#Git工作流程\" class=\"headerlink\" title=\"Git工作流程\"></a>Git工作流程</h1><h2 id=\"分支\"><a href=\"#分支\" class=\"headerlink\" title=\"分支\"></a>分支</h2><ul>\n<li>master: 用于生产环境部署, 只接受合并请求, 不直接提交</li>\n<li>testing: 用于测试环境测试</li>\n<li>develop: 用于日常开发主线, 其他分支只能合并到 develop 分支</li>\n<li>feature-xxx: 用于增加一个新功能</li>\n<li><p>hotfix-xxx: 用于修复一个紧急bug<br>每次开发新功能，都应该新建一个单独的分支</p>\n<h2 id=\"工作流\"><a href=\"#工作流\" class=\"headerlink\" title=\"工作流\"></a>工作流</h2></li>\n<li><p>如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码</p>\n</li>\n<li>Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发</li>\n<li>开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息</li>\n<li>开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库<h2 id=\"Commit-message-和-Change-log-编写指南\"><a href=\"#Commit-message-和-Change-log-编写指南\" class=\"headerlink\" title=\"Commit message 和 Change log 编写指南\"></a>Commit message 和 Change log 编写指南</h2></li>\n</ul>\n<p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从<a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\"> Angular 规范</a></p>\n<h3 id=\"安装-Commitizen-来格式化-commit-使其遵循以上规范\"><a href=\"#安装-Commitizen-来格式化-commit-使其遵循以上规范\" class=\"headerlink\" title=\"安装 Commitizen 来格式化 commit , 使其遵循以上规范\"></a>安装 Commitizen 来格式化 commit , 使其遵循以上规范</h3><p>首先注意将package.json和node_modules加入.gitignore文件<br>全局安装commitizen: <code>npm install -g commitizen</code><br>在项目根目录初始化package.json: <code>npm init --yes</code><br>项目根目录运行 <code>commitizen init cz-conventional-changelog --save --save-exact</code><br>每次提交代码时, 用 <code>git cz</code> 代替<code>git commit</code><br>","more":"</p>\n<h2 id=\"自动生成-Change-log\"><a href=\"#自动生成-Change-log\" class=\"headerlink\" title=\"自动生成 Change log\"></a>自动生成 Change log</h2><p>安装 <code>npm install -g conventional-changelog-cli</code><br>使用<code>conventional-changelog</code>生成日志: <code>conventional-changelog -p angular -i CHANGELOG.md -s -r 0</code></p>\n<h2 id=\"版本号使用规范\"><a href=\"#版本号使用规范\" class=\"headerlink\" title=\"版本号使用规范\"></a>版本号使用规范</h2><p>版本号遵循语义化版本规范.</p>\n<p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p>\n<p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p>\n<p>更多内容参见 <a href=\"http://semver.org/lang/zh-CN/\" target=\"_blank\" rel=\"noopener\">语义化版本</a></p>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><p><a href=\"http://www.ruanyifeng.com/blog/2015/08/git-use-process.html\" target=\"_blank\" rel=\"noopener\">Git 使用规范流程</a><br><a href=\"http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html\" target=\"_blank\" rel=\"noopener\">Commit message 和 Change log 编写指南</a><br><a href=\"http://blog.cheenwe.cn/2016-04-18/git-commit-message/\" target=\"_blank\" rel=\"noopener\">Git commit message 规范</a></p>"},{"title":"gitlab-ci由浅入深","date":"2018-02-11T14:57:07.000Z","_content":"# 概述\n\n持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。\n\n持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.\n\n# 功能\n\n## 持续集成可以实现的功能:\n\n- 代码审核: 自动化代码规范审查, 甚至代码质量检查\n- 自动化测试: 单元测试, 功能测试和验收测试\n- 编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布\n- 构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署\n## 原理\n\nGitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.\nGitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.\nGitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.\n<!--more-->\n在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下\n```\njob-1:\n  script:\n      - echo \"Hello World\"\n```\n      这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\n      script下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n  这样, 一次简单的持续集成已经搞定了.\n\n  如何编写GitLab-CI配置文件\n\n  见文档 如何编写GitLab-CI配置文件\n\n  远程拉取代码\n\n  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新\n\n  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥\n\n  如\n```\n  release-doc:\n      stage: deploy\n          script:\n            - ssh root@$DEPLOY_SERVER \"cd /mnt/data/docker-gollum/wiki && git pull origin master\"\n```\n\n## 关键词\n\n### 根主要关键词一览\n\n|关键词|  含义|    可选 |   备注|\n|--|--|--|--|\n|image  | 声明使用的Docker镜像 |   为空时使用默认镜像 | 该镜像应当满足脚本执行的环境依赖|\n|services   | Docker镜像使用的服务, 通过链接的方式来调用所需服务 | 可空 |   常用于链接数据库|\n|stages  |定义构建阶段  |  为空时, 单纯定义jobs   | 项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务|\n|before_script  | 定义每个job之前执行的脚本  | 可空   | 每个job启动时会先执行该脚本|\n|after_script   | 定义每个job之后执行的脚本  | 可空  |  同上|\n|variables |  定义变量  |  可空  |  同上|\n|cache  | 定义与后续job之间应缓存的文件  | 可空  |  同上|\n### Demo:\n```ci\nimage: aipline\nservices:\n  - mysql\n  - redis\nstages:\n  - build\n  - test\n  - deploy\nbefore_script:\n  - bundle install  \nafter_script:\n  - rm secrets\ncache:\npaths:\n  - binaries/\n  - .config\n```\n## Jobs中的关键词\n### jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\n#### job 这里译为任务\n|关键词 | 含义  |  可选  |  备注|\n|--|--|--|--|\n|image  | 声明任务使用的Docker镜像  |  为空时使用根中的定义  |  该镜像应当满足脚本执行的环境依赖|\n|services   | 任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务  |  可空  |  常用于链接数据库|\n|stage  | 所属构建阶段   | 为空时则不使用stages |   一个任务属于一个构建阶段|\n|before_script  | 定义每个job之前执行的脚本 |  可选  |  如果在job中定义则会覆盖根中的内容|\n|script | 定义每个job执行的脚本  | 必须 |   \n|after_script  |  定义每个job之后执行的脚本 |  可选 |   同上|\n|variables  | 定义任务中使用的变量   | 可选  |  同上|\n|cache  | 定义与后续job之间应缓存的文件 |  可选 |   同上|\n|only   | 指定应用的Git分支 |  可选  | 可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支|\n|except | 排除应用的Git分支 | 可选   | 同上|\n|tags   | 指定执行的GitLab-Runners   | 可选|    通过匹配Runners的标签选定|\n|allow_failure  |  允许失败  |  默认为false 如果允许失败, 本次任务不会影响整个构建的结果|\n|when  |  定义合适执行任务 |   默认为always |   有on_success, on_failure, always or manual可选|\n|dependencies  |  定义合任务所需要的工件|  可空 |   需要首先定义工件|\n|artifacts |  定义工件  |  可空 |   工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压|\n|environment | 定义环境 |   可空 |   在部署任务中, 定义该任务所属的环境|\n\n示例\n``` ci\ninstalling-dependencies:\n  script:\n    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest\n    - composer dump-autoload --optimize\n  artifacts:\n    - name: \"vendor\"\n    - untracked: true\n    - expire_in: 60 mins\n    - paths:\n    - vendor/    \ndeleteocker-build-image:    \n  stage: test\n  only:\n    - master\n  except:\n    - develop\n  tags:\n    - ruby\n    - postgres\n  allow_failure: true\n  dependencies:\n    - installing-dependencies\n  script:        \n    - docker build -t registry.com/mops/image:latest .\n    - docker push registry.com/mops/image:latest \n```\n\n>注意:\njobs的名称不能重名\n同一阶段中的任务, 是并行执行的\n上一阶段所有任务执行完后, 才会进入下一阶段\n定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间\n如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)\n\n###  验证配置文件合法性\n  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证\n##  通过gitlab-ci实现文件的自动部署\n###  实现过程\n  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令\n###  过程\n#### 生成ssh证书\n  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥\n  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys\n#### 添加公钥\n  添加公钥: cat id_rsa.pub >> ~/.ssh/authorized_keys\n  id_rsa.pub为第一步生成的公钥\n  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root\n  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥\n#### 设置CI/CD变量\n  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY\n  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址\n  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令\n  完整代码\n  ```ci\n# 使用alpine镜像, 该镜像很少,只有几兆\nimage: alpine\nstages:\n  - deploy\nbefore_script:\n  # 预先装 ssh-agent\n  - 'which ssh-agent || ( apk update && apk add openssh-client)'\n  # 启动服务\n  - eval $(ssh-agent -s)\n  # 将私钥写入deploy.key 文件\n  - echo \"$SSH_PRIVATE_KEY\" > deploy.key\n  # 配置较低权限\n  - chmod 0600 deploy.key\n  # 注入密钥\n  - ssh-add deploy.key\n  - mkdir -p ~/.ssh    \n  - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n\nrelease-doc:\n  stage: deploy\n  variables:\n    GIT_STRATEGY: none     \n  script:\n    # 连接远程服务器并执行拉取代码的命令\n    - ssh root@$DEPLOY_SERVER \"cd /path/to/wiki && git pull origin master\"\n  only:\n    - master\n  environment:\n    name: production\n    url: http://$DEPLOY_SERVER\n```\n\n\n\n","source":"_posts/gitlab-ci由浅入深.md","raw":"---\ntitle: gitlab-ci由浅入深\ndate: 2018-02-11 22:57:07\ntags:\n---\n# 概述\n\n持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。\n\n持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.\n\n# 功能\n\n## 持续集成可以实现的功能:\n\n- 代码审核: 自动化代码规范审查, 甚至代码质量检查\n- 自动化测试: 单元测试, 功能测试和验收测试\n- 编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布\n- 构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署\n## 原理\n\nGitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.\nGitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.\nGitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.\n<!--more-->\n在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下\n```\njob-1:\n  script:\n      - echo \"Hello World\"\n```\n      这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\n      script下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n  这样, 一次简单的持续集成已经搞定了.\n\n  如何编写GitLab-CI配置文件\n\n  见文档 如何编写GitLab-CI配置文件\n\n  远程拉取代码\n\n  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新\n\n  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥\n\n  如\n```\n  release-doc:\n      stage: deploy\n          script:\n            - ssh root@$DEPLOY_SERVER \"cd /mnt/data/docker-gollum/wiki && git pull origin master\"\n```\n\n## 关键词\n\n### 根主要关键词一览\n\n|关键词|  含义|    可选 |   备注|\n|--|--|--|--|\n|image  | 声明使用的Docker镜像 |   为空时使用默认镜像 | 该镜像应当满足脚本执行的环境依赖|\n|services   | Docker镜像使用的服务, 通过链接的方式来调用所需服务 | 可空 |   常用于链接数据库|\n|stages  |定义构建阶段  |  为空时, 单纯定义jobs   | 项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务|\n|before_script  | 定义每个job之前执行的脚本  | 可空   | 每个job启动时会先执行该脚本|\n|after_script   | 定义每个job之后执行的脚本  | 可空  |  同上|\n|variables |  定义变量  |  可空  |  同上|\n|cache  | 定义与后续job之间应缓存的文件  | 可空  |  同上|\n### Demo:\n```ci\nimage: aipline\nservices:\n  - mysql\n  - redis\nstages:\n  - build\n  - test\n  - deploy\nbefore_script:\n  - bundle install  \nafter_script:\n  - rm secrets\ncache:\npaths:\n  - binaries/\n  - .config\n```\n## Jobs中的关键词\n### jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\n#### job 这里译为任务\n|关键词 | 含义  |  可选  |  备注|\n|--|--|--|--|\n|image  | 声明任务使用的Docker镜像  |  为空时使用根中的定义  |  该镜像应当满足脚本执行的环境依赖|\n|services   | 任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务  |  可空  |  常用于链接数据库|\n|stage  | 所属构建阶段   | 为空时则不使用stages |   一个任务属于一个构建阶段|\n|before_script  | 定义每个job之前执行的脚本 |  可选  |  如果在job中定义则会覆盖根中的内容|\n|script | 定义每个job执行的脚本  | 必须 |   \n|after_script  |  定义每个job之后执行的脚本 |  可选 |   同上|\n|variables  | 定义任务中使用的变量   | 可选  |  同上|\n|cache  | 定义与后续job之间应缓存的文件 |  可选 |   同上|\n|only   | 指定应用的Git分支 |  可选  | 可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支|\n|except | 排除应用的Git分支 | 可选   | 同上|\n|tags   | 指定执行的GitLab-Runners   | 可选|    通过匹配Runners的标签选定|\n|allow_failure  |  允许失败  |  默认为false 如果允许失败, 本次任务不会影响整个构建的结果|\n|when  |  定义合适执行任务 |   默认为always |   有on_success, on_failure, always or manual可选|\n|dependencies  |  定义合任务所需要的工件|  可空 |   需要首先定义工件|\n|artifacts |  定义工件  |  可空 |   工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压|\n|environment | 定义环境 |   可空 |   在部署任务中, 定义该任务所属的环境|\n\n示例\n``` ci\ninstalling-dependencies:\n  script:\n    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest\n    - composer dump-autoload --optimize\n  artifacts:\n    - name: \"vendor\"\n    - untracked: true\n    - expire_in: 60 mins\n    - paths:\n    - vendor/    \ndeleteocker-build-image:    \n  stage: test\n  only:\n    - master\n  except:\n    - develop\n  tags:\n    - ruby\n    - postgres\n  allow_failure: true\n  dependencies:\n    - installing-dependencies\n  script:        \n    - docker build -t registry.com/mops/image:latest .\n    - docker push registry.com/mops/image:latest \n```\n\n>注意:\njobs的名称不能重名\n同一阶段中的任务, 是并行执行的\n上一阶段所有任务执行完后, 才会进入下一阶段\n定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间\n如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)\n\n###  验证配置文件合法性\n  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证\n##  通过gitlab-ci实现文件的自动部署\n###  实现过程\n  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令\n###  过程\n#### 生成ssh证书\n  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥\n  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys\n#### 添加公钥\n  添加公钥: cat id_rsa.pub >> ~/.ssh/authorized_keys\n  id_rsa.pub为第一步生成的公钥\n  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root\n  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥\n#### 设置CI/CD变量\n  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY\n  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址\n  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令\n  完整代码\n  ```ci\n# 使用alpine镜像, 该镜像很少,只有几兆\nimage: alpine\nstages:\n  - deploy\nbefore_script:\n  # 预先装 ssh-agent\n  - 'which ssh-agent || ( apk update && apk add openssh-client)'\n  # 启动服务\n  - eval $(ssh-agent -s)\n  # 将私钥写入deploy.key 文件\n  - echo \"$SSH_PRIVATE_KEY\" > deploy.key\n  # 配置较低权限\n  - chmod 0600 deploy.key\n  # 注入密钥\n  - ssh-add deploy.key\n  - mkdir -p ~/.ssh    \n  - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n\nrelease-doc:\n  stage: deploy\n  variables:\n    GIT_STRATEGY: none     \n  script:\n    # 连接远程服务器并执行拉取代码的命令\n    - ssh root@$DEPLOY_SERVER \"cd /path/to/wiki && git pull origin master\"\n  only:\n    - master\n  environment:\n    name: production\n    url: http://$DEPLOY_SERVER\n```\n\n\n\n","slug":"gitlab-ci由浅入深","published":1,"updated":"2018-02-12T15:54:25.586Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q13000ato7yr7skxjou","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。</p>\n<p>持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.</p>\n<h1 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h1><h2 id=\"持续集成可以实现的功能\"><a href=\"#持续集成可以实现的功能\" class=\"headerlink\" title=\"持续集成可以实现的功能:\"></a>持续集成可以实现的功能:</h2><ul>\n<li>代码审核: 自动化代码规范审查, 甚至代码质量检查</li>\n<li>自动化测试: 单元测试, 功能测试和验收测试</li>\n<li>编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布</li>\n<li>构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2></li>\n</ul>\n<p>GitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.<br>GitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.<br>GitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.<br><a id=\"more\"></a><br>在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">job-1:</div><div class=\"line\">  script:</div><div class=\"line\">      - echo &quot;Hello World&quot;</div></pre></td></tr></table></figure></p>\n<pre><code>这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\nscript下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n</code></pre><p>  这样, 一次简单的持续集成已经搞定了.</p>\n<p>  如何编写GitLab-CI配置文件</p>\n<p>  见文档 如何编写GitLab-CI配置文件</p>\n<p>  远程拉取代码</p>\n<p>  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新</p>\n<p>  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥</p>\n<p>  如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">release-doc:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">        script:</div><div class=\"line\">          - ssh root@$DEPLOY_SERVER &quot;cd /mnt/data/docker-gollum/wiki &amp;&amp; git pull origin master&quot;</div></pre></td></tr></table></figure></p>\n<h2 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h2><h3 id=\"根主要关键词一览\"><a href=\"#根主要关键词一览\" class=\"headerlink\" title=\"根主要关键词一览\"></a>根主要关键词一览</h3><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明使用的Docker镜像</td>\n<td>为空时使用默认镜像</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stages</td>\n<td>定义构建阶段</td>\n<td>为空时, 单纯定义jobs</td>\n<td>项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可空</td>\n<td>每个job启动时会先执行该脚本</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义变量</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo:\"></a>Demo:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">image: aipline</div><div class=\"line\">services:</div><div class=\"line\">  - mysql</div><div class=\"line\">  - redis</div><div class=\"line\">stages:</div><div class=\"line\">  - build</div><div class=\"line\">  - test</div><div class=\"line\">  - deploy</div><div class=\"line\">before_script:</div><div class=\"line\">  - bundle install  </div><div class=\"line\">after_script:</div><div class=\"line\">  - rm secrets</div><div class=\"line\">cache:</div><div class=\"line\">paths:</div><div class=\"line\">  - binaries/</div><div class=\"line\">  - .config</div></pre></td></tr></table></figure>\n<h2 id=\"Jobs中的关键词\"><a href=\"#Jobs中的关键词\" class=\"headerlink\" title=\"Jobs中的关键词\"></a>Jobs中的关键词</h2><h3 id=\"jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\"><a href=\"#jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\" class=\"headerlink\" title=\"jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\"></a>jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行</h3><h4 id=\"job-这里译为任务\"><a href=\"#job-这里译为任务\" class=\"headerlink\" title=\"job 这里译为任务\"></a>job 这里译为任务</h4><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明任务使用的Docker镜像</td>\n<td>为空时使用根中的定义</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stage</td>\n<td>所属构建阶段</td>\n<td>为空时则不使用stages</td>\n<td>一个任务属于一个构建阶段</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可选</td>\n<td>如果在job中定义则会覆盖根中的内容</td>\n</tr>\n<tr>\n<td>script</td>\n<td>定义每个job执行的脚本</td>\n<td>必须</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义任务中使用的变量</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>only</td>\n<td>指定应用的Git分支</td>\n<td>可选</td>\n<td>可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支</td>\n</tr>\n<tr>\n<td>except</td>\n<td>排除应用的Git分支</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>指定执行的GitLab-Runners</td>\n<td>可选</td>\n<td>通过匹配Runners的标签选定</td>\n</tr>\n<tr>\n<td>allow_failure</td>\n<td>允许失败</td>\n<td>默认为false 如果允许失败, 本次任务不会影响整个构建的结果</td>\n</tr>\n<tr>\n<td>when</td>\n<td>定义合适执行任务</td>\n<td>默认为always</td>\n<td>有on_success, on_failure, always or manual可选</td>\n</tr>\n<tr>\n<td>dependencies</td>\n<td>定义合任务所需要的工件</td>\n<td>可空</td>\n<td>需要首先定义工件</td>\n</tr>\n<tr>\n<td>artifacts</td>\n<td>定义工件</td>\n<td>可空</td>\n<td>工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压</td>\n</tr>\n<tr>\n<td>environment</td>\n<td>定义环境</td>\n<td>可空</td>\n<td>在部署任务中, 定义该任务所属的环境</td>\n</tr>\n</tbody>\n</table>\n<p>示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">installing-dependencies:</div><div class=\"line\">  script:</div><div class=\"line\">    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest</div><div class=\"line\">    - composer dump-autoload --optimize</div><div class=\"line\">  artifacts:</div><div class=\"line\">    - name: &quot;vendor&quot;</div><div class=\"line\">    - untracked: true</div><div class=\"line\">    - expire_in: 60 mins</div><div class=\"line\">    - paths:</div><div class=\"line\">    - vendor/    </div><div class=\"line\">deleteocker-build-image:    </div><div class=\"line\">  stage: test</div><div class=\"line\">  only:</div><div class=\"line\">    - master</div><div class=\"line\">  except:</div><div class=\"line\">    - develop</div><div class=\"line\">  tags:</div><div class=\"line\">    - ruby</div><div class=\"line\">    - postgres</div><div class=\"line\">  allow_failure: true</div><div class=\"line\">  dependencies:</div><div class=\"line\">    - installing-dependencies</div><div class=\"line\">  script:        </div><div class=\"line\">    - docker build -t registry.com/mops/image:latest .</div><div class=\"line\">    - docker push registry.com/mops/image:latest</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意:<br>jobs的名称不能重名<br>同一阶段中的任务, 是并行执行的<br>上一阶段所有任务执行完后, 才会进入下一阶段<br>定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间<br>如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)</p>\n</blockquote>\n<h3 id=\"验证配置文件合法性\"><a href=\"#验证配置文件合法性\" class=\"headerlink\" title=\"验证配置文件合法性\"></a>验证配置文件合法性</h3><p>  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证</p>\n<h2 id=\"通过gitlab-ci实现文件的自动部署\"><a href=\"#通过gitlab-ci实现文件的自动部署\" class=\"headerlink\" title=\"通过gitlab-ci实现文件的自动部署\"></a>通过gitlab-ci实现文件的自动部署</h2><h3 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h3><p>  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><h4 id=\"生成ssh证书\"><a href=\"#生成ssh证书\" class=\"headerlink\" title=\"生成ssh证书\"></a>生成ssh证书</h4><p>  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥<br>  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys</p>\n<h4 id=\"添加公钥\"><a href=\"#添加公钥\" class=\"headerlink\" title=\"添加公钥\"></a>添加公钥</h4><p>  添加公钥: cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>  id_rsa.pub为第一步生成的公钥<br>  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root<br>  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥</p>\n<h4 id=\"设置CI-CD变量\"><a href=\"#设置CI-CD变量\" class=\"headerlink\" title=\"设置CI/CD变量\"></a>设置CI/CD变量</h4><p>  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY<br>  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址<br>  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令<br>  完整代码<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 使用alpine镜像, 该镜像很少,只有几兆</div><div class=\"line\">image: alpine</div><div class=\"line\">stages:</div><div class=\"line\">  - deploy</div><div class=\"line\">before_script:</div><div class=\"line\">  # 预先装 ssh-agent</div><div class=\"line\">  - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</div><div class=\"line\">  # 启动服务</div><div class=\"line\">  - eval $(ssh-agent -s)</div><div class=\"line\">  # 将私钥写入deploy.key 文件</div><div class=\"line\">  - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; deploy.key</div><div class=\"line\">  # 配置较低权限</div><div class=\"line\">  - chmod 0600 deploy.key</div><div class=\"line\">  # 注入密钥</div><div class=\"line\">  - ssh-add deploy.key</div><div class=\"line\">  - mkdir -p ~/.ssh    </div><div class=\"line\">  - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</div><div class=\"line\"></div><div class=\"line\">release-doc:</div><div class=\"line\">  stage: deploy</div><div class=\"line\">  variables:</div><div class=\"line\">    GIT_STRATEGY: none     </div><div class=\"line\">  script:</div><div class=\"line\">    # 连接远程服务器并执行拉取代码的命令</div><div class=\"line\">    - ssh root@$DEPLOY_SERVER &quot;cd /path/to/wiki &amp;&amp; git pull origin master&quot;</div><div class=\"line\">  only:</div><div class=\"line\">    - master</div><div class=\"line\">  environment:</div><div class=\"line\">    name: production</div><div class=\"line\">    url: http://$DEPLOY_SERVER</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。</p>\n<p>持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.</p>\n<h1 id=\"功能\"><a href=\"#功能\" class=\"headerlink\" title=\"功能\"></a>功能</h1><h2 id=\"持续集成可以实现的功能\"><a href=\"#持续集成可以实现的功能\" class=\"headerlink\" title=\"持续集成可以实现的功能:\"></a>持续集成可以实现的功能:</h2><ul>\n<li>代码审核: 自动化代码规范审查, 甚至代码质量检查</li>\n<li>自动化测试: 单元测试, 功能测试和验收测试</li>\n<li>编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布</li>\n<li>构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2></li>\n</ul>\n<p>GitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.<br>GitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.<br>GitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.<br>","more":"<br>在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">job-1:</div><div class=\"line\">  script:</div><div class=\"line\">      - echo &quot;Hello World&quot;</div></pre></td></tr></table></figure></p>\n<pre><code>这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,\nscript下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)\n</code></pre><p>  这样, 一次简单的持续集成已经搞定了.</p>\n<p>  如何编写GitLab-CI配置文件</p>\n<p>  见文档 如何编写GitLab-CI配置文件</p>\n<p>  远程拉取代码</p>\n<p>  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新</p>\n<p>  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥</p>\n<p>  如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">release-doc:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">        script:</div><div class=\"line\">          - ssh root@$DEPLOY_SERVER &quot;cd /mnt/data/docker-gollum/wiki &amp;&amp; git pull origin master&quot;</div></pre></td></tr></table></figure></p>\n<h2 id=\"关键词\"><a href=\"#关键词\" class=\"headerlink\" title=\"关键词\"></a>关键词</h2><h3 id=\"根主要关键词一览\"><a href=\"#根主要关键词一览\" class=\"headerlink\" title=\"根主要关键词一览\"></a>根主要关键词一览</h3><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明使用的Docker镜像</td>\n<td>为空时使用默认镜像</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stages</td>\n<td>定义构建阶段</td>\n<td>为空时, 单纯定义jobs</td>\n<td>项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可空</td>\n<td>每个job启动时会先执行该脚本</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义变量</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可空</td>\n<td>同上</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"Demo\"><a href=\"#Demo\" class=\"headerlink\" title=\"Demo:\"></a>Demo:</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\">image: aipline</div><div class=\"line\">services:</div><div class=\"line\">  - mysql</div><div class=\"line\">  - redis</div><div class=\"line\">stages:</div><div class=\"line\">  - build</div><div class=\"line\">  - test</div><div class=\"line\">  - deploy</div><div class=\"line\">before_script:</div><div class=\"line\">  - bundle install  </div><div class=\"line\">after_script:</div><div class=\"line\">  - rm secrets</div><div class=\"line\">cache:</div><div class=\"line\">paths:</div><div class=\"line\">  - binaries/</div><div class=\"line\">  - .config</div></pre></td></tr></table></figure>\n<h2 id=\"Jobs中的关键词\"><a href=\"#Jobs中的关键词\" class=\"headerlink\" title=\"Jobs中的关键词\"></a>Jobs中的关键词</h2><h3 id=\"jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\"><a href=\"#jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行\" class=\"headerlink\" title=\"jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行\"></a>jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行</h3><h4 id=\"job-这里译为任务\"><a href=\"#job-这里译为任务\" class=\"headerlink\" title=\"job 这里译为任务\"></a>job 这里译为任务</h4><table>\n<thead>\n<tr>\n<th>关键词</th>\n<th>含义</th>\n<th>可选</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>image</td>\n<td>声明任务使用的Docker镜像</td>\n<td>为空时使用根中的定义</td>\n<td>该镜像应当满足脚本执行的环境依赖</td>\n</tr>\n<tr>\n<td>services</td>\n<td>任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务</td>\n<td>可空</td>\n<td>常用于链接数据库</td>\n</tr>\n<tr>\n<td>stage</td>\n<td>所属构建阶段</td>\n<td>为空时则不使用stages</td>\n<td>一个任务属于一个构建阶段</td>\n</tr>\n<tr>\n<td>before_script</td>\n<td>定义每个job之前执行的脚本</td>\n<td>可选</td>\n<td>如果在job中定义则会覆盖根中的内容</td>\n</tr>\n<tr>\n<td>script</td>\n<td>定义每个job执行的脚本</td>\n<td>必须</td>\n</tr>\n<tr>\n<td>after_script</td>\n<td>定义每个job之后执行的脚本</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>variables</td>\n<td>定义任务中使用的变量</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>cache</td>\n<td>定义与后续job之间应缓存的文件</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>only</td>\n<td>指定应用的Git分支</td>\n<td>可选</td>\n<td>可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支</td>\n</tr>\n<tr>\n<td>except</td>\n<td>排除应用的Git分支</td>\n<td>可选</td>\n<td>同上</td>\n</tr>\n<tr>\n<td>tags</td>\n<td>指定执行的GitLab-Runners</td>\n<td>可选</td>\n<td>通过匹配Runners的标签选定</td>\n</tr>\n<tr>\n<td>allow_failure</td>\n<td>允许失败</td>\n<td>默认为false 如果允许失败, 本次任务不会影响整个构建的结果</td>\n</tr>\n<tr>\n<td>when</td>\n<td>定义合适执行任务</td>\n<td>默认为always</td>\n<td>有on_success, on_failure, always or manual可选</td>\n</tr>\n<tr>\n<td>dependencies</td>\n<td>定义合任务所需要的工件</td>\n<td>可空</td>\n<td>需要首先定义工件</td>\n</tr>\n<tr>\n<td>artifacts</td>\n<td>定义工件</td>\n<td>可空</td>\n<td>工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压</td>\n</tr>\n<tr>\n<td>environment</td>\n<td>定义环境</td>\n<td>可空</td>\n<td>在部署任务中, 定义该任务所属的环境</td>\n</tr>\n</tbody>\n</table>\n<p>示例<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">installing-dependencies:</div><div class=\"line\">  script:</div><div class=\"line\">    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest</div><div class=\"line\">    - composer dump-autoload --optimize</div><div class=\"line\">  artifacts:</div><div class=\"line\">    - name: &quot;vendor&quot;</div><div class=\"line\">    - untracked: true</div><div class=\"line\">    - expire_in: 60 mins</div><div class=\"line\">    - paths:</div><div class=\"line\">    - vendor/    </div><div class=\"line\">deleteocker-build-image:    </div><div class=\"line\">  stage: test</div><div class=\"line\">  only:</div><div class=\"line\">    - master</div><div class=\"line\">  except:</div><div class=\"line\">    - develop</div><div class=\"line\">  tags:</div><div class=\"line\">    - ruby</div><div class=\"line\">    - postgres</div><div class=\"line\">  allow_failure: true</div><div class=\"line\">  dependencies:</div><div class=\"line\">    - installing-dependencies</div><div class=\"line\">  script:        </div><div class=\"line\">    - docker build -t registry.com/mops/image:latest .</div><div class=\"line\">    - docker push registry.com/mops/image:latest</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意:<br>jobs的名称不能重名<br>同一阶段中的任务, 是并行执行的<br>上一阶段所有任务执行完后, 才会进入下一阶段<br>定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间<br>如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)</p>\n</blockquote>\n<h3 id=\"验证配置文件合法性\"><a href=\"#验证配置文件合法性\" class=\"headerlink\" title=\"验证配置文件合法性\"></a>验证配置文件合法性</h3><p>  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证</p>\n<h2 id=\"通过gitlab-ci实现文件的自动部署\"><a href=\"#通过gitlab-ci实现文件的自动部署\" class=\"headerlink\" title=\"通过gitlab-ci实现文件的自动部署\"></a>通过gitlab-ci实现文件的自动部署</h2><h3 id=\"实现过程\"><a href=\"#实现过程\" class=\"headerlink\" title=\"实现过程\"></a>实现过程</h3><p>  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令</p>\n<h3 id=\"过程\"><a href=\"#过程\" class=\"headerlink\" title=\"过程\"></a>过程</h3><h4 id=\"生成ssh证书\"><a href=\"#生成ssh证书\" class=\"headerlink\" title=\"生成ssh证书\"></a>生成ssh证书</h4><p>  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥<br>  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys</p>\n<h4 id=\"添加公钥\"><a href=\"#添加公钥\" class=\"headerlink\" title=\"添加公钥\"></a>添加公钥</h4><p>  添加公钥: cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>  id_rsa.pub为第一步生成的公钥<br>  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root<br>  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥</p>\n<h4 id=\"设置CI-CD变量\"><a href=\"#设置CI-CD变量\" class=\"headerlink\" title=\"设置CI/CD变量\"></a>设置CI/CD变量</h4><p>  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY<br>  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址<br>  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令<br>  完整代码<br>  <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div></pre></td><td class=\"code\"><pre><div class=\"line\"># 使用alpine镜像, 该镜像很少,只有几兆</div><div class=\"line\">image: alpine</div><div class=\"line\">stages:</div><div class=\"line\">  - deploy</div><div class=\"line\">before_script:</div><div class=\"line\">  # 预先装 ssh-agent</div><div class=\"line\">  - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</div><div class=\"line\">  # 启动服务</div><div class=\"line\">  - eval $(ssh-agent -s)</div><div class=\"line\">  # 将私钥写入deploy.key 文件</div><div class=\"line\">  - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; deploy.key</div><div class=\"line\">  # 配置较低权限</div><div class=\"line\">  - chmod 0600 deploy.key</div><div class=\"line\">  # 注入密钥</div><div class=\"line\">  - ssh-add deploy.key</div><div class=\"line\">  - mkdir -p ~/.ssh    </div><div class=\"line\">  - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</div><div class=\"line\"></div><div class=\"line\">release-doc:</div><div class=\"line\">  stage: deploy</div><div class=\"line\">  variables:</div><div class=\"line\">    GIT_STRATEGY: none     </div><div class=\"line\">  script:</div><div class=\"line\">    # 连接远程服务器并执行拉取代码的命令</div><div class=\"line\">    - ssh root@$DEPLOY_SERVER &quot;cd /path/to/wiki &amp;&amp; git pull origin master&quot;</div><div class=\"line\">  only:</div><div class=\"line\">    - master</div><div class=\"line\">  environment:</div><div class=\"line\">    name: production</div><div class=\"line\">    url: http://$DEPLOY_SERVER</div></pre></td></tr></table></figure></p>"},{"title":"lnmp源码搭建","date":"2017-05-08T14:47:02.000Z","_content":"## mysql源码安装\n1.安装编译源码需要的包\n``` shell\nsudo apt-get install make cmake gcc g++ bison libncurses5-dev\n```\n2.下载相应源码包\n``` shell\n[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz\n[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz\n```\n3.新建MySQL用户和用户组\n``` shell\n[root@graychen ~]# groupadd -r mysql && useradd -r -g mysql -s /sbin/nologin -M mysql\n```\n4.预编译\n\n``` shell\n[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz\n[root@graychen data]# md5sum mysql-5.7.13.tar.gz \n8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz\n[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz\n[root@graychen data]# mkdir -p /data/mysql\n[root@graychen data]# cd mysql-5.7.13\n[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\n-DMYSQL_DATADIR=/data/mysql \\\n-DWITH_BOOST=../boost_1_59_0 \\\n-DSYSCONFDIR=/etc \\\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\n-DWITH_PARTITION_STORAGE_ENGINE=1 \\\n-DWITH_FEDERATED_STORAGE_ENGINE=1 \\\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\n-DWITH_MYISAM_STORAGE_ENGINE=1 \\\n-DENABLED_LOCAL_INFILE=1 \\\n-DENABLE_DTRACE=0 \\\n-DDEFAULT_CHARSET=utf8mb4 \\\n-DDEFAULT_COLLATION=utf8mb4_general_ci \\\n-DWITH_EMBEDDED_SERVER=1\n```\n5.编译安装\n\n<!--more-->\n``` shell\n[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`\n#编译很消耗系统资源，小内存可能编译通不过make install\n[root@graychen mysql-5.7.13]# make install\n```\n6.设置启动脚本，开机自启动\n\n``` shell\n[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql\n[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# systemctl enable mysqld\nmysqld.service is not a native service, redirecting to /sbin/chkconfig.\nExecuting /sbin/chkconfig mysqld on\n```\n7.配置文件\n\n``` shell\n/etc/my.cnf，仅供参考 \n[root@graychen mysql-5.7.13]# cat > /etc/my.cnf << EOF\n[client]\nport = 3306\nsocket = /dev/shm/mysql.sock\n[mysqld]\nport = 3306\nsocket = /dev/shm/mysql.sock\nbasedir = /usr/local/mysql\ndatadir = /data/mysql\npid-file = /data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\ninit-connect = 'SET NAMES utf8mb4'\ncharacter-set-server = utf8mb4\n#skip-name-resolve\n#skip-networking\nback_log = 300\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\nthread_cache_size = 8\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\nft_min_word_len = 4\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\nlog_error = /data/mysql/mysql-error.log\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /data/mysql/mysql-slow.log\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n#lower_case_table_names = 1\nskip-external-locking\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\ninteractive_timeout = 28800\nwait_timeout = 28800\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\nEOF\n```\n9.添加mysql的环境变量\n\n``` shell\n[root@graychen mysql-5.7.13]# echo -e '\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n' >> /etc/profile && source /etc/profile\n```\n10.初始化数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql\n```\n11.启动数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# systemctl start mysqld\n[root@graychen mysql-5.7.13]# systemctl status mysqld\n● mysqld.service - LSB: start and stop MySQL\nLoaded: loaded (/etc/rc.d/init.d/mysqld)\nActive: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago\nDocs: man:systemd-sysv-generator(8)\nProcess: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)\nCGroup: /system.slice/mysqld.service\n├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\n└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...\n\n7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...\n7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]\n7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.\n```\n12.查看MySQL服务进程和端口\n``` shell\n[root@graychen mysql-5.7.13]# ps -ef | grep mysql\nroot     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\nmysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306\n[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld\n```\n13.设置数据库root用户密码\n\nMySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！\n\n``` shell\n[root@graychen mysql-5.7.13]# mysql_secure_installation\n```\n## php源码安装\n\n1.安装编译源码\n``` shell\nwget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror\ntar jxvf php-7.1.4.tar.bz2 \nbzip2 -d php-7.1.4.tar.bz2 \ncd php-7.1.4/\n./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr\nsudo make test\nsudo make install\n```\n2.配置php.ini\n```\ncp php.ini-development /usr/local/php/etc/php.ini\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n3.配置php-fpm.conf\n```\ncd /usr/local/php/etc/\nmv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n4.配置php-fpm开机启动\n```\ncd ~/src/php-7.1.4/sapi/fpm\nsudo cp init.d.php-fpm /etc/init.d/php-fpm\nsudo chmod +x /etc/init.d/php-fpm \nchkconfig --add php-fpm\nsystemctl --add php-fpm\nsudo /sbin/chkconfig\nsudo vi /etc/init.d/php-fpm\nupdate-rc.d -f php-fpm defaults\nrunlevel\nsudo service php-fpm start\n```\n## nginx源码安装\n1.下载源码\n```\nwget http://nginx.org/download/nginx-1.11.2.tar.gz\ntar -xzvf nginx-1.11.2.tar.gz -C /usr/src\n```\n2.安装依赖\n```\nsudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev\n```\n3.编译安装源码\n```\ncd /usr/src/nginx-1.11.2\n# 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译\n./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module\n# make是生成在objs目录中，make install则安装到prefix所示的目录中\nmake && make install\n# 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。\n```\n>成功安装后，进入/usr/local/nginx，可以看到4个目录：\n```\nroot@graychen:/usr/local/nginx# ll\ntotal 44\ndrwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./\ndrwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/\n```\n其中，\n\n conf：放置nginx相关的配置文件，最核心的是nginx.conf\n html：默认的网站根目录\n logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)\n sbin：主程序(nginx)目录\n4.配置Nginx开机自启动\nUbuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下\n> * vi /etc/init.d/nginx ,其中具体的脚本展示如下：\n```\n[plain] view plain copy\n\n #!/bin/bash\n # nginx Startup script for the Nginx HTTP Server\n # it is v.0.0.2 version.\n # chkconfig: - 85 15\n # description: Nginx is a high-performance web and proxy server.\n #              It has a lot of features, but it's not for everyone.\n # processname: nginx\n # pidfile: /var/run/nginx.pid\n # config: /usr/local/nginx/conf/nginx.conf\n\n #注意：这里的三个变量需要根据具体的环境而做修改。\n nginxd=/opt/nginx/sbin/nginx\n nginx_config=/opt/nginx/conf/nginx.conf\n nginx_pid=/opt/nginx/logs/nginx.pid\n RETVAL=0\n prog=\"nginx\"\n\n # Check that networking is up.\n [ -x $nginxd  ] || exit 0\n # Start nginx daemons functions.\n start() {\n     if [ -e $nginx_pid  ];then\n        echo \"nginx already running....\"\n        exit 1\n     fi\n        echo -n $\"Starting $prog: \"\n        $nginxd -c ${nginx_config}\n        RETVAL=$?\n        echo\n        [ $RETVAL = 0  ]\n        return $RETVAL\n     \n}\n # Stop nginx daemons functions.\n stop() {\n       echo -n $\"Stopping $prog: \"\n       $nginxd -s stop\n       RETVAL=$?\n       echo\n       [ $RETVAL = 0  ] && rm -f /var/lock/subsys/nginx $nginx_pid\n     \n}\n # reload nginx service functions.\n reload() {\n       echo -n $\"Reloading $prog: \"\n       kill -HUP `cat ${nginx_pid}`\n       RETVAL=$?\n       echo\n     \n}\n # See how we were called.\n case \"$1\" in\n   start)\n           start\n           ;;\n   stop)\n           stop\n           ;;\n   reload)\n           reload\n           ;;\n   restart)\n           stop\n           start\n           ;;\n   status)\n           status $prog\n           RETVAL=$?\n           ;;\n   *)\n           echo $\"Usage: $prog {start|stop|restart|reload|status|help}\"\n           exit 1\n esac\n exit $RETVAL\n```\n> * sudo chmod a+x /etc/init.d/nginx\n> * 在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start\n最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。\n\n\n到这里整个LNMP已经安装完成.\n## nginx和php的关联\n下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:\n``` shell\ncp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development\ncp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf\nln -s /usr/local/php/bin/php /usr/bin/\n```\n配置php-fpm,编辑php-fpm.conf\n\n``` shell\nvi /usr/local/php/etc/php-fpm.conf\n```\n找到listen那一行,修改成如下内容:\n\n``` shell\nlisten = /var/run/php-fpm/php-fpm.sock   # 使用unix socket\n```\n启动php-fpm\n\n``` shell\nmkdir /var/run/php-fpm\n/usr/local/php/sbin/php-fpm\n```\n然后配置nginx,编辑nginx配置文件\n\n``` shell\nvi /usr/local/nginx/conf/nginx.conf\n```\n修改nginx配置文件支持php:\n``` shell\nserver {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.php index.html index.htm;         # 添加index.php的首页文件\n        }\n\n        # 添加下面内容\n        location ~ \\.php$ {\n            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;\n            fastcgi_index       index.php;\n            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;\n            include fastcgi_params;\n            include fastcgi.conf;\n}\n```\n修改完毕后保存退出重启nginx:\n\npkill -9 nignx\n/usr/local/nginx/sbin/nginx\n然后在/usr/local/nginx/html下创建index.php,\n\nvi /usr/local/nginx/html/index.php\n添加下面内容:\n``` php\n<?php\nphpinfo();\n?>\n} \n```\n保存退出后访问http://localhost/index.php,看到下面页面表示已经安装配置成功:\n\n![php页面](/assets/blogImg/php.png)\n\n\n","source":"_posts/lnmp源码搭建.md","raw":"---\ntitle: lnmp源码搭建\ndate: 2017-05-08 22:47:02\ncategories: 技术\n---\n## mysql源码安装\n1.安装编译源码需要的包\n``` shell\nsudo apt-get install make cmake gcc g++ bison libncurses5-dev\n```\n2.下载相应源码包\n``` shell\n[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz\n[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz\n```\n3.新建MySQL用户和用户组\n``` shell\n[root@graychen ~]# groupadd -r mysql && useradd -r -g mysql -s /sbin/nologin -M mysql\n```\n4.预编译\n\n``` shell\n[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz\n[root@graychen data]# md5sum mysql-5.7.13.tar.gz \n8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz\n[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz\n[root@graychen data]# mkdir -p /data/mysql\n[root@graychen data]# cd mysql-5.7.13\n[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\\n-DMYSQL_DATADIR=/data/mysql \\\n-DWITH_BOOST=../boost_1_59_0 \\\n-DSYSCONFDIR=/etc \\\n-DWITH_INNOBASE_STORAGE_ENGINE=1 \\\n-DWITH_PARTITION_STORAGE_ENGINE=1 \\\n-DWITH_FEDERATED_STORAGE_ENGINE=1 \\\n-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\\n-DWITH_MYISAM_STORAGE_ENGINE=1 \\\n-DENABLED_LOCAL_INFILE=1 \\\n-DENABLE_DTRACE=0 \\\n-DDEFAULT_CHARSET=utf8mb4 \\\n-DDEFAULT_COLLATION=utf8mb4_general_ci \\\n-DWITH_EMBEDDED_SERVER=1\n```\n5.编译安装\n\n<!--more-->\n``` shell\n[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`\n#编译很消耗系统资源，小内存可能编译通不过make install\n[root@graychen mysql-5.7.13]# make install\n```\n6.设置启动脚本，开机自启动\n\n``` shell\n[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql\n[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld\n[root@graychen mysql-5.7.13]# systemctl enable mysqld\nmysqld.service is not a native service, redirecting to /sbin/chkconfig.\nExecuting /sbin/chkconfig mysqld on\n```\n7.配置文件\n\n``` shell\n/etc/my.cnf，仅供参考 \n[root@graychen mysql-5.7.13]# cat > /etc/my.cnf << EOF\n[client]\nport = 3306\nsocket = /dev/shm/mysql.sock\n[mysqld]\nport = 3306\nsocket = /dev/shm/mysql.sock\nbasedir = /usr/local/mysql\ndatadir = /data/mysql\npid-file = /data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\ninit-connect = 'SET NAMES utf8mb4'\ncharacter-set-server = utf8mb4\n#skip-name-resolve\n#skip-networking\nback_log = 300\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\nthread_cache_size = 8\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\nft_min_word_len = 4\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\nlog_error = /data/mysql/mysql-error.log\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /data/mysql/mysql-slow.log\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n#lower_case_table_names = 1\nskip-external-locking\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\ninteractive_timeout = 28800\nwait_timeout = 28800\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\nEOF\n```\n9.添加mysql的环境变量\n\n``` shell\n[root@graychen mysql-5.7.13]# echo -e '\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n' >> /etc/profile && source /etc/profile\n```\n10.初始化数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql\n```\n11.启动数据库\n\n``` shell\n[root@graychen mysql-5.7.13]# systemctl start mysqld\n[root@graychen mysql-5.7.13]# systemctl status mysqld\n● mysqld.service - LSB: start and stop MySQL\nLoaded: loaded (/etc/rc.d/init.d/mysqld)\nActive: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago\nDocs: man:systemd-sysv-generator(8)\nProcess: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)\nCGroup: /system.slice/mysqld.service\n├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\n└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...\n\n7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...\n7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]\n7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.\n```\n12.查看MySQL服务进程和端口\n``` shell\n[root@graychen mysql-5.7.13]# ps -ef | grep mysql\nroot     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid\nmysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306\n[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306\ntcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld\n```\n13.设置数据库root用户密码\n\nMySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！\n\n``` shell\n[root@graychen mysql-5.7.13]# mysql_secure_installation\n```\n## php源码安装\n\n1.安装编译源码\n``` shell\nwget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror\ntar jxvf php-7.1.4.tar.bz2 \nbzip2 -d php-7.1.4.tar.bz2 \ncd php-7.1.4/\n./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr\nsudo make test\nsudo make install\n```\n2.配置php.ini\n```\ncp php.ini-development /usr/local/php/etc/php.ini\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n3.配置php-fpm.conf\n```\ncd /usr/local/php/etc/\nmv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.conf.default php-fpm.conf\nsudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf\n```\n4.配置php-fpm开机启动\n```\ncd ~/src/php-7.1.4/sapi/fpm\nsudo cp init.d.php-fpm /etc/init.d/php-fpm\nsudo chmod +x /etc/init.d/php-fpm \nchkconfig --add php-fpm\nsystemctl --add php-fpm\nsudo /sbin/chkconfig\nsudo vi /etc/init.d/php-fpm\nupdate-rc.d -f php-fpm defaults\nrunlevel\nsudo service php-fpm start\n```\n## nginx源码安装\n1.下载源码\n```\nwget http://nginx.org/download/nginx-1.11.2.tar.gz\ntar -xzvf nginx-1.11.2.tar.gz -C /usr/src\n```\n2.安装依赖\n```\nsudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev\n```\n3.编译安装源码\n```\ncd /usr/src/nginx-1.11.2\n# 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译\n./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module\n# make是生成在objs目录中，make install则安装到prefix所示的目录中\nmake && make install\n# 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。\n```\n>成功安装后，进入/usr/local/nginx，可以看到4个目录：\n```\nroot@graychen:/usr/local/nginx# ll\ntotal 44\ndrwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./\ndrwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/\ndrwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/\n```\n其中，\n\n conf：放置nginx相关的配置文件，最核心的是nginx.conf\n html：默认的网站根目录\n logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)\n sbin：主程序(nginx)目录\n4.配置Nginx开机自启动\nUbuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下\n> * vi /etc/init.d/nginx ,其中具体的脚本展示如下：\n```\n[plain] view plain copy\n\n #!/bin/bash\n # nginx Startup script for the Nginx HTTP Server\n # it is v.0.0.2 version.\n # chkconfig: - 85 15\n # description: Nginx is a high-performance web and proxy server.\n #              It has a lot of features, but it's not for everyone.\n # processname: nginx\n # pidfile: /var/run/nginx.pid\n # config: /usr/local/nginx/conf/nginx.conf\n\n #注意：这里的三个变量需要根据具体的环境而做修改。\n nginxd=/opt/nginx/sbin/nginx\n nginx_config=/opt/nginx/conf/nginx.conf\n nginx_pid=/opt/nginx/logs/nginx.pid\n RETVAL=0\n prog=\"nginx\"\n\n # Check that networking is up.\n [ -x $nginxd  ] || exit 0\n # Start nginx daemons functions.\n start() {\n     if [ -e $nginx_pid  ];then\n        echo \"nginx already running....\"\n        exit 1\n     fi\n        echo -n $\"Starting $prog: \"\n        $nginxd -c ${nginx_config}\n        RETVAL=$?\n        echo\n        [ $RETVAL = 0  ]\n        return $RETVAL\n     \n}\n # Stop nginx daemons functions.\n stop() {\n       echo -n $\"Stopping $prog: \"\n       $nginxd -s stop\n       RETVAL=$?\n       echo\n       [ $RETVAL = 0  ] && rm -f /var/lock/subsys/nginx $nginx_pid\n     \n}\n # reload nginx service functions.\n reload() {\n       echo -n $\"Reloading $prog: \"\n       kill -HUP `cat ${nginx_pid}`\n       RETVAL=$?\n       echo\n     \n}\n # See how we were called.\n case \"$1\" in\n   start)\n           start\n           ;;\n   stop)\n           stop\n           ;;\n   reload)\n           reload\n           ;;\n   restart)\n           stop\n           start\n           ;;\n   status)\n           status $prog\n           RETVAL=$?\n           ;;\n   *)\n           echo $\"Usage: $prog {start|stop|restart|reload|status|help}\"\n           exit 1\n esac\n exit $RETVAL\n```\n> * sudo chmod a+x /etc/init.d/nginx\n> * 在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start\n最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。\n\n\n到这里整个LNMP已经安装完成.\n## nginx和php的关联\n下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:\n``` shell\ncp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development\ncp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf\nln -s /usr/local/php/bin/php /usr/bin/\n```\n配置php-fpm,编辑php-fpm.conf\n\n``` shell\nvi /usr/local/php/etc/php-fpm.conf\n```\n找到listen那一行,修改成如下内容:\n\n``` shell\nlisten = /var/run/php-fpm/php-fpm.sock   # 使用unix socket\n```\n启动php-fpm\n\n``` shell\nmkdir /var/run/php-fpm\n/usr/local/php/sbin/php-fpm\n```\n然后配置nginx,编辑nginx配置文件\n\n``` shell\nvi /usr/local/nginx/conf/nginx.conf\n```\n修改nginx配置文件支持php:\n``` shell\nserver {\n        listen       80;\n        server_name  localhost;\n\n        #charset koi8-r;\n\n        #access_log  logs/host.access.log  main;\n\n        location / {\n            root   html;\n            index  index.php index.html index.htm;         # 添加index.php的首页文件\n        }\n\n        # 添加下面内容\n        location ~ \\.php$ {\n            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;\n            fastcgi_index       index.php;\n            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;\n            include fastcgi_params;\n            include fastcgi.conf;\n}\n```\n修改完毕后保存退出重启nginx:\n\npkill -9 nignx\n/usr/local/nginx/sbin/nginx\n然后在/usr/local/nginx/html下创建index.php,\n\nvi /usr/local/nginx/html/index.php\n添加下面内容:\n``` php\n<?php\nphpinfo();\n?>\n} \n```\n保存退出后访问http://localhost/index.php,看到下面页面表示已经安装配置成功:\n\n![php页面](/assets/blogImg/php.png)\n\n\n","slug":"lnmp源码搭建","published":1,"updated":"2017-12-10T12:38:46.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q16000bto7yjfxyplbx","content":"<h2 id=\"mysql源码安装\"><a href=\"#mysql源码安装\" class=\"headerlink\" title=\"mysql源码安装\"></a>mysql源码安装</h2><p>1.安装编译源码需要的包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install make cmake gcc g++ bison libncurses5-dev</div></pre></td></tr></table></figure></p>\n<p>2.下载相应源码包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz</div><div class=\"line\">[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz</div></pre></td></tr></table></figure></p>\n<p>3.新建MySQL用户和用户组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen ~]# groupadd -r mysql &amp;&amp; useradd -r -g mysql -s /sbin/nologin -M mysql</div></pre></td></tr></table></figure></p>\n<p>4.预编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz</div><div class=\"line\">[root@graychen data]# md5sum mysql-5.7.13.tar.gz </div><div class=\"line\">8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz</div><div class=\"line\">[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz</div><div class=\"line\">[root@graychen data]# mkdir -p /data/mysql</div><div class=\"line\">[root@graychen data]# cd mysql-5.7.13</div><div class=\"line\">[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\</div><div class=\"line\">-DMYSQL_DATADIR=/data/mysql \\</div><div class=\"line\">-DWITH_BOOST=../boost_1_59_0 \\</div><div class=\"line\">-DSYSCONFDIR=/etc \\</div><div class=\"line\">-DWITH_INNOBASE_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_PARTITION_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_FEDERATED_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_MYISAM_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DENABLED_LOCAL_INFILE=1 \\</div><div class=\"line\">-DENABLE_DTRACE=0 \\</div><div class=\"line\">-DDEFAULT_CHARSET=utf8mb4 \\</div><div class=\"line\">-DDEFAULT_COLLATION=utf8mb4_general_ci \\</div><div class=\"line\">-DWITH_EMBEDDED_SERVER=1</div></pre></td></tr></table></figure>\n<p>5.编译安装</p>\n<a id=\"more\"></a>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`</div><div class=\"line\">#编译很消耗系统资源，小内存可能编译通不过make install</div><div class=\"line\">[root@graychen mysql-5.7.13]# make install</div></pre></td></tr></table></figure>\n<p>6.设置启动脚本，开机自启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql</div><div class=\"line\">[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</div><div class=\"line\">[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld</div><div class=\"line\">[root@graychen mysql-5.7.13]# systemctl enable mysqld</div><div class=\"line\">mysqld.service is not a native service, redirecting to /sbin/chkconfig.</div><div class=\"line\">Executing /sbin/chkconfig mysqld on</div></pre></td></tr></table></figure>\n<p>7.配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">/etc/my.cnf，仅供参考 </div><div class=\"line\">[root@graychen mysql-5.7.13]# cat &gt; /etc/my.cnf &lt;&lt; EOF</div><div class=\"line\">[client]</div><div class=\"line\">port = 3306</div><div class=\"line\">socket = /dev/shm/mysql.sock</div><div class=\"line\">[mysqld]</div><div class=\"line\">port = 3306</div><div class=\"line\">socket = /dev/shm/mysql.sock</div><div class=\"line\">basedir = /usr/local/mysql</div><div class=\"line\">datadir = /data/mysql</div><div class=\"line\">pid-file = /data/mysql/mysql.pid</div><div class=\"line\">user = mysql</div><div class=\"line\">bind-address = 0.0.0.0</div><div class=\"line\">server-id = 1</div><div class=\"line\">init-connect = &apos;SET NAMES utf8mb4&apos;</div><div class=\"line\">character-set-server = utf8mb4</div><div class=\"line\">#skip-name-resolve</div><div class=\"line\">#skip-networking</div><div class=\"line\">back_log = 300</div><div class=\"line\">max_connections = 1000</div><div class=\"line\">max_connect_errors = 6000</div><div class=\"line\">open_files_limit = 65535</div><div class=\"line\">table_open_cache = 128</div><div class=\"line\">max_allowed_packet = 4M</div><div class=\"line\">binlog_cache_size = 1M</div><div class=\"line\">max_heap_table_size = 8M</div><div class=\"line\">tmp_table_size = 16M</div><div class=\"line\">read_buffer_size = 2M</div><div class=\"line\">read_rnd_buffer_size = 8M</div><div class=\"line\">sort_buffer_size = 8M</div><div class=\"line\">join_buffer_size = 8M</div><div class=\"line\">key_buffer_size = 4M</div><div class=\"line\">thread_cache_size = 8</div><div class=\"line\">query_cache_type = 1</div><div class=\"line\">query_cache_size = 8M</div><div class=\"line\">query_cache_limit = 2M</div><div class=\"line\">ft_min_word_len = 4</div><div class=\"line\">log_bin = mysql-bin</div><div class=\"line\">binlog_format = mixed</div><div class=\"line\">expire_logs_days = 30</div><div class=\"line\">log_error = /data/mysql/mysql-error.log</div><div class=\"line\">slow_query_log = 1</div><div class=\"line\">long_query_time = 1</div><div class=\"line\">slow_query_log_file = /data/mysql/mysql-slow.log</div><div class=\"line\">performance_schema = 0</div><div class=\"line\">explicit_defaults_for_timestamp</div><div class=\"line\">#lower_case_table_names = 1</div><div class=\"line\">skip-external-locking</div><div class=\"line\">default_storage_engine = InnoDB</div><div class=\"line\">#default-storage-engine = MyISAM</div><div class=\"line\">innodb_file_per_table = 1</div><div class=\"line\">innodb_open_files = 500</div><div class=\"line\">innodb_buffer_pool_size = 64M</div><div class=\"line\">innodb_write_io_threads = 4</div><div class=\"line\">innodb_read_io_threads = 4</div><div class=\"line\">innodb_thread_concurrency = 0</div><div class=\"line\">innodb_purge_threads = 1</div><div class=\"line\">innodb_flush_log_at_trx_commit = 2</div><div class=\"line\">innodb_log_buffer_size = 2M</div><div class=\"line\">innodb_log_file_size = 32M</div><div class=\"line\">innodb_log_files_in_group = 3</div><div class=\"line\">innodb_max_dirty_pages_pct = 90</div><div class=\"line\">innodb_lock_wait_timeout = 120</div><div class=\"line\">bulk_insert_buffer_size = 8M</div><div class=\"line\">myisam_sort_buffer_size = 8M</div><div class=\"line\">myisam_max_sort_file_size = 10G</div><div class=\"line\">myisam_repair_threads = 1</div><div class=\"line\">interactive_timeout = 28800</div><div class=\"line\">wait_timeout = 28800</div><div class=\"line\">[mysqldump]</div><div class=\"line\">quick</div><div class=\"line\">max_allowed_packet = 16M</div><div class=\"line\">[myisamchk]</div><div class=\"line\">key_buffer_size = 8M</div><div class=\"line\">sort_buffer_size = 8M</div><div class=\"line\">read_buffer = 4M</div><div class=\"line\">write_buffer = 4M</div><div class=\"line\">EOF</div></pre></td></tr></table></figure>\n<p>9.添加mysql的环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# echo -e &apos;\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n&apos; &gt;&gt; /etc/profile &amp;&amp; source /etc/profile</div></pre></td></tr></table></figure>\n<p>10.初始化数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql</div></pre></td></tr></table></figure>\n<p>11.启动数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# systemctl start mysqld</div><div class=\"line\">[root@graychen mysql-5.7.13]# systemctl status mysqld</div><div class=\"line\">● mysqld.service - LSB: start and stop MySQL</div><div class=\"line\">Loaded: loaded (/etc/rc.d/init.d/mysqld)</div><div class=\"line\">Active: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago</div><div class=\"line\">Docs: man:systemd-sysv-generator(8)</div><div class=\"line\">Process: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)</div><div class=\"line\">CGroup: /system.slice/mysqld.service</div><div class=\"line\">├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</div><div class=\"line\">└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...</div><div class=\"line\"></div><div class=\"line\">7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...</div><div class=\"line\">7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]</div><div class=\"line\">7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.</div></pre></td></tr></table></figure>\n<p>12.查看MySQL服务进程和端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# ps -ef | grep mysql</div><div class=\"line\">root     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</div><div class=\"line\">mysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306</div><div class=\"line\">[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306</div><div class=\"line\">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld</div></pre></td></tr></table></figure></p>\n<p>13.设置数据库root用户密码</p>\n<p>MySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# mysql_secure_installation</div></pre></td></tr></table></figure>\n<h2 id=\"php源码安装\"><a href=\"#php源码安装\" class=\"headerlink\" title=\"php源码安装\"></a>php源码安装</h2><p>1.安装编译源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror</div><div class=\"line\">tar jxvf php-7.1.4.tar.bz2 </div><div class=\"line\">bzip2 -d php-7.1.4.tar.bz2 </div><div class=\"line\">cd php-7.1.4/</div><div class=\"line\">./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr</div><div class=\"line\">sudo make test</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure></p>\n<p>2.配置php.ini<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp php.ini-development /usr/local/php/etc/php.ini</div><div class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</div></pre></td></tr></table></figure></p>\n<p>3.配置php-fpm.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /usr/local/php/etc/</div><div class=\"line\">mv php-fpm.conf.default php-fpm.conf</div><div class=\"line\">sudo mv php-fpm.conf.default php-fpm.conf</div><div class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</div></pre></td></tr></table></figure></p>\n<p>4.配置php-fpm开机启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/src/php-7.1.4/sapi/fpm</div><div class=\"line\">sudo cp init.d.php-fpm /etc/init.d/php-fpm</div><div class=\"line\">sudo chmod +x /etc/init.d/php-fpm </div><div class=\"line\">chkconfig --add php-fpm</div><div class=\"line\">systemctl --add php-fpm</div><div class=\"line\">sudo /sbin/chkconfig</div><div class=\"line\">sudo vi /etc/init.d/php-fpm</div><div class=\"line\">update-rc.d -f php-fpm defaults</div><div class=\"line\">runlevel</div><div class=\"line\">sudo service php-fpm start</div></pre></td></tr></table></figure></p>\n<h2 id=\"nginx源码安装\"><a href=\"#nginx源码安装\" class=\"headerlink\" title=\"nginx源码安装\"></a>nginx源码安装</h2><p>1.下载源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://nginx.org/download/nginx-1.11.2.tar.gz</div><div class=\"line\">tar -xzvf nginx-1.11.2.tar.gz -C /usr/src</div></pre></td></tr></table></figure></p>\n<p>2.安装依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev</div></pre></td></tr></table></figure></p>\n<p>3.编译安装源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /usr/src/nginx-1.11.2</div><div class=\"line\"># 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译</div><div class=\"line\">./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module</div><div class=\"line\"># make是生成在objs目录中，make install则安装到prefix所示的目录中</div><div class=\"line\">make &amp;&amp; make install</div><div class=\"line\"># 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>成功安装后，进入/usr/local/nginx，可以看到4个目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@graychen:/usr/local/nginx# ll</div><div class=\"line\">total 44</div><div class=\"line\">drwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./</div><div class=\"line\">drwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>其中，</p>\n<p> conf：放置nginx相关的配置文件，最核心的是nginx.conf<br> html：默认的网站根目录<br> logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)<br> sbin：主程序(nginx)目录<br>4.配置Nginx开机自启动<br>Ubuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下</p>\n<blockquote>\n<ul>\n<li><p>vi /etc/init.d/nginx ,其中具体的脚本展示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">[plain] view plain copy</div><div class=\"line\"></div><div class=\"line\"> #!/bin/bash</div><div class=\"line\"> # nginx Startup script for the Nginx HTTP Server</div><div class=\"line\"> # it is v.0.0.2 version.</div><div class=\"line\"> # chkconfig: - 85 15</div><div class=\"line\"> # description: Nginx is a high-performance web and proxy server.</div><div class=\"line\"> #              It has a lot of features, but it&apos;s not for everyone.</div><div class=\"line\"> # processname: nginx</div><div class=\"line\"> # pidfile: /var/run/nginx.pid</div><div class=\"line\"> # config: /usr/local/nginx/conf/nginx.conf</div><div class=\"line\"></div><div class=\"line\"> #注意：这里的三个变量需要根据具体的环境而做修改。</div><div class=\"line\"> nginxd=/opt/nginx/sbin/nginx</div><div class=\"line\"> nginx_config=/opt/nginx/conf/nginx.conf</div><div class=\"line\"> nginx_pid=/opt/nginx/logs/nginx.pid</div><div class=\"line\"> RETVAL=0</div><div class=\"line\"> prog=&quot;nginx&quot;</div><div class=\"line\"></div><div class=\"line\"> # Check that networking is up.</div><div class=\"line\"> [ -x $nginxd  ] || exit 0</div><div class=\"line\"> # Start nginx daemons functions.</div><div class=\"line\"> start() &#123;</div><div class=\"line\">     if [ -e $nginx_pid  ];then</div><div class=\"line\">        echo &quot;nginx already running....&quot;</div><div class=\"line\">        exit 1</div><div class=\"line\">     fi</div><div class=\"line\">        echo -n $&quot;Starting $prog: &quot;</div><div class=\"line\">        $nginxd -c $&#123;nginx_config&#125;</div><div class=\"line\">        RETVAL=$?</div><div class=\"line\">        echo</div><div class=\"line\">        [ $RETVAL = 0  ]</div><div class=\"line\">        return $RETVAL</div><div class=\"line\">     </div><div class=\"line\">&#125;</div><div class=\"line\"> # Stop nginx daemons functions.</div><div class=\"line\"> stop() &#123;</div><div class=\"line\">       echo -n $&quot;Stopping $prog: &quot;</div><div class=\"line\">       $nginxd -s stop</div><div class=\"line\">       RETVAL=$?</div><div class=\"line\">       echo</div><div class=\"line\">       [ $RETVAL = 0  ] &amp;&amp; rm -f /var/lock/subsys/nginx $nginx_pid</div><div class=\"line\">     </div><div class=\"line\">&#125;</div><div class=\"line\"> # reload nginx service functions.</div><div class=\"line\"> reload() &#123;</div><div class=\"line\">       echo -n $&quot;Reloading $prog: &quot;</div><div class=\"line\">       kill -HUP `cat $&#123;nginx_pid&#125;`</div><div class=\"line\">       RETVAL=$?</div><div class=\"line\">       echo</div><div class=\"line\">     </div><div class=\"line\">&#125;</div><div class=\"line\"> # See how we were called.</div><div class=\"line\"> case &quot;$1&quot; in</div><div class=\"line\">   start)</div><div class=\"line\">           start</div><div class=\"line\">           ;;</div><div class=\"line\">   stop)</div><div class=\"line\">           stop</div><div class=\"line\">           ;;</div><div class=\"line\">   reload)</div><div class=\"line\">           reload</div><div class=\"line\">           ;;</div><div class=\"line\">   restart)</div><div class=\"line\">           stop</div><div class=\"line\">           start</div><div class=\"line\">           ;;</div><div class=\"line\">   status)</div><div class=\"line\">           status $prog</div><div class=\"line\">           RETVAL=$?</div><div class=\"line\">           ;;</div><div class=\"line\">   *)</div><div class=\"line\">           echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</div><div class=\"line\">           exit 1</div><div class=\"line\"> esac</div><div class=\"line\"> exit $RETVAL</div></pre></td></tr></table></figure>\n</li>\n<li><p>sudo chmod a+x /etc/init.d/nginx</p>\n</li>\n<li>在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start<br>最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。</li>\n</ul>\n</blockquote>\n<p>到这里整个LNMP已经安装完成.</p>\n<h2 id=\"nginx和php的关联\"><a href=\"#nginx和php的关联\" class=\"headerlink\" title=\"nginx和php的关联\"></a>nginx和php的关联</h2><p>下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development</div><div class=\"line\">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</div><div class=\"line\">ln -s /usr/local/php/bin/php /usr/bin/</div></pre></td></tr></table></figure></p>\n<p>配置php-fpm,编辑php-fpm.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /usr/local/php/etc/php-fpm.conf</div></pre></td></tr></table></figure>\n<p>找到listen那一行,修改成如下内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">listen = /var/run/php-fpm/php-fpm.sock   # 使用unix socket</div></pre></td></tr></table></figure>\n<p>启动php-fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /var/run/php-fpm</div><div class=\"line\">/usr/local/php/sbin/php-fpm</div></pre></td></tr></table></figure>\n<p>然后配置nginx,编辑nginx配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /usr/local/nginx/conf/nginx.conf</div></pre></td></tr></table></figure>\n<p>修改nginx配置文件支持php:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">        listen       80;</div><div class=\"line\">        server_name  localhost;</div><div class=\"line\"></div><div class=\"line\">        #charset koi8-r;</div><div class=\"line\"></div><div class=\"line\">        #access_log  logs/host.access.log  main;</div><div class=\"line\"></div><div class=\"line\">        location / &#123;</div><div class=\"line\">            root   html;</div><div class=\"line\">            index  index.php index.html index.htm;         # 添加index.php的首页文件</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        # 添加下面内容</div><div class=\"line\">        location ~ \\.php$ &#123;</div><div class=\"line\">            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;</div><div class=\"line\">            fastcgi_index       index.php;</div><div class=\"line\">            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;</div><div class=\"line\">            include fastcgi_params;</div><div class=\"line\">            include fastcgi.conf;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>修改完毕后保存退出重启nginx:</p>\n<p>pkill -9 nignx<br>/usr/local/nginx/sbin/nginx<br>然后在/usr/local/nginx/html下创建index.php,</p>\n<p>vi /usr/local/nginx/html/index.php<br>添加下面内容:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">phpinfo();</div><div class=\"line\"><span class=\"meta\">?&gt;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>保存退出后访问<a href=\"http://localhost/index.php,看到下面页面表示已经安装配置成功\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php,看到下面页面表示已经安装配置成功</a>:</p>\n<p><img src=\"/assets/blogImg/php.png\" alt=\"php页面\"></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"mysql源码安装\"><a href=\"#mysql源码安装\" class=\"headerlink\" title=\"mysql源码安装\"></a>mysql源码安装</h2><p>1.安装编译源码需要的包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install make cmake gcc g++ bison libncurses5-dev</div></pre></td></tr></table></figure></p>\n<p>2.下载相应源码包<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz</div><div class=\"line\">[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz</div></pre></td></tr></table></figure></p>\n<p>3.新建MySQL用户和用户组<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen ~]# groupadd -r mysql &amp;&amp; useradd -r -g mysql -s /sbin/nologin -M mysql</div></pre></td></tr></table></figure></p>\n<p>4.预编译</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz</div><div class=\"line\">[root@graychen data]# md5sum mysql-5.7.13.tar.gz </div><div class=\"line\">8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz</div><div class=\"line\">[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz</div><div class=\"line\">[root@graychen data]# mkdir -p /data/mysql</div><div class=\"line\">[root@graychen data]# cd mysql-5.7.13</div><div class=\"line\">[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \\</div><div class=\"line\">-DMYSQL_DATADIR=/data/mysql \\</div><div class=\"line\">-DWITH_BOOST=../boost_1_59_0 \\</div><div class=\"line\">-DSYSCONFDIR=/etc \\</div><div class=\"line\">-DWITH_INNOBASE_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_PARTITION_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_FEDERATED_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DWITH_MYISAM_STORAGE_ENGINE=1 \\</div><div class=\"line\">-DENABLED_LOCAL_INFILE=1 \\</div><div class=\"line\">-DENABLE_DTRACE=0 \\</div><div class=\"line\">-DDEFAULT_CHARSET=utf8mb4 \\</div><div class=\"line\">-DDEFAULT_COLLATION=utf8mb4_general_ci \\</div><div class=\"line\">-DWITH_EMBEDDED_SERVER=1</div></pre></td></tr></table></figure>\n<p>5.编译安装</p>","more":"<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`</div><div class=\"line\">#编译很消耗系统资源，小内存可能编译通不过make install</div><div class=\"line\">[root@graychen mysql-5.7.13]# make install</div></pre></td></tr></table></figure>\n<p>6.设置启动脚本，开机自启动</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql</div><div class=\"line\">[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</div><div class=\"line\">[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld</div><div class=\"line\">[root@graychen mysql-5.7.13]# systemctl enable mysqld</div><div class=\"line\">mysqld.service is not a native service, redirecting to /sbin/chkconfig.</div><div class=\"line\">Executing /sbin/chkconfig mysqld on</div></pre></td></tr></table></figure>\n<p>7.配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">/etc/my.cnf，仅供参考 </div><div class=\"line\">[root@graychen mysql-5.7.13]# cat &gt; /etc/my.cnf &lt;&lt; EOF</div><div class=\"line\">[client]</div><div class=\"line\">port = 3306</div><div class=\"line\">socket = /dev/shm/mysql.sock</div><div class=\"line\">[mysqld]</div><div class=\"line\">port = 3306</div><div class=\"line\">socket = /dev/shm/mysql.sock</div><div class=\"line\">basedir = /usr/local/mysql</div><div class=\"line\">datadir = /data/mysql</div><div class=\"line\">pid-file = /data/mysql/mysql.pid</div><div class=\"line\">user = mysql</div><div class=\"line\">bind-address = 0.0.0.0</div><div class=\"line\">server-id = 1</div><div class=\"line\">init-connect = &apos;SET NAMES utf8mb4&apos;</div><div class=\"line\">character-set-server = utf8mb4</div><div class=\"line\">#skip-name-resolve</div><div class=\"line\">#skip-networking</div><div class=\"line\">back_log = 300</div><div class=\"line\">max_connections = 1000</div><div class=\"line\">max_connect_errors = 6000</div><div class=\"line\">open_files_limit = 65535</div><div class=\"line\">table_open_cache = 128</div><div class=\"line\">max_allowed_packet = 4M</div><div class=\"line\">binlog_cache_size = 1M</div><div class=\"line\">max_heap_table_size = 8M</div><div class=\"line\">tmp_table_size = 16M</div><div class=\"line\">read_buffer_size = 2M</div><div class=\"line\">read_rnd_buffer_size = 8M</div><div class=\"line\">sort_buffer_size = 8M</div><div class=\"line\">join_buffer_size = 8M</div><div class=\"line\">key_buffer_size = 4M</div><div class=\"line\">thread_cache_size = 8</div><div class=\"line\">query_cache_type = 1</div><div class=\"line\">query_cache_size = 8M</div><div class=\"line\">query_cache_limit = 2M</div><div class=\"line\">ft_min_word_len = 4</div><div class=\"line\">log_bin = mysql-bin</div><div class=\"line\">binlog_format = mixed</div><div class=\"line\">expire_logs_days = 30</div><div class=\"line\">log_error = /data/mysql/mysql-error.log</div><div class=\"line\">slow_query_log = 1</div><div class=\"line\">long_query_time = 1</div><div class=\"line\">slow_query_log_file = /data/mysql/mysql-slow.log</div><div class=\"line\">performance_schema = 0</div><div class=\"line\">explicit_defaults_for_timestamp</div><div class=\"line\">#lower_case_table_names = 1</div><div class=\"line\">skip-external-locking</div><div class=\"line\">default_storage_engine = InnoDB</div><div class=\"line\">#default-storage-engine = MyISAM</div><div class=\"line\">innodb_file_per_table = 1</div><div class=\"line\">innodb_open_files = 500</div><div class=\"line\">innodb_buffer_pool_size = 64M</div><div class=\"line\">innodb_write_io_threads = 4</div><div class=\"line\">innodb_read_io_threads = 4</div><div class=\"line\">innodb_thread_concurrency = 0</div><div class=\"line\">innodb_purge_threads = 1</div><div class=\"line\">innodb_flush_log_at_trx_commit = 2</div><div class=\"line\">innodb_log_buffer_size = 2M</div><div class=\"line\">innodb_log_file_size = 32M</div><div class=\"line\">innodb_log_files_in_group = 3</div><div class=\"line\">innodb_max_dirty_pages_pct = 90</div><div class=\"line\">innodb_lock_wait_timeout = 120</div><div class=\"line\">bulk_insert_buffer_size = 8M</div><div class=\"line\">myisam_sort_buffer_size = 8M</div><div class=\"line\">myisam_max_sort_file_size = 10G</div><div class=\"line\">myisam_repair_threads = 1</div><div class=\"line\">interactive_timeout = 28800</div><div class=\"line\">wait_timeout = 28800</div><div class=\"line\">[mysqldump]</div><div class=\"line\">quick</div><div class=\"line\">max_allowed_packet = 16M</div><div class=\"line\">[myisamchk]</div><div class=\"line\">key_buffer_size = 8M</div><div class=\"line\">sort_buffer_size = 8M</div><div class=\"line\">read_buffer = 4M</div><div class=\"line\">write_buffer = 4M</div><div class=\"line\">EOF</div></pre></td></tr></table></figure>\n<p>9.添加mysql的环境变量</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# echo -e &apos;\\n\\nexport PATH=/usr/local/mysql/bin:$PATH\\n&apos; &gt;&gt; /etc/profile &amp;&amp; source /etc/profile</div></pre></td></tr></table></figure>\n<p>10.初始化数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql</div></pre></td></tr></table></figure>\n<p>11.启动数据库</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# systemctl start mysqld</div><div class=\"line\">[root@graychen mysql-5.7.13]# systemctl status mysqld</div><div class=\"line\">● mysqld.service - LSB: start and stop MySQL</div><div class=\"line\">Loaded: loaded (/etc/rc.d/init.d/mysqld)</div><div class=\"line\">Active: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago</div><div class=\"line\">Docs: man:systemd-sysv-generator(8)</div><div class=\"line\">Process: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)</div><div class=\"line\">CGroup: /system.slice/mysqld.service</div><div class=\"line\">├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</div><div class=\"line\">└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...</div><div class=\"line\"></div><div class=\"line\">7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...</div><div class=\"line\">7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]</div><div class=\"line\">7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.</div></pre></td></tr></table></figure>\n<p>12.查看MySQL服务进程和端口<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# ps -ef | grep mysql</div><div class=\"line\">root     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</div><div class=\"line\">mysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306</div><div class=\"line\">[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306</div><div class=\"line\">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld</div></pre></td></tr></table></figure></p>\n<p>13.设置数据库root用户密码</p>\n<p>MySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[root@graychen mysql-5.7.13]# mysql_secure_installation</div></pre></td></tr></table></figure>\n<h2 id=\"php源码安装\"><a href=\"#php源码安装\" class=\"headerlink\" title=\"php源码安装\"></a>php源码安装</h2><p>1.安装编译源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror</div><div class=\"line\">tar jxvf php-7.1.4.tar.bz2 </div><div class=\"line\">bzip2 -d php-7.1.4.tar.bz2 </div><div class=\"line\">cd php-7.1.4/</div><div class=\"line\">./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr</div><div class=\"line\">sudo make test</div><div class=\"line\">sudo make install</div></pre></td></tr></table></figure></p>\n<p>2.配置php.ini<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp php.ini-development /usr/local/php/etc/php.ini</div><div class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</div></pre></td></tr></table></figure></p>\n<p>3.配置php-fpm.conf<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /usr/local/php/etc/</div><div class=\"line\">mv php-fpm.conf.default php-fpm.conf</div><div class=\"line\">sudo mv php-fpm.conf.default php-fpm.conf</div><div class=\"line\">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</div></pre></td></tr></table></figure></p>\n<p>4.配置php-fpm开机启动<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd ~/src/php-7.1.4/sapi/fpm</div><div class=\"line\">sudo cp init.d.php-fpm /etc/init.d/php-fpm</div><div class=\"line\">sudo chmod +x /etc/init.d/php-fpm </div><div class=\"line\">chkconfig --add php-fpm</div><div class=\"line\">systemctl --add php-fpm</div><div class=\"line\">sudo /sbin/chkconfig</div><div class=\"line\">sudo vi /etc/init.d/php-fpm</div><div class=\"line\">update-rc.d -f php-fpm defaults</div><div class=\"line\">runlevel</div><div class=\"line\">sudo service php-fpm start</div></pre></td></tr></table></figure></p>\n<h2 id=\"nginx源码安装\"><a href=\"#nginx源码安装\" class=\"headerlink\" title=\"nginx源码安装\"></a>nginx源码安装</h2><p>1.下载源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://nginx.org/download/nginx-1.11.2.tar.gz</div><div class=\"line\">tar -xzvf nginx-1.11.2.tar.gz -C /usr/src</div></pre></td></tr></table></figure></p>\n<p>2.安装依赖<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev</div></pre></td></tr></table></figure></p>\n<p>3.编译安装源码<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">cd /usr/src/nginx-1.11.2</div><div class=\"line\"># 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译</div><div class=\"line\">./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module</div><div class=\"line\"># make是生成在objs目录中，make install则安装到prefix所示的目录中</div><div class=\"line\">make &amp;&amp; make install</div><div class=\"line\"># 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>成功安装后，进入/usr/local/nginx，可以看到4个目录：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@graychen:/usr/local/nginx# ll</div><div class=\"line\">total 44</div><div class=\"line\">drwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./</div><div class=\"line\">drwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/</div><div class=\"line\">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/</div></pre></td></tr></table></figure></p>\n</blockquote>\n<p>其中，</p>\n<p> conf：放置nginx相关的配置文件，最核心的是nginx.conf<br> html：默认的网站根目录<br> logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)<br> sbin：主程序(nginx)目录<br>4.配置Nginx开机自启动<br>Ubuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下</p>\n<blockquote>\n<ul>\n<li><p>vi /etc/init.d/nginx ,其中具体的脚本展示如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div></pre></td><td class=\"code\"><pre><div class=\"line\">[plain] view plain copy</div><div class=\"line\"></div><div class=\"line\"> #!/bin/bash</div><div class=\"line\"> # nginx Startup script for the Nginx HTTP Server</div><div class=\"line\"> # it is v.0.0.2 version.</div><div class=\"line\"> # chkconfig: - 85 15</div><div class=\"line\"> # description: Nginx is a high-performance web and proxy server.</div><div class=\"line\"> #              It has a lot of features, but it&apos;s not for everyone.</div><div class=\"line\"> # processname: nginx</div><div class=\"line\"> # pidfile: /var/run/nginx.pid</div><div class=\"line\"> # config: /usr/local/nginx/conf/nginx.conf</div><div class=\"line\"></div><div class=\"line\"> #注意：这里的三个变量需要根据具体的环境而做修改。</div><div class=\"line\"> nginxd=/opt/nginx/sbin/nginx</div><div class=\"line\"> nginx_config=/opt/nginx/conf/nginx.conf</div><div class=\"line\"> nginx_pid=/opt/nginx/logs/nginx.pid</div><div class=\"line\"> RETVAL=0</div><div class=\"line\"> prog=&quot;nginx&quot;</div><div class=\"line\"></div><div class=\"line\"> # Check that networking is up.</div><div class=\"line\"> [ -x $nginxd  ] || exit 0</div><div class=\"line\"> # Start nginx daemons functions.</div><div class=\"line\"> start() &#123;</div><div class=\"line\">     if [ -e $nginx_pid  ];then</div><div class=\"line\">        echo &quot;nginx already running....&quot;</div><div class=\"line\">        exit 1</div><div class=\"line\">     fi</div><div class=\"line\">        echo -n $&quot;Starting $prog: &quot;</div><div class=\"line\">        $nginxd -c $&#123;nginx_config&#125;</div><div class=\"line\">        RETVAL=$?</div><div class=\"line\">        echo</div><div class=\"line\">        [ $RETVAL = 0  ]</div><div class=\"line\">        return $RETVAL</div><div class=\"line\">     </div><div class=\"line\">&#125;</div><div class=\"line\"> # Stop nginx daemons functions.</div><div class=\"line\"> stop() &#123;</div><div class=\"line\">       echo -n $&quot;Stopping $prog: &quot;</div><div class=\"line\">       $nginxd -s stop</div><div class=\"line\">       RETVAL=$?</div><div class=\"line\">       echo</div><div class=\"line\">       [ $RETVAL = 0  ] &amp;&amp; rm -f /var/lock/subsys/nginx $nginx_pid</div><div class=\"line\">     </div><div class=\"line\">&#125;</div><div class=\"line\"> # reload nginx service functions.</div><div class=\"line\"> reload() &#123;</div><div class=\"line\">       echo -n $&quot;Reloading $prog: &quot;</div><div class=\"line\">       kill -HUP `cat $&#123;nginx_pid&#125;`</div><div class=\"line\">       RETVAL=$?</div><div class=\"line\">       echo</div><div class=\"line\">     </div><div class=\"line\">&#125;</div><div class=\"line\"> # See how we were called.</div><div class=\"line\"> case &quot;$1&quot; in</div><div class=\"line\">   start)</div><div class=\"line\">           start</div><div class=\"line\">           ;;</div><div class=\"line\">   stop)</div><div class=\"line\">           stop</div><div class=\"line\">           ;;</div><div class=\"line\">   reload)</div><div class=\"line\">           reload</div><div class=\"line\">           ;;</div><div class=\"line\">   restart)</div><div class=\"line\">           stop</div><div class=\"line\">           start</div><div class=\"line\">           ;;</div><div class=\"line\">   status)</div><div class=\"line\">           status $prog</div><div class=\"line\">           RETVAL=$?</div><div class=\"line\">           ;;</div><div class=\"line\">   *)</div><div class=\"line\">           echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</div><div class=\"line\">           exit 1</div><div class=\"line\"> esac</div><div class=\"line\"> exit $RETVAL</div></pre></td></tr></table></figure>\n</li>\n<li><p>sudo chmod a+x /etc/init.d/nginx</p>\n</li>\n<li>在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start<br>最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。</li>\n</ul>\n</blockquote>\n<p>到这里整个LNMP已经安装完成.</p>\n<h2 id=\"nginx和php的关联\"><a href=\"#nginx和php的关联\" class=\"headerlink\" title=\"nginx和php的关联\"></a>nginx和php的关联</h2><p>下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">cp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development</div><div class=\"line\">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</div><div class=\"line\">ln -s /usr/local/php/bin/php /usr/bin/</div></pre></td></tr></table></figure></p>\n<p>配置php-fpm,编辑php-fpm.conf</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /usr/local/php/etc/php-fpm.conf</div></pre></td></tr></table></figure>\n<p>找到listen那一行,修改成如下内容:</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">listen = /var/run/php-fpm/php-fpm.sock   # 使用unix socket</div></pre></td></tr></table></figure>\n<p>启动php-fpm</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mkdir /var/run/php-fpm</div><div class=\"line\">/usr/local/php/sbin/php-fpm</div></pre></td></tr></table></figure>\n<p>然后配置nginx,编辑nginx配置文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">vi /usr/local/nginx/conf/nginx.conf</div></pre></td></tr></table></figure>\n<p>修改nginx配置文件支持php:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">server &#123;</div><div class=\"line\">        listen       80;</div><div class=\"line\">        server_name  localhost;</div><div class=\"line\"></div><div class=\"line\">        #charset koi8-r;</div><div class=\"line\"></div><div class=\"line\">        #access_log  logs/host.access.log  main;</div><div class=\"line\"></div><div class=\"line\">        location / &#123;</div><div class=\"line\">            root   html;</div><div class=\"line\">            index  index.php index.html index.htm;         # 添加index.php的首页文件</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        # 添加下面内容</div><div class=\"line\">        location ~ \\.php$ &#123;</div><div class=\"line\">            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;</div><div class=\"line\">            fastcgi_index       index.php;</div><div class=\"line\">            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;</div><div class=\"line\">            include fastcgi_params;</div><div class=\"line\">            include fastcgi.conf;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>修改完毕后保存退出重启nginx:</p>\n<p>pkill -9 nignx<br>/usr/local/nginx/sbin/nginx<br>然后在/usr/local/nginx/html下创建index.php,</p>\n<p>vi /usr/local/nginx/html/index.php<br>添加下面内容:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">phpinfo();</div><div class=\"line\"><span class=\"meta\">?&gt;</span></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>保存退出后访问<a href=\"http://localhost/index.php,看到下面页面表示已经安装配置成功\" target=\"_blank\" rel=\"noopener\">http://localhost/index.php,看到下面页面表示已经安装配置成功</a>:</p>\n<p><img src=\"/assets/blogImg/php.png\" alt=\"php页面\"></p>"},{"title":"nginx配置优化","date":"2018-01-04T14:52:38.000Z","_content":"最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置\n首先我们看一份较简单的nginx.conf配置文件\n```\n#### 全局块开始 ####\nuser nobody nobody; #配置允许Nginx服务器的用户和用户组\nworker_processes 3; #配置Nginx进程生成的worker_processes数目\nerror_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径\npid nginx.pid; #配置Nginx服务允许时的错误日志存放路径\n#### 全局块结束 ####\n\n#### event开始 ####\nevents {\n        use epoll; #配置事件驱动模型\n        worker_connections 1024; #配置最大连接数\n}\n#### event结束 ####\n#### http块开始 ####\nhttp {\n        include mime.types; #定义MIME-TYPE\n        default_type application/octet-stream; \n        sendfile on; #配置允许使用sendfile方式传输\n        keepalive_timeout 65; #配置连接超时\n        log_format access.log #配置请求处理日志的分格\n        '$remote_addr-[$time_local]-\"$request\"-\"$http_user_agent\"'\n\n        gzip on; #gzip功能设置\n        gzip_min_length 1024; #响应页数据上限\n        gzip_buffers 4 16k; # 缓存空间大小\n        gzip_comp_level 2; # 压缩级别为2\n        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型\n        gzip_vary on #启用压缩标识\n        gzip_disable \"MISIE[1-6]\"; #ie1-6不开启压缩功能\n        gunzip_static no #检查预压缩文件\n        gzip_static on;\n        gzup_http_version 1.0;\n#### server块开始 ####\n        server { #配置虚拟主机1\n                listen 8081; \n                server_name myServer1; #监听端口和主机名称\n                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server1/location1 { #配置处理/server1/location1 请求的location\n                        root /myweb;\n                        index index.svr1-local.htm;\n                }\n                location /server2/location2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n        }\n        server { #配置虚拟主机2\n                listen 8082; \n                gzip off; #主机2关闭压缩\n                server_name 192.168.1.3; #监听端口和主机名称\n                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server2/location1 { #配置处理/server2/location1 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location /server2/loc2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location = /404.html {\n                        root /myweb/;\n                        index 404.html;\n                }\n        }\n#### server块结束 ####\n}\n#### http块结束 ####\n\n```\n通过这个我们认识了nginx配置的基本组成:\n- 全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入\n- event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数\n- http块：代理,缓存,日志定义,第三方模块的配置\n- server块：虚拟主机\n- location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制\n<!--more-->\n## Nginx如何处理请求\n> *同步和异步*：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。\n*阻塞和非阻塞*：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。\n\nNginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。\n## Nginx的事件驱动模型\nIO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。\n> *select*: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用--with-select_module和--without-select_module是否编译该库。\n*poll*: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。\n*epoll*: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。\n\n### 主进程:\n- 读取Nginx配置文件并验证其有效性和正确性\n- 建立，绑定和关闭Socket\n- 按照配置生成管理和结束进程\n- 接收外界指令，比如重启，升级及退出服务器等指令\n- 不中断服务，实现平滑重启，升级及退出服务\n- 开启日志文件，获取文件描述符\n- 编译和处理Perl脚本\n### 工作进程：\n- 接收客户端请求\n- 将请求一次送入各个功能模块进行过滤处理\n- IO调用，获取响应数据\n- 与后端服务器通信，接收后端服务器处理结果\n- 数据缓存，访问索引，查询和调用缓存数据\n- 发送请求结果，响应客户端请求\n- 接收主程序指令，比如重启升级和退出\n### 缓存索引重建及管理进程\n缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据\n魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期\n## 优化配置\n### 针对ipv4的内核参数配置优化\n在/etc/sysctl.conf中追加下面的参数,然后使用*/sbin/sysctl -p*命令使配置生效\n- net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目\n- net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题\n- net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击\n- net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持\n- net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 \n- net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量\n### 针对CPU的Nginx配置优化\n- worker_processes 4; #针对cpu核数\n- worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu\n### 与网络连接相关的配置\n- keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件\n- send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接\n- client_header_buffer_size 4k #客户端响应头部的缓冲区大小\n### 与事件驱动相关(event模块)\nuse epoll #事件驱动模型\nworker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2\nworker_rlimit_sigpending 1024 #Linux事件信号队列长度上限\n#### poll事件驱动\ndevpoll_change 32 #传递给内核的事件数\ndevpoll_events 32 #从内核获取事件数量\n#### kqueue事件驱动\nkqueue_changes 512 #传递给内核的事件数\nkqueue_events 512 #从内核获取事件数量\n#### epoll_events驱动\nepoll_changes 512 #发送和收到内核的事件数\n#### rtsig\nrtsig_signo signo\n###Gzip压缩(http模块)\n#### ngx_http_gip_module模块(适用于大文件下载)\ngzip on #开启压缩功能\ngzip_buffers 32 4k | 16 8k #number*size存储压缩空间\ngzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低\ngzip_disable MSIE [4-6]\\. #ie4-6不进行gzip压缩\ngzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本\ngzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩\ngzip_proxied on #开启对后端服务器返回结构的Gzip压缩\ngzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩\ngzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩\ngzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩\ngzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩\ngzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩\ngzip_proxied any #无条件开启对响应数据的压缩\ngzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能\ngzip_vary on #经过压缩处理的响应会在头部添加\"Vary:Accept-Encoding:gizp\"也可用add_header Vary Accept-Encoding gzip\n#### ngx_http_gzip_static_module模块(可确定数据长度)\n编译添加--with-http_gzip_static_module\ngzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件\ngzip_proxied no-cache no-store private auth;\n#### ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\n编译添加--with-http_gunzip_module\ngunzip_static on\ngunzip_buffers 32 4k | 16 8k\n\n\n\n\n\n\n\n\n","source":"_posts/nginx配置优化.md","raw":"---\ntitle: nginx配置优化\ndate: 2018-01-04 22:52:38\ntag: php\ncategories: 技术\n\n---\n最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置\n首先我们看一份较简单的nginx.conf配置文件\n```\n#### 全局块开始 ####\nuser nobody nobody; #配置允许Nginx服务器的用户和用户组\nworker_processes 3; #配置Nginx进程生成的worker_processes数目\nerror_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径\npid nginx.pid; #配置Nginx服务允许时的错误日志存放路径\n#### 全局块结束 ####\n\n#### event开始 ####\nevents {\n        use epoll; #配置事件驱动模型\n        worker_connections 1024; #配置最大连接数\n}\n#### event结束 ####\n#### http块开始 ####\nhttp {\n        include mime.types; #定义MIME-TYPE\n        default_type application/octet-stream; \n        sendfile on; #配置允许使用sendfile方式传输\n        keepalive_timeout 65; #配置连接超时\n        log_format access.log #配置请求处理日志的分格\n        '$remote_addr-[$time_local]-\"$request\"-\"$http_user_agent\"'\n\n        gzip on; #gzip功能设置\n        gzip_min_length 1024; #响应页数据上限\n        gzip_buffers 4 16k; # 缓存空间大小\n        gzip_comp_level 2; # 压缩级别为2\n        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型\n        gzip_vary on #启用压缩标识\n        gzip_disable \"MISIE[1-6]\"; #ie1-6不开启压缩功能\n        gunzip_static no #检查预压缩文件\n        gzip_static on;\n        gzup_http_version 1.0;\n#### server块开始 ####\n        server { #配置虚拟主机1\n                listen 8081; \n                server_name myServer1; #监听端口和主机名称\n                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server1/location1 { #配置处理/server1/location1 请求的location\n                        root /myweb;\n                        index index.svr1-local.htm;\n                }\n                location /server2/location2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n        }\n        server { #配置虚拟主机2\n                listen 8082; \n                gzip off; #主机2关闭压缩\n                server_name 192.168.1.3; #监听端口和主机名称\n                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径\n                error_page 404 /404.html; \n                location /server2/location1 { #配置处理/server2/location1 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location /server2/loc2 { #配置处理/server2/location2 请求的location\n                        root /myweb;\n                        index index.svr2-local.htm;\n                }\n                location = /404.html {\n                        root /myweb/;\n                        index 404.html;\n                }\n        }\n#### server块结束 ####\n}\n#### http块结束 ####\n\n```\n通过这个我们认识了nginx配置的基本组成:\n- 全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入\n- event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数\n- http块：代理,缓存,日志定义,第三方模块的配置\n- server块：虚拟主机\n- location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制\n<!--more-->\n## Nginx如何处理请求\n> *同步和异步*：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。\n*阻塞和非阻塞*：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。\n\nNginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。\n## Nginx的事件驱动模型\nIO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。\n> *select*: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用--with-select_module和--without-select_module是否编译该库。\n*poll*: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。\n*epoll*: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。\n\n### 主进程:\n- 读取Nginx配置文件并验证其有效性和正确性\n- 建立，绑定和关闭Socket\n- 按照配置生成管理和结束进程\n- 接收外界指令，比如重启，升级及退出服务器等指令\n- 不中断服务，实现平滑重启，升级及退出服务\n- 开启日志文件，获取文件描述符\n- 编译和处理Perl脚本\n### 工作进程：\n- 接收客户端请求\n- 将请求一次送入各个功能模块进行过滤处理\n- IO调用，获取响应数据\n- 与后端服务器通信，接收后端服务器处理结果\n- 数据缓存，访问索引，查询和调用缓存数据\n- 发送请求结果，响应客户端请求\n- 接收主程序指令，比如重启升级和退出\n### 缓存索引重建及管理进程\n缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据\n魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期\n## 优化配置\n### 针对ipv4的内核参数配置优化\n在/etc/sysctl.conf中追加下面的参数,然后使用*/sbin/sysctl -p*命令使配置生效\n- net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目\n- net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题\n- net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击\n- net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持\n- net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 \n- net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量\n### 针对CPU的Nginx配置优化\n- worker_processes 4; #针对cpu核数\n- worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu\n### 与网络连接相关的配置\n- keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件\n- send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接\n- client_header_buffer_size 4k #客户端响应头部的缓冲区大小\n### 与事件驱动相关(event模块)\nuse epoll #事件驱动模型\nworker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2\nworker_rlimit_sigpending 1024 #Linux事件信号队列长度上限\n#### poll事件驱动\ndevpoll_change 32 #传递给内核的事件数\ndevpoll_events 32 #从内核获取事件数量\n#### kqueue事件驱动\nkqueue_changes 512 #传递给内核的事件数\nkqueue_events 512 #从内核获取事件数量\n#### epoll_events驱动\nepoll_changes 512 #发送和收到内核的事件数\n#### rtsig\nrtsig_signo signo\n###Gzip压缩(http模块)\n#### ngx_http_gip_module模块(适用于大文件下载)\ngzip on #开启压缩功能\ngzip_buffers 32 4k | 16 8k #number*size存储压缩空间\ngzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低\ngzip_disable MSIE [4-6]\\. #ie4-6不进行gzip压缩\ngzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本\ngzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩\ngzip_proxied on #开启对后端服务器返回结构的Gzip压缩\ngzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩\ngzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩\ngzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩\ngzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩\ngzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩\ngzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩\ngzip_proxied any #无条件开启对响应数据的压缩\ngzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能\ngzip_vary on #经过压缩处理的响应会在头部添加\"Vary:Accept-Encoding:gizp\"也可用add_header Vary Accept-Encoding gzip\n#### ngx_http_gzip_static_module模块(可确定数据长度)\n编译添加--with-http_gzip_static_module\ngzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件\ngzip_proxied no-cache no-store private auth;\n#### ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\n编译添加--with-http_gunzip_module\ngunzip_static on\ngunzip_buffers 32 4k | 16 8k\n\n\n\n\n\n\n\n\n","slug":"nginx配置优化","published":1,"updated":"2018-01-14T16:03:40.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q1b000fto7y0ton6svd","content":"<p>最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置<br>首先我们看一份较简单的nginx.conf配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 全局块开始 ####</div><div class=\"line\">user nobody nobody; #配置允许Nginx服务器的用户和用户组</div><div class=\"line\">worker_processes 3; #配置Nginx进程生成的worker_processes数目</div><div class=\"line\">error_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径</div><div class=\"line\">pid nginx.pid; #配置Nginx服务允许时的错误日志存放路径</div><div class=\"line\">#### 全局块结束 ####</div><div class=\"line\"></div><div class=\"line\">#### event开始 ####</div><div class=\"line\">events &#123;</div><div class=\"line\">        use epoll; #配置事件驱动模型</div><div class=\"line\">        worker_connections 1024; #配置最大连接数</div><div class=\"line\">&#125;</div><div class=\"line\">#### event结束 ####</div><div class=\"line\">#### http块开始 ####</div><div class=\"line\">http &#123;</div><div class=\"line\">        include mime.types; #定义MIME-TYPE</div><div class=\"line\">        default_type application/octet-stream; </div><div class=\"line\">        sendfile on; #配置允许使用sendfile方式传输</div><div class=\"line\">        keepalive_timeout 65; #配置连接超时</div><div class=\"line\">        log_format access.log #配置请求处理日志的分格</div><div class=\"line\">        &apos;$remote_addr-[$time_local]-&quot;$request&quot;-&quot;$http_user_agent&quot;&apos;</div><div class=\"line\"></div><div class=\"line\">        gzip on; #gzip功能设置</div><div class=\"line\">        gzip_min_length 1024; #响应页数据上限</div><div class=\"line\">        gzip_buffers 4 16k; # 缓存空间大小</div><div class=\"line\">        gzip_comp_level 2; # 压缩级别为2</div><div class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型</div><div class=\"line\">        gzip_vary on #启用压缩标识</div><div class=\"line\">        gzip_disable &quot;MISIE[1-6]&quot;; #ie1-6不开启压缩功能</div><div class=\"line\">        gunzip_static no #检查预压缩文件</div><div class=\"line\">        gzip_static on;</div><div class=\"line\">        gzup_http_version 1.0;</div><div class=\"line\">#### server块开始 ####</div><div class=\"line\">        server &#123; #配置虚拟主机1</div><div class=\"line\">                listen 8081; </div><div class=\"line\">                server_name myServer1; #监听端口和主机名称</div><div class=\"line\">                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径</div><div class=\"line\">                error_page 404 /404.html; </div><div class=\"line\">                location /server1/location1 &#123; #配置处理/server1/location1 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr1-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">                location /server2/location2 &#123; #配置处理/server2/location2 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr2-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        server &#123; #配置虚拟主机2</div><div class=\"line\">                listen 8082; </div><div class=\"line\">                gzip off; #主机2关闭压缩</div><div class=\"line\">                server_name 192.168.1.3; #监听端口和主机名称</div><div class=\"line\">                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径</div><div class=\"line\">                error_page 404 /404.html; </div><div class=\"line\">                location /server2/location1 &#123; #配置处理/server2/location1 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr2-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">                location /server2/loc2 &#123; #配置处理/server2/location2 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr2-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">                location = /404.html &#123;</div><div class=\"line\">                        root /myweb/;</div><div class=\"line\">                        index 404.html;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#### server块结束 ####</div><div class=\"line\">&#125;</div><div class=\"line\">#### http块结束 ####</div></pre></td></tr></table></figure></p>\n<p>通过这个我们认识了nginx配置的基本组成:</p>\n<ul>\n<li>全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入</li>\n<li>event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数</li>\n<li>http块：代理,缓存,日志定义,第三方模块的配置</li>\n<li>server块：虚拟主机</li>\n<li>location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制<a id=\"more\"></a>\n<h2 id=\"Nginx如何处理请求\"><a href=\"#Nginx如何处理请求\" class=\"headerlink\" title=\"Nginx如何处理请求\"></a>Nginx如何处理请求</h2><blockquote>\n<p><em>同步和异步</em>：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。<br><em>阻塞和非阻塞</em>：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。</p>\n</blockquote>\n</li>\n</ul>\n<p>Nginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。</p>\n<h2 id=\"Nginx的事件驱动模型\"><a href=\"#Nginx的事件驱动模型\" class=\"headerlink\" title=\"Nginx的事件驱动模型\"></a>Nginx的事件驱动模型</h2><p>IO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。</p>\n<blockquote>\n<p><em>select</em>: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用–with-select_module和–without-select_module是否编译该库。<br><em>poll</em>: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。<br><em>epoll</em>: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。</p>\n</blockquote>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程:\"></a>主进程:</h3><ul>\n<li>读取Nginx配置文件并验证其有效性和正确性</li>\n<li>建立，绑定和关闭Socket</li>\n<li>按照配置生成管理和结束进程</li>\n<li>接收外界指令，比如重启，升级及退出服务器等指令</li>\n<li>不中断服务，实现平滑重启，升级及退出服务</li>\n<li>开启日志文件，获取文件描述符</li>\n<li>编译和处理Perl脚本<h3 id=\"工作进程：\"><a href=\"#工作进程：\" class=\"headerlink\" title=\"工作进程：\"></a>工作进程：</h3></li>\n<li>接收客户端请求</li>\n<li>将请求一次送入各个功能模块进行过滤处理</li>\n<li>IO调用，获取响应数据</li>\n<li>与后端服务器通信，接收后端服务器处理结果</li>\n<li>数据缓存，访问索引，查询和调用缓存数据</li>\n<li>发送请求结果，响应客户端请求</li>\n<li>接收主程序指令，比如重启升级和退出<h3 id=\"缓存索引重建及管理进程\"><a href=\"#缓存索引重建及管理进程\" class=\"headerlink\" title=\"缓存索引重建及管理进程\"></a>缓存索引重建及管理进程</h3>缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据<br>魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期<h2 id=\"优化配置\"><a href=\"#优化配置\" class=\"headerlink\" title=\"优化配置\"></a>优化配置</h2><h3 id=\"针对ipv4的内核参数配置优化\"><a href=\"#针对ipv4的内核参数配置优化\" class=\"headerlink\" title=\"针对ipv4的内核参数配置优化\"></a>针对ipv4的内核参数配置优化</h3>在/etc/sysctl.conf中追加下面的参数,然后使用<em>/sbin/sysctl -p</em>命令使配置生效</li>\n<li>net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目</li>\n<li>net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题</li>\n<li>net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击</li>\n<li>net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持</li>\n<li>net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 </li>\n<li>net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量<h3 id=\"针对CPU的Nginx配置优化\"><a href=\"#针对CPU的Nginx配置优化\" class=\"headerlink\" title=\"针对CPU的Nginx配置优化\"></a>针对CPU的Nginx配置优化</h3></li>\n<li>worker_processes 4; #针对cpu核数</li>\n<li>worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu<h3 id=\"与网络连接相关的配置\"><a href=\"#与网络连接相关的配置\" class=\"headerlink\" title=\"与网络连接相关的配置\"></a>与网络连接相关的配置</h3></li>\n<li>keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件</li>\n<li>send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接</li>\n<li>client_header_buffer_size 4k #客户端响应头部的缓冲区大小<h3 id=\"与事件驱动相关-event模块\"><a href=\"#与事件驱动相关-event模块\" class=\"headerlink\" title=\"与事件驱动相关(event模块)\"></a>与事件驱动相关(event模块)</h3>use epoll #事件驱动模型<br>worker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2<br>worker_rlimit_sigpending 1024 #Linux事件信号队列长度上限<h4 id=\"poll事件驱动\"><a href=\"#poll事件驱动\" class=\"headerlink\" title=\"poll事件驱动\"></a>poll事件驱动</h4>devpoll_change 32 #传递给内核的事件数<br>devpoll_events 32 #从内核获取事件数量<h4 id=\"kqueue事件驱动\"><a href=\"#kqueue事件驱动\" class=\"headerlink\" title=\"kqueue事件驱动\"></a>kqueue事件驱动</h4>kqueue_changes 512 #传递给内核的事件数<br>kqueue_events 512 #从内核获取事件数量<h4 id=\"epoll-events驱动\"><a href=\"#epoll-events驱动\" class=\"headerlink\" title=\"epoll_events驱动\"></a>epoll_events驱动</h4>epoll_changes 512 #发送和收到内核的事件数<h4 id=\"rtsig\"><a href=\"#rtsig\" class=\"headerlink\" title=\"rtsig\"></a>rtsig</h4>rtsig_signo signo<br>###Gzip压缩(http模块)<h4 id=\"ngx-http-gip-module模块-适用于大文件下载\"><a href=\"#ngx-http-gip-module模块-适用于大文件下载\" class=\"headerlink\" title=\"ngx_http_gip_module模块(适用于大文件下载)\"></a>ngx_http_gip_module模块(适用于大文件下载)</h4>gzip on #开启压缩功能<br>gzip_buffers 32 4k | 16 8k #number*size存储压缩空间<br>gzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低<br>gzip_disable MSIE [4-6]. #ie4-6不进行gzip压缩<br>gzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本<br>gzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩<br>gzip_proxied on #开启对后端服务器返回结构的Gzip压缩<br>gzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩<br>gzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩<br>gzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩<br>gzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩<br>gzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩<br>gzip_proxied any #无条件开启对响应数据的压缩<br>gzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能<br>gzip_vary on #经过压缩处理的响应会在头部添加”Vary:Accept-Encoding:gizp”也可用add_header Vary Accept-Encoding gzip<h4 id=\"ngx-http-gzip-static-module模块-可确定数据长度\"><a href=\"#ngx-http-gzip-static-module模块-可确定数据长度\" class=\"headerlink\" title=\"ngx_http_gzip_static_module模块(可确定数据长度)\"></a>ngx_http_gzip_static_module模块(可确定数据长度)</h4>编译添加–with-http_gzip_static_module<br>gzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件<br>gzip_proxied no-cache no-store private auth;<h4 id=\"ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\"><a href=\"#ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\" class=\"headerlink\" title=\"ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\"></a>ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)</h4>编译添加–with-http_gunzip_module<br>gunzip_static on<br>gunzip_buffers 32 4k | 16 8k</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近由于刚看完nginx高性能web服务器详解，就想结合自己工作的经历，对nginx的优化配置做一个系统的总结，这篇是初级篇，是单机的nginx优化配置<br>首先我们看一份较简单的nginx.conf配置文件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div></pre></td><td class=\"code\"><pre><div class=\"line\">#### 全局块开始 ####</div><div class=\"line\">user nobody nobody; #配置允许Nginx服务器的用户和用户组</div><div class=\"line\">worker_processes 3; #配置Nginx进程生成的worker_processes数目</div><div class=\"line\">error_log logs/error_log; #配置Nginx服务器允许对错误日志存放路径</div><div class=\"line\">pid nginx.pid; #配置Nginx服务允许时的错误日志存放路径</div><div class=\"line\">#### 全局块结束 ####</div><div class=\"line\"></div><div class=\"line\">#### event开始 ####</div><div class=\"line\">events &#123;</div><div class=\"line\">        use epoll; #配置事件驱动模型</div><div class=\"line\">        worker_connections 1024; #配置最大连接数</div><div class=\"line\">&#125;</div><div class=\"line\">#### event结束 ####</div><div class=\"line\">#### http块开始 ####</div><div class=\"line\">http &#123;</div><div class=\"line\">        include mime.types; #定义MIME-TYPE</div><div class=\"line\">        default_type application/octet-stream; </div><div class=\"line\">        sendfile on; #配置允许使用sendfile方式传输</div><div class=\"line\">        keepalive_timeout 65; #配置连接超时</div><div class=\"line\">        log_format access.log #配置请求处理日志的分格</div><div class=\"line\">        &apos;$remote_addr-[$time_local]-&quot;$request&quot;-&quot;$http_user_agent&quot;&apos;</div><div class=\"line\"></div><div class=\"line\">        gzip on; #gzip功能设置</div><div class=\"line\">        gzip_min_length 1024; #响应页数据上限</div><div class=\"line\">        gzip_buffers 4 16k; # 缓存空间大小</div><div class=\"line\">        gzip_comp_level 2; # 压缩级别为2</div><div class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml; #压缩文件类型</div><div class=\"line\">        gzip_vary on #启用压缩标识</div><div class=\"line\">        gzip_disable &quot;MISIE[1-6]&quot;; #ie1-6不开启压缩功能</div><div class=\"line\">        gunzip_static no #检查预压缩文件</div><div class=\"line\">        gzip_static on;</div><div class=\"line\">        gzup_http_version 1.0;</div><div class=\"line\">#### server块开始 ####</div><div class=\"line\">        server &#123; #配置虚拟主机1</div><div class=\"line\">                listen 8081; </div><div class=\"line\">                server_name myServer1; #监听端口和主机名称</div><div class=\"line\">                access_log /myweb/server1/log/access_log; #配置请求处理日志存放路径</div><div class=\"line\">                error_page 404 /404.html; </div><div class=\"line\">                location /server1/location1 &#123; #配置处理/server1/location1 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr1-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">                location /server2/location2 &#123; #配置处理/server2/location2 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr2-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        server &#123; #配置虚拟主机2</div><div class=\"line\">                listen 8082; </div><div class=\"line\">                gzip off; #主机2关闭压缩</div><div class=\"line\">                server_name 192.168.1.3; #监听端口和主机名称</div><div class=\"line\">                access_log /myweb/server2/log/access_log; #配置请求处理日志存放路径</div><div class=\"line\">                error_page 404 /404.html; </div><div class=\"line\">                location /server2/location1 &#123; #配置处理/server2/location1 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr2-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">                location /server2/loc2 &#123; #配置处理/server2/location2 请求的location</div><div class=\"line\">                        root /myweb;</div><div class=\"line\">                        index index.svr2-local.htm;</div><div class=\"line\">                &#125;</div><div class=\"line\">                location = /404.html &#123;</div><div class=\"line\">                        root /myweb/;</div><div class=\"line\">                        index 404.html;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">#### server块结束 ####</div><div class=\"line\">&#125;</div><div class=\"line\">#### http块结束 ####</div></pre></td></tr></table></figure></p>\n<p>通过这个我们认识了nginx配置的基本组成:</p>\n<ul>\n<li>全局块：配置整体允许的配置指令，包括用户组，worker process数，Nginx进程,日志存放路径，配置文件引入</li>\n<li>event块：与用户的网络连接,事件模型的选择，worker process下的网络序列化,是否允许同事接受多个网络连接，每个worker process最大支持连接数</li>\n<li>http块：代理,缓存,日志定义,第三方模块的配置</li>\n<li>server块：虚拟主机</li>\n<li>location块: 基于请求对除虚拟主机之外的字符串进行匹配,包括地址定向，数据缓存，应答控制","more":"<h2 id=\"Nginx如何处理请求\"><a href=\"#Nginx如何处理请求\" class=\"headerlink\" title=\"Nginx如何处理请求\"></a>Nginx如何处理请求</h2><blockquote>\n<p><em>同步和异步</em>：同步是指发送方发送请求后，需要等待接收到接收方发回的响应后，才接着发送下一个请求；异步是指发送第一个请求后，不等待接收方响应请求，就继续发送下个请求。在同步机制中，发送方和接收方的步调是一致的；异步中，所有请求形成队列，接收方处理完成后通知发送方。<br><em>阻塞和非阻塞</em>：描述进程处理调度方式，在网络通信中，主要指网络套接字Socket的阻塞和非阻塞，Socket的调用方式是调用结果返回之前，当前线程从运行状态被挂起，一直等到调用结果返回之后，才进入就绪状态，获取CPU后继续执行;Socket的非阻塞调用方式，如果调用结果不能返回，当前线程不会挂起，而是立即放回执行下一个调用。</p>\n</blockquote>\n</li>\n</ul>\n<p>Nginx主要使用Master-Worker模式，每个工作进程使用异步非阻塞方式，可以处理多个客户端请求。当某个工作进程接收到客户端的请求后，调用IO进行处理，如果不能立即得到结果，就去处理其他请求，而客户端再次期间也无需等待响应，可以去处理其他事情。当IO调用放回结果，就会通知此工作进程；该进程得到通知，暂时挂起当前处理的事物，去响应客户端请求。</p>\n<h2 id=\"Nginx的事件驱动模型\"><a href=\"#Nginx的事件驱动模型\" class=\"headerlink\" title=\"Nginx的事件驱动模型\"></a>Nginx的事件驱动模型</h2><p>IO调用是如何把自己的状态通知给工作进程的呢？IO调用在完成后能主动通知工作进程主要是使用事件驱动模型。</p>\n<blockquote>\n<p><em>select</em>: 支持linux和windows，首先创建所关注事件的描述符集合（收集读事件的描述符，写事件的描述符，异常事件描述符）,然后调用select函数，轮询事件描述符，检查是否有相应事件发生。使用–with-select_module和–without-select_module是否编译该库。<br><em>poll</em>: 支持linux，是select的优化版本，在一个描述符上设置了读，写，异常事件,轮询时可以同时检查事件是否发生。<br><em>epoll</em>: 支持linux2.6以上，将待处理事件表直接放到内核中，然后给这些描述符设置所关注的事件，把它添加到事件列表中，在具体编码过程中通过相关调用对事件的描述符进行修改和删除。它支持一个进程打开大数目的事件描述符，上限是系统打开文件的最大数目，同时，epoll库的IO效率不随描述符怎家二线性下降，因为只对内核上报的活跃描述符进行操作。</p>\n</blockquote>\n<h3 id=\"主进程\"><a href=\"#主进程\" class=\"headerlink\" title=\"主进程:\"></a>主进程:</h3><ul>\n<li>读取Nginx配置文件并验证其有效性和正确性</li>\n<li>建立，绑定和关闭Socket</li>\n<li>按照配置生成管理和结束进程</li>\n<li>接收外界指令，比如重启，升级及退出服务器等指令</li>\n<li>不中断服务，实现平滑重启，升级及退出服务</li>\n<li>开启日志文件，获取文件描述符</li>\n<li>编译和处理Perl脚本<h3 id=\"工作进程：\"><a href=\"#工作进程：\" class=\"headerlink\" title=\"工作进程：\"></a>工作进程：</h3></li>\n<li>接收客户端请求</li>\n<li>将请求一次送入各个功能模块进行过滤处理</li>\n<li>IO调用，获取响应数据</li>\n<li>与后端服务器通信，接收后端服务器处理结果</li>\n<li>数据缓存，访问索引，查询和调用缓存数据</li>\n<li>发送请求结果，响应客户端请求</li>\n<li>接收主程序指令，比如重启升级和退出<h3 id=\"缓存索引重建及管理进程\"><a href=\"#缓存索引重建及管理进程\" class=\"headerlink\" title=\"缓存索引重建及管理进程\"></a>缓存索引重建及管理进程</h3>缓存索引重建:在Nginx启动一段时间后由主进程生成，在缓存元数据重建完成后退出,根据本地磁盘在内存中建立索引元数据<br>魂村索引管理:存在主进程的整个生命周期，主要在索引数据更新后，判断是否过期<h2 id=\"优化配置\"><a href=\"#优化配置\" class=\"headerlink\" title=\"优化配置\"></a>优化配置</h2><h3 id=\"针对ipv4的内核参数配置优化\"><a href=\"#针对ipv4的内核参数配置优化\" class=\"headerlink\" title=\"针对ipv4的内核参数配置优化\"></a>针对ipv4的内核参数配置优化</h3>在/etc/sysctl.conf中追加下面的参数,然后使用<em>/sbin/sysctl -p</em>命令使配置生效</li>\n<li>net.core.netdev_max_backlog=262144 #表示当每个接收数据包的速率比内核处理这些包的速率快时，允许发送到队列的数据包的最大数目</li>\n<li>net.core.somaxconn=262144 #TCP连接数，高并发下，可能导致连接超时或重传问题</li>\n<li>net.ipv4.tcp_max_orphans=262144 #允许最多Tcp套接字关联到用户文件句柄上，防止Dos攻击</li>\n<li>net.ipv4.tcp_timestamps=0 # 禁用对时间戳的支持</li>\n<li>net.ipv4.tcp_synack_retries=1 # 放弃tcp连接之前发送一次SYN+ACK包 </li>\n<li>net.ipv4.tcp_syn_retries=1 # 设置放弃连接之前发送SYN包的数量<h3 id=\"针对CPU的Nginx配置优化\"><a href=\"#针对CPU的Nginx配置优化\" class=\"headerlink\" title=\"针对CPU的Nginx配置优化\"></a>针对CPU的Nginx配置优化</h3></li>\n<li>worker_processes 4; #针对cpu核数</li>\n<li>worker_cpu_affinity 0001 0100 1000 0010 #为每个分配分配他的cpu<h3 id=\"与网络连接相关的配置\"><a href=\"#与网络连接相关的配置\" class=\"headerlink\" title=\"与网络连接相关的配置\"></a>与网络连接相关的配置</h3></li>\n<li>keepalive_timeout 60 50 #（1）服务端与客户端保持连接的超时时间 （2）Keep-Alive消息头，客户端连接事件</li>\n<li>send_timeout 10s # 设置Nginx服务器响应客户端的超时事件，某次会话等待客户端响应超过10s，断开连接</li>\n<li>client_header_buffer_size 4k #客户端响应头部的缓冲区大小<h3 id=\"与事件驱动相关-event模块\"><a href=\"#与事件驱动相关-event模块\" class=\"headerlink\" title=\"与事件驱动相关(event模块)\"></a>与事件驱动相关(event模块)</h3>use epoll #事件驱动模型<br>worker_connections 65535 #每个工作进程允许同时连接客户端的最大数量，Client=worker_processes * worker_connections /2<br>worker_rlimit_sigpending 1024 #Linux事件信号队列长度上限<h4 id=\"poll事件驱动\"><a href=\"#poll事件驱动\" class=\"headerlink\" title=\"poll事件驱动\"></a>poll事件驱动</h4>devpoll_change 32 #传递给内核的事件数<br>devpoll_events 32 #从内核获取事件数量<h4 id=\"kqueue事件驱动\"><a href=\"#kqueue事件驱动\" class=\"headerlink\" title=\"kqueue事件驱动\"></a>kqueue事件驱动</h4>kqueue_changes 512 #传递给内核的事件数<br>kqueue_events 512 #从内核获取事件数量<h4 id=\"epoll-events驱动\"><a href=\"#epoll-events驱动\" class=\"headerlink\" title=\"epoll_events驱动\"></a>epoll_events驱动</h4>epoll_changes 512 #发送和收到内核的事件数<h4 id=\"rtsig\"><a href=\"#rtsig\" class=\"headerlink\" title=\"rtsig\"></a>rtsig</h4>rtsig_signo signo<br>###Gzip压缩(http模块)<h4 id=\"ngx-http-gip-module模块-适用于大文件下载\"><a href=\"#ngx-http-gip-module模块-适用于大文件下载\" class=\"headerlink\" title=\"ngx_http_gip_module模块(适用于大文件下载)\"></a>ngx_http_gip_module模块(适用于大文件下载)</h4>gzip on #开启压缩功能<br>gzip_buffers 32 4k | 16 8k #number*size存储压缩空间<br>gzip_comp_level 1 #压缩基本，1-9 1:压缩程度低，压缩效率高 9：压缩程度最高，压缩效率最低<br>gzip_disable MSIE [4-6]. #ie4-6不进行gzip压缩<br>gzip_http_version 1.0|1.1; # 开启Gzip功能的最低http协议版本<br>gzip_min_length 1024 #开启页面压缩的最小值,页面大于这个值才开启压缩<br>gzip_proxied on #开启对后端服务器返回结构的Gzip压缩<br>gzip_proxied expired #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-cache #当后端服务器响应页头部包含只是响应数据过期时间的expired头域时，开启对响应数据的压缩<br>gzip_proxied no-store #当后端服务器响应页头部Cache-Control的指令为no-store时，开启对响应数据的Gzip压缩<br>gzip_proxied private #当后端服务器响应页头部Cache-Control的指令为private时，开启对响应数据的Gzip压缩<br>gzip_proxied no_last_modified #当后端服务器响应页头部不包含Last-Modified时，开启对响应数据的压缩<br>gzip_proxied no_etag #当后端服务器响应页头部不包含ETag时，开启对响应数据的压缩<br>gzip_proxied auth #当后端服务器响应页头部用于标示HTTP授权证书时，开启对响应数据的压缩<br>gzip_proxied any #无条件开启对响应数据的压缩<br>gzip_types text/plain application/x-javascript text/css text/html application/xml #根据响应页的MIME-TYPE选择性地开启Gzip压缩功能<br>gzip_vary on #经过压缩处理的响应会在头部添加”Vary:Accept-Encoding:gizp”也可用add_header Vary Accept-Encoding gzip<h4 id=\"ngx-http-gzip-static-module模块-可确定数据长度\"><a href=\"#ngx-http-gzip-static-module模块-可确定数据长度\" class=\"headerlink\" title=\"ngx_http_gzip_static_module模块(可确定数据长度)\"></a>ngx_http_gzip_static_module模块(可确定数据长度)</h4>编译添加–with-http_gzip_static_module<br>gzip_static on | off | aways; #开启 | 关闭 | 不检查客户端是否支持压缩,直接发送压缩文件<br>gzip_proxied no-cache no-store private auth;<h4 id=\"ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\"><a href=\"#ngx-http-gunzip-module模块-不支持解压的浏览器，对数据进行解压\" class=\"headerlink\" title=\"ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)\"></a>ngx_http_gunzip_module模块(不支持解压的浏览器，对数据进行解压)</h4>编译添加–with-http_gunzip_module<br>gunzip_static on<br>gunzip_buffers 32 4k | 16 8k</li>\n</ul>"},{"title":"php的并发io","date":"2017-06-25T15:04:46.000Z","_content":"\n计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。\n## 多进程/多线程同步阻塞\n最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。\n ![\"我是傲娇的效果图\"](/assets/blogImg/manyporcess.png)\n因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。\n``` php\n\n$serv = stream_socket_server(\"tcp://0.0.0.0.8000\",$errno,$errstr) or die(\"create server failed\");\nwhile(1) {\n        $conn = stream_socket_accept($serv);\n        if(pcntl_fork() ==0) {\n                $request = fread($conn);\n                fwite($repose);\n                fclose($conn);\n                exit(0);\n        }\n}\n\n```\n<!--more-->\n## 多进程/线程模型的流程\n1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现\n2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket\n3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。\n4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。\n5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。\n**这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。**\n``` php\n\n<?php\n$serv = stream_socket_server(\"tcp://0.0.0.0:8000\",$error,$errstr) or die(\"create server failed\");\nfor($i=0; $i< 32;$i++){\n        if (pcntl_fork() == 0 ){\n                while(1) {\n                        $conn = stream_socket_accept($serv);\n                        if($conn == false) continue;\n                        $request = fread($conn);\n                        fwrite($reponse);\n                        fclose($conn);\n                }\n                exit(0);\n        }\n}\n\n```\n他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。\n优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM\n缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。\n还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。\n\n有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。\n## IO复用/事件循环/异步非阻塞\n其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。\n直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。\nIO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。\n ![\"我是傲娇的效果图\"](/assets/blogImg/reactor.png)\n Reactor有4个核心的操作：\n add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等\n set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。\n del从reactor中移除，不再监听事件\n callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。\n Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：\n ``` php\n <?php\n $reactor=new Reactor();\n $svr_sock=stream_socket_server('tcp://127.0.0.1:9501');\n $reactor->add($svr_sock,EV_READ,function() use ($svr_sock,$reactor){\n         $cli_sock = stream_socket_accept($svr_sock);\n         $reactor->add($cli_sock,EV_READ,function() use ($cli_sock,$reactor){\n                 $request = fread($cli_sock,8192);\n                 $reactor->add($cli_sock,EV_WRITE,function() use ($cli_sock,$request,$reactor){\n                         fwrite($cli_sock,\"hello world\\n\");\n                         $reactor->del($cli_sock);\n                         fclose($cli_sock);\n                 });\n         });\n});\n \n ```\n > Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如\n Nginx：多进程Reactor\n Nginx+Lua：多进程Reactor+协程\n Golang：单线程Reactor+多线程协程\n Swoole：多线程Reactor+多进程Worker\n\n 协程是什么\n 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在\n\n 参考文章:\n-------------------\n[PHP并发IO编程之路](http://rango.swoole.com/archives/508)\n\n\n\n\n\n\n\n\n","source":"_posts/php的并发io.md","raw":"---\ntitle: php的并发io\ndate: 2017-06-25 23:04:46\ntag: php\ncategories: 技术\n\n---\n\n计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。\n## 多进程/多线程同步阻塞\n最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。\n ![\"我是傲娇的效果图\"](/assets/blogImg/manyporcess.png)\n因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。\n``` php\n\n$serv = stream_socket_server(\"tcp://0.0.0.0.8000\",$errno,$errstr) or die(\"create server failed\");\nwhile(1) {\n        $conn = stream_socket_accept($serv);\n        if(pcntl_fork() ==0) {\n                $request = fread($conn);\n                fwite($repose);\n                fclose($conn);\n                exit(0);\n        }\n}\n\n```\n<!--more-->\n## 多进程/线程模型的流程\n1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现\n2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket\n3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。\n4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。\n5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。\n**这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。**\n``` php\n\n<?php\n$serv = stream_socket_server(\"tcp://0.0.0.0:8000\",$error,$errstr) or die(\"create server failed\");\nfor($i=0; $i< 32;$i++){\n        if (pcntl_fork() == 0 ){\n                while(1) {\n                        $conn = stream_socket_accept($serv);\n                        if($conn == false) continue;\n                        $request = fread($conn);\n                        fwrite($reponse);\n                        fclose($conn);\n                }\n                exit(0);\n        }\n}\n\n```\n他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。\n优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM\n缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。\n还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。\n\n有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。\n## IO复用/事件循环/异步非阻塞\n其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。\n直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。\nIO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。\n ![\"我是傲娇的效果图\"](/assets/blogImg/reactor.png)\n Reactor有4个核心的操作：\n add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等\n set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。\n del从reactor中移除，不再监听事件\n callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。\n Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：\n ``` php\n <?php\n $reactor=new Reactor();\n $svr_sock=stream_socket_server('tcp://127.0.0.1:9501');\n $reactor->add($svr_sock,EV_READ,function() use ($svr_sock,$reactor){\n         $cli_sock = stream_socket_accept($svr_sock);\n         $reactor->add($cli_sock,EV_READ,function() use ($cli_sock,$reactor){\n                 $request = fread($cli_sock,8192);\n                 $reactor->add($cli_sock,EV_WRITE,function() use ($cli_sock,$request,$reactor){\n                         fwrite($cli_sock,\"hello world\\n\");\n                         $reactor->del($cli_sock);\n                         fclose($cli_sock);\n                 });\n         });\n});\n \n ```\n > Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如\n Nginx：多进程Reactor\n Nginx+Lua：多进程Reactor+协程\n Golang：单线程Reactor+多线程协程\n Swoole：多线程Reactor+多进程Worker\n\n 协程是什么\n 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在\n\n 参考文章:\n-------------------\n[PHP并发IO编程之路](http://rango.swoole.com/archives/508)\n\n\n\n\n\n\n\n\n","slug":"php的并发io","published":1,"updated":"2018-01-14T16:02:59.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q1f000hto7yzn2q7auw","content":"<p>计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。</p>\n<h2 id=\"多进程-多线程同步阻塞\"><a href=\"#多进程-多线程同步阻塞\" class=\"headerlink\" title=\"多进程/多线程同步阻塞\"></a>多进程/多线程同步阻塞</h2><p>最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。<br> <img src=\"/assets/blogImg/manyporcess.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0.8000\"</span>,$errno,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        $conn = stream_socket_accept($serv);</div><div class=\"line\">        <span class=\"keyword\">if</span>(pcntl_fork() ==<span class=\"number\">0</span>) &#123;</div><div class=\"line\">                $request = fread($conn);</div><div class=\"line\">                fwite($repose);</div><div class=\"line\">                fclose($conn);</div><div class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<h2 id=\"多进程-线程模型的流程\"><a href=\"#多进程-线程模型的流程\" class=\"headerlink\" title=\"多进程/线程模型的流程\"></a>多进程/线程模型的流程</h2><p>1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现<br>2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket<br>3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。<br>4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。<br>5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。<br><strong>这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0:8000\"</span>,$error,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</div><div class=\"line\"><span class=\"keyword\">for</span>($i=<span class=\"number\">0</span>; $i&lt; <span class=\"number\">32</span>;$i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pcntl_fork() == <span class=\"number\">0</span> )&#123;</div><div class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</div><div class=\"line\">                        $conn = stream_socket_accept($serv);</div><div class=\"line\">                        <span class=\"keyword\">if</span>($conn == <span class=\"keyword\">false</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                        $request = fread($conn);</div><div class=\"line\">                        fwrite($reponse);</div><div class=\"line\">                        fclose($conn);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。<br>优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM<br>缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。<br>还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。</p>\n<p>有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。</p>\n<h2 id=\"IO复用-事件循环-异步非阻塞\"><a href=\"#IO复用-事件循环-异步非阻塞\" class=\"headerlink\" title=\"IO复用/事件循环/异步非阻塞\"></a>IO复用/事件循环/异步非阻塞</h2><p>其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。<br>直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。<br>IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。<br> <img src=\"/assets/blogImg/reactor.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> Reactor有4个核心的操作：<br> add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等<br> set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。<br> del从reactor中移除，不再监听事件<br> callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。<br> Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：<br> <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"meta\">&lt;?php</span></div><div class=\"line\"> $reactor=<span class=\"keyword\">new</span> Reactor();</div><div class=\"line\"> $svr_sock=stream_socket_server(<span class=\"string\">'tcp://127.0.0.1:9501'</span>);</div><div class=\"line\"> $reactor-&gt;add($svr_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($svr_sock,$reactor)</span></span>&#123;</div><div class=\"line\">         $cli_sock = stream_socket_accept($svr_sock);</div><div class=\"line\">         $reactor-&gt;add($cli_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$reactor)</span></span>&#123;</div><div class=\"line\">                 $request = fread($cli_sock,<span class=\"number\">8192</span>);</div><div class=\"line\">                 $reactor-&gt;add($cli_sock,EV_WRITE,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$request,$reactor)</span></span>&#123;</div><div class=\"line\">                         fwrite($cli_sock,<span class=\"string\">\"hello world\\n\"</span>);</div><div class=\"line\">                         $reactor-&gt;del($cli_sock);</div><div class=\"line\">                         fclose($cli_sock);</div><div class=\"line\">                 &#125;);</div><div class=\"line\">         &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如<br> Nginx：多进程Reactor<br> Nginx+Lua：多进程Reactor+协程<br> Golang：单线程Reactor+多线程协程<br> Swoole：多线程Reactor+多进程Worker</p>\n</blockquote>\n<p> 协程是什么<br> 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"http://rango.swoole.com/archives/508\" target=\"_blank\" rel=\"noopener\">PHP并发IO编程之路</a></p>\n","site":{"data":{}},"excerpt":"<p>计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。</p>\n<h2 id=\"多进程-多线程同步阻塞\"><a href=\"#多进程-多线程同步阻塞\" class=\"headerlink\" title=\"多进程/多线程同步阻塞\"></a>多进程/多线程同步阻塞</h2><p>最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。<br> <img src=\"/assets/blogImg/manyporcess.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0.8000\"</span>,$errno,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</div><div class=\"line\"><span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</div><div class=\"line\">        $conn = stream_socket_accept($serv);</div><div class=\"line\">        <span class=\"keyword\">if</span>(pcntl_fork() ==<span class=\"number\">0</span>) &#123;</div><div class=\"line\">                $request = fread($conn);</div><div class=\"line\">                fwite($repose);</div><div class=\"line\">                fclose($conn);</div><div class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>","more":"<h2 id=\"多进程-线程模型的流程\"><a href=\"#多进程-线程模型的流程\" class=\"headerlink\" title=\"多进程/线程模型的流程\"></a>多进程/线程模型的流程</h2><p>1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现<br>2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket<br>3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。<br>4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。<br>5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。<br><strong>这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。</strong><br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$serv = stream_socket_server(<span class=\"string\">\"tcp://0.0.0.0:8000\"</span>,$error,$errstr) <span class=\"keyword\">or</span> <span class=\"keyword\">die</span>(<span class=\"string\">\"create server failed\"</span>);</div><div class=\"line\"><span class=\"keyword\">for</span>($i=<span class=\"number\">0</span>; $i&lt; <span class=\"number\">32</span>;$i++)&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pcntl_fork() == <span class=\"number\">0</span> )&#123;</div><div class=\"line\">                <span class=\"keyword\">while</span>(<span class=\"number\">1</span>) &#123;</div><div class=\"line\">                        $conn = stream_socket_accept($serv);</div><div class=\"line\">                        <span class=\"keyword\">if</span>($conn == <span class=\"keyword\">false</span>) <span class=\"keyword\">continue</span>;</div><div class=\"line\">                        $request = fread($conn);</div><div class=\"line\">                        fwrite($reponse);</div><div class=\"line\">                        fclose($conn);</div><div class=\"line\">                &#125;</div><div class=\"line\">                <span class=\"keyword\">exit</span>(<span class=\"number\">0</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。<br>优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM<br>缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。<br>还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。</p>\n<p>有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。</p>\n<h2 id=\"IO复用-事件循环-异步非阻塞\"><a href=\"#IO复用-事件循环-异步非阻塞\" class=\"headerlink\" title=\"IO复用/事件循环/异步非阻塞\"></a>IO复用/事件循环/异步非阻塞</h2><p>其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。<br>直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。<br>IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。<br> <img src=\"/assets/blogImg/reactor.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> Reactor有4个核心的操作：<br> add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等<br> set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。<br> del从reactor中移除，不再监听事件<br> callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。<br> Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：<br> <figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"> <span class=\"meta\">&lt;?php</span></div><div class=\"line\"> $reactor=<span class=\"keyword\">new</span> Reactor();</div><div class=\"line\"> $svr_sock=stream_socket_server(<span class=\"string\">'tcp://127.0.0.1:9501'</span>);</div><div class=\"line\"> $reactor-&gt;add($svr_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($svr_sock,$reactor)</span></span>&#123;</div><div class=\"line\">         $cli_sock = stream_socket_accept($svr_sock);</div><div class=\"line\">         $reactor-&gt;add($cli_sock,EV_READ,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$reactor)</span></span>&#123;</div><div class=\"line\">                 $request = fread($cli_sock,<span class=\"number\">8192</span>);</div><div class=\"line\">                 $reactor-&gt;add($cli_sock,EV_WRITE,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">()</span> <span class=\"title\">use</span> <span class=\"params\">($cli_sock,$request,$reactor)</span></span>&#123;</div><div class=\"line\">                         fwrite($cli_sock,<span class=\"string\">\"hello world\\n\"</span>);</div><div class=\"line\">                         $reactor-&gt;del($cli_sock);</div><div class=\"line\">                         fclose($cli_sock);</div><div class=\"line\">                 &#125;);</div><div class=\"line\">         &#125;);</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如<br> Nginx：多进程Reactor<br> Nginx+Lua：多进程Reactor+协程<br> Golang：单线程Reactor+多线程协程<br> Swoole：多线程Reactor+多进程Worker</p>\n</blockquote>\n<p> 协程是什么<br> 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"http://rango.swoole.com/archives/508\" target=\"_blank\" rel=\"noopener\">PHP并发IO编程之路</a></p>"},{"title":"ubuntu下lnmp快速搭建","date":"2017-05-10T13:12:37.000Z","_content":"\n我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。\n>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8\n\n## 安装php7.1\n安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：\n\n``` bash\nsudo apt-get update  \nsudo apt-get install -y language-pack-en-base  \n```\n\n这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。\n\n安装完成之后，运行：\n\n``` bash\nlocale-gen en_US.UTF-8  \n```\n\n设定语言编码为<font color=\"red\">UTF-8</font>。\n\n进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：\n\n``` bash\nsudo apt-get install software-properties-common  \n```\n\n<!--more-->\nsoftware-properties-common是add-apt-repository所依赖的包，安装成功后，运行：\n\n``` bash\nsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php  \n\n```\n\n安装完成之后，运行<font color=\"red\">**sudo apt-get update**</font>更新安装包，把刚才添加的包拉取下来。 运行**<font color=\"red\">apt-cache search php7.1</font>**搜索php7.1开头的包检验是否安装成功，输出如下：\n\n``` bash\nroot@demo:~# apt-cache search php7.1  \nphp-yaml - YAML-1.1 parser and emitter for PHP  \nphp-apcu - APC User Cache for PHP  \nphp-ssh2 - Bindings for the libssh2 library  \nphp-igbinary - igbinary PHP serializer  \nphp-mailparse - Email message manipulation for PHP  \nphp-libsodium - PHP wrapper for the Sodium cryptographic library  \nphp-propro - propro module for PHP\n\n...\n...\n...\n```\n\n安装php7.1\n\n``` bash\nsudo apt-get -y install php7.1\n```\n\n安装完成后运行**<font color=\"red\">php -v</font>**查看是否安装成功,成功的话显示\n\n``` bash\nPHP 7.1.0beta2 (cli) ( NTS  )  \nCopyright (c) 1997-2016 The PHP Group  \nZend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  \n    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies\n```\n接着安装php7.1-mysql，这是php和mysql通信的模块\n\n``` bash\nsudo apt-get -y install php7.1-mysql  \n```\n安装 fpm，这是Nginx 用来解析php文件的：\n\n``` bash\nsudo apt-get install php7.1-fpm  \n```\n\n安装其他必备模块：\n\n``` bash\napt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring  \n```\n\n至此与php相关的模块安装安装完成。\n## 安装Mysql\n直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！\n\n>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 http://dev.mysql.com/downloads/mysql/ 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。\n下载.deb包到你的服务器：\n\n``` bash\nwget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb  \n```\n 然后使用dpkg命令添加Mysql的源：\n``` bash\nsudo dpkg -i mysql-apt-config_0.5.3-1_all.deb  \n```\n注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可\n安装\n\n``` bash\nsudo apt-get update  \nsudo apt-get install mysql-server  \n``` \n安装完成之后运行mysql -V查看版本：\n\n``` bash\nroot@demo:~# mysql -V  \n``` \nmysql  Ver 14.14 Distrib 5.7.15, for Linux (x86_64) using  EditLine wrapper  \n注意\n\n如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源\n\n``` bash\nsudo apt-add-repository --remove ppa:ondrej/mysql-5.6  \n``` \n 如果没有 apt-add-repository 先安装上\n``` bash\n sudo apt-get install software-properties-common\n``` \n然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。\n## 安装Nginx\n简单，运行：\n``` bash\nsudo apt-get -y install nginx  \n``` \n## nginx配置php\n\n``` bash\nsudo vim /etc/php/7.1/fpm/php.ini  \n``` \n输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：\n编辑fpm的配置文件： 运行：\n\n``` bash\nsudo vim /etc/php/7.1/fpm/pool.d/www.conf  \n``` \n找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。\n\n``` bash\nservice php7.1-fpm stop\nservice php7.1-fpm start\n``` \n配置Nginx：\n\n运行：\n\n``` bash\nsudo vim /etc/nginx/sites-available/default  \n``` \n下面是配置文件\n``` bash\nserver {  \n    #listen 80 default_server;\n    listen 80;\n    #listen [::]:80 default_server ipv6only=on;\n    \n    root /var/www;\n    index index.php index.html index.htm;\n                                        \n    # Make site accessible from http://localhost/\n    server_name lufficc.com www.lufficc.com;\n    \n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ /index.php?$query_string;\n        # Uncomment to enable naxsi on this location\n        # include /etc/nginx/naxsi.rules\n    }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        # With php7.0-cgi alone:\n        fastcgi_pass 127.0.0.1:9000;\n        # With php7.0-fpm:\n        fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n    }\n}\n``` \n> \n  - root：是你的项目的public目录，也就是网站的入口\n  - index：添加了，index.php，告诉Nginx先解析index.php文件\n  - server_name：你的域名，没有的话填写localhost\n  - location / try_files修改为了try_files $uri $uri/ /index.php?$query_string;\n  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。\n\n## 运行nginx服务\n\n``` bash\nsudo service nginx restart  \nsudo service php7.1-fpm restart  \n```\n如果出现下列错误\n``` bash\n[emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)\n```\n这是80端口被占用，运行下面命令，关闭80端口\n\n``` bash\nsudo fuser -k 80/tcp\nservice nginx start\n```\n**好了，一切完成！**\n\n\n\n\n\n\n\n","source":"_posts/ubuntu下lnmp快速搭建.md","raw":"---\ntitle: ubuntu下lnmp快速搭建\ndate: 2017-05-10 21:12:37\ntags: linux\ncategories: 技术\n\n---\n\n我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。\n>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8\n\n## 安装php7.1\n安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：\n\n``` bash\nsudo apt-get update  \nsudo apt-get install -y language-pack-en-base  \n```\n\n这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。\n\n安装完成之后，运行：\n\n``` bash\nlocale-gen en_US.UTF-8  \n```\n\n设定语言编码为<font color=\"red\">UTF-8</font>。\n\n进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：\n\n``` bash\nsudo apt-get install software-properties-common  \n```\n\n<!--more-->\nsoftware-properties-common是add-apt-repository所依赖的包，安装成功后，运行：\n\n``` bash\nsudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php  \n\n```\n\n安装完成之后，运行<font color=\"red\">**sudo apt-get update**</font>更新安装包，把刚才添加的包拉取下来。 运行**<font color=\"red\">apt-cache search php7.1</font>**搜索php7.1开头的包检验是否安装成功，输出如下：\n\n``` bash\nroot@demo:~# apt-cache search php7.1  \nphp-yaml - YAML-1.1 parser and emitter for PHP  \nphp-apcu - APC User Cache for PHP  \nphp-ssh2 - Bindings for the libssh2 library  \nphp-igbinary - igbinary PHP serializer  \nphp-mailparse - Email message manipulation for PHP  \nphp-libsodium - PHP wrapper for the Sodium cryptographic library  \nphp-propro - propro module for PHP\n\n...\n...\n...\n```\n\n安装php7.1\n\n``` bash\nsudo apt-get -y install php7.1\n```\n\n安装完成后运行**<font color=\"red\">php -v</font>**查看是否安装成功,成功的话显示\n\n``` bash\nPHP 7.1.0beta2 (cli) ( NTS  )  \nCopyright (c) 1997-2016 The PHP Group  \nZend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  \n    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies\n```\n接着安装php7.1-mysql，这是php和mysql通信的模块\n\n``` bash\nsudo apt-get -y install php7.1-mysql  \n```\n安装 fpm，这是Nginx 用来解析php文件的：\n\n``` bash\nsudo apt-get install php7.1-fpm  \n```\n\n安装其他必备模块：\n\n``` bash\napt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring  \n```\n\n至此与php相关的模块安装安装完成。\n## 安装Mysql\n直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！\n\n>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 http://dev.mysql.com/downloads/mysql/ 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。\n下载.deb包到你的服务器：\n\n``` bash\nwget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb  \n```\n 然后使用dpkg命令添加Mysql的源：\n``` bash\nsudo dpkg -i mysql-apt-config_0.5.3-1_all.deb  \n```\n注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可\n安装\n\n``` bash\nsudo apt-get update  \nsudo apt-get install mysql-server  \n``` \n安装完成之后运行mysql -V查看版本：\n\n``` bash\nroot@demo:~# mysql -V  \n``` \nmysql  Ver 14.14 Distrib 5.7.15, for Linux (x86_64) using  EditLine wrapper  \n注意\n\n如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源\n\n``` bash\nsudo apt-add-repository --remove ppa:ondrej/mysql-5.6  \n``` \n 如果没有 apt-add-repository 先安装上\n``` bash\n sudo apt-get install software-properties-common\n``` \n然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。\n## 安装Nginx\n简单，运行：\n``` bash\nsudo apt-get -y install nginx  \n``` \n## nginx配置php\n\n``` bash\nsudo vim /etc/php/7.1/fpm/php.ini  \n``` \n输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：\n编辑fpm的配置文件： 运行：\n\n``` bash\nsudo vim /etc/php/7.1/fpm/pool.d/www.conf  \n``` \n找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。\n\n``` bash\nservice php7.1-fpm stop\nservice php7.1-fpm start\n``` \n配置Nginx：\n\n运行：\n\n``` bash\nsudo vim /etc/nginx/sites-available/default  \n``` \n下面是配置文件\n``` bash\nserver {  \n    #listen 80 default_server;\n    listen 80;\n    #listen [::]:80 default_server ipv6only=on;\n    \n    root /var/www;\n    index index.php index.html index.htm;\n                                        \n    # Make site accessible from http://localhost/\n    server_name lufficc.com www.lufficc.com;\n    \n    location / {\n        # First attempt to serve request as file, then\n        # as directory, then fall back to displaying a 404.\n        try_files $uri $uri/ /index.php?$query_string;\n        # Uncomment to enable naxsi on this location\n        # include /etc/nginx/naxsi.rules\n    }\n\n    location ~ \\.php$ {\n        include snippets/fastcgi-php.conf;\n        # With php7.0-cgi alone:\n        fastcgi_pass 127.0.0.1:9000;\n        # With php7.0-fpm:\n        fastcgi_pass unix:/run/php/php7.0-fpm.sock;\n    }\n}\n``` \n> \n  - root：是你的项目的public目录，也就是网站的入口\n  - index：添加了，index.php，告诉Nginx先解析index.php文件\n  - server_name：你的域名，没有的话填写localhost\n  - location / try_files修改为了try_files $uri $uri/ /index.php?$query_string;\n  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。\n\n## 运行nginx服务\n\n``` bash\nsudo service nginx restart  \nsudo service php7.1-fpm restart  \n```\n如果出现下列错误\n``` bash\n[emerg]: bind() to 0.0.0.0:80 failed (98: Address already in use)\n```\n这是80端口被占用，运行下面命令，关闭80端口\n\n``` bash\nsudo fuser -k 80/tcp\nservice nginx start\n```\n**好了，一切完成！**\n\n\n\n\n\n\n\n","slug":"ubuntu下lnmp快速搭建","published":1,"updated":"2017-12-10T12:38:46.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q1m000lto7y86xrcdmf","content":"<p>我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。</p>\n<blockquote>\n<p>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8</p>\n</blockquote>\n<h2 id=\"安装php7-1\"><a href=\"#安装php7-1\" class=\"headerlink\" title=\"安装php7.1\"></a>安装php7.1</h2><p>安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update  </div><div class=\"line\">sudo apt-get install -y language-pack-en-base</div></pre></td></tr></table></figure>\n<p>这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。</p>\n<p>安装完成之后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">locale-gen en_US.UTF-8</div></pre></td></tr></table></figure>\n<p>设定语言编码为<font color=\"red\">UTF-8</font>。</p>\n<p>进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install software-properties-common</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>software-properties-common是add-apt-repository所依赖的包，安装成功后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</div></pre></td></tr></table></figure>\n<p>安装完成之后，运行<font color=\"red\"><strong>sudo apt-get update</strong></font>更新安装包，把刚才添加的包拉取下来。 运行<strong><font color=\"red\">apt-cache search php7.1</font></strong>搜索php7.1开头的包检验是否安装成功，输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@demo:~<span class=\"comment\"># apt-cache search php7.1  </span></div><div class=\"line\">php-yaml - YAML-1.1 parser and emitter <span class=\"keyword\">for</span> PHP  </div><div class=\"line\">php-apcu - APC User Cache <span class=\"keyword\">for</span> PHP  </div><div class=\"line\">php-ssh2 - Bindings <span class=\"keyword\">for</span> the libssh2 library  </div><div class=\"line\">php-igbinary - igbinary PHP serializer  </div><div class=\"line\">php-mailparse - Email message manipulation <span class=\"keyword\">for</span> PHP  </div><div class=\"line\">php-libsodium - PHP wrapper <span class=\"keyword\">for</span> the Sodium cryptographic library  </div><div class=\"line\">php-propro - propro module <span class=\"keyword\">for</span> PHP</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\">...</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>安装php7.1</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install php7.1</div></pre></td></tr></table></figure>\n<p>安装完成后运行<strong><font color=\"red\">php -v</font></strong>查看是否安装成功,成功的话显示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">PHP 7.1.0beta2 (cli) ( NTS  )  </div><div class=\"line\">Copyright (c) 1997-2016 The PHP Group  </div><div class=\"line\">Zend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  </div><div class=\"line\">    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies</div></pre></td></tr></table></figure>\n<p>接着安装php7.1-mysql，这是php和mysql通信的模块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install php7.1-mysql</div></pre></td></tr></table></figure>\n<p>安装 fpm，这是Nginx 用来解析php文件的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install php7.1-fpm</div></pre></td></tr></table></figure>\n<p>安装其他必备模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring</div></pre></td></tr></table></figure>\n<p>至此与php相关的模块安装安装完成。</p>\n<h2 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h2><p>直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！</p>\n<blockquote>\n<p>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 <a href=\"http://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/mysql/</a> 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。<br>下载.deb包到你的服务器：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb</div></pre></td></tr></table></figure>\n<p> 然后使用dpkg命令添加Mysql的源：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo dpkg -i mysql-apt-config_0.5.3-1_all.deb</div></pre></td></tr></table></figure></p>\n<p>注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可<br>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update  </div><div class=\"line\">sudo apt-get install mysql-server  </div><div class=\"line\">``` </div><div class=\"line\">安装完成之后运行mysql -V查看版本：</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">root@demo:~<span class=\"comment\"># mysql -V  </span></div><div class=\"line\">``` </div><div class=\"line\">mysql  Ver 14.14 Distrib 5.7.15, <span class=\"keyword\">for</span> Linux (x86_64) using  EditLine wrapper  </div><div class=\"line\">注意</div><div class=\"line\"></div><div class=\"line\">如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo apt-add-repository --remove ppa:ondrej/mysql-5.6  </div><div class=\"line\">``` </div><div class=\"line\"> 如果没有 apt-add-repository 先安装上</div><div class=\"line\">``` bash</div><div class=\"line\"> sudo apt-get install software-properties-common</div><div class=\"line\">``` </div><div class=\"line\">然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。</div><div class=\"line\"><span class=\"comment\">## 安装Nginx</span></div><div class=\"line\">简单，运行：</div><div class=\"line\">``` bash</div><div class=\"line\">sudo apt-get -y install nginx  </div><div class=\"line\">``` </div><div class=\"line\"><span class=\"comment\">## nginx配置php</span></div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo vim /etc/php/7.1/fpm/php.ini  </div><div class=\"line\">``` </div><div class=\"line\">输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：</div><div class=\"line\">编辑fpm的配置文件： 运行：</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo vim /etc/php/7.1/fpm/pool.d/www.conf  </div><div class=\"line\">``` </div><div class=\"line\">找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">service php7.1-fpm stop</div><div class=\"line\">service php7.1-fpm start</div><div class=\"line\">``` </div><div class=\"line\">配置Nginx：</div><div class=\"line\"></div><div class=\"line\">运行：</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo vim /etc/nginx/sites-available/default  </div><div class=\"line\">``` </div><div class=\"line\">下面是配置文件</div><div class=\"line\">``` bash</div><div class=\"line\">server &#123;  </div><div class=\"line\">    <span class=\"comment\">#listen 80 default_server;</span></div><div class=\"line\">    listen 80;</div><div class=\"line\">    <span class=\"comment\">#listen [::]:80 default_server ipv6only=on;</span></div><div class=\"line\">    </div><div class=\"line\">    root /var/www;</div><div class=\"line\">    index index.php index.html index.htm;</div><div class=\"line\">                                        </div><div class=\"line\">    <span class=\"comment\"># Make site accessible from http://localhost/</span></div><div class=\"line\">    server_name lufficc.com www.lufficc.com;</div><div class=\"line\">    </div><div class=\"line\">    location / &#123;</div><div class=\"line\">        <span class=\"comment\"># First attempt to serve request as file, then</span></div><div class=\"line\">        <span class=\"comment\"># as directory, then fall back to displaying a 404.</span></div><div class=\"line\">        try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</div><div class=\"line\">        <span class=\"comment\"># Uncomment to enable naxsi on this location</span></div><div class=\"line\">        <span class=\"comment\"># include /etc/nginx/naxsi.rules</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ \\.php$ &#123;</div><div class=\"line\">        include snippets/fastcgi-php.conf;</div><div class=\"line\">        <span class=\"comment\"># With php7.0-cgi alone:</span></div><div class=\"line\">        fastcgi_pass 127.0.0.1:9000;</div><div class=\"line\">        <span class=\"comment\"># With php7.0-fpm:</span></div><div class=\"line\">        fastcgi_pass unix:/run/php/php7.0-fpm.sock;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">``` </div><div class=\"line\">&gt; </div><div class=\"line\">  - root：是你的项目的public目录，也就是网站的入口</div><div class=\"line\">  - index：添加了，index.php，告诉Nginx先解析index.php文件</div><div class=\"line\">  - server_name：你的域名，没有的话填写localhost</div><div class=\"line\">  - location / try_files修改为了try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</div><div class=\"line\">  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## 运行nginx服务</span></div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo service nginx restart  </div><div class=\"line\">sudo service php7.1-fpm restart</div></pre></td></tr></table></figure>\n<p>如果出现下列错误<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[emerg]: <span class=\"built_in\">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class=\"keyword\">in</span> use)</div></pre></td></tr></table></figure></p>\n<p>这是80端口被占用，运行下面命令，关闭80端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo fuser -k 80/tcp</div><div class=\"line\">service nginx start</div></pre></td></tr></table></figure>\n<p><strong>好了，一切完成！</strong></p>\n","site":{"data":{}},"excerpt":"<p>我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。</p>\n<blockquote>\n<p>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8</p>\n</blockquote>\n<h2 id=\"安装php7-1\"><a href=\"#安装php7-1\" class=\"headerlink\" title=\"安装php7.1\"></a>安装php7.1</h2><p>安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update  </div><div class=\"line\">sudo apt-get install -y language-pack-en-base</div></pre></td></tr></table></figure>\n<p>这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。</p>\n<p>安装完成之后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">locale-gen en_US.UTF-8</div></pre></td></tr></table></figure>\n<p>设定语言编码为<font color=\"red\">UTF-8</font>。</p>\n<p>进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install software-properties-common</div></pre></td></tr></table></figure>","more":"<p>software-properties-common是add-apt-repository所依赖的包，安装成功后，运行：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</div></pre></td></tr></table></figure>\n<p>安装完成之后，运行<font color=\"red\"><strong>sudo apt-get update</strong></font>更新安装包，把刚才添加的包拉取下来。 运行<strong><font color=\"red\">apt-cache search php7.1</font></strong>搜索php7.1开头的包检验是否安装成功，输出如下：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">root@demo:~<span class=\"comment\"># apt-cache search php7.1  </span></div><div class=\"line\">php-yaml - YAML-1.1 parser and emitter <span class=\"keyword\">for</span> PHP  </div><div class=\"line\">php-apcu - APC User Cache <span class=\"keyword\">for</span> PHP  </div><div class=\"line\">php-ssh2 - Bindings <span class=\"keyword\">for</span> the libssh2 library  </div><div class=\"line\">php-igbinary - igbinary PHP serializer  </div><div class=\"line\">php-mailparse - Email message manipulation <span class=\"keyword\">for</span> PHP  </div><div class=\"line\">php-libsodium - PHP wrapper <span class=\"keyword\">for</span> the Sodium cryptographic library  </div><div class=\"line\">php-propro - propro module <span class=\"keyword\">for</span> PHP</div><div class=\"line\"></div><div class=\"line\">...</div><div class=\"line\">...</div><div class=\"line\">...</div></pre></td></tr></table></figure>\n<p>安装php7.1</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install php7.1</div></pre></td></tr></table></figure>\n<p>安装完成后运行<strong><font color=\"red\">php -v</font></strong>查看是否安装成功,成功的话显示</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">PHP 7.1.0beta2 (cli) ( NTS  )  </div><div class=\"line\">Copyright (c) 1997-2016 The PHP Group  </div><div class=\"line\">Zend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  </div><div class=\"line\">    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies</div></pre></td></tr></table></figure>\n<p>接着安装php7.1-mysql，这是php和mysql通信的模块</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get -y install php7.1-mysql</div></pre></td></tr></table></figure>\n<p>安装 fpm，这是Nginx 用来解析php文件的：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install php7.1-fpm</div></pre></td></tr></table></figure>\n<p>安装其他必备模块：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring</div></pre></td></tr></table></figure>\n<p>至此与php相关的模块安装安装完成。</p>\n<h2 id=\"安装Mysql\"><a href=\"#安装Mysql\" class=\"headerlink\" title=\"安装Mysql\"></a>安装Mysql</h2><p>直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！</p>\n<blockquote>\n<p>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 <a href=\"http://dev.mysql.com/downloads/mysql/\" target=\"_blank\" rel=\"noopener\">http://dev.mysql.com/downloads/mysql/</a> 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。<br>下载.deb包到你的服务器：</p>\n</blockquote>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">wget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb</div></pre></td></tr></table></figure>\n<p> 然后使用dpkg命令添加Mysql的源：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo dpkg -i mysql-apt-config_0.5.3-1_all.deb</div></pre></td></tr></table></figure></p>\n<p>注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可<br>安装</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get update  </div><div class=\"line\">sudo apt-get install mysql-server  </div><div class=\"line\">``` </div><div class=\"line\">安装完成之后运行mysql -V查看版本：</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">root@demo:~<span class=\"comment\"># mysql -V  </span></div><div class=\"line\">``` </div><div class=\"line\">mysql  Ver 14.14 Distrib 5.7.15, <span class=\"keyword\">for</span> Linux (x86_64) using  EditLine wrapper  </div><div class=\"line\">注意</div><div class=\"line\"></div><div class=\"line\">如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo apt-add-repository --remove ppa:ondrej/mysql-5.6  </div><div class=\"line\">``` </div><div class=\"line\"> 如果没有 apt-add-repository 先安装上</div><div class=\"line\">``` bash</div><div class=\"line\"> sudo apt-get install software-properties-common</div><div class=\"line\">``` </div><div class=\"line\">然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。</div><div class=\"line\"><span class=\"comment\">## 安装Nginx</span></div><div class=\"line\">简单，运行：</div><div class=\"line\">``` bash</div><div class=\"line\">sudo apt-get -y install nginx  </div><div class=\"line\">``` </div><div class=\"line\"><span class=\"comment\">## nginx配置php</span></div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo vim /etc/php/7.1/fpm/php.ini  </div><div class=\"line\">``` </div><div class=\"line\">输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：</div><div class=\"line\">编辑fpm的配置文件： 运行：</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo vim /etc/php/7.1/fpm/pool.d/www.conf  </div><div class=\"line\">``` </div><div class=\"line\">找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">service php7.1-fpm stop</div><div class=\"line\">service php7.1-fpm start</div><div class=\"line\">``` </div><div class=\"line\">配置Nginx：</div><div class=\"line\"></div><div class=\"line\">运行：</div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo vim /etc/nginx/sites-available/default  </div><div class=\"line\">``` </div><div class=\"line\">下面是配置文件</div><div class=\"line\">``` bash</div><div class=\"line\">server &#123;  </div><div class=\"line\">    <span class=\"comment\">#listen 80 default_server;</span></div><div class=\"line\">    listen 80;</div><div class=\"line\">    <span class=\"comment\">#listen [::]:80 default_server ipv6only=on;</span></div><div class=\"line\">    </div><div class=\"line\">    root /var/www;</div><div class=\"line\">    index index.php index.html index.htm;</div><div class=\"line\">                                        </div><div class=\"line\">    <span class=\"comment\"># Make site accessible from http://localhost/</span></div><div class=\"line\">    server_name lufficc.com www.lufficc.com;</div><div class=\"line\">    </div><div class=\"line\">    location / &#123;</div><div class=\"line\">        <span class=\"comment\"># First attempt to serve request as file, then</span></div><div class=\"line\">        <span class=\"comment\"># as directory, then fall back to displaying a 404.</span></div><div class=\"line\">        try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</div><div class=\"line\">        <span class=\"comment\"># Uncomment to enable naxsi on this location</span></div><div class=\"line\">        <span class=\"comment\"># include /etc/nginx/naxsi.rules</span></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    location ~ \\.php$ &#123;</div><div class=\"line\">        include snippets/fastcgi-php.conf;</div><div class=\"line\">        <span class=\"comment\"># With php7.0-cgi alone:</span></div><div class=\"line\">        fastcgi_pass 127.0.0.1:9000;</div><div class=\"line\">        <span class=\"comment\"># With php7.0-fpm:</span></div><div class=\"line\">        fastcgi_pass unix:/run/php/php7.0-fpm.sock;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">``` </div><div class=\"line\">&gt; </div><div class=\"line\">  - root：是你的项目的public目录，也就是网站的入口</div><div class=\"line\">  - index：添加了，index.php，告诉Nginx先解析index.php文件</div><div class=\"line\">  - server_name：你的域名，没有的话填写localhost</div><div class=\"line\">  - location / try_files修改为了try_files <span class=\"variable\">$uri</span> <span class=\"variable\">$uri</span>/ /index.php?<span class=\"variable\">$query_string</span>;</div><div class=\"line\">  - location ~ \\.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">## 运行nginx服务</span></div><div class=\"line\"></div><div class=\"line\">``` bash</div><div class=\"line\">sudo service nginx restart  </div><div class=\"line\">sudo service php7.1-fpm restart</div></pre></td></tr></table></figure>\n<p>如果出现下列错误<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">[emerg]: <span class=\"built_in\">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class=\"keyword\">in</span> use)</div></pre></td></tr></table></figure></p>\n<p>这是80端口被占用，运行下面命令，关闭80端口</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo fuser -k 80/tcp</div><div class=\"line\">service nginx start</div></pre></td></tr></table></figure>\n<p><strong>好了，一切完成！</strong></p>"},{"title":"vichrome像vi一样操作你的chrome浏览器","date":"2016-10-18T01:24:53.000Z","_content":"**vichrome**是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。\n下面是它的操作命令：\n## 基础篇\n- k 上移 \n- j 下移 \n- H 后退 \n- L 前进\n- gg 飞到顶部 \n- G 掉到底部 \n- gt 去下一个标签 (ctrl+l) \n- gT 去上一个标签 (ctrl+h)\n- t 新开一个标签 \n- x 关闭当前标签页 \n- X 关闭当前标签页并跳到下一个标签页  \n- u 恢复刚刚的标签页 \n- r 刷新 \n- f 进入f模式(可以点击链接) \n- F 在新标签中进入f模式 \n- i 聚焦在第一个输入框\n- esc 退出\n<!--more-->\n## 进阶篇\n- ctrl+f 下一页\n- ctrl+b 上一页\n- ctrl+d 下半页\n- ctrl+u 上半页\n- / 搜索\n- ? 反向搜索\n- a 在带链接的文本中搜索\n- n 下一个搜索结果\n- N 上一个搜索结果\n- tab 下一个候补选项\n- shift+tab 上一个候补选项\n- : 进入命令模式\n- yy 复制url\n- p/P 打开刚刚复制的url\n- o/O 打开(输入url)\n- s/S 用搜索引擎搜索\n- b/B 打开收藏夹\n## 高级篇\n- gp 新开一个窗口(对当前标签页)\n\n\n\n","source":"_posts/vichrome像vi一样操作你的chrome浏览器.md","raw":"---\ntitle: vichrome像vi一样操作你的chrome浏览器\ndate: 2016-10-18 09:24:53\ntag: 工具\ncategories: 技术\n\n---\n**vichrome**是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。\n下面是它的操作命令：\n## 基础篇\n- k 上移 \n- j 下移 \n- H 后退 \n- L 前进\n- gg 飞到顶部 \n- G 掉到底部 \n- gt 去下一个标签 (ctrl+l) \n- gT 去上一个标签 (ctrl+h)\n- t 新开一个标签 \n- x 关闭当前标签页 \n- X 关闭当前标签页并跳到下一个标签页  \n- u 恢复刚刚的标签页 \n- r 刷新 \n- f 进入f模式(可以点击链接) \n- F 在新标签中进入f模式 \n- i 聚焦在第一个输入框\n- esc 退出\n<!--more-->\n## 进阶篇\n- ctrl+f 下一页\n- ctrl+b 上一页\n- ctrl+d 下半页\n- ctrl+u 上半页\n- / 搜索\n- ? 反向搜索\n- a 在带链接的文本中搜索\n- n 下一个搜索结果\n- N 上一个搜索结果\n- tab 下一个候补选项\n- shift+tab 上一个候补选项\n- : 进入命令模式\n- yy 复制url\n- p/P 打开刚刚复制的url\n- o/O 打开(输入url)\n- s/S 用搜索引擎搜索\n- b/B 打开收藏夹\n## 高级篇\n- gp 新开一个窗口(对当前标签页)\n\n\n\n","slug":"vichrome像vi一样操作你的chrome浏览器","published":1,"updated":"2017-12-10T12:38:46.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q1q000oto7yz5eab2qx","content":"<p><strong>vichrome</strong>是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。<br>下面是它的操作命令：</p>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><ul>\n<li>k 上移 </li>\n<li>j 下移 </li>\n<li>H 后退 </li>\n<li>L 前进</li>\n<li>gg 飞到顶部 </li>\n<li>G 掉到底部 </li>\n<li>gt 去下一个标签 (ctrl+l) </li>\n<li>gT 去上一个标签 (ctrl+h)</li>\n<li>t 新开一个标签 </li>\n<li>x 关闭当前标签页 </li>\n<li>X 关闭当前标签页并跳到下一个标签页  </li>\n<li>u 恢复刚刚的标签页 </li>\n<li>r 刷新 </li>\n<li>f 进入f模式(可以点击链接) </li>\n<li>F 在新标签中进入f模式 </li>\n<li>i 聚焦在第一个输入框</li>\n<li>esc 退出<a id=\"more\"></a>\n<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2></li>\n<li>ctrl+f 下一页</li>\n<li>ctrl+b 上一页</li>\n<li>ctrl+d 下半页</li>\n<li>ctrl+u 上半页</li>\n<li>/ 搜索</li>\n<li>? 反向搜索</li>\n<li>a 在带链接的文本中搜索</li>\n<li>n 下一个搜索结果</li>\n<li>N 上一个搜索结果</li>\n<li>tab 下一个候补选项</li>\n<li>shift+tab 上一个候补选项</li>\n<li>: 进入命令模式</li>\n<li>yy 复制url</li>\n<li>p/P 打开刚刚复制的url</li>\n<li>o/O 打开(输入url)</li>\n<li>s/S 用搜索引擎搜索</li>\n<li>b/B 打开收藏夹<h2 id=\"高级篇\"><a href=\"#高级篇\" class=\"headerlink\" title=\"高级篇\"></a>高级篇</h2></li>\n<li>gp 新开一个窗口(对当前标签页)</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p><strong>vichrome</strong>是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。<br>下面是它的操作命令：</p>\n<h2 id=\"基础篇\"><a href=\"#基础篇\" class=\"headerlink\" title=\"基础篇\"></a>基础篇</h2><ul>\n<li>k 上移 </li>\n<li>j 下移 </li>\n<li>H 后退 </li>\n<li>L 前进</li>\n<li>gg 飞到顶部 </li>\n<li>G 掉到底部 </li>\n<li>gt 去下一个标签 (ctrl+l) </li>\n<li>gT 去上一个标签 (ctrl+h)</li>\n<li>t 新开一个标签 </li>\n<li>x 关闭当前标签页 </li>\n<li>X 关闭当前标签页并跳到下一个标签页  </li>\n<li>u 恢复刚刚的标签页 </li>\n<li>r 刷新 </li>\n<li>f 进入f模式(可以点击链接) </li>\n<li>F 在新标签中进入f模式 </li>\n<li>i 聚焦在第一个输入框</li>\n<li>esc 退出","more":"<h2 id=\"进阶篇\"><a href=\"#进阶篇\" class=\"headerlink\" title=\"进阶篇\"></a>进阶篇</h2></li>\n<li>ctrl+f 下一页</li>\n<li>ctrl+b 上一页</li>\n<li>ctrl+d 下半页</li>\n<li>ctrl+u 上半页</li>\n<li>/ 搜索</li>\n<li>? 反向搜索</li>\n<li>a 在带链接的文本中搜索</li>\n<li>n 下一个搜索结果</li>\n<li>N 上一个搜索结果</li>\n<li>tab 下一个候补选项</li>\n<li>shift+tab 上一个候补选项</li>\n<li>: 进入命令模式</li>\n<li>yy 复制url</li>\n<li>p/P 打开刚刚复制的url</li>\n<li>o/O 打开(输入url)</li>\n<li>s/S 用搜索引擎搜索</li>\n<li>b/B 打开收藏夹<h2 id=\"高级篇\"><a href=\"#高级篇\" class=\"headerlink\" title=\"高级篇\"></a>高级篇</h2></li>\n<li>gp 新开一个窗口(对当前标签页)</li>\n</ul>"},{"title":"vi的使用总结","date":"2016-09-21T14:15:36.000Z","_content":"# 初级篇\n## 移动篇\n- 上 k\n- 下 j\n- 左 h\n- 右 l\n\n- 至顶 gg\n- 至尾部 Shift+g\n- 行跳转 行号+gg\n\n- 行首 Shift+6 (^)\n- 行尾 Shift+4 ($) \n\n- 词组移动(词首) w \n- 词组移动(词首) W \n- 词组移动(词尾) e \n- 词组移动(词尾) E \n\n- 移动到查找的字母后 f\n- 移动到查找的字母后 F\n\n<!--more-->\n## 操作篇\n### 增    \n- 在单词前插入 i\n- 在单词前插入 a\n- 在句首前插入 I\n- 在句尾插入 A\n- 在下一行插入 o\n- 在上一行插入 O\n### 删    \n- 删除光标行内容 d\n- 删除光标至尾行内容 D\n- 删除当前行及n-1行数 数字dd\n### 改    \n- 复制 yy\n- 粘贴 p\n- 替换插入 s\n- 替换整句插入 S\n- 替换单个字母 r\n- 接下来的子都要替换 R\n- 当前行替换第一个单词 :s/oldwords/newwords/\n- 替换当前行所有单词 :s/oldwords/newwords/g\n- 替换每一行的第一个单词 :%s/oldwords/newwords/\n- 替换每一行的单词 :%s/oldwords/newwords/g\n\n### 查    \n- 向后查找 /\n- 向前查找 ?\n\n## 选中篇\n- 左选择 v+h\n- 右选择 v+l\n- 上选择 v+k\n- 下选择 v+j\n\n- 选择当前行V(shift+v) \n- 选择向上行V+k(shift+v) \n- 选择向下行V+j(shift+v) \n\n- 括号内的选择 v+i+) (不含括号)\n- 括号内的选择 v+a+) (包含括号)\n\n- 居中显示 zz \n- 头部显示 zt \n- 尾巴显示 zb \n## 退出篇\n- 不保存退出 :q \n- 保存退出 :wq \n- 保存 :w \n- 强制退出 :q! \n- 强制退出 ctrl+z \n- 恢复 fg\n## 文件切换篇\n- 向右切换 tg\n- 向左切换 tG\n\n","source":"_posts/vi的使用总结.md","raw":"---\ntitle: vi的使用总结\ndate: 2016-09-21 22:15:36\ntags: 编辑器\ncategories: 技术\n\n---\n# 初级篇\n## 移动篇\n- 上 k\n- 下 j\n- 左 h\n- 右 l\n\n- 至顶 gg\n- 至尾部 Shift+g\n- 行跳转 行号+gg\n\n- 行首 Shift+6 (^)\n- 行尾 Shift+4 ($) \n\n- 词组移动(词首) w \n- 词组移动(词首) W \n- 词组移动(词尾) e \n- 词组移动(词尾) E \n\n- 移动到查找的字母后 f\n- 移动到查找的字母后 F\n\n<!--more-->\n## 操作篇\n### 增    \n- 在单词前插入 i\n- 在单词前插入 a\n- 在句首前插入 I\n- 在句尾插入 A\n- 在下一行插入 o\n- 在上一行插入 O\n### 删    \n- 删除光标行内容 d\n- 删除光标至尾行内容 D\n- 删除当前行及n-1行数 数字dd\n### 改    \n- 复制 yy\n- 粘贴 p\n- 替换插入 s\n- 替换整句插入 S\n- 替换单个字母 r\n- 接下来的子都要替换 R\n- 当前行替换第一个单词 :s/oldwords/newwords/\n- 替换当前行所有单词 :s/oldwords/newwords/g\n- 替换每一行的第一个单词 :%s/oldwords/newwords/\n- 替换每一行的单词 :%s/oldwords/newwords/g\n\n### 查    \n- 向后查找 /\n- 向前查找 ?\n\n## 选中篇\n- 左选择 v+h\n- 右选择 v+l\n- 上选择 v+k\n- 下选择 v+j\n\n- 选择当前行V(shift+v) \n- 选择向上行V+k(shift+v) \n- 选择向下行V+j(shift+v) \n\n- 括号内的选择 v+i+) (不含括号)\n- 括号内的选择 v+a+) (包含括号)\n\n- 居中显示 zz \n- 头部显示 zt \n- 尾巴显示 zb \n## 退出篇\n- 不保存退出 :q \n- 保存退出 :wq \n- 保存 :w \n- 强制退出 :q! \n- 强制退出 ctrl+z \n- 恢复 fg\n## 文件切换篇\n- 向右切换 tg\n- 向左切换 tG\n\n","slug":"vi的使用总结","published":1,"updated":"2017-12-10T12:38:46.164Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q1t000sto7yzwrcxt40","content":"<h1 id=\"初级篇\"><a href=\"#初级篇\" class=\"headerlink\" title=\"初级篇\"></a>初级篇</h1><h2 id=\"移动篇\"><a href=\"#移动篇\" class=\"headerlink\" title=\"移动篇\"></a>移动篇</h2><ul>\n<li>上 k</li>\n<li>下 j</li>\n<li>左 h</li>\n<li><p>右 l</p>\n</li>\n<li><p>至顶 gg</p>\n</li>\n<li>至尾部 Shift+g</li>\n<li><p>行跳转 行号+gg</p>\n</li>\n<li><p>行首 Shift+6 (^)</p>\n</li>\n<li><p>行尾 Shift+4 ($) </p>\n</li>\n<li><p>词组移动(词首) w </p>\n</li>\n<li>词组移动(词首) W </li>\n<li>词组移动(词尾) e </li>\n<li><p>词组移动(词尾) E </p>\n</li>\n<li><p>移动到查找的字母后 f</p>\n</li>\n<li>移动到查找的字母后 F</li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"操作篇\"><a href=\"#操作篇\" class=\"headerlink\" title=\"操作篇\"></a>操作篇</h2><h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li>在单词前插入 i</li>\n<li>在单词前插入 a</li>\n<li>在句首前插入 I</li>\n<li>在句尾插入 A</li>\n<li>在下一行插入 o</li>\n<li>在上一行插入 O<h3 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h3></li>\n<li>删除光标行内容 d</li>\n<li>删除光标至尾行内容 D</li>\n<li>删除当前行及n-1行数 数字dd<h3 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h3></li>\n<li>复制 yy</li>\n<li>粘贴 p</li>\n<li>替换插入 s</li>\n<li>替换整句插入 S</li>\n<li>替换单个字母 r</li>\n<li>接下来的子都要替换 R</li>\n<li>当前行替换第一个单词 :s/oldwords/newwords/</li>\n<li>替换当前行所有单词 :s/oldwords/newwords/g</li>\n<li>替换每一行的第一个单词 :%s/oldwords/newwords/</li>\n<li>替换每一行的单词 :%s/oldwords/newwords/g</li>\n</ul>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li>向后查找 /</li>\n<li>向前查找 ?</li>\n</ul>\n<h2 id=\"选中篇\"><a href=\"#选中篇\" class=\"headerlink\" title=\"选中篇\"></a>选中篇</h2><ul>\n<li>左选择 v+h</li>\n<li>右选择 v+l</li>\n<li>上选择 v+k</li>\n<li><p>下选择 v+j</p>\n</li>\n<li><p>选择当前行V(shift+v) </p>\n</li>\n<li>选择向上行V+k(shift+v) </li>\n<li><p>选择向下行V+j(shift+v) </p>\n</li>\n<li><p>括号内的选择 v+i+) (不含括号)</p>\n</li>\n<li><p>括号内的选择 v+a+) (包含括号)</p>\n</li>\n<li><p>居中显示 zz </p>\n</li>\n<li>头部显示 zt </li>\n<li>尾巴显示 zb <h2 id=\"退出篇\"><a href=\"#退出篇\" class=\"headerlink\" title=\"退出篇\"></a>退出篇</h2></li>\n<li>不保存退出 :q </li>\n<li>保存退出 :wq </li>\n<li>保存 :w </li>\n<li>强制退出 :q! </li>\n<li>强制退出 ctrl+z </li>\n<li>恢复 fg<h2 id=\"文件切换篇\"><a href=\"#文件切换篇\" class=\"headerlink\" title=\"文件切换篇\"></a>文件切换篇</h2></li>\n<li>向右切换 tg</li>\n<li>向左切换 tG</li>\n</ul>\n","site":{"data":{}},"excerpt":"<h1 id=\"初级篇\"><a href=\"#初级篇\" class=\"headerlink\" title=\"初级篇\"></a>初级篇</h1><h2 id=\"移动篇\"><a href=\"#移动篇\" class=\"headerlink\" title=\"移动篇\"></a>移动篇</h2><ul>\n<li>上 k</li>\n<li>下 j</li>\n<li>左 h</li>\n<li><p>右 l</p>\n</li>\n<li><p>至顶 gg</p>\n</li>\n<li>至尾部 Shift+g</li>\n<li><p>行跳转 行号+gg</p>\n</li>\n<li><p>行首 Shift+6 (^)</p>\n</li>\n<li><p>行尾 Shift+4 ($) </p>\n</li>\n<li><p>词组移动(词首) w </p>\n</li>\n<li>词组移动(词首) W </li>\n<li>词组移动(词尾) e </li>\n<li><p>词组移动(词尾) E </p>\n</li>\n<li><p>移动到查找的字母后 f</p>\n</li>\n<li>移动到查找的字母后 F</li>\n</ul>","more":"<h2 id=\"操作篇\"><a href=\"#操作篇\" class=\"headerlink\" title=\"操作篇\"></a>操作篇</h2><h3 id=\"增\"><a href=\"#增\" class=\"headerlink\" title=\"增\"></a>增</h3><ul>\n<li>在单词前插入 i</li>\n<li>在单词前插入 a</li>\n<li>在句首前插入 I</li>\n<li>在句尾插入 A</li>\n<li>在下一行插入 o</li>\n<li>在上一行插入 O<h3 id=\"删\"><a href=\"#删\" class=\"headerlink\" title=\"删\"></a>删</h3></li>\n<li>删除光标行内容 d</li>\n<li>删除光标至尾行内容 D</li>\n<li>删除当前行及n-1行数 数字dd<h3 id=\"改\"><a href=\"#改\" class=\"headerlink\" title=\"改\"></a>改</h3></li>\n<li>复制 yy</li>\n<li>粘贴 p</li>\n<li>替换插入 s</li>\n<li>替换整句插入 S</li>\n<li>替换单个字母 r</li>\n<li>接下来的子都要替换 R</li>\n<li>当前行替换第一个单词 :s/oldwords/newwords/</li>\n<li>替换当前行所有单词 :s/oldwords/newwords/g</li>\n<li>替换每一行的第一个单词 :%s/oldwords/newwords/</li>\n<li>替换每一行的单词 :%s/oldwords/newwords/g</li>\n</ul>\n<h3 id=\"查\"><a href=\"#查\" class=\"headerlink\" title=\"查\"></a>查</h3><ul>\n<li>向后查找 /</li>\n<li>向前查找 ?</li>\n</ul>\n<h2 id=\"选中篇\"><a href=\"#选中篇\" class=\"headerlink\" title=\"选中篇\"></a>选中篇</h2><ul>\n<li>左选择 v+h</li>\n<li>右选择 v+l</li>\n<li>上选择 v+k</li>\n<li><p>下选择 v+j</p>\n</li>\n<li><p>选择当前行V(shift+v) </p>\n</li>\n<li>选择向上行V+k(shift+v) </li>\n<li><p>选择向下行V+j(shift+v) </p>\n</li>\n<li><p>括号内的选择 v+i+) (不含括号)</p>\n</li>\n<li><p>括号内的选择 v+a+) (包含括号)</p>\n</li>\n<li><p>居中显示 zz </p>\n</li>\n<li>头部显示 zt </li>\n<li>尾巴显示 zb <h2 id=\"退出篇\"><a href=\"#退出篇\" class=\"headerlink\" title=\"退出篇\"></a>退出篇</h2></li>\n<li>不保存退出 :q </li>\n<li>保存退出 :wq </li>\n<li>保存 :w </li>\n<li>强制退出 :q! </li>\n<li>强制退出 ctrl+z </li>\n<li>恢复 fg<h2 id=\"文件切换篇\"><a href=\"#文件切换篇\" class=\"headerlink\" title=\"文件切换篇\"></a>文件切换篇</h2></li>\n<li>向右切换 tg</li>\n<li>向左切换 tG</li>\n</ul>"},{"title":"swoole利用websocket进行wss访问","date":"2018-01-03T13:32:26.000Z","_content":"最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。\n> **websocket**: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n## 在docker中搭建swoole的环境\n* 先建立build_swoole.sh这样的安装shell文件\n``` shell\napk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev\nln -s /usr/bin/php-config7 /usr/bin/php-config\nln -s /usr/bin/phpize7 /usr/bin/phpize\ncd /root/\ngit clone https://github.com/swoole/swoole-src.git\ncd /root/swoole-src\nphpize\n./configure --enable-openssl\nmake && make install\napk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev\napk del --no-cache php-dev\napk del --no-cache git\napk del --no-cache build-base\napk del --no-cache make\napk del --no-cache openssl-dev\napk del --no-cache linux-headers\napk del --no-cache libaio-dev\napk del --no-cache pcre-dev\napk del --no-cache autoconf\napk del --no-cache .persistent-deps\napk del --no-cache libmcrypt-dev\napk del --no-cache g++\n# apk del --no-cache icu-dev\napk info\nphp -m\nrm -rf /var/cache/apk/*\nrm -rf /root/swoole-src/\nrm -rf /tmp/*\n```\n* 然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入`extension=swoole.so`\n``` shell\nFROM zacksleo/php:7.1-alpine-fpm-supervisor\nCOPY build_swoole.sh /root\nRUN sh /root/build_swoole.sh\n```\n* 接着`docker-composer build 创建对应的docker镜像`，并且运行`docker-composer up`，在进入对应的docker容器中`docker exec 你的镜像名`,执行命令`php -m`,如果出现swoole，那我们的swoole扩展就安装好了\n<!--more-->\n## 创建服务器的swoole的监听\n``` php\n<?php\n\nnamespace console\\controllers;\n\nuse common\\models\\QrcodeToken;\nuse yii;\nuse common\\models\\User;\nuse yii\\console\\Controller;\nuse Swoole\\WebSocket\\Server;\n\n/**\n * Class PremiumController\n * @package console\\controllers\n * @auth graychen <455803034@qq.com>\n */\nclass WebSocketController extends Controller\n{\n    public $server;\n\n    /**\n     * websocket 监听扫码登录\n     */\n    public function actionListenLogin()\n    {\n        $setConfig = array(\n            'ssl_key_file' => '/var/www/html/services/nginx/ssl-cert/ssl.key',\n            'ssl_cert_file' => '/var/www/html/services/nginx/ssl-cert/ssl.crt'\n        );\n        $this->server = new Server('0.0.0.0', 9502, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);\n        $this->server->set($setConfig);\n        $this->server->on('open', function (Server $server, $request) {\n            echo \"server: handshake success with fd{$request->fd}\\n\";\n        });\n        $this->server->on('message', function (Server $server, $frame) {\n            echo \"receive from {$frame->fd}:{$frame->data},opcode:{$frame->opcode},fin:{$frame->finish}\\n\";\n            $message = json_decode($frame->data);\n            $timestamp = $message->timestamp;\n            $token = $message->token;\n            swoole_timer_tick(1000, function ($timerId) use ($token, $server, $frame) {\n                $token = $this->findModel($token);\n                if ($token === null || $token->status == QrcodeToken::STATUS_EXPIRED) {\n                    $response = json_encode([\n                        'timestamp' => time(),\n                        'status' => QrcodeToken::STATUS_EXPIRED\n                    ]);\n                    $server->push($frame->fd, $response);\n                    swoole_timer_clear($timerId);\n                } else {\n                    if ($server->exist($frame->fd) && in_array($token->status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) {\n                        $response = json_encode([\n                            'timestamp' => $token->updated_at,\n                            'status' => $token->status\n                        ]);\n                        $server->push($frame->fd, $response);\n                    }\n                };\n            });\n        });\n        $this->server->on('close', function (Server $server, $fd) {\n            echo \"client {$fd} closed\\n\";\n        });\n        $this->server->start();\n    }\n\n    private function findModel($id)\n    {\n        clearstatcache();\n        $token = QrcodeToken::findOne(['id' => $id]);\n        return $token;\n    }\n}\n\n```\n* 如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。\n``` js\nvar error = false;\n    var timestamp = {$timestamp};\n    var _t = '{$token}';\n    function startWebSocket(){\n        var host=document.domain;\n        websocket = new WebSocket('wss://' + host + ':9502');\n        websocket.onopen = function (evt) {\n            var message={\n                timestamp:timestamp,\n                token:_t\n            };\n            if(message!==null){\n                websocket.send(JSON.stringify(message));\n            }\n        };\n        websocket.onclose = function (evt) {\n            console.log(\\\"关闭连接\\\");\n        };\n        websocket.onmessage = function (evt) {\n            var response=JSON.parse(evt.data);\n            if(response.status==1){                  \n              $('#fn-tips').text('已扫码, 请点击确认');\n              timestamp = response.timestamp;\n            }\n            if(response.status==2){\n              $('#fn-tips').text('已登录, 正在跳转···');\n              setTimeout(function(){\n                $('#ff-qrcode-token').submit();                    \n              },500);                  \n            }\n            if(response.status==-2){\n              alert('二维码已失效, 请刷新页面');\n            }\n            error = false;\n            timestamp = response.timestamp;                \n        };\n        \n        websocket.onerror = function (evt, e) {\n            console.log('错误代码: ' + evt.data);\n        };\n    }\n\n```\n\n\n\n\n\n","source":"_posts/websocket结合swoole进行wss访问.md","raw":"---\ntitle: swoole利用websocket进行wss访问\ndate: 2018-01-03 21:32:26\ntags: 技术\n---\n最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。\n> **websocket**: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。\n\n## 在docker中搭建swoole的环境\n* 先建立build_swoole.sh这样的安装shell文件\n``` shell\napk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev\nln -s /usr/bin/php-config7 /usr/bin/php-config\nln -s /usr/bin/phpize7 /usr/bin/phpize\ncd /root/\ngit clone https://github.com/swoole/swoole-src.git\ncd /root/swoole-src\nphpize\n./configure --enable-openssl\nmake && make install\napk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev\napk del --no-cache php-dev\napk del --no-cache git\napk del --no-cache build-base\napk del --no-cache make\napk del --no-cache openssl-dev\napk del --no-cache linux-headers\napk del --no-cache libaio-dev\napk del --no-cache pcre-dev\napk del --no-cache autoconf\napk del --no-cache .persistent-deps\napk del --no-cache libmcrypt-dev\napk del --no-cache g++\n# apk del --no-cache icu-dev\napk info\nphp -m\nrm -rf /var/cache/apk/*\nrm -rf /root/swoole-src/\nrm -rf /tmp/*\n```\n* 然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入`extension=swoole.so`\n``` shell\nFROM zacksleo/php:7.1-alpine-fpm-supervisor\nCOPY build_swoole.sh /root\nRUN sh /root/build_swoole.sh\n```\n* 接着`docker-composer build 创建对应的docker镜像`，并且运行`docker-composer up`，在进入对应的docker容器中`docker exec 你的镜像名`,执行命令`php -m`,如果出现swoole，那我们的swoole扩展就安装好了\n<!--more-->\n## 创建服务器的swoole的监听\n``` php\n<?php\n\nnamespace console\\controllers;\n\nuse common\\models\\QrcodeToken;\nuse yii;\nuse common\\models\\User;\nuse yii\\console\\Controller;\nuse Swoole\\WebSocket\\Server;\n\n/**\n * Class PremiumController\n * @package console\\controllers\n * @auth graychen <455803034@qq.com>\n */\nclass WebSocketController extends Controller\n{\n    public $server;\n\n    /**\n     * websocket 监听扫码登录\n     */\n    public function actionListenLogin()\n    {\n        $setConfig = array(\n            'ssl_key_file' => '/var/www/html/services/nginx/ssl-cert/ssl.key',\n            'ssl_cert_file' => '/var/www/html/services/nginx/ssl-cert/ssl.crt'\n        );\n        $this->server = new Server('0.0.0.0', 9502, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);\n        $this->server->set($setConfig);\n        $this->server->on('open', function (Server $server, $request) {\n            echo \"server: handshake success with fd{$request->fd}\\n\";\n        });\n        $this->server->on('message', function (Server $server, $frame) {\n            echo \"receive from {$frame->fd}:{$frame->data},opcode:{$frame->opcode},fin:{$frame->finish}\\n\";\n            $message = json_decode($frame->data);\n            $timestamp = $message->timestamp;\n            $token = $message->token;\n            swoole_timer_tick(1000, function ($timerId) use ($token, $server, $frame) {\n                $token = $this->findModel($token);\n                if ($token === null || $token->status == QrcodeToken::STATUS_EXPIRED) {\n                    $response = json_encode([\n                        'timestamp' => time(),\n                        'status' => QrcodeToken::STATUS_EXPIRED\n                    ]);\n                    $server->push($frame->fd, $response);\n                    swoole_timer_clear($timerId);\n                } else {\n                    if ($server->exist($frame->fd) && in_array($token->status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) {\n                        $response = json_encode([\n                            'timestamp' => $token->updated_at,\n                            'status' => $token->status\n                        ]);\n                        $server->push($frame->fd, $response);\n                    }\n                };\n            });\n        });\n        $this->server->on('close', function (Server $server, $fd) {\n            echo \"client {$fd} closed\\n\";\n        });\n        $this->server->start();\n    }\n\n    private function findModel($id)\n    {\n        clearstatcache();\n        $token = QrcodeToken::findOne(['id' => $id]);\n        return $token;\n    }\n}\n\n```\n* 如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。\n``` js\nvar error = false;\n    var timestamp = {$timestamp};\n    var _t = '{$token}';\n    function startWebSocket(){\n        var host=document.domain;\n        websocket = new WebSocket('wss://' + host + ':9502');\n        websocket.onopen = function (evt) {\n            var message={\n                timestamp:timestamp,\n                token:_t\n            };\n            if(message!==null){\n                websocket.send(JSON.stringify(message));\n            }\n        };\n        websocket.onclose = function (evt) {\n            console.log(\\\"关闭连接\\\");\n        };\n        websocket.onmessage = function (evt) {\n            var response=JSON.parse(evt.data);\n            if(response.status==1){                  \n              $('#fn-tips').text('已扫码, 请点击确认');\n              timestamp = response.timestamp;\n            }\n            if(response.status==2){\n              $('#fn-tips').text('已登录, 正在跳转···');\n              setTimeout(function(){\n                $('#ff-qrcode-token').submit();                    \n              },500);                  \n            }\n            if(response.status==-2){\n              alert('二维码已失效, 请刷新页面');\n            }\n            error = false;\n            timestamp = response.timestamp;                \n        };\n        \n        websocket.onerror = function (evt, e) {\n            console.log('错误代码: ' + evt.data);\n        };\n    }\n\n```\n\n\n\n\n\n","slug":"websocket结合swoole进行wss访问","published":1,"updated":"2018-01-03T15:20:10.123Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q1x000vto7yniem7qb7","content":"<p>最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。</p>\n<blockquote>\n<p><strong>websocket</strong>: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n</blockquote>\n<h2 id=\"在docker中搭建swoole的环境\"><a href=\"#在docker中搭建swoole的环境\" class=\"headerlink\" title=\"在docker中搭建swoole的环境\"></a>在docker中搭建swoole的环境</h2><ul>\n<li><p>先建立build_swoole.sh这样的安装shell文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">apk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev</div><div class=\"line\">ln -s /usr/bin/php-config7 /usr/bin/php-config</div><div class=\"line\">ln -s /usr/bin/phpize7 /usr/bin/phpize</div><div class=\"line\">cd /root/</div><div class=\"line\">git clone https://github.com/swoole/swoole-src.git</div><div class=\"line\">cd /root/swoole-src</div><div class=\"line\">phpize</div><div class=\"line\">./configure --enable-openssl</div><div class=\"line\">make &amp;&amp; make install</div><div class=\"line\">apk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev</div><div class=\"line\">apk del --no-cache php-dev</div><div class=\"line\">apk del --no-cache git</div><div class=\"line\">apk del --no-cache build-base</div><div class=\"line\">apk del --no-cache make</div><div class=\"line\">apk del --no-cache openssl-dev</div><div class=\"line\">apk del --no-cache linux-headers</div><div class=\"line\">apk del --no-cache libaio-dev</div><div class=\"line\">apk del --no-cache pcre-dev</div><div class=\"line\">apk del --no-cache autoconf</div><div class=\"line\">apk del --no-cache .persistent-deps</div><div class=\"line\">apk del --no-cache libmcrypt-dev</div><div class=\"line\">apk del --no-cache g++</div><div class=\"line\"># apk del --no-cache icu-dev</div><div class=\"line\">apk info</div><div class=\"line\">php -m</div><div class=\"line\">rm -rf /var/cache/apk/*</div><div class=\"line\">rm -rf /root/swoole-src/</div><div class=\"line\">rm -rf /tmp/*</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入<code>extension=swoole.so</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM zacksleo/php:7.1-alpine-fpm-supervisor</div><div class=\"line\">COPY build_swoole.sh /root</div><div class=\"line\">RUN sh /root/build_swoole.sh</div></pre></td></tr></table></figure>\n</li>\n<li><p>接着<code>docker-composer build 创建对应的docker镜像</code>，并且运行<code>docker-composer up</code>，在进入对应的docker容器中<code>docker exec 你的镜像名</code>,执行命令<code>php -m</code>,如果出现swoole，那我们的swoole扩展就安装好了</p>\n<a id=\"more\"></a>\n<h2 id=\"创建服务器的swoole的监听\"><a href=\"#创建服务器的swoole的监听\" class=\"headerlink\" title=\"创建服务器的swoole的监听\"></a>创建服务器的swoole的监听</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">console</span>\\<span class=\"title\">controllers</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">QrcodeToken</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">User</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>\\<span class=\"title\">console</span>\\<span class=\"title\">Controller</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Swoole</span>\\<span class=\"title\">WebSocket</span>\\<span class=\"title\">Server</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Class PremiumController</div><div class=\"line\"> * <span class=\"doctag\">@package</span> console\\controllers</div><div class=\"line\"> * <span class=\"doctag\">@auth</span> graychen &lt;455803034<span class=\"doctag\">@qq</span>.com&gt;</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSocketController</span> <span class=\"keyword\">extends</span> <span class=\"title\">Controller</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> $server;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * websocket 监听扫码登录</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionListenLogin</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        $setConfig = <span class=\"keyword\">array</span>(</div><div class=\"line\">            <span class=\"string\">'ssl_key_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.key'</span>,</div><div class=\"line\">            <span class=\"string\">'ssl_cert_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.crt'</span></div><div class=\"line\">        );</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server = <span class=\"keyword\">new</span> Server(<span class=\"string\">'0.0.0.0'</span>, <span class=\"number\">9502</span>, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;set($setConfig);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'open'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $request)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"server: handshake success with fd&#123;$request-&gt;fd&#125;\\n\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $frame)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n\"</span>;</div><div class=\"line\">            $message = json_decode($frame-&gt;data);</div><div class=\"line\">            $timestamp = $message-&gt;timestamp;</div><div class=\"line\">            $token = $message-&gt;token;</div><div class=\"line\">            swoole_timer_tick(<span class=\"number\">1000</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">($timerId)</span> <span class=\"title\">use</span> <span class=\"params\">($token, $server, $frame)</span> </span>&#123;</div><div class=\"line\">                $token = <span class=\"keyword\">$this</span>-&gt;findModel($token);</div><div class=\"line\">                <span class=\"keyword\">if</span> ($token === <span class=\"keyword\">null</span> || $token-&gt;status == QrcodeToken::STATUS_EXPIRED) &#123;</div><div class=\"line\">                    $response = json_encode([</div><div class=\"line\">                        <span class=\"string\">'timestamp'</span> =&gt; time(),</div><div class=\"line\">                        <span class=\"string\">'status'</span> =&gt; QrcodeToken::STATUS_EXPIRED</div><div class=\"line\">                    ]);</div><div class=\"line\">                    $server-&gt;push($frame-&gt;fd, $response);</div><div class=\"line\">                    swoole_timer_clear($timerId);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> ($server-&gt;exist($frame-&gt;fd) &amp;&amp; in_array($token-&gt;status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) &#123;</div><div class=\"line\">                        $response = json_encode([</div><div class=\"line\">                            <span class=\"string\">'timestamp'</span> =&gt; $token-&gt;updated_at,</div><div class=\"line\">                            <span class=\"string\">'status'</span> =&gt; $token-&gt;status</div><div class=\"line\">                        ]);</div><div class=\"line\">                        $server-&gt;push($frame-&gt;fd, $response);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'close'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $fd)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"client &#123;$fd&#125; closed\\n\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findModel</span><span class=\"params\">($id)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        clearstatcache();</div><div class=\"line\">        $token = QrcodeToken::findOne([<span class=\"string\">'id'</span> =&gt; $id]);</div><div class=\"line\">        <span class=\"keyword\">return</span> $token;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">var error = false;</div><div class=\"line\">    var timestamp = &#123;$timestamp&#125;;</div><div class=\"line\">    var _t = '&#123;$token&#125;';</div><div class=\"line\">    function startWebSocket()&#123;</div><div class=\"line\">        var host=document.domain;</div><div class=\"line\">        websocket = new WebSocket('wss://' + host + ':9502');</div><div class=\"line\">        websocket.onopen = function (evt) &#123;</div><div class=\"line\">            var message=&#123;</div><div class=\"line\">                timestamp:timestamp,</div><div class=\"line\">                token:_t</div><div class=\"line\">            &#125;;</div><div class=\"line\">            if(message!==null)&#123;</div><div class=\"line\">                websocket.send(JSON.stringify(message));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        websocket.onclose = function (evt) &#123;</div><div class=\"line\">            console.log(\\\"关闭连接\\\");</div><div class=\"line\">        &#125;;</div><div class=\"line\">        websocket.onmessage = function (evt) &#123;</div><div class=\"line\">            var response=JSON.parse(evt.data);</div><div class=\"line\">            if(response.status==1)&#123;                  </div><div class=\"line\">              $('#fn-tips').text('已扫码, 请点击确认');</div><div class=\"line\">              timestamp = response.timestamp;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if(response.status==2)&#123;</div><div class=\"line\">              $('#fn-tips').text('已登录, 正在跳转···');</div><div class=\"line\">              setTimeout(function()&#123;</div><div class=\"line\">                $('#ff-qrcode-token').submit();                    </div><div class=\"line\">              &#125;,500);                  </div><div class=\"line\">            &#125;</div><div class=\"line\">            if(response.status==-2)&#123;</div><div class=\"line\">              alert('二维码已失效, 请刷新页面');</div><div class=\"line\">            &#125;</div><div class=\"line\">            error = false;</div><div class=\"line\">            timestamp = response.timestamp;                </div><div class=\"line\">        &#125;;</div><div class=\"line\">        </div><div class=\"line\">        websocket.onerror = function (evt, e) &#123;</div><div class=\"line\">            console.log('错误代码: ' + evt.data);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>最近利用swoole的websocket对扫码登录进行重构，原本是利用长轮循监听用户的的扫码，但对服务器的资源消耗太大，所以改用websocket节省带宽和服务器资源。</p>\n<blockquote>\n<p><strong>websocket</strong>: 一种在单个 TCP 连接上进行全双工通讯的协议。使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>\n</blockquote>\n<h2 id=\"在docker中搭建swoole的环境\"><a href=\"#在docker中搭建swoole的环境\" class=\"headerlink\" title=\"在docker中搭建swoole的环境\"></a>在docker中搭建swoole的环境</h2><ul>\n<li><p>先建立build_swoole.sh这样的安装shell文件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">apk add git autoconf build-base linux-headers libaio-dev pcre-dev openssl-dev icu-dev</div><div class=\"line\">ln -s /usr/bin/php-config7 /usr/bin/php-config</div><div class=\"line\">ln -s /usr/bin/phpize7 /usr/bin/phpize</div><div class=\"line\">cd /root/</div><div class=\"line\">git clone https://github.com/swoole/swoole-src.git</div><div class=\"line\">cd /root/swoole-src</div><div class=\"line\">phpize</div><div class=\"line\">./configure --enable-openssl</div><div class=\"line\">make &amp;&amp; make install</div><div class=\"line\">apk del libaio-dev php-dev git autoconf build-base linux-headers pcre-dev</div><div class=\"line\">apk del --no-cache php-dev</div><div class=\"line\">apk del --no-cache git</div><div class=\"line\">apk del --no-cache build-base</div><div class=\"line\">apk del --no-cache make</div><div class=\"line\">apk del --no-cache openssl-dev</div><div class=\"line\">apk del --no-cache linux-headers</div><div class=\"line\">apk del --no-cache libaio-dev</div><div class=\"line\">apk del --no-cache pcre-dev</div><div class=\"line\">apk del --no-cache autoconf</div><div class=\"line\">apk del --no-cache .persistent-deps</div><div class=\"line\">apk del --no-cache libmcrypt-dev</div><div class=\"line\">apk del --no-cache g++</div><div class=\"line\"># apk del --no-cache icu-dev</div><div class=\"line\">apk info</div><div class=\"line\">php -m</div><div class=\"line\">rm -rf /var/cache/apk/*</div><div class=\"line\">rm -rf /root/swoole-src/</div><div class=\"line\">rm -rf /tmp/*</div></pre></td></tr></table></figure>\n</li>\n<li><p>然后在Dockerfile中使用我们的安装脚本,编译安装成功后，修改php.ini加入<code>extension=swoole.so</code></p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">FROM zacksleo/php:7.1-alpine-fpm-supervisor</div><div class=\"line\">COPY build_swoole.sh /root</div><div class=\"line\">RUN sh /root/build_swoole.sh</div></pre></td></tr></table></figure>\n</li>\n<li><p>接着<code>docker-composer build 创建对应的docker镜像</code>，并且运行<code>docker-composer up</code>，在进入对应的docker容器中<code>docker exec 你的镜像名</code>,执行命令<code>php -m</code>,如果出现swoole，那我们的swoole扩展就安装好了</p>","more":"<h2 id=\"创建服务器的swoole的监听\"><a href=\"#创建服务器的swoole的监听\" class=\"headerlink\" title=\"创建服务器的swoole的监听\"></a>创建服务器的swoole的监听</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">namespace</span> <span class=\"title\">console</span>\\<span class=\"title\">controllers</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">QrcodeToken</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">common</span>\\<span class=\"title\">models</span>\\<span class=\"title\">User</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">yii</span>\\<span class=\"title\">console</span>\\<span class=\"title\">Controller</span>;</div><div class=\"line\"><span class=\"keyword\">use</span> <span class=\"title\">Swoole</span>\\<span class=\"title\">WebSocket</span>\\<span class=\"title\">Server</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\"> * Class PremiumController</div><div class=\"line\"> * <span class=\"doctag\">@package</span> console\\controllers</div><div class=\"line\"> * <span class=\"doctag\">@auth</span> graychen &lt;455803034<span class=\"doctag\">@qq</span>.com&gt;</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WebSocketController</span> <span class=\"keyword\">extends</span> <span class=\"title\">Controller</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> $server;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">/**</span></div><div class=\"line\">     * websocket 监听扫码登录</div><div class=\"line\">     */</div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">actionListenLogin</span><span class=\"params\">()</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        $setConfig = <span class=\"keyword\">array</span>(</div><div class=\"line\">            <span class=\"string\">'ssl_key_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.key'</span>,</div><div class=\"line\">            <span class=\"string\">'ssl_cert_file'</span> =&gt; <span class=\"string\">'/var/www/html/services/nginx/ssl-cert/ssl.crt'</span></div><div class=\"line\">        );</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server = <span class=\"keyword\">new</span> Server(<span class=\"string\">'0.0.0.0'</span>, <span class=\"number\">9502</span>, SWOOLE_PROCESS, SWOOLE_SOCK_TCP | SWOOLE_SSL);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;set($setConfig);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'open'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $request)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"server: handshake success with fd&#123;$request-&gt;fd&#125;\\n\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'message'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $frame)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"receive from &#123;$frame-&gt;fd&#125;:&#123;$frame-&gt;data&#125;,opcode:&#123;$frame-&gt;opcode&#125;,fin:&#123;$frame-&gt;finish&#125;\\n\"</span>;</div><div class=\"line\">            $message = json_decode($frame-&gt;data);</div><div class=\"line\">            $timestamp = $message-&gt;timestamp;</div><div class=\"line\">            $token = $message-&gt;token;</div><div class=\"line\">            swoole_timer_tick(<span class=\"number\">1000</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">($timerId)</span> <span class=\"title\">use</span> <span class=\"params\">($token, $server, $frame)</span> </span>&#123;</div><div class=\"line\">                $token = <span class=\"keyword\">$this</span>-&gt;findModel($token);</div><div class=\"line\">                <span class=\"keyword\">if</span> ($token === <span class=\"keyword\">null</span> || $token-&gt;status == QrcodeToken::STATUS_EXPIRED) &#123;</div><div class=\"line\">                    $response = json_encode([</div><div class=\"line\">                        <span class=\"string\">'timestamp'</span> =&gt; time(),</div><div class=\"line\">                        <span class=\"string\">'status'</span> =&gt; QrcodeToken::STATUS_EXPIRED</div><div class=\"line\">                    ]);</div><div class=\"line\">                    $server-&gt;push($frame-&gt;fd, $response);</div><div class=\"line\">                    swoole_timer_clear($timerId);</div><div class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> ($server-&gt;exist($frame-&gt;fd) &amp;&amp; in_array($token-&gt;status, [QrcodeToken::STATUS_SCANNED, QrcodeToken::STATUS_LOGGED_IN])) &#123;</div><div class=\"line\">                        $response = json_encode([</div><div class=\"line\">                            <span class=\"string\">'timestamp'</span> =&gt; $token-&gt;updated_at,</div><div class=\"line\">                            <span class=\"string\">'status'</span> =&gt; $token-&gt;status</div><div class=\"line\">                        ]);</div><div class=\"line\">                        $server-&gt;push($frame-&gt;fd, $response);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">            &#125;);</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;on(<span class=\"string\">'close'</span>, <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"params\">(Server $server, $fd)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">echo</span> <span class=\"string\">\"client &#123;$fd&#125; closed\\n\"</span>;</div><div class=\"line\">        &#125;);</div><div class=\"line\">        <span class=\"keyword\">$this</span>-&gt;server-&gt;start();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">findModel</span><span class=\"params\">($id)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        clearstatcache();</div><div class=\"line\">        $token = QrcodeToken::findOne([<span class=\"string\">'id'</span> =&gt; $id]);</div><div class=\"line\">        <span class=\"keyword\">return</span> $token;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n<li><p>如果你的网站本身是https，那必须要用wss，就是在原来的ws连接的基础上加入对应的ssl连接证书,注意如果你是在本地连接的话，因为证书需要对应的域名，可以通过修改linux环境下的hosts文件，将127.0.0.1的对应域名改成你证书的域名即可。</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div></pre></td><td class=\"code\"><pre><div class=\"line\">var error = false;</div><div class=\"line\">    var timestamp = &#123;$timestamp&#125;;</div><div class=\"line\">    var _t = '&#123;$token&#125;';</div><div class=\"line\">    function startWebSocket()&#123;</div><div class=\"line\">        var host=document.domain;</div><div class=\"line\">        websocket = new WebSocket('wss://' + host + ':9502');</div><div class=\"line\">        websocket.onopen = function (evt) &#123;</div><div class=\"line\">            var message=&#123;</div><div class=\"line\">                timestamp:timestamp,</div><div class=\"line\">                token:_t</div><div class=\"line\">            &#125;;</div><div class=\"line\">            if(message!==null)&#123;</div><div class=\"line\">                websocket.send(JSON.stringify(message));</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;;</div><div class=\"line\">        websocket.onclose = function (evt) &#123;</div><div class=\"line\">            console.log(\\\"关闭连接\\\");</div><div class=\"line\">        &#125;;</div><div class=\"line\">        websocket.onmessage = function (evt) &#123;</div><div class=\"line\">            var response=JSON.parse(evt.data);</div><div class=\"line\">            if(response.status==1)&#123;                  </div><div class=\"line\">              $('#fn-tips').text('已扫码, 请点击确认');</div><div class=\"line\">              timestamp = response.timestamp;</div><div class=\"line\">            &#125;</div><div class=\"line\">            if(response.status==2)&#123;</div><div class=\"line\">              $('#fn-tips').text('已登录, 正在跳转···');</div><div class=\"line\">              setTimeout(function()&#123;</div><div class=\"line\">                $('#ff-qrcode-token').submit();                    </div><div class=\"line\">              &#125;,500);                  </div><div class=\"line\">            &#125;</div><div class=\"line\">            if(response.status==-2)&#123;</div><div class=\"line\">              alert('二维码已失效, 请刷新页面');</div><div class=\"line\">            &#125;</div><div class=\"line\">            error = false;</div><div class=\"line\">            timestamp = response.timestamp;                </div><div class=\"line\">        &#125;;</div><div class=\"line\">        </div><div class=\"line\">        websocket.onerror = function (evt, e) &#123;</div><div class=\"line\">            console.log('错误代码: ' + evt.data);</div><div class=\"line\">        &#125;;</div><div class=\"line\">    &#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>"},{"title":"yii2-queue队列的使用说明","date":"2017-07-28T04:15:36.000Z","_content":"## 概述\n\nyii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。\n\n## 来源\n\n+ [github](https://github.com/yiisoft/yii2-queue)\n+ [packaglist](https://packagist.org/packages/yiisoft/yii2-queue)\n\n<!--more-->\n## 安装 \n\n``` php\ncomposer require yiisoft/yii2-queue\n```\n或者\n\n``` php\n在composer中添加\"yiisoft/yii2-queue\": \"~2.0.0\",然后持续composer install\n```\n<!--more-->\n\n## 操作步骤\n发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：\n下面的例子以redis作为驱动，[其它驱动](https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md)\n首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/\n注意要为queue配置一个queue的redis配置\n```return [\n    'bootstrap' => [\n            'queue', // The component registers own console commands\n    ],\n    'compoents' => [\n        ...//其它的配置\n        'redis_queue' => [\n            'class' => 'yii\\redis\\Connection',\n            'hostname' => 'redis',\n            'port' => '6379',\n            'database' => 0,\n        ],\n        'queue' => [\n            'class' => \\yii\\queue\\redis\\Queue::class,\n            'redis' => 'redis2', // Redis connection component or its config\n            'channel' => 'queue', // Queue channel key\n            'as log' => \\yii\\queue\\LogBehavior::class\n        ],\n    ]\n```\n\n\n``` php\nclass DownloadJob extends Object implements \\yii\\queue\\Job\n{\n    public $url;\n    public $file;\n                \n    public function execute($queue)\n    {\n        file_put_contents($this->file, file_get_contents($this->url));\n    }\n}\n\n```\n\n以下是将任务发送到队列中的方法：\n\n``` php\nYii::$app->queue->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n\n```\n\n将作业推入5分钟后运行的队列：\n\n``` php\nYii::$app->queue->delay(5 * 60)->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n```\n\n执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。\n在循环中获取并执行任务的命令，直到队列为空：\n\n``` php\nyii queue/run\n```\n\n命令启动一个无限查询队列的守护程序：\n\n``` php\nyii queue/listen\n```\n该组件具有跟踪被推入队列的作业的状态的能力。\n\n``` php\n\n//将作业推入队列并获取按摩ID。\n$id = Yii::$app->queue->push(new SomeJob());\n\n//工作正在等待执行。\nYii::$app->queue->isWaiting($id);\n\n// Worker从队列中获取作业并执行它。\nYii::$app->queue->isReserved($id);\n\n// Worker已经执行了这个工作。\nYii::$app->queue->isDone($id);\n\n```\n## 使用Supervisor管理php yii queue/listen\nSupervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：\n``` php\nsudo apt-get install supervisor\n```\n主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。\n配置示例:\n``` php\n[program:yii-queue-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/bin/php /var/www/my_project/yii queue/listen --verbose=1 --color=0\nautostart=true\nautorestart=true\nuser=www-data\nnumprocs=4\nredirect_stderr=true\nstdout_logfile=/var/www/my_project/log/yii-queue-worker.log\n```\n\n\n\n\n\n\n","source":"_posts/yii2-queue队列的使用说明.md","raw":"---\ntitle: yii2-queue队列的使用说明\ndate: 2017-07-28 12:15:36\ntags: 编辑器\ncategories: 技术\n\n---\n## 概述\n\nyii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。\n\n## 来源\n\n+ [github](https://github.com/yiisoft/yii2-queue)\n+ [packaglist](https://packagist.org/packages/yiisoft/yii2-queue)\n\n<!--more-->\n## 安装 \n\n``` php\ncomposer require yiisoft/yii2-queue\n```\n或者\n\n``` php\n在composer中添加\"yiisoft/yii2-queue\": \"~2.0.0\",然后持续composer install\n```\n<!--more-->\n\n## 操作步骤\n发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：\n下面的例子以redis作为驱动，[其它驱动](https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md)\n首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/\n注意要为queue配置一个queue的redis配置\n```return [\n    'bootstrap' => [\n            'queue', // The component registers own console commands\n    ],\n    'compoents' => [\n        ...//其它的配置\n        'redis_queue' => [\n            'class' => 'yii\\redis\\Connection',\n            'hostname' => 'redis',\n            'port' => '6379',\n            'database' => 0,\n        ],\n        'queue' => [\n            'class' => \\yii\\queue\\redis\\Queue::class,\n            'redis' => 'redis2', // Redis connection component or its config\n            'channel' => 'queue', // Queue channel key\n            'as log' => \\yii\\queue\\LogBehavior::class\n        ],\n    ]\n```\n\n\n``` php\nclass DownloadJob extends Object implements \\yii\\queue\\Job\n{\n    public $url;\n    public $file;\n                \n    public function execute($queue)\n    {\n        file_put_contents($this->file, file_get_contents($this->url));\n    }\n}\n\n```\n\n以下是将任务发送到队列中的方法：\n\n``` php\nYii::$app->queue->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n\n```\n\n将作业推入5分钟后运行的队列：\n\n``` php\nYii::$app->queue->delay(5 * 60)->push(new DownloadJob([\n    'url' => 'http://example.com/image.jpg',\n    'file' => '/tmp/image.jpg',\n]));\n```\n\n执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。\n在循环中获取并执行任务的命令，直到队列为空：\n\n``` php\nyii queue/run\n```\n\n命令启动一个无限查询队列的守护程序：\n\n``` php\nyii queue/listen\n```\n该组件具有跟踪被推入队列的作业的状态的能力。\n\n``` php\n\n//将作业推入队列并获取按摩ID。\n$id = Yii::$app->queue->push(new SomeJob());\n\n//工作正在等待执行。\nYii::$app->queue->isWaiting($id);\n\n// Worker从队列中获取作业并执行它。\nYii::$app->queue->isReserved($id);\n\n// Worker已经执行了这个工作。\nYii::$app->queue->isDone($id);\n\n```\n## 使用Supervisor管理php yii queue/listen\nSupervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：\n``` php\nsudo apt-get install supervisor\n```\n主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。\n配置示例:\n``` php\n[program:yii-queue-worker]\nprocess_name=%(program_name)s_%(process_num)02d\ncommand=/usr/bin/php /var/www/my_project/yii queue/listen --verbose=1 --color=0\nautostart=true\nautorestart=true\nuser=www-data\nnumprocs=4\nredirect_stderr=true\nstdout_logfile=/var/www/my_project/log/yii-queue-worker.log\n```\n\n\n\n\n\n\n","slug":"yii2-queue队列的使用说明","published":1,"updated":"2017-12-10T12:38:46.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q27000yto7y2fxs7gwq","content":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>yii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。</p>\n<h2 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h2><ul>\n<li><a href=\"https://github.com/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li><a href=\"https://packagist.org/packages/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">packaglist</a></li>\n</ul>\n<a id=\"more\"></a>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer <span class=\"keyword\">require</span> yiisoft/yii2-queue</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">在composer中添加<span class=\"string\">\"yiisoft/yii2-queue\"</span>: <span class=\"string\">\"~2.0.0\"</span>,然后持续composer install</div></pre></td></tr></table></figure>\n<!--more-->\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><p>发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：<br>下面的例子以redis作为驱动，<a href=\"https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md\" target=\"_blank\" rel=\"noopener\">其它驱动</a><br>首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/<br>注意要为queue配置一个queue的redis配置<br><figure class=\"highlight plain\"><figcaption><span>[</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;bootstrap&apos; =&gt; [</div><div class=\"line\">        &apos;queue&apos;, // The component registers own console commands</div><div class=\"line\">],</div><div class=\"line\">&apos;compoents&apos; =&gt; [</div><div class=\"line\">    ...//其它的配置</div><div class=\"line\">    &apos;redis_queue&apos; =&gt; [</div><div class=\"line\">        &apos;class&apos; =&gt; &apos;yii\\redis\\Connection&apos;,</div><div class=\"line\">        &apos;hostname&apos; =&gt; &apos;redis&apos;,</div><div class=\"line\">        &apos;port&apos; =&gt; &apos;6379&apos;,</div><div class=\"line\">        &apos;database&apos; =&gt; 0,</div><div class=\"line\">    ],</div><div class=\"line\">    &apos;queue&apos; =&gt; [</div><div class=\"line\">        &apos;class&apos; =&gt; \\yii\\queue\\redis\\Queue::class,</div><div class=\"line\">        &apos;redis&apos; =&gt; &apos;redis2&apos;, // Redis connection component or its config</div><div class=\"line\">        &apos;channel&apos; =&gt; &apos;queue&apos;, // Queue channel key</div><div class=\"line\">        &apos;as log&apos; =&gt; \\yii\\queue\\LogBehavior::class</div><div class=\"line\">    ],</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadJob</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">yii</span>\\<span class=\"title\">queue</span>\\<span class=\"title\">Job</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> $url;</div><div class=\"line\">    <span class=\"keyword\">public</span> $file;</div><div class=\"line\">                </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span><span class=\"params\">($queue)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        file_put_contents(<span class=\"keyword\">$this</span>-&gt;file, file_get_contents(<span class=\"keyword\">$this</span>-&gt;url));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以下是将任务发送到队列中的方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</div><div class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</div><div class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</div><div class=\"line\">]));</div></pre></td></tr></table></figure>\n<p>将作业推入5分钟后运行的队列：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Yii::$app-&gt;queue-&gt;delay(<span class=\"number\">5</span> * <span class=\"number\">60</span>)-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</div><div class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</div><div class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</div><div class=\"line\">]));</div></pre></td></tr></table></figure>\n<p>执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。<br>在循环中获取并执行任务的命令，直到队列为空：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yii queue/run</div></pre></td></tr></table></figure>\n<p>命令启动一个无限查询队列的守护程序：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yii queue/listen</div></pre></td></tr></table></figure>\n<p>该组件具有跟踪被推入队列的作业的状态的能力。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将作业推入队列并获取按摩ID。</span></div><div class=\"line\">$id = Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> SomeJob());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//工作正在等待执行。</span></div><div class=\"line\">Yii::$app-&gt;queue-&gt;isWaiting($id);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Worker从队列中获取作业并执行它。</span></div><div class=\"line\">Yii::$app-&gt;queue-&gt;isReserved($id);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Worker已经执行了这个工作。</span></div><div class=\"line\">Yii::$app-&gt;queue-&gt;isDone($id);</div></pre></td></tr></table></figure>\n<h2 id=\"使用Supervisor管理php-yii-queue-listen\"><a href=\"#使用Supervisor管理php-yii-queue-listen\" class=\"headerlink\" title=\"使用Supervisor管理php yii queue/listen\"></a>使用Supervisor管理php yii queue/listen</h2><p>Supervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install supervisor</div></pre></td></tr></table></figure></p>\n<p>主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。<br>配置示例:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:yii-queue-worker]</div><div class=\"line\">process_name=%(program_name)s_%(process_num)<span class=\"number\">02</span>d</div><div class=\"line\">command=/usr/bin/php /<span class=\"keyword\">var</span>/www/my_project/yii queue/listen --verbose=<span class=\"number\">1</span> --color=<span class=\"number\">0</span></div><div class=\"line\">autostart=<span class=\"keyword\">true</span></div><div class=\"line\">autorestart=<span class=\"keyword\">true</span></div><div class=\"line\">user=www-data</div><div class=\"line\">numprocs=<span class=\"number\">4</span></div><div class=\"line\">redirect_stderr=<span class=\"keyword\">true</span></div><div class=\"line\">stdout_logfile=/<span class=\"keyword\">var</span>/www/my_project/log/yii-queue-worker.log</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h2><p>yii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。</p>\n<h2 id=\"来源\"><a href=\"#来源\" class=\"headerlink\" title=\"来源\"></a>来源</h2><ul>\n<li><a href=\"https://github.com/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">github</a></li>\n<li><a href=\"https://packagist.org/packages/yiisoft/yii2-queue\" target=\"_blank\" rel=\"noopener\">packaglist</a></li>\n</ul>","more":"<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer <span class=\"keyword\">require</span> yiisoft/yii2-queue</div></pre></td></tr></table></figure>\n<p>或者</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">在composer中添加<span class=\"string\">\"yiisoft/yii2-queue\"</span>: <span class=\"string\">\"~2.0.0\"</span>,然后持续composer install</div></pre></td></tr></table></figure>\n<!--more-->\n<h2 id=\"操作步骤\"><a href=\"#操作步骤\" class=\"headerlink\" title=\"操作步骤\"></a>操作步骤</h2><p>发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：<br>下面的例子以redis作为驱动，<a href=\"https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md\" target=\"_blank\" rel=\"noopener\">其它驱动</a><br>首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/<br>注意要为queue配置一个queue的redis配置<br><figure class=\"highlight plain\"><figcaption><span>[</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div></pre></td><td class=\"code\"><pre><div class=\"line\">&apos;bootstrap&apos; =&gt; [</div><div class=\"line\">        &apos;queue&apos;, // The component registers own console commands</div><div class=\"line\">],</div><div class=\"line\">&apos;compoents&apos; =&gt; [</div><div class=\"line\">    ...//其它的配置</div><div class=\"line\">    &apos;redis_queue&apos; =&gt; [</div><div class=\"line\">        &apos;class&apos; =&gt; &apos;yii\\redis\\Connection&apos;,</div><div class=\"line\">        &apos;hostname&apos; =&gt; &apos;redis&apos;,</div><div class=\"line\">        &apos;port&apos; =&gt; &apos;6379&apos;,</div><div class=\"line\">        &apos;database&apos; =&gt; 0,</div><div class=\"line\">    ],</div><div class=\"line\">    &apos;queue&apos; =&gt; [</div><div class=\"line\">        &apos;class&apos; =&gt; \\yii\\queue\\redis\\Queue::class,</div><div class=\"line\">        &apos;redis&apos; =&gt; &apos;redis2&apos;, // Redis connection component or its config</div><div class=\"line\">        &apos;channel&apos; =&gt; &apos;queue&apos;, // Queue channel key</div><div class=\"line\">        &apos;as log&apos; =&gt; \\yii\\queue\\LogBehavior::class</div><div class=\"line\">    ],</div><div class=\"line\">]</div></pre></td></tr></table></figure></p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DownloadJob</span> <span class=\"keyword\">extends</span> <span class=\"title\">Object</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">yii</span>\\<span class=\"title\">queue</span>\\<span class=\"title\">Job</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">public</span> $url;</div><div class=\"line\">    <span class=\"keyword\">public</span> $file;</div><div class=\"line\">                </div><div class=\"line\">    <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">execute</span><span class=\"params\">($queue)</span></span></div><div class=\"line\">    &#123;</div><div class=\"line\">        file_put_contents(<span class=\"keyword\">$this</span>-&gt;file, file_get_contents(<span class=\"keyword\">$this</span>-&gt;url));</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以下是将任务发送到队列中的方法：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</div><div class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</div><div class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</div><div class=\"line\">]));</div></pre></td></tr></table></figure>\n<p>将作业推入5分钟后运行的队列：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Yii::$app-&gt;queue-&gt;delay(<span class=\"number\">5</span> * <span class=\"number\">60</span>)-&gt;push(<span class=\"keyword\">new</span> DownloadJob([</div><div class=\"line\">    <span class=\"string\">'url'</span> =&gt; <span class=\"string\">'http://example.com/image.jpg'</span>,</div><div class=\"line\">    <span class=\"string\">'file'</span> =&gt; <span class=\"string\">'/tmp/image.jpg'</span>,</div><div class=\"line\">]));</div></pre></td></tr></table></figure>\n<p>执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。<br>在循环中获取并执行任务的命令，直到队列为空：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yii queue/run</div></pre></td></tr></table></figure>\n<p>命令启动一个无限查询队列的守护程序：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">yii queue/listen</div></pre></td></tr></table></figure>\n<p>该组件具有跟踪被推入队列的作业的状态的能力。</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//将作业推入队列并获取按摩ID。</span></div><div class=\"line\">$id = Yii::$app-&gt;queue-&gt;push(<span class=\"keyword\">new</span> SomeJob());</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//工作正在等待执行。</span></div><div class=\"line\">Yii::$app-&gt;queue-&gt;isWaiting($id);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Worker从队列中获取作业并执行它。</span></div><div class=\"line\">Yii::$app-&gt;queue-&gt;isReserved($id);</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">// Worker已经执行了这个工作。</span></div><div class=\"line\">Yii::$app-&gt;queue-&gt;isDone($id);</div></pre></td></tr></table></figure>\n<h2 id=\"使用Supervisor管理php-yii-queue-listen\"><a href=\"#使用Supervisor管理php-yii-queue-listen\" class=\"headerlink\" title=\"使用Supervisor管理php yii queue/listen\"></a>使用Supervisor管理php yii queue/listen</h2><p>Supervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install supervisor</div></pre></td></tr></table></figure></p>\n<p>主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。<br>配置示例:<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">[program:yii-queue-worker]</div><div class=\"line\">process_name=%(program_name)s_%(process_num)<span class=\"number\">02</span>d</div><div class=\"line\">command=/usr/bin/php /<span class=\"keyword\">var</span>/www/my_project/yii queue/listen --verbose=<span class=\"number\">1</span> --color=<span class=\"number\">0</span></div><div class=\"line\">autostart=<span class=\"keyword\">true</span></div><div class=\"line\">autorestart=<span class=\"keyword\">true</span></div><div class=\"line\">user=www-data</div><div class=\"line\">numprocs=<span class=\"number\">4</span></div><div class=\"line\">redirect_stderr=<span class=\"keyword\">true</span></div><div class=\"line\">stdout_logfile=/<span class=\"keyword\">var</span>/www/my_project/log/yii-queue-worker.log</div></pre></td></tr></table></figure></p>"},{"title":"使用Prometheus+Grafana监控","date":"2017-12-10T10:09:37.000Z","_content":"## 简介\nPrometheus（普罗米修斯）是一套开源的监控&报警&时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。\nPrometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。\nPrometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。\n\n输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：https://github.com/prometheus。\n\n与其他监控系统相比，Prometheus的主要特点是：\n\n- 一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。\n- 非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。\n- 一种灵活的查询语言。\n- 不依赖分布式存储，单个服务器节点。\n- 时间集合通过HTTP上的PULL模型进行。\n- 通过中间网关支持推送时间。\n- 通过服务发现或静态配置发现目标。\n- 多种模式的图形和仪表板支持。\n\n## Prometheus架构概览\n\n该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：\n![Prometheus架构概览](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg)\n它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。\n\n- Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。\n\n- Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。\n\n- PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。\n\n## Prometheus的数据模型\n\nPrometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。\nmetrics name&label指标名称和标签\n\n每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。\n\n### 指标名称：\n一般是给监测对像起一名字，例如http_requests_total这样，它有一些命名规则，可以包字母数字_之类的的。通常是以应用名称开头_监测对像_数值类型_单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。\n\n### 标签：\n就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。\n\n记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。\n\n查询语句就可以跟据上面标签的组合来查询聚合结果了。\n\n如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。\n\n<!--more-->\n## Prometheus四种数据类型\n\n### Counter\nCounter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。\n\n例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。\n### Gauge\nGauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。\n\n例如： memory_usage_bytes{host=”master-01″} 100 < 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 < 抓取值。\n### Histogram\n\nHistogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。\n\n例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。\n### Summary\nSummary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。\n\n例如：count=7次，sum=7次的值求值。\n\n它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。\n## 配置文件解析\n###下面的例子以这个项目为例(promethes项目)[https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]\n\n``` yaml\n# docker-compose.yml\nversion: '2.0'\n\nservices:\n  prometheus: \n    image: prom/prometheus:v1.0.1\n    volumes:\n        - ./prometheus.yml:/etc/prometheus/prometheus.yml\n        - prometheus_data:/prometheus\n        - ./alert.rules:/etc/prometheus/alert.rules\n    command:\n        - '-config.file=/etc/prometheus/prometheus.yml'\n        - '-alertmanager.url=http://alertmanager:9093'\n    ports:\n        - '9090:9090'\n\n  grafana:\n    image: \"grafana/grafana:3.1.1\"\n    environment:\n        - GF_SECURITY_ADMIN_PASSWORD=pass\n    depends_on:\n        - prometheus\n    volumes:\n        - grafana_data:/var/lib/grafana\n        - ./alert.rules:/etc/prometheus/alert.rules\n    ports:\n        - \"3000:3000\"\n\n  alertmanager:\n    image: \"prom/alertmanager:v0.8.0\"\n    volumes:\n        - ./alertmanager.yml:/alertmanager.yml\n    command:\n        - '-config.file=/alertmanager.yml'\n    \nvolumes:\n  prometheus_data: {}\n  grafana_data: {}\n```\nPrometheus内置了一个web界面，我们可通过http://monitor_host:9090进行访问：\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg)\n但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg)\n\n在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。\n这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点\n或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。\n \n### cAdvisor 容器数据采集\n\n因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器\n \n```\ncadvisor:\n image: google/cadvisor\n volumes:\n   - /:/rootfs:ro\n   - /var/run:/var/run:rw\n   - /sys:/sys:ro\n   - /var/lib/docker/:/var/lib/docker:ro\n ports:\n     - \"8080:8080\"\n expose:\n     - \"8080\"\n```\n\n### prometheus.yaml 配置监听数据地址\n\nprometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址\n\n``` \n# my global config\nglobal:\n  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.\n  # scrape_timeout is set to the global default (10s).\n\n  # Attach these labels to any time series or alerts when communicating with\n  # external systems (federation, remote storage, Alertmanager).\n  external_labels:\n      monitor: 'codelab-monitor'\n\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n    - 'alert.rules'\n\n# A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Prometheus itself.\nscrape_configs:\n  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n    #scrape_interval: 5s\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: ['192.168.1.162:9090']\n        labels:\n          instance: prometheus\n\n  - job_name: 'docker-online'\n    #scrape_interval: 5s\n    #scheme: http\n    static_configs:\n      - targets: ['192.168.1.162:8080']\n        labels:\n         group: 'port'\n```\n\n### Alertmanager报警组件\n\nAlertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。\n要查看所有可用的命令行flag，运行alertmanager -h。\nAlertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。\n配置文件\n要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。\n```\nglobal:\n  # ResolveTimeout is the time after which an alert is declared resolved\n  # if it has not been updated.\n  [ resolve_timeout: <duration> | default = 5m ]\n\n  # The default SMTP From header field.\n  [ smtp_from: <tmpl_string> ]\n  # The default SMTP smarthost used for sending emails.\n  [ smtp_smarthost: <string> ]\n\n  # The API URL to use for Slack notifications.\n  [ slack_api_url: <string> ]\n\n  [ pagerduty_url: <string> | default = \"https://events.pagerduty.com/generic/2010-04-15/create_event.json\" ]\n  [ opsgenie_api_host: <string> | default = \"https://api.opsgenie.com/\" ]\n\n# Files from which custom notification template definitions are read.\n# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.\ntemplates:\n  [ - <filepath> ... ]\n\n# The root node of the routing tree.\nroute: <route>\n\n# A list of notification receivers.\nreceivers:\n  - <receiver> ...\n\n# A list of inhibition rules.\ninhibit_rules:\n  [ - <inhibit_rule> ... ]\n```\n\n路由 route\n路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。\n每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。\n路由配置格式\n\n```\n[ receiver: <string> ]\n[ group_by: '[' <labelname>, ... ']' ]\n\n# Whether an alert should continue matching subsequent sibling nodes.\n[ continue: <boolean> | default = false ]\n\n# A set of equality matchers an alert has to fulfill to match the node.\nmatch:\n  [ <labelname>: <labelvalue>, ... ]\n\n# A set of regex-matchers an alert has to fulfill to match the node.\nmatch_re:\n  [ <labelname>: <regex>, ... ]\n\n# How long to initially wait to send a notification for a group\n# of alerts. Allows to wait for an inhibiting alert to arrive or collect\n# more initial alerts for the same group. (Usually ~0s to few minutes.)\n[ group_wait: <duration> ]\n\n# How long to wait before sending notification about new alerts that are\n# in are added to a group of alerts for which an initial notification\n# has already been sent. (Usually ~5min or more.)\n[ group_interval: <duration> ]\n\n# How long to wait before sending a notification again if it has already\n# been sent successfully for an alert. (Usually ~3h or more).\n[ repeat_interval: <duration> ]\n\n# Zero or more child routes.\nroutes:\n  [ - <route> ... ]\n```\n\n在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：\n\n``` yaml  \nroute:\n    receiver: 'slack'\nreceivers:\n    - name: 'slack'\n      slack_configs:\n          - send_resolved: true\n            username: 'Prometheus'\n            channel: '#random'\n            api_url: 'https://hooks.slack.com/services/<your>/<stuff>/<here>'\n```\n\n### 报警规则\n\n报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。\n报警规则通过以下格式定义：\n\n```\nALERT <alert name>\n  IF <expression>\n  [ FOR <duration> ]\n  [ LABELS <label set> ]\n  [ ANNOTATIONS <label set> ]\n```\n\nFOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。\nLABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。\nANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。\n示例：\n\n```\n# alert.rules\nALERT service_down\n  IF up == 0\nALERT high_load\n  IF node_load1 > 0.5\n  ANNOTATIONS {\n      summary = \"Instance {{ $labels.instance }} under high load\",\n      description = \"{{ $labels.instance }} of job {{ $labels.job }} is under highload.\",\n  }\n```\n\n## 参考资料\n\n+ [prometheus](https://prometheus.io)\n+ [grafana](http://grafana.org)\n+ [Prometheus监控 - Alertmanager报警模块](https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html)\n+ [Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center](https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/)\n+ [使用Prometheus+Grafana监控MySQL实践 – 运维那点事](http://www.ywnds.com/?p=9656)\n+ [使用Prometheus监控服务器](http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html)\n+ [Prometheus在Kubernetes下的监控实践](http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/)\n+ [通过Prometheus，Grafana和Docker进行监控](https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1)\n","source":"_posts/使用Prometheus-Grafana监控.md","raw":"---\ntitle: 使用Prometheus+Grafana监控\ndate: 2017-12-10 18:09:37\ntags: devops\n---\n## 简介\nPrometheus（普罗米修斯）是一套开源的监控&报警&时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。\nPrometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。\nPrometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。\n\n输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：https://github.com/prometheus。\n\n与其他监控系统相比，Prometheus的主要特点是：\n\n- 一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。\n- 非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。\n- 一种灵活的查询语言。\n- 不依赖分布式存储，单个服务器节点。\n- 时间集合通过HTTP上的PULL模型进行。\n- 通过中间网关支持推送时间。\n- 通过服务发现或静态配置发现目标。\n- 多种模式的图形和仪表板支持。\n\n## Prometheus架构概览\n\n该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：\n![Prometheus架构概览](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg)\n它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。\n\n- Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。\n\n- Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。\n\n- PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。\n\n## Prometheus的数据模型\n\nPrometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。\nmetrics name&label指标名称和标签\n\n每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。\n\n### 指标名称：\n一般是给监测对像起一名字，例如http_requests_total这样，它有一些命名规则，可以包字母数字_之类的的。通常是以应用名称开头_监测对像_数值类型_单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。\n\n### 标签：\n就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。\n\n记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。\n\n查询语句就可以跟据上面标签的组合来查询聚合结果了。\n\n如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。\n\n<!--more-->\n## Prometheus四种数据类型\n\n### Counter\nCounter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。\n\n例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。\n### Gauge\nGauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。\n\n例如： memory_usage_bytes{host=”master-01″} 100 < 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 < 抓取值。\n### Histogram\n\nHistogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。\n\n例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。\n### Summary\nSummary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。\n\n例如：count=7次，sum=7次的值求值。\n\n它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。\n## 配置文件解析\n###下面的例子以这个项目为例(promethes项目)[https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master]\n\n``` yaml\n# docker-compose.yml\nversion: '2.0'\n\nservices:\n  prometheus: \n    image: prom/prometheus:v1.0.1\n    volumes:\n        - ./prometheus.yml:/etc/prometheus/prometheus.yml\n        - prometheus_data:/prometheus\n        - ./alert.rules:/etc/prometheus/alert.rules\n    command:\n        - '-config.file=/etc/prometheus/prometheus.yml'\n        - '-alertmanager.url=http://alertmanager:9093'\n    ports:\n        - '9090:9090'\n\n  grafana:\n    image: \"grafana/grafana:3.1.1\"\n    environment:\n        - GF_SECURITY_ADMIN_PASSWORD=pass\n    depends_on:\n        - prometheus\n    volumes:\n        - grafana_data:/var/lib/grafana\n        - ./alert.rules:/etc/prometheus/alert.rules\n    ports:\n        - \"3000:3000\"\n\n  alertmanager:\n    image: \"prom/alertmanager:v0.8.0\"\n    volumes:\n        - ./alertmanager.yml:/alertmanager.yml\n    command:\n        - '-config.file=/alertmanager.yml'\n    \nvolumes:\n  prometheus_data: {}\n  grafana_data: {}\n```\nPrometheus内置了一个web界面，我们可通过http://monitor_host:9090进行访问：\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg)\n但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,\n![](http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg)\n\n在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。\n这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点\n或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。\n \n### cAdvisor 容器数据采集\n\n因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器\n \n```\ncadvisor:\n image: google/cadvisor\n volumes:\n   - /:/rootfs:ro\n   - /var/run:/var/run:rw\n   - /sys:/sys:ro\n   - /var/lib/docker/:/var/lib/docker:ro\n ports:\n     - \"8080:8080\"\n expose:\n     - \"8080\"\n```\n\n### prometheus.yaml 配置监听数据地址\n\nprometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址\n\n``` \n# my global config\nglobal:\n  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.\n  # scrape_timeout is set to the global default (10s).\n\n  # Attach these labels to any time series or alerts when communicating with\n  # external systems (federation, remote storage, Alertmanager).\n  external_labels:\n      monitor: 'codelab-monitor'\n\n# Load rules once and periodically evaluate them according to the global 'evaluation_interval'.\nrule_files:\n    - 'alert.rules'\n\n# A scrape configuration containing exactly one endpoint to scrape:\n# Here it's Prometheus itself.\nscrape_configs:\n  # The job name is added as a label `job=<job_name>` to any timeseries scraped from this config.\n  - job_name: 'prometheus'\n    #scrape_interval: 5s\n    # metrics_path defaults to '/metrics'\n    # scheme defaults to 'http'.\n\n    static_configs:\n      - targets: ['192.168.1.162:9090']\n        labels:\n          instance: prometheus\n\n  - job_name: 'docker-online'\n    #scrape_interval: 5s\n    #scheme: http\n    static_configs:\n      - targets: ['192.168.1.162:8080']\n        labels:\n         group: 'port'\n```\n\n### Alertmanager报警组件\n\nAlertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。\n要查看所有可用的命令行flag，运行alertmanager -h。\nAlertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。\n配置文件\n要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。\n```\nglobal:\n  # ResolveTimeout is the time after which an alert is declared resolved\n  # if it has not been updated.\n  [ resolve_timeout: <duration> | default = 5m ]\n\n  # The default SMTP From header field.\n  [ smtp_from: <tmpl_string> ]\n  # The default SMTP smarthost used for sending emails.\n  [ smtp_smarthost: <string> ]\n\n  # The API URL to use for Slack notifications.\n  [ slack_api_url: <string> ]\n\n  [ pagerduty_url: <string> | default = \"https://events.pagerduty.com/generic/2010-04-15/create_event.json\" ]\n  [ opsgenie_api_host: <string> | default = \"https://api.opsgenie.com/\" ]\n\n# Files from which custom notification template definitions are read.\n# The last component may use a wildcard matcher, e.g. 'templates/*.tmpl'.\ntemplates:\n  [ - <filepath> ... ]\n\n# The root node of the routing tree.\nroute: <route>\n\n# A list of notification receivers.\nreceivers:\n  - <receiver> ...\n\n# A list of inhibition rules.\ninhibit_rules:\n  [ - <inhibit_rule> ... ]\n```\n\n路由 route\n路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。\n每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。\n路由配置格式\n\n```\n[ receiver: <string> ]\n[ group_by: '[' <labelname>, ... ']' ]\n\n# Whether an alert should continue matching subsequent sibling nodes.\n[ continue: <boolean> | default = false ]\n\n# A set of equality matchers an alert has to fulfill to match the node.\nmatch:\n  [ <labelname>: <labelvalue>, ... ]\n\n# A set of regex-matchers an alert has to fulfill to match the node.\nmatch_re:\n  [ <labelname>: <regex>, ... ]\n\n# How long to initially wait to send a notification for a group\n# of alerts. Allows to wait for an inhibiting alert to arrive or collect\n# more initial alerts for the same group. (Usually ~0s to few minutes.)\n[ group_wait: <duration> ]\n\n# How long to wait before sending notification about new alerts that are\n# in are added to a group of alerts for which an initial notification\n# has already been sent. (Usually ~5min or more.)\n[ group_interval: <duration> ]\n\n# How long to wait before sending a notification again if it has already\n# been sent successfully for an alert. (Usually ~3h or more).\n[ repeat_interval: <duration> ]\n\n# Zero or more child routes.\nroutes:\n  [ - <route> ... ]\n```\n\n在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：\n\n``` yaml  \nroute:\n    receiver: 'slack'\nreceivers:\n    - name: 'slack'\n      slack_configs:\n          - send_resolved: true\n            username: 'Prometheus'\n            channel: '#random'\n            api_url: 'https://hooks.slack.com/services/<your>/<stuff>/<here>'\n```\n\n### 报警规则\n\n报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。\n报警规则通过以下格式定义：\n\n```\nALERT <alert name>\n  IF <expression>\n  [ FOR <duration> ]\n  [ LABELS <label set> ]\n  [ ANNOTATIONS <label set> ]\n```\n\nFOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。\nLABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。\nANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。\n示例：\n\n```\n# alert.rules\nALERT service_down\n  IF up == 0\nALERT high_load\n  IF node_load1 > 0.5\n  ANNOTATIONS {\n      summary = \"Instance {{ $labels.instance }} under high load\",\n      description = \"{{ $labels.instance }} of job {{ $labels.job }} is under highload.\",\n  }\n```\n\n## 参考资料\n\n+ [prometheus](https://prometheus.io)\n+ [grafana](http://grafana.org)\n+ [Prometheus监控 - Alertmanager报警模块](https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html)\n+ [Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center](https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/)\n+ [使用Prometheus+Grafana监控MySQL实践 – 运维那点事](http://www.ywnds.com/?p=9656)\n+ [使用Prometheus监控服务器](http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html)\n+ [Prometheus在Kubernetes下的监控实践](http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/)\n+ [通过Prometheus，Grafana和Docker进行监控](https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1)\n","slug":"使用Prometheus-Grafana监控","published":1,"updated":"2017-12-10T12:38:46.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q2a0011to7yun73os3m","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Prometheus（普罗米修斯）是一套开源的监控&amp;报警&amp;时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。<br>Prometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。<br>Prometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。</p>\n<p>输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：<a href=\"https://github.com/prometheus。\" target=\"_blank\" rel=\"noopener\">https://github.com/prometheus。</a></p>\n<p>与其他监控系统相比，Prometheus的主要特点是：</p>\n<ul>\n<li>一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。</li>\n<li>非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。</li>\n<li>一种灵活的查询语言。</li>\n<li>不依赖分布式存储，单个服务器节点。</li>\n<li>时间集合通过HTTP上的PULL模型进行。</li>\n<li>通过中间网关支持推送时间。</li>\n<li>通过服务发现或静态配置发现目标。</li>\n<li>多种模式的图形和仪表板支持。</li>\n</ul>\n<h2 id=\"Prometheus架构概览\"><a href=\"#Prometheus架构概览\" class=\"headerlink\" title=\"Prometheus架构概览\"></a>Prometheus架构概览</h2><p>该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg\" alt=\"Prometheus架构概览\"><br>它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。</p>\n<ul>\n<li><p>Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。</p>\n</li>\n<li><p>Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</p>\n</li>\n<li><p>PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</p>\n</li>\n</ul>\n<h2 id=\"Prometheus的数据模型\"><a href=\"#Prometheus的数据模型\" class=\"headerlink\" title=\"Prometheus的数据模型\"></a>Prometheus的数据模型</h2><p>Prometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。<br>metrics name&amp;label指标名称和标签</p>\n<p>每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。</p>\n<h3 id=\"指标名称：\"><a href=\"#指标名称：\" class=\"headerlink\" title=\"指标名称：\"></a>指标名称：</h3><p>一般是给监测对像起一名字，例如http_requests<em>total这样，它有一些命名规则，可以包字母数字</em>之类的的。通常是以应用名称开头<em>监测对像</em>数值类型_单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。</p>\n<h3 id=\"标签：\"><a href=\"#标签：\" class=\"headerlink\" title=\"标签：\"></a>标签：</h3><p>就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。</p>\n<p>记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。</p>\n<p>查询语句就可以跟据上面标签的组合来查询聚合结果了。</p>\n<p>如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。</p>\n<a id=\"more\"></a>\n<h2 id=\"Prometheus四种数据类型\"><a href=\"#Prometheus四种数据类型\" class=\"headerlink\" title=\"Prometheus四种数据类型\"></a>Prometheus四种数据类型</h2><h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>Counter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。</p>\n<p>例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。</p>\n<h3 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h3><p>Gauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。</p>\n<p>例如： memory_usage_bytes{host=”master-01″} 100 &lt; 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 &lt; 抓取值。</p>\n<h3 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h3><p>Histogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。</p>\n<p>例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>Summary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。</p>\n<p>例如：count=7次，sum=7次的值求值。</p>\n<p>它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。</p>\n<h2 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h2><p>###下面的例子以这个项目为例(promethes项目)[<a href=\"https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master\" target=\"_blank\" rel=\"noopener\">https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master</a>]</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># docker-compose.yml</span></div><div class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2.0'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">services:</span></div><div class=\"line\"><span class=\"attr\">  prometheus:</span> </div><div class=\"line\"><span class=\"attr\">    image:</span> prom/prometheus:v1<span class=\"number\">.0</span><span class=\"number\">.1</span></div><div class=\"line\"><span class=\"attr\">    volumes:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> ./prometheus.yml:/etc/prometheus/prometheus.yml</div><div class=\"line\"><span class=\"attr\">        - prometheus_data:</span>/prometheus</div><div class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</div><div class=\"line\"><span class=\"attr\">    command:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/etc/prometheus/prometheus.yml'</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-alertmanager.url=http://alertmanager:9093'</span></div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'9090:9090'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">  grafana:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"grafana/grafana:3.1.1\"</span></div><div class=\"line\"><span class=\"attr\">    environment:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> GF_SECURITY_ADMIN_PASSWORD=pass</div><div class=\"line\"><span class=\"attr\">    depends_on:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> prometheus</div><div class=\"line\"><span class=\"attr\">    volumes:</span></div><div class=\"line\"><span class=\"attr\">        - grafana_data:</span>/var/lib/grafana</div><div class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">\"3000:3000\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">  alertmanager:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"prom/alertmanager:v0.8.0\"</span></div><div class=\"line\"><span class=\"attr\">    volumes:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> ./alertmanager.yml:/alertmanager.yml</div><div class=\"line\"><span class=\"attr\">    command:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/alertmanager.yml'</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"attr\">volumes:</span></div><div class=\"line\"><span class=\"attr\">  prometheus_data:</span> &#123;&#125;</div><div class=\"line\"><span class=\"attr\">  grafana_data:</span> &#123;&#125;</div></pre></td></tr></table></figure>\n<p>Prometheus内置了一个web界面，我们可通过<a href=\"http://monitor_host:9090进行访问：\" target=\"_blank\" rel=\"noopener\">http://monitor_host:9090进行访问：</a><br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg\" alt=\"\"><br>但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg\" alt=\"\"></p>\n<p>在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。<br>这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点<br>或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。</p>\n<h3 id=\"cAdvisor-容器数据采集\"><a href=\"#cAdvisor-容器数据采集\" class=\"headerlink\" title=\"cAdvisor 容器数据采集\"></a>cAdvisor 容器数据采集</h3><p>因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">cadvisor:</div><div class=\"line\"> image: google/cadvisor</div><div class=\"line\"> volumes:</div><div class=\"line\">   - /:/rootfs:ro</div><div class=\"line\">   - /var/run:/var/run:rw</div><div class=\"line\">   - /sys:/sys:ro</div><div class=\"line\">   - /var/lib/docker/:/var/lib/docker:ro</div><div class=\"line\"> ports:</div><div class=\"line\">     - &quot;8080:8080&quot;</div><div class=\"line\"> expose:</div><div class=\"line\">     - &quot;8080&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"prometheus-yaml-配置监听数据地址\"><a href=\"#prometheus-yaml-配置监听数据地址\" class=\"headerlink\" title=\"prometheus.yaml 配置监听数据地址\"></a>prometheus.yaml 配置监听数据地址</h3><p>prometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"># my global config</div><div class=\"line\">global:</div><div class=\"line\">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</div><div class=\"line\">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</div><div class=\"line\">  # scrape_timeout is set to the global default (10s).</div><div class=\"line\"></div><div class=\"line\">  # Attach these labels to any time series or alerts when communicating with</div><div class=\"line\">  # external systems (federation, remote storage, Alertmanager).</div><div class=\"line\">  external_labels:</div><div class=\"line\">      monitor: &apos;codelab-monitor&apos;</div><div class=\"line\"></div><div class=\"line\"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</div><div class=\"line\">rule_files:</div><div class=\"line\">    - &apos;alert.rules&apos;</div><div class=\"line\"></div><div class=\"line\"># A scrape configuration containing exactly one endpoint to scrape:</div><div class=\"line\"># Here it&apos;s Prometheus itself.</div><div class=\"line\">scrape_configs:</div><div class=\"line\">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</div><div class=\"line\">  - job_name: &apos;prometheus&apos;</div><div class=\"line\">    #scrape_interval: 5s</div><div class=\"line\">    # metrics_path defaults to &apos;/metrics&apos;</div><div class=\"line\">    # scheme defaults to &apos;http&apos;.</div><div class=\"line\"></div><div class=\"line\">    static_configs:</div><div class=\"line\">      - targets: [&apos;192.168.1.162:9090&apos;]</div><div class=\"line\">        labels:</div><div class=\"line\">          instance: prometheus</div><div class=\"line\"></div><div class=\"line\">  - job_name: &apos;docker-online&apos;</div><div class=\"line\">    #scrape_interval: 5s</div><div class=\"line\">    #scheme: http</div><div class=\"line\">    static_configs:</div><div class=\"line\">      - targets: [&apos;192.168.1.162:8080&apos;]</div><div class=\"line\">        labels:</div><div class=\"line\">         group: &apos;port&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"Alertmanager报警组件\"><a href=\"#Alertmanager报警组件\" class=\"headerlink\" title=\"Alertmanager报警组件\"></a>Alertmanager报警组件</h3><p>Alertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。<br>要查看所有可用的命令行flag，运行alertmanager -h。<br>Alertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。<br>配置文件<br>要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">global:</div><div class=\"line\">  # ResolveTimeout is the time after which an alert is declared resolved</div><div class=\"line\">  # if it has not been updated.</div><div class=\"line\">  [ resolve_timeout: &lt;duration&gt; | default = 5m ]</div><div class=\"line\"></div><div class=\"line\">  # The default SMTP From header field.</div><div class=\"line\">  [ smtp_from: &lt;tmpl_string&gt; ]</div><div class=\"line\">  # The default SMTP smarthost used for sending emails.</div><div class=\"line\">  [ smtp_smarthost: &lt;string&gt; ]</div><div class=\"line\"></div><div class=\"line\">  # The API URL to use for Slack notifications.</div><div class=\"line\">  [ slack_api_url: &lt;string&gt; ]</div><div class=\"line\"></div><div class=\"line\">  [ pagerduty_url: &lt;string&gt; | default = &quot;https://events.pagerduty.com/generic/2010-04-15/create_event.json&quot; ]</div><div class=\"line\">  [ opsgenie_api_host: &lt;string&gt; | default = &quot;https://api.opsgenie.com/&quot; ]</div><div class=\"line\"></div><div class=\"line\"># Files from which custom notification template definitions are read.</div><div class=\"line\"># The last component may use a wildcard matcher, e.g. &apos;templates/*.tmpl&apos;.</div><div class=\"line\">templates:</div><div class=\"line\">  [ - &lt;filepath&gt; ... ]</div><div class=\"line\"></div><div class=\"line\"># The root node of the routing tree.</div><div class=\"line\">route: &lt;route&gt;</div><div class=\"line\"></div><div class=\"line\"># A list of notification receivers.</div><div class=\"line\">receivers:</div><div class=\"line\">  - &lt;receiver&gt; ...</div><div class=\"line\"></div><div class=\"line\"># A list of inhibition rules.</div><div class=\"line\">inhibit_rules:</div><div class=\"line\">  [ - &lt;inhibit_rule&gt; ... ]</div></pre></td></tr></table></figure></p>\n<p>路由 route<br>路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。<br>每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。<br>路由配置格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ receiver: &lt;string&gt; ]</div><div class=\"line\">[ group_by: &apos;[&apos; &lt;labelname&gt;, ... &apos;]&apos; ]</div><div class=\"line\"></div><div class=\"line\"># Whether an alert should continue matching subsequent sibling nodes.</div><div class=\"line\">[ continue: &lt;boolean&gt; | default = false ]</div><div class=\"line\"></div><div class=\"line\"># A set of equality matchers an alert has to fulfill to match the node.</div><div class=\"line\">match:</div><div class=\"line\">  [ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</div><div class=\"line\"></div><div class=\"line\"># A set of regex-matchers an alert has to fulfill to match the node.</div><div class=\"line\">match_re:</div><div class=\"line\">  [ &lt;labelname&gt;: &lt;regex&gt;, ... ]</div><div class=\"line\"></div><div class=\"line\"># How long to initially wait to send a notification for a group</div><div class=\"line\"># of alerts. Allows to wait for an inhibiting alert to arrive or collect</div><div class=\"line\"># more initial alerts for the same group. (Usually ~0s to few minutes.)</div><div class=\"line\">[ group_wait: &lt;duration&gt; ]</div><div class=\"line\"></div><div class=\"line\"># How long to wait before sending notification about new alerts that are</div><div class=\"line\"># in are added to a group of alerts for which an initial notification</div><div class=\"line\"># has already been sent. (Usually ~5min or more.)</div><div class=\"line\">[ group_interval: &lt;duration&gt; ]</div><div class=\"line\"></div><div class=\"line\"># How long to wait before sending a notification again if it has already</div><div class=\"line\"># been sent successfully for an alert. (Usually ~3h or more).</div><div class=\"line\">[ repeat_interval: &lt;duration&gt; ]</div><div class=\"line\"></div><div class=\"line\"># Zero or more child routes.</div><div class=\"line\">routes:</div><div class=\"line\">  [ - &lt;route&gt; ... ]</div></pre></td></tr></table></figure>\n<p>在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">route:</span></div><div class=\"line\"><span class=\"attr\">    receiver:</span> <span class=\"string\">'slack'</span></div><div class=\"line\"><span class=\"attr\">receivers:</span></div><div class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">'slack'</span></div><div class=\"line\"><span class=\"attr\">      slack_configs:</span></div><div class=\"line\"><span class=\"attr\">          - send_resolved:</span> <span class=\"literal\">true</span></div><div class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">'Prometheus'</span></div><div class=\"line\"><span class=\"attr\">            channel:</span> <span class=\"string\">'#random'</span></div><div class=\"line\"><span class=\"attr\">            api_url:</span> <span class=\"string\">'https://hooks.slack.com/services/&lt;your&gt;/&lt;stuff&gt;/&lt;here&gt;'</span></div></pre></td></tr></table></figure>\n<h3 id=\"报警规则\"><a href=\"#报警规则\" class=\"headerlink\" title=\"报警规则\"></a>报警规则</h3><p>报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。<br>报警规则通过以下格式定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALERT &lt;alert name&gt;</div><div class=\"line\">  IF &lt;expression&gt;</div><div class=\"line\">  [ FOR &lt;duration&gt; ]</div><div class=\"line\">  [ LABELS &lt;label set&gt; ]</div><div class=\"line\">  [ ANNOTATIONS &lt;label set&gt; ]</div></pre></td></tr></table></figure>\n<p>FOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。<br>LABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。<br>ANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。<br>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># alert.rules</div><div class=\"line\">ALERT service_down</div><div class=\"line\">  IF up == 0</div><div class=\"line\">ALERT high_load</div><div class=\"line\">  IF node_load1 &gt; 0.5</div><div class=\"line\">  ANNOTATIONS &#123;</div><div class=\"line\">      summary = &quot;Instance &#123;&#123; $labels.instance &#125;&#125; under high load&quot;,</div><div class=\"line\">      description = &quot;&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; is under highload.&quot;,</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://prometheus.io\" target=\"_blank\" rel=\"noopener\">prometheus</a></li>\n<li><a href=\"http://grafana.org\" target=\"_blank\" rel=\"noopener\">grafana</a></li>\n<li><a href=\"https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html\" target=\"_blank\" rel=\"noopener\">Prometheus监控 - Alertmanager报警模块</a></li>\n<li><a href=\"https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/\" target=\"_blank\" rel=\"noopener\">Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center</a></li>\n<li><a href=\"http://www.ywnds.com/?p=9656\" target=\"_blank\" rel=\"noopener\">使用Prometheus+Grafana监控MySQL实践 – 运维那点事</a></li>\n<li><a href=\"http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html\" target=\"_blank\" rel=\"noopener\">使用Prometheus监控服务器</a></li>\n<li><a href=\"http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/\" target=\"_blank\" rel=\"noopener\">Prometheus在Kubernetes下的监控实践</a></li>\n<li><a href=\"https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1\" target=\"_blank\" rel=\"noopener\">通过Prometheus，Grafana和Docker进行监控</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Prometheus（普罗米修斯）是一套开源的监控&amp;报警&amp;时间序列数据库的组合，起始是由SoundCloud公司开发的。随着发展，越来越多公司和组织接受采用Prometheus，社会也十分活跃，他们便将它独立成开源项目，并且有公司来运作。Google SRE的书内也曾提到跟他们BorgMon监控系统相似的实现是Prometheus。现在最常见的Kubernetes容器管理系统中，通常会搭配Prometheus进行监控。<br>Prometheus基本原理是通过HTTP协议周期性抓取被监控组件的状态，这样做的好处是任意组件只要提供HTTP接口就可以接入监控系统，不需要任何SDK或者其他的集成过程。这样做非常适合虚拟化环境比如VM或者Docker 。<br>Prometheus应该是为数不多的适合Docker、Mesos、Kubernetes环境的监控系统之一。</p>\n<p>输出被监控组件信息的HTTP接口被叫做exporter 。目前互联网公司常用的组件大部分都有exporter可以直接使用，比如Varnish、Haproxy、Nginx、MySQL、Linux 系统信息 (包括磁盘、内存、CPU、网络等等)，具体支持的源看：<a href=\"https://github.com/prometheus。\" target=\"_blank\" rel=\"noopener\">https://github.com/prometheus。</a></p>\n<p>与其他监控系统相比，Prometheus的主要特点是：</p>\n<ul>\n<li>一个多维数据模型（时间序列由指标名称定义和设置键/值尺寸）。</li>\n<li>非常高效的存储，平均一个采样数据占~3.5bytes左右，320万的时间序列，每30秒采样，保持60天，消耗磁盘大概228G。</li>\n<li>一种灵活的查询语言。</li>\n<li>不依赖分布式存储，单个服务器节点。</li>\n<li>时间集合通过HTTP上的PULL模型进行。</li>\n<li>通过中间网关支持推送时间。</li>\n<li>通过服务发现或静态配置发现目标。</li>\n<li>多种模式的图形和仪表板支持。</li>\n</ul>\n<h2 id=\"Prometheus架构概览\"><a href=\"#Prometheus架构概览\" class=\"headerlink\" title=\"Prometheus架构概览\"></a>Prometheus架构概览</h2><p>该图说明了普罗米修斯（Prometheus）及其一些生态系统组件的整体架构：<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4pg7j25ej30l60dw40p.jpg\" alt=\"Prometheus架构概览\"><br>它的服务过程是这样的Prometheus daemon负责定时去目标上抓取metrics(指标) 数据，每个抓取目标需要暴露一个http服务的接口给它定时抓取。</p>\n<ul>\n<li><p>Prometheus：支持通过配置文件、文本文件、zookeeper、Consul、DNS SRV lookup等方式指定抓取目标。支持很多方式的图表可视化，例如十分精美的Grafana，自带的Promdash，以及自身提供的模版引擎等等，还提供HTTP API的查询方式，自定义所需要的输出。</p>\n</li>\n<li><p>Alertmanager：是独立于Prometheus的一个组件，可以支持Prometheus的查询语句，提供十分灵活的报警方式。</p>\n</li>\n<li><p>PushGateway：这个组件是支持Client主动推送metrics到PushGateway，而Prometheus只是定时去Gateway上抓取数据。</p>\n</li>\n</ul>\n<h2 id=\"Prometheus的数据模型\"><a href=\"#Prometheus的数据模型\" class=\"headerlink\" title=\"Prometheus的数据模型\"></a>Prometheus的数据模型</h2><p>Prometheus从根本上所有的存储都是按时间序列去实现的，相同的metrics(指标名称) 和label(一个或多个标签) 组成一条时间序列，不同的label表示不同的时间序列。为了支持一些查询，有时还会临时产生一些时间序列存储。<br>metrics name&amp;label指标名称和标签</p>\n<p>每条时间序列是由唯一的”指标名称”和一组”标签（key=value）”的形式组成。</p>\n<h3 id=\"指标名称：\"><a href=\"#指标名称：\" class=\"headerlink\" title=\"指标名称：\"></a>指标名称：</h3><p>一般是给监测对像起一名字，例如http_requests<em>total这样，它有一些命名规则，可以包字母数字</em>之类的的。通常是以应用名称开头<em>监测对像</em>数值类型_单位这样。例如：push_total、userlogin_mysql_duration_seconds、app_memory_usage_bytes。</p>\n<h3 id=\"标签：\"><a href=\"#标签：\" class=\"headerlink\" title=\"标签：\"></a>标签：</h3><p>就是对一条时间序列不同维度的识别了，例如一个http请求用的是POST还是GET，它的endpoint是什么，这时候就要用标签去标记了。最终形成的标识便是这样了：http_requests_total{method=”POST”,endpoint=”/api/tracks”}。</p>\n<p>记住，针对http_requests_total这个metrics name无论是增加标签还是删除标签都会形成一条新的时间序列。</p>\n<p>查询语句就可以跟据上面标签的组合来查询聚合结果了。</p>\n<p>如果以传统数据库的理解来看这条语句，则可以考虑http_requests_total是表名，标签是字段，而timestamp是主键，还有一个float64字段是值了。（Prometheus里面所有值都是按float64存储）。</p>","more":"<h2 id=\"Prometheus四种数据类型\"><a href=\"#Prometheus四种数据类型\" class=\"headerlink\" title=\"Prometheus四种数据类型\"></a>Prometheus四种数据类型</h2><h3 id=\"Counter\"><a href=\"#Counter\" class=\"headerlink\" title=\"Counter\"></a>Counter</h3><p>Counter用于累计值，例如记录请求次数、任务完成数、错误发生次数。一直增加，不会减少。重启进程后，会被重置。</p>\n<p>例如：http_response_total{method=”GET”,endpoint=”/api/tracks”} 100，10秒后抓取http_response_total{method=”GET”,endpoint=”/api/tracks”} 100。</p>\n<h3 id=\"Gauge\"><a href=\"#Gauge\" class=\"headerlink\" title=\"Gauge\"></a>Gauge</h3><p>Gauge常规数值，例如 温度变化、内存使用变化。可变大，可变小。重启进程后，会被重置。</p>\n<p>例如： memory_usage_bytes{host=”master-01″} 100 &lt; 抓取值、memory_usage_bytes{host=”master-01″} 30、memory_usage_bytes{host=”master-01″} 50、memory_usage_bytes{host=”master-01″} 80 &lt; 抓取值。</p>\n<h3 id=\"Histogram\"><a href=\"#Histogram\" class=\"headerlink\" title=\"Histogram\"></a>Histogram</h3><p>Histogram（直方图）可以理解为柱状图的意思，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。它特别之处是可以对记录的内容进行分组，提供count和sum全部值的功能。</p>\n<p>例如：{小于10=5次，小于20=1次，小于30=2次}，count=7次，sum=7次的求和值。</p>\n<h3 id=\"Summary\"><a href=\"#Summary\" class=\"headerlink\" title=\"Summary\"></a>Summary</h3><p>Summary和Histogram十分相似，常用于跟踪事件发生的规模，例如：请求耗时、响应大小。同样提供 count 和 sum 全部值的功能。</p>\n<p>例如：count=7次，sum=7次的值求值。</p>\n<p>它提供一个quantiles的功能，可以按%比划分跟踪的结果。例如：quantile取值0.95，表示取采样值里面的95%数据。</p>\n<h2 id=\"配置文件解析\"><a href=\"#配置文件解析\" class=\"headerlink\" title=\"配置文件解析\"></a>配置文件解析</h2><p>###下面的例子以这个项目为例(promethes项目)[<a href=\"https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master\" target=\"_blank\" rel=\"noopener\">https://mops-gitlab.lianluo.com/chenjiahui/Prometheus/tree/master</a>]</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\"># docker-compose.yml</span></div><div class=\"line\"><span class=\"attr\">version:</span> <span class=\"string\">'2.0'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">services:</span></div><div class=\"line\"><span class=\"attr\">  prometheus:</span> </div><div class=\"line\"><span class=\"attr\">    image:</span> prom/prometheus:v1<span class=\"number\">.0</span><span class=\"number\">.1</span></div><div class=\"line\"><span class=\"attr\">    volumes:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> ./prometheus.yml:/etc/prometheus/prometheus.yml</div><div class=\"line\"><span class=\"attr\">        - prometheus_data:</span>/prometheus</div><div class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</div><div class=\"line\"><span class=\"attr\">    command:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/etc/prometheus/prometheus.yml'</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-alertmanager.url=http://alertmanager:9093'</span></div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'9090:9090'</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">  grafana:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"grafana/grafana:3.1.1\"</span></div><div class=\"line\"><span class=\"attr\">    environment:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> GF_SECURITY_ADMIN_PASSWORD=pass</div><div class=\"line\"><span class=\"attr\">    depends_on:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> prometheus</div><div class=\"line\"><span class=\"attr\">    volumes:</span></div><div class=\"line\"><span class=\"attr\">        - grafana_data:</span>/var/lib/grafana</div><div class=\"line\"><span class=\"bullet\">        -</span> ./alert.rules:/etc/prometheus/alert.rules</div><div class=\"line\"><span class=\"attr\">    ports:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">\"3000:3000\"</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"attr\">  alertmanager:</span></div><div class=\"line\"><span class=\"attr\">    image:</span> <span class=\"string\">\"prom/alertmanager:v0.8.0\"</span></div><div class=\"line\"><span class=\"attr\">    volumes:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> ./alertmanager.yml:/alertmanager.yml</div><div class=\"line\"><span class=\"attr\">    command:</span></div><div class=\"line\"><span class=\"bullet\">        -</span> <span class=\"string\">'-config.file=/alertmanager.yml'</span></div><div class=\"line\">    </div><div class=\"line\"><span class=\"attr\">volumes:</span></div><div class=\"line\"><span class=\"attr\">  prometheus_data:</span> &#123;&#125;</div><div class=\"line\"><span class=\"attr\">  grafana_data:</span> &#123;&#125;</div></pre></td></tr></table></figure>\n<p>Prometheus内置了一个web界面，我们可通过<a href=\"http://monitor_host:9090进行访问：\" target=\"_blank\" rel=\"noopener\">http://monitor_host:9090进行访问：</a><br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tb10am7j30mh093jsh.jpg\" alt=\"\"><br>但是自带的图形工具过于简陋，grafana是他的替代品，您可以通过http：// localhost：3000 / login访问Grafana,<br><img src=\"http://ww1.sinaimg.cn/large/0060OHG5gy1fm4tbxey4xj30mo08k3zm.jpg\" alt=\"\"></p>\n<p>在状态页面的“配置”下方，您会看到一个“目标”部分，其中列出了“prometheus”端点。<br>这相当于scrape_configs相同的设置，job_name 并且是普罗米修斯提供的指标的来源。换句话说，普罗米修斯服务器带有一个度量端点<br>或者上面所说的出口商，它报告普罗米修斯服务器本身的统计数据。</p>\n<h3 id=\"cAdvisor-容器数据采集\"><a href=\"#cAdvisor-容器数据采集\" class=\"headerlink\" title=\"cAdvisor 容器数据采集\"></a>cAdvisor 容器数据采集</h3><p>因为promethus是通过主动去指定的地址拉取数据，所以要监听的项目需要配置导出器</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">cadvisor:</div><div class=\"line\"> image: google/cadvisor</div><div class=\"line\"> volumes:</div><div class=\"line\">   - /:/rootfs:ro</div><div class=\"line\">   - /var/run:/var/run:rw</div><div class=\"line\">   - /sys:/sys:ro</div><div class=\"line\">   - /var/lib/docker/:/var/lib/docker:ro</div><div class=\"line\"> ports:</div><div class=\"line\">     - &quot;8080:8080&quot;</div><div class=\"line\"> expose:</div><div class=\"line\">     - &quot;8080&quot;</div></pre></td></tr></table></figure>\n<h3 id=\"prometheus-yaml-配置监听数据地址\"><a href=\"#prometheus-yaml-配置监听数据地址\" class=\"headerlink\" title=\"prometheus.yaml 配置监听数据地址\"></a>prometheus.yaml 配置监听数据地址</h3><p>prometheus通过在这些目标上抓取指标HTTP端点来从监控目标收集指标,监听的就是数据导出器的地址</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div></pre></td><td class=\"code\"><pre><div class=\"line\"># my global config</div><div class=\"line\">global:</div><div class=\"line\">  scrape_interval:     15s # Set the scrape interval to every 15 seconds. Default is every 1 minute.</div><div class=\"line\">  evaluation_interval: 15s # Evaluate rules every 15 seconds. The default is every 1 minute.</div><div class=\"line\">  # scrape_timeout is set to the global default (10s).</div><div class=\"line\"></div><div class=\"line\">  # Attach these labels to any time series or alerts when communicating with</div><div class=\"line\">  # external systems (federation, remote storage, Alertmanager).</div><div class=\"line\">  external_labels:</div><div class=\"line\">      monitor: &apos;codelab-monitor&apos;</div><div class=\"line\"></div><div class=\"line\"># Load rules once and periodically evaluate them according to the global &apos;evaluation_interval&apos;.</div><div class=\"line\">rule_files:</div><div class=\"line\">    - &apos;alert.rules&apos;</div><div class=\"line\"></div><div class=\"line\"># A scrape configuration containing exactly one endpoint to scrape:</div><div class=\"line\"># Here it&apos;s Prometheus itself.</div><div class=\"line\">scrape_configs:</div><div class=\"line\">  # The job name is added as a label `job=&lt;job_name&gt;` to any timeseries scraped from this config.</div><div class=\"line\">  - job_name: &apos;prometheus&apos;</div><div class=\"line\">    #scrape_interval: 5s</div><div class=\"line\">    # metrics_path defaults to &apos;/metrics&apos;</div><div class=\"line\">    # scheme defaults to &apos;http&apos;.</div><div class=\"line\"></div><div class=\"line\">    static_configs:</div><div class=\"line\">      - targets: [&apos;192.168.1.162:9090&apos;]</div><div class=\"line\">        labels:</div><div class=\"line\">          instance: prometheus</div><div class=\"line\"></div><div class=\"line\">  - job_name: &apos;docker-online&apos;</div><div class=\"line\">    #scrape_interval: 5s</div><div class=\"line\">    #scheme: http</div><div class=\"line\">    static_configs:</div><div class=\"line\">      - targets: [&apos;192.168.1.162:8080&apos;]</div><div class=\"line\">        labels:</div><div class=\"line\">         group: &apos;port&apos;</div></pre></td></tr></table></figure>\n<h3 id=\"Alertmanager报警组件\"><a href=\"#Alertmanager报警组件\" class=\"headerlink\" title=\"Alertmanager报警组件\"></a>Alertmanager报警组件</h3><p>Alertmanager通过命令行flag和一个配置文件进行配置。命令行flag配置不变的系统参数、配置文件定义的禁止规则、通知路由和通知接收器。<br>要查看所有可用的命令行flag，运行alertmanager -h。<br>Alertmanager在运行时加载配置，如果不能很好的形成新的配置，更改将不会被应用，并记录错误。<br>配置文件<br>要指定加载的配置文件，需要使用-config.file标志。该文件使用YAML来完成，通过下面的描述来定义。括号内的参数是可选的，对于非列表的参数的值设置为指定的缺省值。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">global:</div><div class=\"line\">  # ResolveTimeout is the time after which an alert is declared resolved</div><div class=\"line\">  # if it has not been updated.</div><div class=\"line\">  [ resolve_timeout: &lt;duration&gt; | default = 5m ]</div><div class=\"line\"></div><div class=\"line\">  # The default SMTP From header field.</div><div class=\"line\">  [ smtp_from: &lt;tmpl_string&gt; ]</div><div class=\"line\">  # The default SMTP smarthost used for sending emails.</div><div class=\"line\">  [ smtp_smarthost: &lt;string&gt; ]</div><div class=\"line\"></div><div class=\"line\">  # The API URL to use for Slack notifications.</div><div class=\"line\">  [ slack_api_url: &lt;string&gt; ]</div><div class=\"line\"></div><div class=\"line\">  [ pagerduty_url: &lt;string&gt; | default = &quot;https://events.pagerduty.com/generic/2010-04-15/create_event.json&quot; ]</div><div class=\"line\">  [ opsgenie_api_host: &lt;string&gt; | default = &quot;https://api.opsgenie.com/&quot; ]</div><div class=\"line\"></div><div class=\"line\"># Files from which custom notification template definitions are read.</div><div class=\"line\"># The last component may use a wildcard matcher, e.g. &apos;templates/*.tmpl&apos;.</div><div class=\"line\">templates:</div><div class=\"line\">  [ - &lt;filepath&gt; ... ]</div><div class=\"line\"></div><div class=\"line\"># The root node of the routing tree.</div><div class=\"line\">route: &lt;route&gt;</div><div class=\"line\"></div><div class=\"line\"># A list of notification receivers.</div><div class=\"line\">receivers:</div><div class=\"line\">  - &lt;receiver&gt; ...</div><div class=\"line\"></div><div class=\"line\"># A list of inhibition rules.</div><div class=\"line\">inhibit_rules:</div><div class=\"line\">  [ - &lt;inhibit_rule&gt; ... ]</div></pre></td></tr></table></figure></p>\n<p>路由 route<br>路由块定义了路由树及其子节点。如果没有设置的话，子节点的可选配置参数从其父节点继承。<br>每个警报进入配置的路由树的顶级路径，顶级路径必须匹配所有警报（即没有任何形式的匹配）。然后匹配子节点。如果continue的值设置为false，它在匹配第一个孩子后就停止；如果在子节点匹配，continue的值为true，警报将继续进行后续兄弟姐妹的匹配。如果警报不匹配任何节点的任何子节点（没有匹配的子节点，或不存在），该警报基于当前节点的配置处理。<br>路由配置格式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\">[ receiver: &lt;string&gt; ]</div><div class=\"line\">[ group_by: &apos;[&apos; &lt;labelname&gt;, ... &apos;]&apos; ]</div><div class=\"line\"></div><div class=\"line\"># Whether an alert should continue matching subsequent sibling nodes.</div><div class=\"line\">[ continue: &lt;boolean&gt; | default = false ]</div><div class=\"line\"></div><div class=\"line\"># A set of equality matchers an alert has to fulfill to match the node.</div><div class=\"line\">match:</div><div class=\"line\">  [ &lt;labelname&gt;: &lt;labelvalue&gt;, ... ]</div><div class=\"line\"></div><div class=\"line\"># A set of regex-matchers an alert has to fulfill to match the node.</div><div class=\"line\">match_re:</div><div class=\"line\">  [ &lt;labelname&gt;: &lt;regex&gt;, ... ]</div><div class=\"line\"></div><div class=\"line\"># How long to initially wait to send a notification for a group</div><div class=\"line\"># of alerts. Allows to wait for an inhibiting alert to arrive or collect</div><div class=\"line\"># more initial alerts for the same group. (Usually ~0s to few minutes.)</div><div class=\"line\">[ group_wait: &lt;duration&gt; ]</div><div class=\"line\"></div><div class=\"line\"># How long to wait before sending notification about new alerts that are</div><div class=\"line\"># in are added to a group of alerts for which an initial notification</div><div class=\"line\"># has already been sent. (Usually ~5min or more.)</div><div class=\"line\">[ group_interval: &lt;duration&gt; ]</div><div class=\"line\"></div><div class=\"line\"># How long to wait before sending a notification again if it has already</div><div class=\"line\"># been sent successfully for an alert. (Usually ~3h or more).</div><div class=\"line\">[ repeat_interval: &lt;duration&gt; ]</div><div class=\"line\"></div><div class=\"line\"># Zero or more child routes.</div><div class=\"line\">routes:</div><div class=\"line\">  [ - &lt;route&gt; ... ]</div></pre></td></tr></table></figure>\n<p>在alertmanager这个配置文件配置任何警报报警alertmanager.yml，这看起来如下,这个例子是用slack(一款聊天工具),也可以用邮件,短信等其它方式报警：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"attr\">route:</span></div><div class=\"line\"><span class=\"attr\">    receiver:</span> <span class=\"string\">'slack'</span></div><div class=\"line\"><span class=\"attr\">receivers:</span></div><div class=\"line\"><span class=\"attr\">    - name:</span> <span class=\"string\">'slack'</span></div><div class=\"line\"><span class=\"attr\">      slack_configs:</span></div><div class=\"line\"><span class=\"attr\">          - send_resolved:</span> <span class=\"literal\">true</span></div><div class=\"line\"><span class=\"attr\">            username:</span> <span class=\"string\">'Prometheus'</span></div><div class=\"line\"><span class=\"attr\">            channel:</span> <span class=\"string\">'#random'</span></div><div class=\"line\"><span class=\"attr\">            api_url:</span> <span class=\"string\">'https://hooks.slack.com/services/&lt;your&gt;/&lt;stuff&gt;/&lt;here&gt;'</span></div></pre></td></tr></table></figure>\n<h3 id=\"报警规则\"><a href=\"#报警规则\" class=\"headerlink\" title=\"报警规则\"></a>报警规则</h3><p>报警规则允许你定义基于Prometheus语言表达的报警条件，并发送报警通知到外部服务。<br>报警规则通过以下格式定义：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">ALERT &lt;alert name&gt;</div><div class=\"line\">  IF &lt;expression&gt;</div><div class=\"line\">  [ FOR &lt;duration&gt; ]</div><div class=\"line\">  [ LABELS &lt;label set&gt; ]</div><div class=\"line\">  [ ANNOTATIONS &lt;label set&gt; ]</div></pre></td></tr></table></figure>\n<p>FOR子句使得Prometheus等待第一个传进来的向量元素（例如高HTTP错误的实例），并计数一个警报。如果元素是active，但是没有firing的，就处于pending状态。<br>LABELS（标签）子句允许指定一组附加的标签附到警报上。现有的任何标签都会被覆盖，标签值可以被模板化。<br>ANNOTATIONS（注释）子句指定另一组未查明警报实例的标签，它们被用于存储更长的其他信息，例如警报描述或者链接，注释值可以被模板化。<br>示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\"># alert.rules</div><div class=\"line\">ALERT service_down</div><div class=\"line\">  IF up == 0</div><div class=\"line\">ALERT high_load</div><div class=\"line\">  IF node_load1 &gt; 0.5</div><div class=\"line\">  ANNOTATIONS &#123;</div><div class=\"line\">      summary = &quot;Instance &#123;&#123; $labels.instance &#125;&#125; under high load&quot;,</div><div class=\"line\">      description = &quot;&#123;&#123; $labels.instance &#125;&#125; of job &#123;&#123; $labels.job &#125;&#125; is under highload.&quot;,</div><div class=\"line\">  &#125;</div></pre></td></tr></table></figure>\n<h2 id=\"参考资料\"><a href=\"#参考资料\" class=\"headerlink\" title=\"参考资料\"></a>参考资料</h2><ul>\n<li><a href=\"https://prometheus.io\" target=\"_blank\" rel=\"noopener\">prometheus</a></li>\n<li><a href=\"http://grafana.org\" target=\"_blank\" rel=\"noopener\">grafana</a></li>\n<li><a href=\"https://sagittariusyx.github.io/2016/03/07/prometheus-alertmanager/index.html\" target=\"_blank\" rel=\"noopener\">Prometheus监控 - Alertmanager报警模块</a></li>\n<li><a href=\"https://www.ctl.io/developers/blog/post/monitoring-docker-services-with-prometheus/\" target=\"_blank\" rel=\"noopener\">Monitoring Docker Services with Prometheus - CenturyLink Cloud Developer Center</a></li>\n<li><a href=\"http://www.ywnds.com/?p=9656\" target=\"_blank\" rel=\"noopener\">使用Prometheus+Grafana监控MySQL实践 – 运维那点事</a></li>\n<li><a href=\"http://blog.frognew.com/2017/02/use-prometheus-on-centos7.html\" target=\"_blank\" rel=\"noopener\">使用Prometheus监控服务器</a></li>\n<li><a href=\"http://yunlzheng.github.io/2017/07/04/prometheus-kubernates/\" target=\"_blank\" rel=\"noopener\">Prometheus在Kubernetes下的监控实践</a></li>\n<li><a href=\"https://finestructure.co/blog/2016/5/16/monitoring-with-prometheus-grafana-docker-part-1\" target=\"_blank\" rel=\"noopener\">通过Prometheus，Grafana和Docker进行监控</a></li>\n</ul>"},{"title":"利用gitlab进行持续部署","date":"2018-02-12T15:55:00.000Z","_content":"\n## GitLab-CI使用Docker进行持续部署\nDocker镜像通过私有仓库进行发布(如阿里云), 发布命令为:\n```ci\n docker login -u username -p password registry.demo.com\n docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\n```\n其中 `username`是用户名, `password`是密码, registry.demo.com是私有镜像库地址,\n`$CI_PROJECT_NAME` 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如\n```ci\ndocker build -t registry.demo.com/repos/image-name:latest .\n```\n`image-name`, 就是要构建的镜像名称, `latest`是TAG标签, `repos`是仓库的空间名称\n\n在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署\n<!--more-->\n项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需\n```\nimage: zacksleo/docker-composer:1.1\n\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\nstages:\n    - prepare    \n    - build\n    - deploy\n\nvariables:\n    COMPOSER_CACHE_DIR: \"/cache/composer\"\n    DOCKER_DRIVER: overlay\n\ninstalling-dependencies:\n    stage: prepare\n    script:\n        - composer install --prefer-dist -n --no-interaction -v --no-suggest\n    artifacts:\n        name: \"vendor\"\n        untracked: true\n        expire_in: 60 mins\n        paths:\n            - $CI_PROJECT_DIR/vendor    \ntest-image:\n    stage: build\n    image: docker:latest\n    services:\n        - docker:dind\n    dependencies:\n        - installing-dependencies\n    script:\n        - docker login -u username -p password registry.demo.com\n        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        \n        - ssh root@$DEPLOY_SERVER \"docker login -u username -p password registry.demo.com\"\n        - ssh root@$DEPLOY_SERVER \"cd /data/$CI_PROJECT_NAME && docker-compose stop && docker-compose rm -f && docker-compose pull && docker-compose up -d\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0\"\n```\n## GitLab-CI使用LFTP进行持续部署\n\nLFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。\n\n本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署\n\nmirror 命令及主要参数\n\n-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)\n-L 下载符号链接作为文件, 主要处理文件软链接的问题\n-v 详细输出日志\n-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)\n--transfer-all 传输所有文件, 不论新旧\n--parallel 同时传输的文件数\n--file 本地文件\n--target-directory 目标目录\n\n配置参考\n```\ndeploy:\n    stage: deploy\n    dependencies:\n        - installing-dependencies\n    script:\n        - apk add lftp\n        # 只上传新文件\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 指定目录覆盖上传 (强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 单独上传autoload文件(强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all\"\n    only:\n        - master\n```\n## GitLab-CI使用Rsync进行持续部署\nrsync命令是一个远程数据同步工具\n主要参数\n-r 递归目录\n-t 保留修改时间\n-v 详细日志\n-h 输出数字以人类可读的格式\n-z 在传输过程中压缩文件数据\n-e 指定要使用的远程shell, 注意该过程需要注入SSH\n\n配置参考\n```\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\n\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats\n```\n>注意\n远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误\n","source":"_posts/利用gitlab进行持续部署.md","raw":"---\ntitle: 利用gitlab进行持续部署\ndate: 2018-02-12 23:55:00\ntags: devops\ncategories: 技术\n\n---\n\n## GitLab-CI使用Docker进行持续部署\nDocker镜像通过私有仓库进行发布(如阿里云), 发布命令为:\n```ci\n docker login -u username -p password registry.demo.com\n docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\n```\n其中 `username`是用户名, `password`是密码, registry.demo.com是私有镜像库地址,\n`$CI_PROJECT_NAME` 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如\n```ci\ndocker build -t registry.demo.com/repos/image-name:latest .\n```\n`image-name`, 就是要构建的镜像名称, `latest`是TAG标签, `repos`是仓库的空间名称\n\n在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署\n<!--more-->\n项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需\n```\nimage: zacksleo/docker-composer:1.1\n\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\nstages:\n    - prepare    \n    - build\n    - deploy\n\nvariables:\n    COMPOSER_CACHE_DIR: \"/cache/composer\"\n    DOCKER_DRIVER: overlay\n\ninstalling-dependencies:\n    stage: prepare\n    script:\n        - composer install --prefer-dist -n --no-interaction -v --no-suggest\n    artifacts:\n        name: \"vendor\"\n        untracked: true\n        expire_in: 60 mins\n        paths:\n            - $CI_PROJECT_DIR/vendor    \ntest-image:\n    stage: build\n    image: docker:latest\n    services:\n        - docker:dind\n    dependencies:\n        - installing-dependencies\n    script:\n        - docker login -u username -p password registry.demo.com\n        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .\n        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        \n        - ssh root@$DEPLOY_SERVER \"docker login -u username -p password registry.demo.com\"\n        - ssh root@$DEPLOY_SERVER \"cd /data/$CI_PROJECT_NAME && docker-compose stop && docker-compose rm -f && docker-compose pull && docker-compose up -d\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets\"\n        - ssh root@$DEPLOY_SERVER \"docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0\"\n```\n## GitLab-CI使用LFTP进行持续部署\n\nLFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。\n\n本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署\n\nmirror 命令及主要参数\n\n-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)\n-L 下载符号链接作为文件, 主要处理文件软链接的问题\n-v 详细输出日志\n-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)\n--transfer-all 传输所有文件, 不论新旧\n--parallel 同时传输的文件数\n--file 本地文件\n--target-directory 目标目录\n\n配置参考\n```\ndeploy:\n    stage: deploy\n    dependencies:\n        - installing-dependencies\n    script:\n        - apk add lftp\n        # 只上传新文件\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 指定目录覆盖上传 (强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/\"\n        # 单独上传autoload文件(强制更新)\n        - lftp -c \"set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all\"\n    only:\n        - master\n```\n## GitLab-CI使用Rsync进行持续部署\nrsync命令是一个远程数据同步工具\n主要参数\n-r 递归目录\n-t 保留修改时间\n-v 详细日志\n-h 输出数字以人类可读的格式\n-z 在传输过程中压缩文件数据\n-e 指定要使用的远程shell, 注意该过程需要注入SSH\n\n配置参考\n```\nbefore_script:\n    - 'which ssh-agent || ( apk update && apk add openssh-client)'\n    - apk add rsync\n    - eval $(ssh-agent -s)\n    - echo \"$SSH_PRIVATE_KEY\" > ~/deploy.key\n    - chmod 0600 ~/deploy.key\n    - ssh-add ~/deploy.key\n    - mkdir -p ~/.ssh\n    - '[[ -f /.dockerenv ]] && echo -e \"Host *\\n\\tStrictHostKeyChecking no\\n\\n\" > ~/.ssh/config'\n    - export APP_ENV=testing\n\n\ntesting-server:\n    stage: deploy\n    image: alpine\n    variables:\n        DEPLOY_SERVER: \"server-host\"\n    script:\n        - cd deploy\n        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats\n```\n>注意\n远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误\n","slug":"利用gitlab进行持续部署","published":1,"updated":"2018-02-12T16:42:38.744Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q2e0014to7yun0kcgfj","content":"<h2 id=\"GitLab-CI使用Docker进行持续部署\"><a href=\"#GitLab-CI使用Docker进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Docker进行持续部署\"></a>GitLab-CI使用Docker进行持续部署</h2><p>Docker镜像通过私有仓库进行发布(如阿里云), 发布命令为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker login -u username -p password registry.demo.com</div><div class=\"line\">docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</div><div class=\"line\">docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</div></pre></td></tr></table></figure></p>\n<p>其中 <code>username</code>是用户名, <code>password</code>是密码, registry.demo.com是私有镜像库地址,<br><code>$CI_PROJECT_NAME</code> 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker build -t registry.demo.com/repos/image-name:latest .</div></pre></td></tr></table></figure></p>\n<p><code>image-name</code>, 就是要构建的镜像名称, <code>latest</code>是TAG标签, <code>repos</code>是仓库的空间名称</p>\n<p>在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署<br><a id=\"more\"></a><br>项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">image: zacksleo/docker-composer:1.1</div><div class=\"line\"></div><div class=\"line\">before_script:</div><div class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</div><div class=\"line\">    - apk add rsync</div><div class=\"line\">    - eval $(ssh-agent -s)</div><div class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</div><div class=\"line\">    - chmod 0600 ~/deploy.key</div><div class=\"line\">    - ssh-add ~/deploy.key</div><div class=\"line\">    - mkdir -p ~/.ssh</div><div class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</div><div class=\"line\">    - export APP_ENV=testing</div><div class=\"line\"></div><div class=\"line\">stages:</div><div class=\"line\">    - prepare    </div><div class=\"line\">    - build</div><div class=\"line\">    - deploy</div><div class=\"line\"></div><div class=\"line\">variables:</div><div class=\"line\">    COMPOSER_CACHE_DIR: &quot;/cache/composer&quot;</div><div class=\"line\">    DOCKER_DRIVER: overlay</div><div class=\"line\"></div><div class=\"line\">installing-dependencies:</div><div class=\"line\">    stage: prepare</div><div class=\"line\">    script:</div><div class=\"line\">        - composer install --prefer-dist -n --no-interaction -v --no-suggest</div><div class=\"line\">    artifacts:</div><div class=\"line\">        name: &quot;vendor&quot;</div><div class=\"line\">        untracked: true</div><div class=\"line\">        expire_in: 60 mins</div><div class=\"line\">        paths:</div><div class=\"line\">            - $CI_PROJECT_DIR/vendor    </div><div class=\"line\">test-image:</div><div class=\"line\">    stage: build</div><div class=\"line\">    image: docker:latest</div><div class=\"line\">    services:</div><div class=\"line\">        - docker:dind</div><div class=\"line\">    dependencies:</div><div class=\"line\">        - installing-dependencies</div><div class=\"line\">    script:</div><div class=\"line\">        - docker login -u username -p password registry.demo.com</div><div class=\"line\">        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</div><div class=\"line\">        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</div><div class=\"line\">testing-server:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">    image: alpine</div><div class=\"line\">    variables:</div><div class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</div><div class=\"line\">    script:</div><div class=\"line\">        - cd deploy</div><div class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        </div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker login -u username -p password registry.demo.com&quot;</div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;cd /data/$CI_PROJECT_NAME &amp;&amp; docker-compose stop &amp;&amp; docker-compose rm -f &amp;&amp; docker-compose pull &amp;&amp; docker-compose up -d&quot;</div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets&quot;</div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0&quot;</div></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用LFTP进行持续部署\"><a href=\"#GitLab-CI使用LFTP进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用LFTP进行持续部署\"></a>GitLab-CI使用LFTP进行持续部署</h2><p>LFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。</p>\n<p>本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署</p>\n<p>mirror 命令及主要参数</p>\n<p>-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)<br>-L 下载符号链接作为文件, 主要处理文件软链接的问题<br>-v 详细输出日志<br>-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)<br>–transfer-all 传输所有文件, 不论新旧<br>–parallel 同时传输的文件数<br>–file 本地文件<br>–target-directory 目标目录</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">    dependencies:</div><div class=\"line\">        - installing-dependencies</div><div class=\"line\">    script:</div><div class=\"line\">        - apk add lftp</div><div class=\"line\">        # 只上传新文件</div><div class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/&quot;</div><div class=\"line\">        # 指定目录覆盖上传 (强制更新)</div><div class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/&quot;</div><div class=\"line\">        # 单独上传autoload文件(强制更新)</div><div class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all&quot;</div><div class=\"line\">    only:</div><div class=\"line\">        - master</div></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用Rsync进行持续部署\"><a href=\"#GitLab-CI使用Rsync进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Rsync进行持续部署\"></a>GitLab-CI使用Rsync进行持续部署</h2><p>rsync命令是一个远程数据同步工具<br>主要参数<br>-r 递归目录<br>-t 保留修改时间<br>-v 详细日志<br>-h 输出数字以人类可读的格式<br>-z 在传输过程中压缩文件数据<br>-e 指定要使用的远程shell, 注意该过程需要注入SSH</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">before_script:</div><div class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</div><div class=\"line\">    - apk add rsync</div><div class=\"line\">    - eval $(ssh-agent -s)</div><div class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</div><div class=\"line\">    - chmod 0600 ~/deploy.key</div><div class=\"line\">    - ssh-add ~/deploy.key</div><div class=\"line\">    - mkdir -p ~/.ssh</div><div class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</div><div class=\"line\">    - export APP_ENV=testing</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">testing-server:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">    image: alpine</div><div class=\"line\">    variables:</div><div class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</div><div class=\"line\">    script:</div><div class=\"line\">        - cd deploy</div><div class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意<br>远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<h2 id=\"GitLab-CI使用Docker进行持续部署\"><a href=\"#GitLab-CI使用Docker进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Docker进行持续部署\"></a>GitLab-CI使用Docker进行持续部署</h2><p>Docker镜像通过私有仓库进行发布(如阿里云), 发布命令为:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker login -u username -p password registry.demo.com</div><div class=\"line\">docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</div><div class=\"line\">docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</div></pre></td></tr></table></figure></p>\n<p>其中 <code>username</code>是用户名, <code>password</code>是密码, registry.demo.com是私有镜像库地址,<br><code>$CI_PROJECT_NAME</code> 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker build -t registry.demo.com/repos/image-name:latest .</div></pre></td></tr></table></figure></p>\n<p><code>image-name</code>, 就是要构建的镜像名称, <code>latest</code>是TAG标签, <code>repos</code>是仓库的空间名称</p>\n<p>在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署<br>","more":"<br>项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div></pre></td><td class=\"code\"><pre><div class=\"line\">image: zacksleo/docker-composer:1.1</div><div class=\"line\"></div><div class=\"line\">before_script:</div><div class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</div><div class=\"line\">    - apk add rsync</div><div class=\"line\">    - eval $(ssh-agent -s)</div><div class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</div><div class=\"line\">    - chmod 0600 ~/deploy.key</div><div class=\"line\">    - ssh-add ~/deploy.key</div><div class=\"line\">    - mkdir -p ~/.ssh</div><div class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</div><div class=\"line\">    - export APP_ENV=testing</div><div class=\"line\"></div><div class=\"line\">stages:</div><div class=\"line\">    - prepare    </div><div class=\"line\">    - build</div><div class=\"line\">    - deploy</div><div class=\"line\"></div><div class=\"line\">variables:</div><div class=\"line\">    COMPOSER_CACHE_DIR: &quot;/cache/composer&quot;</div><div class=\"line\">    DOCKER_DRIVER: overlay</div><div class=\"line\"></div><div class=\"line\">installing-dependencies:</div><div class=\"line\">    stage: prepare</div><div class=\"line\">    script:</div><div class=\"line\">        - composer install --prefer-dist -n --no-interaction -v --no-suggest</div><div class=\"line\">    artifacts:</div><div class=\"line\">        name: &quot;vendor&quot;</div><div class=\"line\">        untracked: true</div><div class=\"line\">        expire_in: 60 mins</div><div class=\"line\">        paths:</div><div class=\"line\">            - $CI_PROJECT_DIR/vendor    </div><div class=\"line\">test-image:</div><div class=\"line\">    stage: build</div><div class=\"line\">    image: docker:latest</div><div class=\"line\">    services:</div><div class=\"line\">        - docker:dind</div><div class=\"line\">    dependencies:</div><div class=\"line\">        - installing-dependencies</div><div class=\"line\">    script:</div><div class=\"line\">        - docker login -u username -p password registry.demo.com</div><div class=\"line\">        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</div><div class=\"line\">        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</div><div class=\"line\">testing-server:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">    image: alpine</div><div class=\"line\">    variables:</div><div class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</div><div class=\"line\">    script:</div><div class=\"line\">        - cd deploy</div><div class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        </div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker login -u username -p password registry.demo.com&quot;</div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;cd /data/$CI_PROJECT_NAME &amp;&amp; docker-compose stop &amp;&amp; docker-compose rm -f &amp;&amp; docker-compose pull &amp;&amp; docker-compose up -d&quot;</div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets&quot;</div><div class=\"line\">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0&quot;</div></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用LFTP进行持续部署\"><a href=\"#GitLab-CI使用LFTP进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用LFTP进行持续部署\"></a>GitLab-CI使用LFTP进行持续部署</h2><p>LFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。</p>\n<p>本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署</p>\n<p>mirror 命令及主要参数</p>\n<p>-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)<br>-L 下载符号链接作为文件, 主要处理文件软链接的问题<br>-v 详细输出日志<br>-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)<br>–transfer-all 传输所有文件, 不论新旧<br>–parallel 同时传输的文件数<br>–file 本地文件<br>–target-directory 目标目录</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">deploy:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">    dependencies:</div><div class=\"line\">        - installing-dependencies</div><div class=\"line\">    script:</div><div class=\"line\">        - apk add lftp</div><div class=\"line\">        # 只上传新文件</div><div class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/&quot;</div><div class=\"line\">        # 指定目录覆盖上传 (强制更新)</div><div class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/&quot;</div><div class=\"line\">        # 单独上传autoload文件(强制更新)</div><div class=\"line\">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all&quot;</div><div class=\"line\">    only:</div><div class=\"line\">        - master</div></pre></td></tr></table></figure></p>\n<h2 id=\"GitLab-CI使用Rsync进行持续部署\"><a href=\"#GitLab-CI使用Rsync进行持续部署\" class=\"headerlink\" title=\"GitLab-CI使用Rsync进行持续部署\"></a>GitLab-CI使用Rsync进行持续部署</h2><p>rsync命令是一个远程数据同步工具<br>主要参数<br>-r 递归目录<br>-t 保留修改时间<br>-v 详细日志<br>-h 输出数字以人类可读的格式<br>-z 在传输过程中压缩文件数据<br>-e 指定要使用的远程shell, 注意该过程需要注入SSH</p>\n<p>配置参考<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">before_script:</div><div class=\"line\">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</div><div class=\"line\">    - apk add rsync</div><div class=\"line\">    - eval $(ssh-agent -s)</div><div class=\"line\">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</div><div class=\"line\">    - chmod 0600 ~/deploy.key</div><div class=\"line\">    - ssh-add ~/deploy.key</div><div class=\"line\">    - mkdir -p ~/.ssh</div><div class=\"line\">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\\n\\tStrictHostKeyChecking no\\n\\n&quot; &gt; ~/.ssh/config&apos;</div><div class=\"line\">    - export APP_ENV=testing</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">testing-server:</div><div class=\"line\">    stage: deploy</div><div class=\"line\">    image: alpine</div><div class=\"line\">    variables:</div><div class=\"line\">        DEPLOY_SERVER: &quot;server-host&quot;</div><div class=\"line\">    script:</div><div class=\"line\">        - cd deploy</div><div class=\"line\">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>注意<br>远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误</p>\n</blockquote>"},{"title":"压力测试，压力山大","date":"2017-06-21T12:09:31.000Z","_content":"压力测试的基本概念\n### 吞吐率（Requests per second）\n概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。\n计算公式：总请求数 / 处理完成这些请求数所花费的时间，即\nRequest per second = Complete requests / Time taken for tests\n\n### 并发连接数（The number of concurrent connections）\n概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n\n### 并发用户数（The number of concurrent users，Concurrency Level）\n概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。\n\n### 用户平均请求等待时间（Time per request）\n计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即\nTime per request = Time taken for tests /（ Complete requests / Concurrency Level）\n\n<!--more-->\n### 服务器平均请求等待时间（Time per request: across all concurrent requests）\n计算公式：处理完成所有请求数所花费的时间 / 总请求数，即\nTime taken for / testsComplete requests\n可以看到，它是吞吐率的倒数。\n同时，它也=用户平均请求等待时间/并发用户数，即\nTime per request / Concurrency Level\n### 压力测试工具\n## ab\nab工具简介\nab全称为：apache bench\n在官网上的解释如下：\nab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。\n开始测试:\n输入命令\n`ab -n 100 -c 10 https://www.baidu.com/`\n>其中－n表示请求数，－c表示并发数\n\n测试结果分析\n上面的命令运行完毕后就出来测试报告了\n``` bash\ngraychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/\nThis is ApacheBench, Version 2.3 <$Revision: 1706008 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking www.baidu.com (be patient).....done\n\n\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n\nDocument Path:          /\nDocument Length:        227 bytes\n\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n\n这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80\n``` bash\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n```\n这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）\n``` bash\nDocument Path:          /\nDocument Length:        227 bytes\n这段展示了压力测试的几个重要指标\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n```\n\n`Concurrency Level: 10`\n//并发请求数\n`Time taken for tests: 1.765 seconds`\n//整个测试持续的时间\n`Complete requests: 100`\n//完成的请求数\n`Failed requests: 0`\n//失败的请求数\n\n`Total transferred:      103255 bytes`\n//整个场景中的网络传输量\n`HTML transferred:       22700 bytes`\n//整个场景中的HTML内容传输量\n**//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       176.522 [ms] (mean)`\n**//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       17.652 [ms] (mean, across all concurrent requests)`\n**//服务器平均请求处理时间，大家最关心的指标之三**\n\n`Transfer rate:          57.12 [Kbytes/sec] received`\n//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题\n\n这段表示网络上消耗的时间的分解\n``` bash\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n```\n这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内...，重要的是看90%的处理时间。\n``` zsh\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n## 登陆的测试\n有时候进行压力测试需要用户登录，怎么办？\n请参考以下步骤：\n\n先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来\n如果只用到一个Cookie，那么只需键入命令：\nab －n 100 －C key＝value http://test.com/\n\n如果需要多个Cookie，就直接设Header：\nab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/\n\n\n\n\n\n\n","source":"_posts/压力测试，压力山大.md","raw":"---\ntitle: 压力测试，压力山大\ndate: 2017-06-21 20:09:31\ntags: php php扩展 c\ncategories: 技术\n\n---\n压力测试的基本概念\n### 吞吐率（Requests per second）\n概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。\n计算公式：总请求数 / 处理完成这些请求数所花费的时间，即\nRequest per second = Complete requests / Time taken for tests\n\n### 并发连接数（The number of concurrent connections）\n概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。\n\n### 并发用户数（The number of concurrent users，Concurrency Level）\n概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。\n\n### 用户平均请求等待时间（Time per request）\n计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即\nTime per request = Time taken for tests /（ Complete requests / Concurrency Level）\n\n<!--more-->\n### 服务器平均请求等待时间（Time per request: across all concurrent requests）\n计算公式：处理完成所有请求数所花费的时间 / 总请求数，即\nTime taken for / testsComplete requests\n可以看到，它是吞吐率的倒数。\n同时，它也=用户平均请求等待时间/并发用户数，即\nTime per request / Concurrency Level\n### 压力测试工具\n## ab\nab工具简介\nab全称为：apache bench\n在官网上的解释如下：\nab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。\n开始测试:\n输入命令\n`ab -n 100 -c 10 https://www.baidu.com/`\n>其中－n表示请求数，－c表示并发数\n\n测试结果分析\n上面的命令运行完毕后就出来测试报告了\n``` bash\ngraychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/\nThis is ApacheBench, Version 2.3 <$Revision: 1706008 $>\nCopyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/\nLicensed to The Apache Software Foundation, http://www.apache.org/\n\nBenchmarking www.baidu.com (be patient).....done\n\n\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n\nDocument Path:          /\nDocument Length:        227 bytes\n\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n\n这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80\n``` bash\nServer Software:        bfe/1.0.8.18\nServer Hostname:        www.baidu.com\nServer Port:            443\nSSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128\n```\n这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）\n``` bash\nDocument Path:          /\nDocument Length:        227 bytes\n这段展示了压力测试的几个重要指标\nConcurrency Level:      10\nTime taken for tests:   1.765 seconds\nComplete requests:      100\nFailed requests:        0\nTotal transferred:      103255 bytes\nHTML transferred:       22700 bytes\nRequests per second:    56.65 [#/sec] (mean)\nTime per request:       176.522 [ms] (mean)\nTime per request:       17.652 [ms] (mean, across all concurrent requests)\nTransfer rate:          57.12 [Kbytes/sec] received\n```\n\n`Concurrency Level: 10`\n//并发请求数\n`Time taken for tests: 1.765 seconds`\n//整个测试持续的时间\n`Complete requests: 100`\n//完成的请求数\n`Failed requests: 0`\n//失败的请求数\n\n`Total transferred:      103255 bytes`\n//整个场景中的网络传输量\n`HTML transferred:       22700 bytes`\n//整个场景中的HTML内容传输量\n**//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       176.522 [ms] (mean)`\n**//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值**\n`Time per request:       17.652 [ms] (mean, across all concurrent requests)`\n**//服务器平均请求处理时间，大家最关心的指标之三**\n\n`Transfer rate:          57.12 [Kbytes/sec] received`\n//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题\n\n这段表示网络上消耗的时间的分解\n``` bash\nConnection Times (ms)\nmin  mean[+/-sd] median   max\nConnect:      104  126  12.3    125     162\nProcessing:    32   39   5.7     38      68\nWaiting:       32   38   5.0     37      60\nTotal:        138  165  14.1    164     220\n```\n这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内...，重要的是看90%的处理时间。\n``` zsh\nPercentage of the requests served within a certain time (ms)\n        50%    164\n        66%    170\n        75%    173\n        80%    177\n        90%    184\n```\n## 登陆的测试\n有时候进行压力测试需要用户登录，怎么办？\n请参考以下步骤：\n\n先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来\n如果只用到一个Cookie，那么只需键入命令：\nab －n 100 －C key＝value http://test.com/\n\n如果需要多个Cookie，就直接设Header：\nab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” http://test.com/\n\n\n\n\n\n\n","slug":"压力测试，压力山大","published":1,"updated":"2017-12-10T12:38:46.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q2i0017to7ysmeczsu1","content":"<p>压力测试的基本概念</p>\n<h3 id=\"吞吐率（Requests-per-second）\"><a href=\"#吞吐率（Requests-per-second）\" class=\"headerlink\" title=\"吞吐率（Requests per second）\"></a>吞吐率（Requests per second）</h3><p>概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br>计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br>Request per second = Complete requests / Time taken for tests</p>\n<h3 id=\"并发连接数（The-number-of-concurrent-connections）\"><a href=\"#并发连接数（The-number-of-concurrent-connections）\" class=\"headerlink\" title=\"并发连接数（The number of concurrent connections）\"></a>并发连接数（The number of concurrent connections）</h3><p>概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p>\n<h3 id=\"并发用户数（The-number-of-concurrent-users，Concurrency-Level）\"><a href=\"#并发用户数（The-number-of-concurrent-users，Concurrency-Level）\" class=\"headerlink\" title=\"并发用户数（The number of concurrent users，Concurrency Level）\"></a>并发用户数（The number of concurrent users，Concurrency Level）</h3><p>概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</p>\n<h3 id=\"用户平均请求等待时间（Time-per-request）\"><a href=\"#用户平均请求等待时间（Time-per-request）\" class=\"headerlink\" title=\"用户平均请求等待时间（Time per request）\"></a>用户平均请求等待时间（Time per request）</h3><p>计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p>\n<a id=\"more\"></a>\n<h3 id=\"服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\"><a href=\"#服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\" class=\"headerlink\" title=\"服务器平均请求等待时间（Time per request: across all concurrent requests）\"></a>服务器平均请求等待时间（Time per request: across all concurrent requests）</h3><p>计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br>Time taken for / testsComplete requests<br>可以看到，它是吞吐率的倒数。<br>同时，它也=用户平均请求等待时间/并发用户数，即<br>Time per request / Concurrency Level</p>\n<h3 id=\"压力测试工具\"><a href=\"#压力测试工具\" class=\"headerlink\" title=\"压力测试工具\"></a>压力测试工具</h3><h2 id=\"ab\"><a href=\"#ab\" class=\"headerlink\" title=\"ab\"></a>ab</h2><p>ab工具简介<br>ab全称为：apache bench<br>在官网上的解释如下：<br>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。<br>开始测试:<br>输入命令<br><code>ab -n 100 -c 10 https://www.baidu.com/</code></p>\n<blockquote>\n<p>其中－n表示请求数，－c表示并发数</p>\n</blockquote>\n<p>测试结果分析<br>上面的命令运行完毕后就出来测试报告了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">graychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/</div><div class=\"line\">This is ApacheBench, Version 2.3 &lt;<span class=\"variable\">$Revision</span>: 1706008 $&gt;</div><div class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</div><div class=\"line\">Licensed to The Apache Software Foundation, http://www.apache.org/</div><div class=\"line\"></div><div class=\"line\">Benchmarking www.baidu.com (be patient).....done</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Server Software:        bfe/1.0.8.18</div><div class=\"line\">Server Hostname:        www.baidu.com</div><div class=\"line\">Server Port:            443</div><div class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</div><div class=\"line\"></div><div class=\"line\">Document Path:          /</div><div class=\"line\">Document Length:        227 bytes</div><div class=\"line\"></div><div class=\"line\">Concurrency Level:      10</div><div class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</div><div class=\"line\">Complete requests:      100</div><div class=\"line\">Failed requests:        0</div><div class=\"line\">Total transferred:      103255 bytes</div><div class=\"line\">HTML transferred:       22700 bytes</div><div class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></div><div class=\"line\">Time per request:       176.522 [ms] (mean)</div><div class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</div><div class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</div><div class=\"line\"></div><div class=\"line\">Connection Times (ms)</div><div class=\"line\">min  mean[+/-sd] median   max</div><div class=\"line\">Connect:      104  126  12.3    125     162</div><div class=\"line\">Processing:    32   39   5.7     38      68</div><div class=\"line\">Waiting:       32   38   5.0     37      60</div><div class=\"line\">Total:        138  165  14.1    164     220</div><div class=\"line\"></div><div class=\"line\">Percentage of the requests served within a certain time (ms)</div><div class=\"line\">        50%    164</div><div class=\"line\">        66%    170</div><div class=\"line\">        75%    173</div><div class=\"line\">        80%    177</div><div class=\"line\">        90%    184</div></pre></td></tr></table></figure></p>\n<p>这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Server Software:        bfe/1.0.8.18</div><div class=\"line\">Server Hostname:        www.baidu.com</div><div class=\"line\">Server Port:            443</div><div class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</div></pre></td></tr></table></figure></p>\n<p>这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Document Path:          /</div><div class=\"line\">Document Length:        227 bytes</div><div class=\"line\">这段展示了压力测试的几个重要指标</div><div class=\"line\">Concurrency Level:      10</div><div class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</div><div class=\"line\">Complete requests:      100</div><div class=\"line\">Failed requests:        0</div><div class=\"line\">Total transferred:      103255 bytes</div><div class=\"line\">HTML transferred:       22700 bytes</div><div class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></div><div class=\"line\">Time per request:       176.522 [ms] (mean)</div><div class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</div><div class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</div></pre></td></tr></table></figure></p>\n<p><code>Concurrency Level: 10</code><br>//并发请求数<br><code>Time taken for tests: 1.765 seconds</code><br>//整个测试持续的时间<br><code>Complete requests: 100</code><br>//完成的请求数<br><code>Failed requests: 0</code><br>//失败的请求数</p>\n<p><code>Total transferred:      103255 bytes</code><br>//整个场景中的网络传输量<br><code>HTML transferred:       22700 bytes</code><br>//整个场景中的HTML内容传输量<br><strong>//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       176.522 [ms] (mean)</code><br><strong>//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       17.652 [ms] (mean, across all concurrent requests)</code><br><strong>//服务器平均请求处理时间，大家最关心的指标之三</strong></p>\n<p><code>Transfer rate:          57.12 [Kbytes/sec] received</code><br>//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</p>\n<p>这段表示网络上消耗的时间的分解<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Connection Times (ms)</div><div class=\"line\">min  mean[+/-sd] median   max</div><div class=\"line\">Connect:      104  126  12.3    125     162</div><div class=\"line\">Processing:    32   39   5.7     38      68</div><div class=\"line\">Waiting:       32   38   5.0     37      60</div><div class=\"line\">Total:        138  165  14.1    164     220</div></pre></td></tr></table></figure></p>\n<p>这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内…，重要的是看90%的处理时间。<br><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Percentage of the requests served within a certain time (ms)</div><div class=\"line\">        50%    164</div><div class=\"line\">        66%    170</div><div class=\"line\">        75%    173</div><div class=\"line\">        80%    177</div><div class=\"line\">        90%    184</div></pre></td></tr></table></figure></p>\n<h2 id=\"登陆的测试\"><a href=\"#登陆的测试\" class=\"headerlink\" title=\"登陆的测试\"></a>登陆的测试</h2><p>有时候进行压力测试需要用户登录，怎么办？<br>请参考以下步骤：</p>\n<p>先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来<br>如果只用到一个Cookie，那么只需键入命令：<br>ab －n 100 －C key＝value <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>\n<p>如果需要多个Cookie，就直接设Header：<br>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>\n","site":{"data":{}},"excerpt":"<p>压力测试的基本概念</p>\n<h3 id=\"吞吐率（Requests-per-second）\"><a href=\"#吞吐率（Requests-per-second）\" class=\"headerlink\" title=\"吞吐率（Requests per second）\"></a>吞吐率（Requests per second）</h3><p>概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br>计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br>Request per second = Complete requests / Time taken for tests</p>\n<h3 id=\"并发连接数（The-number-of-concurrent-connections）\"><a href=\"#并发连接数（The-number-of-concurrent-connections）\" class=\"headerlink\" title=\"并发连接数（The number of concurrent connections）\"></a>并发连接数（The number of concurrent connections）</h3><p>概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p>\n<h3 id=\"并发用户数（The-number-of-concurrent-users，Concurrency-Level）\"><a href=\"#并发用户数（The-number-of-concurrent-users，Concurrency-Level）\" class=\"headerlink\" title=\"并发用户数（The number of concurrent users，Concurrency Level）\"></a>并发用户数（The number of concurrent users，Concurrency Level）</h3><p>概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</p>\n<h3 id=\"用户平均请求等待时间（Time-per-request）\"><a href=\"#用户平均请求等待时间（Time-per-request）\" class=\"headerlink\" title=\"用户平均请求等待时间（Time per request）\"></a>用户平均请求等待时间（Time per request）</h3><p>计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p>","more":"<h3 id=\"服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\"><a href=\"#服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）\" class=\"headerlink\" title=\"服务器平均请求等待时间（Time per request: across all concurrent requests）\"></a>服务器平均请求等待时间（Time per request: across all concurrent requests）</h3><p>计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br>Time taken for / testsComplete requests<br>可以看到，它是吞吐率的倒数。<br>同时，它也=用户平均请求等待时间/并发用户数，即<br>Time per request / Concurrency Level</p>\n<h3 id=\"压力测试工具\"><a href=\"#压力测试工具\" class=\"headerlink\" title=\"压力测试工具\"></a>压力测试工具</h3><h2 id=\"ab\"><a href=\"#ab\" class=\"headerlink\" title=\"ab\"></a>ab</h2><p>ab工具简介<br>ab全称为：apache bench<br>在官网上的解释如下：<br>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。<br>开始测试:<br>输入命令<br><code>ab -n 100 -c 10 https://www.baidu.com/</code></p>\n<blockquote>\n<p>其中－n表示请求数，－c表示并发数</p>\n</blockquote>\n<p>测试结果分析<br>上面的命令运行完毕后就出来测试报告了<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">graychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/</div><div class=\"line\">This is ApacheBench, Version 2.3 &lt;<span class=\"variable\">$Revision</span>: 1706008 $&gt;</div><div class=\"line\">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</div><div class=\"line\">Licensed to The Apache Software Foundation, http://www.apache.org/</div><div class=\"line\"></div><div class=\"line\">Benchmarking www.baidu.com (be patient).....done</div><div class=\"line\"></div><div class=\"line\"></div><div class=\"line\">Server Software:        bfe/1.0.8.18</div><div class=\"line\">Server Hostname:        www.baidu.com</div><div class=\"line\">Server Port:            443</div><div class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</div><div class=\"line\"></div><div class=\"line\">Document Path:          /</div><div class=\"line\">Document Length:        227 bytes</div><div class=\"line\"></div><div class=\"line\">Concurrency Level:      10</div><div class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</div><div class=\"line\">Complete requests:      100</div><div class=\"line\">Failed requests:        0</div><div class=\"line\">Total transferred:      103255 bytes</div><div class=\"line\">HTML transferred:       22700 bytes</div><div class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></div><div class=\"line\">Time per request:       176.522 [ms] (mean)</div><div class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</div><div class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</div><div class=\"line\"></div><div class=\"line\">Connection Times (ms)</div><div class=\"line\">min  mean[+/-sd] median   max</div><div class=\"line\">Connect:      104  126  12.3    125     162</div><div class=\"line\">Processing:    32   39   5.7     38      68</div><div class=\"line\">Waiting:       32   38   5.0     37      60</div><div class=\"line\">Total:        138  165  14.1    164     220</div><div class=\"line\"></div><div class=\"line\">Percentage of the requests served within a certain time (ms)</div><div class=\"line\">        50%    164</div><div class=\"line\">        66%    170</div><div class=\"line\">        75%    173</div><div class=\"line\">        80%    177</div><div class=\"line\">        90%    184</div></pre></td></tr></table></figure></p>\n<p>这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Server Software:        bfe/1.0.8.18</div><div class=\"line\">Server Hostname:        www.baidu.com</div><div class=\"line\">Server Port:            443</div><div class=\"line\">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</div></pre></td></tr></table></figure></p>\n<p>这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Document Path:          /</div><div class=\"line\">Document Length:        227 bytes</div><div class=\"line\">这段展示了压力测试的几个重要指标</div><div class=\"line\">Concurrency Level:      10</div><div class=\"line\">Time taken <span class=\"keyword\">for</span> tests:   1.765 seconds</div><div class=\"line\">Complete requests:      100</div><div class=\"line\">Failed requests:        0</div><div class=\"line\">Total transferred:      103255 bytes</div><div class=\"line\">HTML transferred:       22700 bytes</div><div class=\"line\">Requests per second:    56.65 [<span class=\"comment\">#/sec] (mean)</span></div><div class=\"line\">Time per request:       176.522 [ms] (mean)</div><div class=\"line\">Time per request:       17.652 [ms] (mean, across all concurrent requests)</div><div class=\"line\">Transfer rate:          57.12 [Kbytes/sec] received</div></pre></td></tr></table></figure></p>\n<p><code>Concurrency Level: 10</code><br>//并发请求数<br><code>Time taken for tests: 1.765 seconds</code><br>//整个测试持续的时间<br><code>Complete requests: 100</code><br>//完成的请求数<br><code>Failed requests: 0</code><br>//失败的请求数</p>\n<p><code>Total transferred:      103255 bytes</code><br>//整个场景中的网络传输量<br><code>HTML transferred:       22700 bytes</code><br>//整个场景中的HTML内容传输量<br><strong>//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       176.522 [ms] (mean)</code><br><strong>//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       17.652 [ms] (mean, across all concurrent requests)</code><br><strong>//服务器平均请求处理时间，大家最关心的指标之三</strong></p>\n<p><code>Transfer rate:          57.12 [Kbytes/sec] received</code><br>//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</p>\n<p>这段表示网络上消耗的时间的分解<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Connection Times (ms)</div><div class=\"line\">min  mean[+/-sd] median   max</div><div class=\"line\">Connect:      104  126  12.3    125     162</div><div class=\"line\">Processing:    32   39   5.7     38      68</div><div class=\"line\">Waiting:       32   38   5.0     37      60</div><div class=\"line\">Total:        138  165  14.1    164     220</div></pre></td></tr></table></figure></p>\n<p>这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内…，重要的是看90%的处理时间。<br><figure class=\"highlight zsh\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Percentage of the requests served within a certain time (ms)</div><div class=\"line\">        50%    164</div><div class=\"line\">        66%    170</div><div class=\"line\">        75%    173</div><div class=\"line\">        80%    177</div><div class=\"line\">        90%    184</div></pre></td></tr></table></figure></p>\n<h2 id=\"登陆的测试\"><a href=\"#登陆的测试\" class=\"headerlink\" title=\"登陆的测试\"></a>登陆的测试</h2><p>有时候进行压力测试需要用户登录，怎么办？<br>请参考以下步骤：</p>\n<p>先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来<br>如果只用到一个Cookie，那么只需键入命令：<br>ab －n 100 －C key＝value <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>\n<p>如果需要多个Cookie，就直接设Header：<br>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” <a href=\"http://test.com/\" target=\"_blank\" rel=\"noopener\">http://test.com/</a></p>"},{"title":"变身吧！我的linux配置环境","date":"2016-10-18T06:35:17.000Z","_content":" 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。\n# 先上效果图\n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面带终端效果图.png)\n## 终端改造  Terminator\nubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。\n### 安装方式\nsudo apt-get install terminator\n### 常用快捷键\n垂直分割窗口 `Ctrl+Shift+e`\n水平分割窗口 `Ctrl+Shift+o`\n复制         `Ctrl+Shift+c`\n粘贴         `Ctrl+Shift+v`\n切换窗口     `Ctrl+Shift+n`\n将分割的某个窗口放大至全屏使用         `Ctrl+Shift+x`\n从放大的某一窗口回到多窗口格局         `Ctrl+Shift+z`\n ![\"我是傲娇的效果图\"](/assets/blogImg/多窗终端.png)\n\n<!--more-->\n### 终端主题\n ``` shell\n apt-get install zsh\n wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh\n chsh -s `which zsh`\n sudo shutdown -r 0\n ```\n 我用的主题是`ys`\n\n### 桌面主题\n 首先在这里[下载](https://github.com/anmoljagetia/Flatabulous/archive/master.zip)主题包，将文件解压后移动到`/usr/share/themes/`,接着安装图标:\n ```shell\n sudo add-apt-repository ppa:noobslab/icons\n sudo apt-get update\n sudo apt-get install ultra-flat-icons```\n \n 然后需要`unity-tweak-tool`\n ```shell\n sudo apt-get install unity-tweak-tool\n sudo unity-tweak-tool\n```\n在Themes和icons下分别选择刚刚的主题和图标，大功告成！\n\n ![\"我是傲娇的效果图\"](/assets/blogImg/选择主题.png)\n \n完成后的样子 \n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面效果图.png)\n\n","source":"_posts/变身吧！我的linux配置环境.md","raw":"---\ntitle: 变身吧！我的linux配置环境\ndate: 2016-10-18 14:35:17\ntags: linux\ncategories: 技术\n\n---\n 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。\n# 先上效果图\n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面带终端效果图.png)\n## 终端改造  Terminator\nubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。\n### 安装方式\nsudo apt-get install terminator\n### 常用快捷键\n垂直分割窗口 `Ctrl+Shift+e`\n水平分割窗口 `Ctrl+Shift+o`\n复制         `Ctrl+Shift+c`\n粘贴         `Ctrl+Shift+v`\n切换窗口     `Ctrl+Shift+n`\n将分割的某个窗口放大至全屏使用         `Ctrl+Shift+x`\n从放大的某一窗口回到多窗口格局         `Ctrl+Shift+z`\n ![\"我是傲娇的效果图\"](/assets/blogImg/多窗终端.png)\n\n<!--more-->\n### 终端主题\n ``` shell\n apt-get install zsh\n wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh\n chsh -s `which zsh`\n sudo shutdown -r 0\n ```\n 我用的主题是`ys`\n\n### 桌面主题\n 首先在这里[下载](https://github.com/anmoljagetia/Flatabulous/archive/master.zip)主题包，将文件解压后移动到`/usr/share/themes/`,接着安装图标:\n ```shell\n sudo add-apt-repository ppa:noobslab/icons\n sudo apt-get update\n sudo apt-get install ultra-flat-icons```\n \n 然后需要`unity-tweak-tool`\n ```shell\n sudo apt-get install unity-tweak-tool\n sudo unity-tweak-tool\n```\n在Themes和icons下分别选择刚刚的主题和图标，大功告成！\n\n ![\"我是傲娇的效果图\"](/assets/blogImg/选择主题.png)\n \n完成后的样子 \n ![\"我是傲娇的效果图\"](/assets/blogImg/桌面效果图.png)\n\n","slug":"变身吧！我的linux配置环境","published":1,"updated":"2017-12-10T12:38:46.176Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q2m0019to7y71rkatr0","content":"<p> 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。</p>\n<h1 id=\"先上效果图\"><a href=\"#先上效果图\" class=\"headerlink\" title=\"先上效果图\"></a>先上效果图</h1><p> <img src=\"/assets/blogImg/桌面带终端效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"终端改造-Terminator\"><a href=\"#终端改造-Terminator\" class=\"headerlink\" title=\"终端改造  Terminator\"></a>终端改造  Terminator</h2><p>ubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。</p>\n<h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h3><p>sudo apt-get install terminator</p>\n<h3 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h3><p>垂直分割窗口 <code>Ctrl+Shift+e</code><br>水平分割窗口 <code>Ctrl+Shift+o</code><br>复制         <code>Ctrl+Shift+c</code><br>粘贴         <code>Ctrl+Shift+v</code><br>切换窗口     <code>Ctrl+Shift+n</code><br>将分割的某个窗口放大至全屏使用         <code>Ctrl+Shift+x</code><br>从放大的某一窗口回到多窗口格局         <code>Ctrl+Shift+z</code><br> <img src=\"/assets/blogImg/多窗终端.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<a id=\"more\"></a>\n<h3 id=\"终端主题\"><a href=\"#终端主题\" class=\"headerlink\" title=\"终端主题\"></a>终端主题</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install zsh</div><div class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh</div><div class=\"line\">chsh -s `which zsh`</div><div class=\"line\">sudo shutdown -r 0</div></pre></td></tr></table></figure>\n<p> 我用的主题是<code>ys</code></p>\n<h3 id=\"桌面主题\"><a href=\"#桌面主题\" class=\"headerlink\" title=\"桌面主题\"></a>桌面主题</h3><p> 首先在这里<a href=\"https://github.com/anmoljagetia/Flatabulous/archive/master.zip\" target=\"_blank\" rel=\"noopener\">下载</a>主题包，将文件解压后移动到<code>/usr/share/themes/</code>,接着安装图标:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:noobslab/icons</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install ultra-flat-icons</div></pre></td></tr></table></figure></p>\n<p> 然后需要<code>unity-tweak-tool</code><br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install unity-tweak-tool</div><div class=\"line\">sudo unity-tweak-tool</div></pre></td></tr></table></figure></p>\n<p>在Themes和icons下分别选择刚刚的主题和图标，大功告成！</p>\n<p> <img src=\"/assets/blogImg/选择主题.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>完成后的样子<br> <img src=\"/assets/blogImg/桌面效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n","site":{"data":{}},"excerpt":"<p> 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。</p>\n<h1 id=\"先上效果图\"><a href=\"#先上效果图\" class=\"headerlink\" title=\"先上效果图\"></a>先上效果图</h1><p> <img src=\"/assets/blogImg/桌面带终端效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h2 id=\"终端改造-Terminator\"><a href=\"#终端改造-Terminator\" class=\"headerlink\" title=\"终端改造  Terminator\"></a>终端改造  Terminator</h2><p>ubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。</p>\n<h3 id=\"安装方式\"><a href=\"#安装方式\" class=\"headerlink\" title=\"安装方式\"></a>安装方式</h3><p>sudo apt-get install terminator</p>\n<h3 id=\"常用快捷键\"><a href=\"#常用快捷键\" class=\"headerlink\" title=\"常用快捷键\"></a>常用快捷键</h3><p>垂直分割窗口 <code>Ctrl+Shift+e</code><br>水平分割窗口 <code>Ctrl+Shift+o</code><br>复制         <code>Ctrl+Shift+c</code><br>粘贴         <code>Ctrl+Shift+v</code><br>切换窗口     <code>Ctrl+Shift+n</code><br>将分割的某个窗口放大至全屏使用         <code>Ctrl+Shift+x</code><br>从放大的某一窗口回到多窗口格局         <code>Ctrl+Shift+z</code><br> <img src=\"/assets/blogImg/多窗终端.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>","more":"<h3 id=\"终端主题\"><a href=\"#终端主题\" class=\"headerlink\" title=\"终端主题\"></a>终端主题</h3> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">apt-get install zsh</div><div class=\"line\">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh</div><div class=\"line\">chsh -s `which zsh`</div><div class=\"line\">sudo shutdown -r 0</div></pre></td></tr></table></figure>\n<p> 我用的主题是<code>ys</code></p>\n<h3 id=\"桌面主题\"><a href=\"#桌面主题\" class=\"headerlink\" title=\"桌面主题\"></a>桌面主题</h3><p> 首先在这里<a href=\"https://github.com/anmoljagetia/Flatabulous/archive/master.zip\" target=\"_blank\" rel=\"noopener\">下载</a>主题包，将文件解压后移动到<code>/usr/share/themes/</code>,接着安装图标:<br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo add-apt-repository ppa:noobslab/icons</div><div class=\"line\">sudo apt-get update</div><div class=\"line\">sudo apt-get install ultra-flat-icons</div></pre></td></tr></table></figure></p>\n<p> 然后需要<code>unity-tweak-tool</code><br> <figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">sudo apt-get install unity-tweak-tool</div><div class=\"line\">sudo unity-tweak-tool</div></pre></td></tr></table></figure></p>\n<p>在Themes和icons下分别选择刚刚的主题和图标，大功告成！</p>\n<p> <img src=\"/assets/blogImg/选择主题.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>完成后的样子<br> <img src=\"/assets/blogImg/桌面效果图.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>"},{"title":"Codeception测试框架如何编写测试","date":"2017-06-18T05:38:51.000Z","_content":"## 如何编写测试\nYii2高级应用程序使用Codeception作为其主要测试框架。\n### 搭建测试环境\n为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：\n``` php\ncomposer global require \"codeception/codeception=2.1.*\"\ncomposer global require \"codeception/specify=*\"\ncomposer global require \"codeception/verify=*\"\n```\n创建测试目录\n```\ncodecept bootstrap \n```\n构建测试套件：\n``` php\ncodecept build\n```\n如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：\n``` php\n./yii_test migrate\n```\n\n<!--more-->\n然后所有的样例测试可以通过运行如下代码：\n```\ncodecept run\n```\ndocker环境下运行搭建并运行测试：\n```\ndocker exec -it health_web_1 ./vendor/bin/codecept boostrap\ndocker exec -it health_web_1 ./vendor/bin/./yii_test migrate\ndocker exec -it health_web_1 ./vendor/bin/codecept build\ndocker exec -it health_web_1 ./vendor/bin/codecept run\n```\n测试套件描述：\n\n- unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。\n- api ⇒ api接口测试(主要)。\n- functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。\n- acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。\n\n## 启动测试\n\n\n``` bash\n docker exec -it usercenter_web_1 bash\n//或者\n docker exec -it health_web_1 /bin/sh\n./vendor/bin/codecept run -c tests\n```\n-c 指定目录\napi测试需要启动一个web服务器\n``` bash\nphp -S localhost:80 --docroot api/tests &>/dev/null&\n```\n\n## 搭建测试环境\n目录结构\n\n``` bash\n├── codeception\n│   ├── api  //api测试\n│   ├── api.suite.yml  //api测试配置\n│   ├── _bootstrap.php\n│   ├── _data\n│   │   └── dump.sql  //初始化sql\n│   ├── _output  //日志\n│   ├── _support                                                    \n│   ├── unit\n│   │   ├── _bootstrap.php   //依赖文件\n│   │   ├── models\n│   │   │   ├── ActivityConfigTest.php  //单元测试\n│   │   └── UnitTester.php\n│   └── unit.suite.yml  //单元测试配置文件\n├── codeception.yml\n├── _envs\n├── _output\n└── _support\n    └── _generated\n```\n\n在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件\n### api测试详解\nAPI测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件\n``` bash\n./vendor/bin/codecept g:suite api\n```\n您将需要启用REST，Yii2模块tests/api.suite.yml：\n``` bash\nclass_name: ApiTester\nmodules:\n    enabled:\n        - REST:\n            url: /api/v1\n            depends: Yii2\n        - \\ApiBundle\\Helper\\Api\n    config:\n        - Yii2\n```\nYii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。\n\n[继续执行REST API测试指南»](http://codeception.com/docs/10-WebServices#REST)\n### 单位测试详解\n单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。\n\n每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：\n``` bash\nmodules:\n    enabled:\n      - Yii2:\n            part: [orm, email]\n```\n该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。\n\n通过访问测试用例中的$this->tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：\n```\n<?php\n// insert records in database\n$this->tester->haveRecord('app/model/User', ['username' => 'davert']);\n// check records in database\n$this->tester->seeRecord('app/model/User', ['username' => 'davert']);\n// test email was sent\n$this->tester->seeEmailIsSent();\n// get a last sent emails\n$this->tester->grabLastSentEmail();\n```\n如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：\n```\n<?php\n// load fixtures\n$this->tester->haveFixtures([\n    'user' => [\n        'class' => UserFixture::className(),\n        // fixture data located in tests/_data/user.php\n        'dataFile' => codecept_data_dir() . 'user.php'\n    ]\n]);\n// get first user from fixtures\n$this->tester->grabFixture('user', 0);\n```\n如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。\n\n \n[继续进行单元测试指南»](http://codeception.com/docs/05-UnitTests)\n### 功能测试\n当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：\n```\n<?php\n$I->amOnPage(['site/contact']);\n$I->submitForm('#contact-form', []);\n$I->expectTo('see validations errors');\n$I->see('Contact', 'h1');\n$I->see('Name cannot be blank');\n$I->see('Email cannot be blank');\n$I->see('Subject cannot be blank');\n$I->see('Body cannot be blank');\n```\n这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。\n\n功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：\n\n./vendor/bin/codecept g:cest functional MyNewScenarioCest\n 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。\n\n[继续进行功能测试指南»](http://codeception.com/docs/04-FunctionalTests)\n\n### 验收测试\n从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。\n\n默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml\n```\nmv tests/acceptance.suite.yml.example tests/acceptance.suite.yml\n基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。\n```\n那么您将需要在测试模式下启动应用服务器：\n```\n./tests/bin/yii serve\n```\n并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：\n```\n# config at tests/acceptance.yml\nmodules:\n    enabled:\n        - WebDriver:\n            url: http://127.0.0.1:8080/\n            browser: firefox\n        - Yii2:\n            part: [orm, fixtures] # allow to use AR methods\n            cleanup: false # don't wrap test in transaction\n            entryScript: index-test.php\n```\n正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。\n\n与功能测试类似，建议使用Cest格式进行验收测试：\n```\n./vendor/bin/codecept g:cest acceptance MyNewScenarioCest\n```\n\n[继续验收测试指南»](http://codeception.com/docs/03-AcceptanceTests)\n\n\n### 手动设置&&配置\n要开始，您需要通过Composer安装Codeception\n```\ncomposer require \"codeception/codeception\" --dev\n```\n创建基本的测试套件\n```\n./vendor/bin/codecept bootstrap\n```\n启用模块Yii2进行功能测试functional.suite.yml：\n```\n# functional.suite.yml\nmodules:\n    enabled:\n        - Yii2:\n            configFile: #insert path to config file\n```\nYii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：\n```\n<?php\n// config/test.php\n$config =  yii\\helpers\\ArrayHelper::merge(\n    require(__DIR__ . '/main.php'),\n    require(__DIR__ . '/main-local.php'),\n    [\n        'id' => 'app-tests',\n        'components' => [\n            'db' => [\n                'dsn' => 'mysql:host=localhost;dbname=yii_app_test',\n            ]\n        ]        \n    ]\n);\nreturn $config;\n```\n测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。\n\n还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。\n\n一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。\n\n在基础和高级应用程序模板configFile中定义了全局配置文件：\n```\n# inside codeception.yml\nmodules:\n    config:\n        Yii2:\n            configFile: 'config/test.php'\n```\n这样我们不需要为每个定义的套件提供测试配置。\n### 伪数据生成器\n安装\n```\ncomposer require fzaninotto/faker\n```\n使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。\n```\n<?php\n// require the Faker autoloader\nrequire_once '/path/to/Faker/src/autoload.php';\n// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)\n\n// use the factory to create a Faker\\Generator instance\n$faker = Faker\\Factory::create();\n\n// generate data by accessing properties\necho $faker->name;\n  // 'Lucy Cechtelar';\necho $faker->address;\n  // \"426 Jordy Lodge\n  // Cartwrightshire, SC 88120-6700\"\necho $faker->text;\n  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit\n  // et sit et mollitia sed.\n  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium\n  // sit minima sint.\n```\n\n\n","source":"_posts/如何编写测试.md","raw":"---\ntitle: Codeception测试框架如何编写测试\ndate: 2017-06-18 13:38:51\ntags: php\ncategories: 技术\n\n---\n## 如何编写测试\nYii2高级应用程序使用Codeception作为其主要测试框架。\n### 搭建测试环境\n为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：\n``` php\ncomposer global require \"codeception/codeception=2.1.*\"\ncomposer global require \"codeception/specify=*\"\ncomposer global require \"codeception/verify=*\"\n```\n创建测试目录\n```\ncodecept bootstrap \n```\n构建测试套件：\n``` php\ncodecept build\n```\n如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：\n``` php\n./yii_test migrate\n```\n\n<!--more-->\n然后所有的样例测试可以通过运行如下代码：\n```\ncodecept run\n```\ndocker环境下运行搭建并运行测试：\n```\ndocker exec -it health_web_1 ./vendor/bin/codecept boostrap\ndocker exec -it health_web_1 ./vendor/bin/./yii_test migrate\ndocker exec -it health_web_1 ./vendor/bin/codecept build\ndocker exec -it health_web_1 ./vendor/bin/codecept run\n```\n测试套件描述：\n\n- unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。\n- api ⇒ api接口测试(主要)。\n- functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。\n- acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。\n\n## 启动测试\n\n\n``` bash\n docker exec -it usercenter_web_1 bash\n//或者\n docker exec -it health_web_1 /bin/sh\n./vendor/bin/codecept run -c tests\n```\n-c 指定目录\napi测试需要启动一个web服务器\n``` bash\nphp -S localhost:80 --docroot api/tests &>/dev/null&\n```\n\n## 搭建测试环境\n目录结构\n\n``` bash\n├── codeception\n│   ├── api  //api测试\n│   ├── api.suite.yml  //api测试配置\n│   ├── _bootstrap.php\n│   ├── _data\n│   │   └── dump.sql  //初始化sql\n│   ├── _output  //日志\n│   ├── _support                                                    \n│   ├── unit\n│   │   ├── _bootstrap.php   //依赖文件\n│   │   ├── models\n│   │   │   ├── ActivityConfigTest.php  //单元测试\n│   │   └── UnitTester.php\n│   └── unit.suite.yml  //单元测试配置文件\n├── codeception.yml\n├── _envs\n├── _output\n└── _support\n    └── _generated\n```\n\n在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件\n### api测试详解\nAPI测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件\n``` bash\n./vendor/bin/codecept g:suite api\n```\n您将需要启用REST，Yii2模块tests/api.suite.yml：\n``` bash\nclass_name: ApiTester\nmodules:\n    enabled:\n        - REST:\n            url: /api/v1\n            depends: Yii2\n        - \\ApiBundle\\Helper\\Api\n    config:\n        - Yii2\n```\nYii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。\n\n[继续执行REST API测试指南»](http://codeception.com/docs/10-WebServices#REST)\n### 单位测试详解\n单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。\n\n每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：\n``` bash\nmodules:\n    enabled:\n      - Yii2:\n            part: [orm, email]\n```\n该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。\n\n通过访问测试用例中的$this->tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：\n```\n<?php\n// insert records in database\n$this->tester->haveRecord('app/model/User', ['username' => 'davert']);\n// check records in database\n$this->tester->seeRecord('app/model/User', ['username' => 'davert']);\n// test email was sent\n$this->tester->seeEmailIsSent();\n// get a last sent emails\n$this->tester->grabLastSentEmail();\n```\n如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：\n```\n<?php\n// load fixtures\n$this->tester->haveFixtures([\n    'user' => [\n        'class' => UserFixture::className(),\n        // fixture data located in tests/_data/user.php\n        'dataFile' => codecept_data_dir() . 'user.php'\n    ]\n]);\n// get first user from fixtures\n$this->tester->grabFixture('user', 0);\n```\n如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。\n\n \n[继续进行单元测试指南»](http://codeception.com/docs/05-UnitTests)\n### 功能测试\n当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：\n```\n<?php\n$I->amOnPage(['site/contact']);\n$I->submitForm('#contact-form', []);\n$I->expectTo('see validations errors');\n$I->see('Contact', 'h1');\n$I->see('Name cannot be blank');\n$I->see('Email cannot be blank');\n$I->see('Subject cannot be blank');\n$I->see('Body cannot be blank');\n```\n这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。\n\n功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：\n\n./vendor/bin/codecept g:cest functional MyNewScenarioCest\n 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。\n\n[继续进行功能测试指南»](http://codeception.com/docs/04-FunctionalTests)\n\n### 验收测试\n从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。\n\n默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml\n```\nmv tests/acceptance.suite.yml.example tests/acceptance.suite.yml\n基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。\n```\n那么您将需要在测试模式下启动应用服务器：\n```\n./tests/bin/yii serve\n```\n并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：\n```\n# config at tests/acceptance.yml\nmodules:\n    enabled:\n        - WebDriver:\n            url: http://127.0.0.1:8080/\n            browser: firefox\n        - Yii2:\n            part: [orm, fixtures] # allow to use AR methods\n            cleanup: false # don't wrap test in transaction\n            entryScript: index-test.php\n```\n正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。\n\n与功能测试类似，建议使用Cest格式进行验收测试：\n```\n./vendor/bin/codecept g:cest acceptance MyNewScenarioCest\n```\n\n[继续验收测试指南»](http://codeception.com/docs/03-AcceptanceTests)\n\n\n### 手动设置&&配置\n要开始，您需要通过Composer安装Codeception\n```\ncomposer require \"codeception/codeception\" --dev\n```\n创建基本的测试套件\n```\n./vendor/bin/codecept bootstrap\n```\n启用模块Yii2进行功能测试functional.suite.yml：\n```\n# functional.suite.yml\nmodules:\n    enabled:\n        - Yii2:\n            configFile: #insert path to config file\n```\nYii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：\n```\n<?php\n// config/test.php\n$config =  yii\\helpers\\ArrayHelper::merge(\n    require(__DIR__ . '/main.php'),\n    require(__DIR__ . '/main-local.php'),\n    [\n        'id' => 'app-tests',\n        'components' => [\n            'db' => [\n                'dsn' => 'mysql:host=localhost;dbname=yii_app_test',\n            ]\n        ]        \n    ]\n);\nreturn $config;\n```\n测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。\n\n还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。\n\n一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。\n\n在基础和高级应用程序模板configFile中定义了全局配置文件：\n```\n# inside codeception.yml\nmodules:\n    config:\n        Yii2:\n            configFile: 'config/test.php'\n```\n这样我们不需要为每个定义的套件提供测试配置。\n### 伪数据生成器\n安装\n```\ncomposer require fzaninotto/faker\n```\n使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。\n```\n<?php\n// require the Faker autoloader\nrequire_once '/path/to/Faker/src/autoload.php';\n// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)\n\n// use the factory to create a Faker\\Generator instance\n$faker = Faker\\Factory::create();\n\n// generate data by accessing properties\necho $faker->name;\n  // 'Lucy Cechtelar';\necho $faker->address;\n  // \"426 Jordy Lodge\n  // Cartwrightshire, SC 88120-6700\"\necho $faker->text;\n  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit\n  // et sit et mollitia sed.\n  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium\n  // sit minima sint.\n```\n\n\n","slug":"如何编写测试","published":1,"updated":"2017-12-10T12:38:46.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q2v001cto7ylxmg61nw","content":"<h2 id=\"如何编写测试\"><a href=\"#如何编写测试\" class=\"headerlink\" title=\"如何编写测试\"></a>如何编写测试</h2><p>Yii2高级应用程序使用Codeception作为其主要测试框架。</p>\n<h3 id=\"搭建测试环境\"><a href=\"#搭建测试环境\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h3><p>为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/codeception=2.1.*\"</span></div><div class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/specify=*\"</span></div><div class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/verify=*\"</span></div></pre></td></tr></table></figure></p>\n<p>创建测试目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codecept bootstrap</div></pre></td></tr></table></figure></p>\n<p>构建测试套件：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codecept build</div></pre></td></tr></table></figure></p>\n<p>如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./yii_test migrate</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>然后所有的样例测试可以通过运行如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codecept run</div></pre></td></tr></table></figure></p>\n<p>docker环境下运行搭建并运行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept boostrap</div><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/./yii_test migrate</div><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept build</div><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept run</div></pre></td></tr></table></figure></p>\n<p>测试套件描述：</p>\n<ul>\n<li>unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。</li>\n<li>api ⇒ api接口测试(主要)。</li>\n<li>functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。</li>\n<li>acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。</li>\n</ul>\n<h2 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> docker <span class=\"built_in\">exec</span> -it usercenter_web_1 bash</div><div class=\"line\">//或者</div><div class=\"line\"> docker <span class=\"built_in\">exec</span> -it health_web_1 /bin/sh</div><div class=\"line\">./vendor/bin/codecept run -c tests</div></pre></td></tr></table></figure>\n<p>-c 指定目录<br>api测试需要启动一个web服务器<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">php -S localhost:80 --docroot api/tests &amp;&gt;/dev/null&amp;</div></pre></td></tr></table></figure></p>\n<h2 id=\"搭建测试环境-1\"><a href=\"#搭建测试环境-1\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h2><p>目录结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── codeception</div><div class=\"line\">│   ├── api  //api测试</div><div class=\"line\">│   ├── api.suite.yml  //api测试配置</div><div class=\"line\">│   ├── _bootstrap.php</div><div class=\"line\">│   ├── _data</div><div class=\"line\">│   │   └── dump.sql  //初始化sql</div><div class=\"line\">│   ├── _output  //日志</div><div class=\"line\">│   ├── _support                                                    </div><div class=\"line\">│   ├── unit</div><div class=\"line\">│   │   ├── _bootstrap.php   //依赖文件</div><div class=\"line\">│   │   ├── models</div><div class=\"line\">│   │   │   ├── ActivityConfigTest.php  //单元测试</div><div class=\"line\">│   │   └── UnitTester.php</div><div class=\"line\">│   └── unit.suite.yml  //单元测试配置文件</div><div class=\"line\">├── codeception.yml</div><div class=\"line\">├── _envs</div><div class=\"line\">├── _output</div><div class=\"line\">└── _support</div><div class=\"line\">    └── _generated</div></pre></td></tr></table></figure>\n<p>在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件</p>\n<h3 id=\"api测试详解\"><a href=\"#api测试详解\" class=\"headerlink\" title=\"api测试详解\"></a>api测试详解</h3><p>API测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./vendor/bin/codecept g:suite api</div></pre></td></tr></table></figure></p>\n<p>您将需要启用REST，Yii2模块tests/api.suite.yml：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">class_name: ApiTester</div><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">        - REST:</div><div class=\"line\">            url: /api/v1</div><div class=\"line\">            depends: Yii2</div><div class=\"line\">        - \\ApiBundle\\Helper\\Api</div><div class=\"line\">    config:</div><div class=\"line\">        - Yii2</div></pre></td></tr></table></figure></p>\n<p>Yii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。</p>\n<p><a href=\"http://codeception.com/docs/10-WebServices#REST\" target=\"_blank\" rel=\"noopener\">继续执行REST API测试指南»</a></p>\n<h3 id=\"单位测试详解\"><a href=\"#单位测试详解\" class=\"headerlink\" title=\"单位测试详解\"></a>单位测试详解</h3><p>单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。</p>\n<p>每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">      - Yii2:</div><div class=\"line\">            part: [orm, email]</div></pre></td></tr></table></figure></p>\n<p>该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。</p>\n<p>通过访问测试用例中的$this-&gt;tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// insert records in database</div><div class=\"line\">$this-&gt;tester-&gt;haveRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class=\"line\">// check records in database</div><div class=\"line\">$this-&gt;tester-&gt;seeRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class=\"line\">// test email was sent</div><div class=\"line\">$this-&gt;tester-&gt;seeEmailIsSent();</div><div class=\"line\">// get a last sent emails</div><div class=\"line\">$this-&gt;tester-&gt;grabLastSentEmail();</div></pre></td></tr></table></figure></p>\n<p>如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// load fixtures</div><div class=\"line\">$this-&gt;tester-&gt;haveFixtures([</div><div class=\"line\">    &apos;user&apos; =&gt; [</div><div class=\"line\">        &apos;class&apos; =&gt; UserFixture::className(),</div><div class=\"line\">        // fixture data located in tests/_data/user.php</div><div class=\"line\">        &apos;dataFile&apos; =&gt; codecept_data_dir() . &apos;user.php&apos;</div><div class=\"line\">    ]</div><div class=\"line\">]);</div><div class=\"line\">// get first user from fixtures</div><div class=\"line\">$this-&gt;tester-&gt;grabFixture(&apos;user&apos;, 0);</div></pre></td></tr></table></figure></p>\n<p>如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。</p>\n<p><a href=\"http://codeception.com/docs/05-UnitTests\" target=\"_blank\" rel=\"noopener\">继续进行单元测试指南»</a></p>\n<h3 id=\"功能测试\"><a href=\"#功能测试\" class=\"headerlink\" title=\"功能测试\"></a>功能测试</h3><p>当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">$I-&gt;amOnPage([&apos;site/contact&apos;]);</div><div class=\"line\">$I-&gt;submitForm(&apos;#contact-form&apos;, []);</div><div class=\"line\">$I-&gt;expectTo(&apos;see validations errors&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Contact&apos;, &apos;h1&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Name cannot be blank&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Email cannot be blank&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Subject cannot be blank&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Body cannot be blank&apos;);</div></pre></td></tr></table></figure></p>\n<p>这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。</p>\n<p>功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：</p>\n<p>./vendor/bin/codecept g:cest functional MyNewScenarioCest<br> 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。</p>\n<p><a href=\"http://codeception.com/docs/04-FunctionalTests\" target=\"_blank\" rel=\"noopener\">继续进行功能测试指南»</a></p>\n<h3 id=\"验收测试\"><a href=\"#验收测试\" class=\"headerlink\" title=\"验收测试\"></a>验收测试</h3><p>从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。</p>\n<p>默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mv tests/acceptance.suite.yml.example tests/acceptance.suite.yml</div><div class=\"line\">基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。</div></pre></td></tr></table></figure></p>\n<p>那么您将需要在测试模式下启动应用服务器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./tests/bin/yii serve</div></pre></td></tr></table></figure></p>\n<p>并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"># config at tests/acceptance.yml</div><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">        - WebDriver:</div><div class=\"line\">            url: http://127.0.0.1:8080/</div><div class=\"line\">            browser: firefox</div><div class=\"line\">        - Yii2:</div><div class=\"line\">            part: [orm, fixtures] # allow to use AR methods</div><div class=\"line\">            cleanup: false # don&apos;t wrap test in transaction</div><div class=\"line\">            entryScript: index-test.php</div></pre></td></tr></table></figure></p>\n<p>正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。</p>\n<p>与功能测试类似，建议使用Cest格式进行验收测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./vendor/bin/codecept g:cest acceptance MyNewScenarioCest</div></pre></td></tr></table></figure></p>\n<p><a href=\"http://codeception.com/docs/03-AcceptanceTests\" target=\"_blank\" rel=\"noopener\">继续验收测试指南»</a></p>\n<h3 id=\"手动设置-amp-amp-配置\"><a href=\"#手动设置-amp-amp-配置\" class=\"headerlink\" title=\"手动设置&amp;&amp;配置\"></a>手动设置&amp;&amp;配置</h3><p>要开始，您需要通过Composer安装Codeception<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer require &quot;codeception/codeception&quot; --dev</div></pre></td></tr></table></figure></p>\n<p>创建基本的测试套件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./vendor/bin/codecept bootstrap</div></pre></td></tr></table></figure></p>\n<p>启用模块Yii2进行功能测试functional.suite.yml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># functional.suite.yml</div><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">        - Yii2:</div><div class=\"line\">            configFile: #insert path to config file</div></pre></td></tr></table></figure></p>\n<p>Yii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// config/test.php</div><div class=\"line\">$config =  yii\\helpers\\ArrayHelper::merge(</div><div class=\"line\">    require(__DIR__ . &apos;/main.php&apos;),</div><div class=\"line\">    require(__DIR__ . &apos;/main-local.php&apos;),</div><div class=\"line\">    [</div><div class=\"line\">        &apos;id&apos; =&gt; &apos;app-tests&apos;,</div><div class=\"line\">        &apos;components&apos; =&gt; [</div><div class=\"line\">            &apos;db&apos; =&gt; [</div><div class=\"line\">                &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yii_app_test&apos;,</div><div class=\"line\">            ]</div><div class=\"line\">        ]        </div><div class=\"line\">    ]</div><div class=\"line\">);</div><div class=\"line\">return $config;</div></pre></td></tr></table></figure></p>\n<p>测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。</p>\n<p>还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。</p>\n<p>一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。</p>\n<p>在基础和高级应用程序模板configFile中定义了全局配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># inside codeception.yml</div><div class=\"line\">modules:</div><div class=\"line\">    config:</div><div class=\"line\">        Yii2:</div><div class=\"line\">            configFile: &apos;config/test.php&apos;</div></pre></td></tr></table></figure></p>\n<p>这样我们不需要为每个定义的套件提供测试配置。</p>\n<h3 id=\"伪数据生成器\"><a href=\"#伪数据生成器\" class=\"headerlink\" title=\"伪数据生成器\"></a>伪数据生成器</h3><p>安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer require fzaninotto/faker</div></pre></td></tr></table></figure></p>\n<p>使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// require the Faker autoloader</div><div class=\"line\">require_once &apos;/path/to/Faker/src/autoload.php&apos;;</div><div class=\"line\">// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)</div><div class=\"line\"></div><div class=\"line\">// use the factory to create a Faker\\Generator instance</div><div class=\"line\">$faker = Faker\\Factory::create();</div><div class=\"line\"></div><div class=\"line\">// generate data by accessing properties</div><div class=\"line\">echo $faker-&gt;name;</div><div class=\"line\">  // &apos;Lucy Cechtelar&apos;;</div><div class=\"line\">echo $faker-&gt;address;</div><div class=\"line\">  // &quot;426 Jordy Lodge</div><div class=\"line\">  // Cartwrightshire, SC 88120-6700&quot;</div><div class=\"line\">echo $faker-&gt;text;</div><div class=\"line\">  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit</div><div class=\"line\">  // et sit et mollitia sed.</div><div class=\"line\">  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium</div><div class=\"line\">  // sit minima sint.</div></pre></td></tr></table></figure></p>\n","site":{"data":{}},"excerpt":"<h2 id=\"如何编写测试\"><a href=\"#如何编写测试\" class=\"headerlink\" title=\"如何编写测试\"></a>如何编写测试</h2><p>Yii2高级应用程序使用Codeception作为其主要测试框架。</p>\n<h3 id=\"搭建测试环境\"><a href=\"#搭建测试环境\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h3><p>为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/codeception=2.1.*\"</span></div><div class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/specify=*\"</span></div><div class=\"line\">composer <span class=\"keyword\">global</span> <span class=\"keyword\">require</span> <span class=\"string\">\"codeception/verify=*\"</span></div></pre></td></tr></table></figure></p>\n<p>创建测试目录<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codecept bootstrap</div></pre></td></tr></table></figure></p>\n<p>构建测试套件：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codecept build</div></pre></td></tr></table></figure></p>\n<p>如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./yii_test migrate</div></pre></td></tr></table></figure></p>","more":"<p>然后所有的样例测试可以通过运行如下代码：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">codecept run</div></pre></td></tr></table></figure></p>\n<p>docker环境下运行搭建并运行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept boostrap</div><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/./yii_test migrate</div><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept build</div><div class=\"line\">docker exec -it health_web_1 ./vendor/bin/codecept run</div></pre></td></tr></table></figure></p>\n<p>测试套件描述：</p>\n<ul>\n<li>unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。</li>\n<li>api ⇒ api接口测试(主要)。</li>\n<li>functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。</li>\n<li>acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。</li>\n</ul>\n<h2 id=\"启动测试\"><a href=\"#启动测试\" class=\"headerlink\" title=\"启动测试\"></a>启动测试</h2><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"> docker <span class=\"built_in\">exec</span> -it usercenter_web_1 bash</div><div class=\"line\">//或者</div><div class=\"line\"> docker <span class=\"built_in\">exec</span> -it health_web_1 /bin/sh</div><div class=\"line\">./vendor/bin/codecept run -c tests</div></pre></td></tr></table></figure>\n<p>-c 指定目录<br>api测试需要启动一个web服务器<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">php -S localhost:80 --docroot api/tests &amp;&gt;/dev/null&amp;</div></pre></td></tr></table></figure></p>\n<h2 id=\"搭建测试环境-1\"><a href=\"#搭建测试环境-1\" class=\"headerlink\" title=\"搭建测试环境\"></a>搭建测试环境</h2><p>目录结构</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">├── codeception</div><div class=\"line\">│   ├── api  //api测试</div><div class=\"line\">│   ├── api.suite.yml  //api测试配置</div><div class=\"line\">│   ├── _bootstrap.php</div><div class=\"line\">│   ├── _data</div><div class=\"line\">│   │   └── dump.sql  //初始化sql</div><div class=\"line\">│   ├── _output  //日志</div><div class=\"line\">│   ├── _support                                                    </div><div class=\"line\">│   ├── unit</div><div class=\"line\">│   │   ├── _bootstrap.php   //依赖文件</div><div class=\"line\">│   │   ├── models</div><div class=\"line\">│   │   │   ├── ActivityConfigTest.php  //单元测试</div><div class=\"line\">│   │   └── UnitTester.php</div><div class=\"line\">│   └── unit.suite.yml  //单元测试配置文件</div><div class=\"line\">├── codeception.yml</div><div class=\"line\">├── _envs</div><div class=\"line\">├── _output</div><div class=\"line\">└── _support</div><div class=\"line\">    └── _generated</div></pre></td></tr></table></figure>\n<p>在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件</p>\n<h3 id=\"api测试详解\"><a href=\"#api测试详解\" class=\"headerlink\" title=\"api测试详解\"></a>api测试详解</h3><p>API测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./vendor/bin/codecept g:suite api</div></pre></td></tr></table></figure></p>\n<p>您将需要启用REST，Yii2模块tests/api.suite.yml：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">class_name: ApiTester</div><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">        - REST:</div><div class=\"line\">            url: /api/v1</div><div class=\"line\">            depends: Yii2</div><div class=\"line\">        - \\ApiBundle\\Helper\\Api</div><div class=\"line\">    config:</div><div class=\"line\">        - Yii2</div></pre></td></tr></table></figure></p>\n<p>Yii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。</p>\n<p><a href=\"http://codeception.com/docs/10-WebServices#REST\" target=\"_blank\" rel=\"noopener\">继续执行REST API测试指南»</a></p>\n<h3 id=\"单位测试详解\"><a href=\"#单位测试详解\" class=\"headerlink\" title=\"单位测试详解\"></a>单位测试详解</h3><p>单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。</p>\n<p>每个测试用例扩展Codeception\\Test\\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：<br><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">      - Yii2:</div><div class=\"line\">            part: [orm, email]</div></pre></td></tr></table></figure></p>\n<p>该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。</p>\n<p>通过访问测试用例中的$this-&gt;tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// insert records in database</div><div class=\"line\">$this-&gt;tester-&gt;haveRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class=\"line\">// check records in database</div><div class=\"line\">$this-&gt;tester-&gt;seeRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class=\"line\">// test email was sent</div><div class=\"line\">$this-&gt;tester-&gt;seeEmailIsSent();</div><div class=\"line\">// get a last sent emails</div><div class=\"line\">$this-&gt;tester-&gt;grabLastSentEmail();</div></pre></td></tr></table></figure></p>\n<p>如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// load fixtures</div><div class=\"line\">$this-&gt;tester-&gt;haveFixtures([</div><div class=\"line\">    &apos;user&apos; =&gt; [</div><div class=\"line\">        &apos;class&apos; =&gt; UserFixture::className(),</div><div class=\"line\">        // fixture data located in tests/_data/user.php</div><div class=\"line\">        &apos;dataFile&apos; =&gt; codecept_data_dir() . &apos;user.php&apos;</div><div class=\"line\">    ]</div><div class=\"line\">]);</div><div class=\"line\">// get first user from fixtures</div><div class=\"line\">$this-&gt;tester-&gt;grabFixture(&apos;user&apos;, 0);</div></pre></td></tr></table></figure></p>\n<p>如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\\Test\\Unit而是写出你自己的单独的Helper类。</p>\n<p><a href=\"http://codeception.com/docs/05-UnitTests\" target=\"_blank\" rel=\"noopener\">继续进行单元测试指南»</a></p>\n<h3 id=\"功能测试\"><a href=\"#功能测试\" class=\"headerlink\" title=\"功能测试\"></a>功能测试</h3><p>当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">$I-&gt;amOnPage([&apos;site/contact&apos;]);</div><div class=\"line\">$I-&gt;submitForm(&apos;#contact-form&apos;, []);</div><div class=\"line\">$I-&gt;expectTo(&apos;see validations errors&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Contact&apos;, &apos;h1&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Name cannot be blank&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Email cannot be blank&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Subject cannot be blank&apos;);</div><div class=\"line\">$I-&gt;see(&apos;Body cannot be blank&apos;);</div></pre></td></tr></table></figure></p>\n<p>这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。</p>\n<p>功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：</p>\n<p>./vendor/bin/codecept g:cest functional MyNewScenarioCest<br> 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。</p>\n<p><a href=\"http://codeception.com/docs/04-FunctionalTests\" target=\"_blank\" rel=\"noopener\">继续进行功能测试指南»</a></p>\n<h3 id=\"验收测试\"><a href=\"#验收测试\" class=\"headerlink\" title=\"验收测试\"></a>验收测试</h3><p>从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。</p>\n<p>默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">mv tests/acceptance.suite.yml.example tests/acceptance.suite.yml</div><div class=\"line\">基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。</div></pre></td></tr></table></figure></p>\n<p>那么您将需要在测试模式下启动应用服务器：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./tests/bin/yii serve</div></pre></td></tr></table></figure></p>\n<p>并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"># config at tests/acceptance.yml</div><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">        - WebDriver:</div><div class=\"line\">            url: http://127.0.0.1:8080/</div><div class=\"line\">            browser: firefox</div><div class=\"line\">        - Yii2:</div><div class=\"line\">            part: [orm, fixtures] # allow to use AR methods</div><div class=\"line\">            cleanup: false # don&apos;t wrap test in transaction</div><div class=\"line\">            entryScript: index-test.php</div></pre></td></tr></table></figure></p>\n<p>正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。</p>\n<p>与功能测试类似，建议使用Cest格式进行验收测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./vendor/bin/codecept g:cest acceptance MyNewScenarioCest</div></pre></td></tr></table></figure></p>\n<p><a href=\"http://codeception.com/docs/03-AcceptanceTests\" target=\"_blank\" rel=\"noopener\">继续验收测试指南»</a></p>\n<h3 id=\"手动设置-amp-amp-配置\"><a href=\"#手动设置-amp-amp-配置\" class=\"headerlink\" title=\"手动设置&amp;&amp;配置\"></a>手动设置&amp;&amp;配置</h3><p>要开始，您需要通过Composer安装Codeception<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer require &quot;codeception/codeception&quot; --dev</div></pre></td></tr></table></figure></p>\n<p>创建基本的测试套件<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">./vendor/bin/codecept bootstrap</div></pre></td></tr></table></figure></p>\n<p>启用模块Yii2进行功能测试functional.suite.yml：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># functional.suite.yml</div><div class=\"line\">modules:</div><div class=\"line\">    enabled:</div><div class=\"line\">        - Yii2:</div><div class=\"line\">            configFile: #insert path to config file</div></pre></td></tr></table></figure></p>\n<p>Yii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// config/test.php</div><div class=\"line\">$config =  yii\\helpers\\ArrayHelper::merge(</div><div class=\"line\">    require(__DIR__ . &apos;/main.php&apos;),</div><div class=\"line\">    require(__DIR__ . &apos;/main-local.php&apos;),</div><div class=\"line\">    [</div><div class=\"line\">        &apos;id&apos; =&gt; &apos;app-tests&apos;,</div><div class=\"line\">        &apos;components&apos; =&gt; [</div><div class=\"line\">            &apos;db&apos; =&gt; [</div><div class=\"line\">                &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yii_app_test&apos;,</div><div class=\"line\">            ]</div><div class=\"line\">        ]        </div><div class=\"line\">    ]</div><div class=\"line\">);</div><div class=\"line\">return $config;</div></pre></td></tr></table></figure></p>\n<p>测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。</p>\n<p>还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。</p>\n<p>一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。</p>\n<p>在基础和高级应用程序模板configFile中定义了全局配置文件：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"># inside codeception.yml</div><div class=\"line\">modules:</div><div class=\"line\">    config:</div><div class=\"line\">        Yii2:</div><div class=\"line\">            configFile: &apos;config/test.php&apos;</div></pre></td></tr></table></figure></p>\n<p>这样我们不需要为每个定义的套件提供测试配置。</p>\n<h3 id=\"伪数据生成器\"><a href=\"#伪数据生成器\" class=\"headerlink\" title=\"伪数据生成器\"></a>伪数据生成器</h3><p>安装<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">composer require fzaninotto/faker</div></pre></td></tr></table></figure></p>\n<p>使用Faker\\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">&lt;?php</div><div class=\"line\">// require the Faker autoloader</div><div class=\"line\">require_once &apos;/path/to/Faker/src/autoload.php&apos;;</div><div class=\"line\">// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)</div><div class=\"line\"></div><div class=\"line\">// use the factory to create a Faker\\Generator instance</div><div class=\"line\">$faker = Faker\\Factory::create();</div><div class=\"line\"></div><div class=\"line\">// generate data by accessing properties</div><div class=\"line\">echo $faker-&gt;name;</div><div class=\"line\">  // &apos;Lucy Cechtelar&apos;;</div><div class=\"line\">echo $faker-&gt;address;</div><div class=\"line\">  // &quot;426 Jordy Lodge</div><div class=\"line\">  // Cartwrightshire, SC 88120-6700&quot;</div><div class=\"line\">echo $faker-&gt;text;</div><div class=\"line\">  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit</div><div class=\"line\">  // et sit et mollitia sed.</div><div class=\"line\">  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium</div><div class=\"line\">  // sit minima sint.</div></pre></td></tr></table></figure></p>"},{"title":"探索php中的变量zval结构体","date":"2017-06-18T15:03:30.000Z","_content":"## 变量的类型\nphp是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.\n注意这个php的版本是5.4,最新的php7结构体已经变更\nPHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：\n``` c\n\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc;\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n\n//在Zend/zend_types.h里定义的：\ntypedef unsigned int zend_uint;\ntypedef unsigned char zend_uchar;\n\n```\n\n<!--more-->\n保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：\n``` c\ntypedef union _zvalue_value {\n        long lval;                  /* long value */\n        double dval;                /* double value */\n        struct {\n                char *val;\n                int len;\n        } str;\n        HashTable *ht;              /* hash table value */\n        zend_object_value obj;\n} zvalue_value;\n\n```\n\n> PHP中常见的变量类型有：\n1. 整型/浮点/长整型/bool值 等等\n2. 字符串\n3. 数组/关联数组\n4. 对象\n5. 资源\n\n\nPHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:\n\n``` c\n      zval.type = IS_LONG;//整形\n      zval.type = IS_BOOL;//布尔值\n```\n\n就去取zval.value.lval,对于bool值来说lval∈(0|1);\n如果是双精度，或者float则会去取zval.value的dval。\n而如果是字符串，那么:\n\n``` c\n         zval.type = IS_STRING\n```\n\n这个时候，就会取:\n\n``` c \n         zval.value.str\n```\n\n而这个也是个结构，存有C分格的字符串和字符串的长度。\n而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj\n比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:\n\n``` c\n            type = IS_RESOURCE\n```\n## 变量类型的实现\n在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：\n\n| 常量名称： |  解释 |\n| :--------  |  :---:|\n| IS_NULL    | 第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。|\n| IS_BOOL    | 布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。|\n| IS_LONG    | PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。| \n| IS_DOUBLE  | PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011....。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333.....，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0. |\n| IS_STRING  | PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。|\n| IS_ARRAY   | 数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。\n| IS_OBJECT  | 和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！\n| IS_RESOURCE| 有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。\n\n\nzval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。\n如果要我们检测一个变量的类型\n``` c\nvoid describe_zval(zval *foo)\n{\n        if ( Z_TYPE_P(foo) == IS_NULL  )\n        {\n                    php_printf(\"这个变量的数据类型是： NULL\");\n                        \n        }\n        else\n        {\n                    php_printf(\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\", Z_TYPE_P(foo));\n                        \n        }\n\n}\n```\n\n以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。\n\n``` c\n//开始定义php语言中的函数gettype\nPHP_FUNCTION(gettype)\n{\n    //arg间接指向调用gettype函数时所传递的参数。是一个zval**结构\n    //所以我们要对他使用__PP后缀的宏。\n    zval **arg;\n\n    //这个if的操作主要是让arg指向参数～\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &arg) == FAILURE) {\n                return;\n    }\n                    \n    //调用Z_TYPE_PP宏来获取arg指向zval的类型。\n    //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值\n    switch (Z_TYPE_PP(arg)) {\n        case IS_NULL:\n            RETVAL_STRING(\"NULL\", 1);\n            break;\n        case IS_BOOL:\n            RETVAL_STRING(\"boolean\", 1);\n            break;\n        case IS_LONG:\n            RETVAL_STRING(\"integer\", 1);\n            break;\n        case IS_DOUBLE:\n            RETVAL_STRING(\"double\", 1);\n            break;\n        case IS_STRING:\n            RETVAL_STRING(\"string\", 1);\n            break;\n        case IS_ARRAY:\n            RETVAL_STRING(\"array\", 1);\n            break;\n        case IS_OBJECT:\n            RETVAL_STRING(\"object\", 1);\n            break;\n        case IS_RESOURCE:\n        {\n            char *type_name;\n            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);\n            if (type_name) {\n                RETVAL_STRING(\"resource\", 1);\n                break;\n            }\n        }\n        default:\n                    RETVAL_STRING(\"unknown type\", 1);\n    }\n}       \n```\n以上三个宏的定义在Zend/zend_operators.h里，定义分别是：\n\n#define Z_TYPE(zval)        (zval).type\n#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)\n#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)\n\n## 变量值的实现\nPHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.\n内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:\n``` c\nvoid display_value(zval zv,zval *zv_p,zval **zv_pp)\n{\n    if( Z_TYPE(zv) == IS_NULL)\n    {\n                php_printf(\"类型是 IS_NULL!\\n\");\n    }\n    if( Z_TYPE_P(zv_p) == IS_LONG)\n    {\n                php_printf(\"类型是 IS_LONG，值是：%ld\" , Z_LVAL_P(zv_p));\n    }\n    if(Z_TYPE_PP(zv_pp) == IS_DOUBLE)\n    {\n                php_printf(\"类型是 IS_DOUBLE,值是：%f\" , Z_DVAL_PP(zv_pp) );\n    }\n}   \n```\nstring型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。\n``` c\nvoid display_string(zval *zstr)\n{\n    if (Z_TYPE_P(zstr) != IS_STRING) {\n        php_printf(\"这个变量不是字符串!\\n\");\n        return;\n    }\n    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));\n    //这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。\n}       \n ```       \nArray型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。\n对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。\n资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。\n有关值操作的宏都定义在./Zend/zend_operators.h文件里：\n``` c\n//操作整数的\n#define Z_LVAL(zval)            (zval).value.lval\n#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)\n#define Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)\n\n//操作IS_BOOL布尔型的\n#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)\n#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)\n#define Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)\n\n//操作浮点数的\n#define Z_DVAL(zval)            (zval).value.dval\n#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)\n#define Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)\n\n//操作字符串的值和长度的\n#define Z_STRVAL(zval)          (zval).value.str.val\n#define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)\n#define Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)\n\n#define Z_STRLEN(zval)          (zval).value.str.len\n#define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)\n#define Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)\n\n#define Z_ARRVAL(zval)          (zval).value.ht\n#define Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)\n#define Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)\n\n//操作对象的\n#define Z_OBJVAL(zval)          (zval).value.obj\n#define Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)\n#define Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)\n\n#define Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle\n#define Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)\n#define Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)\n\n#define Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers\n#define Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)\n#define Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)\n\n#define Z_OBJCE(zval)           zend_get_class_entry(&(zval) TSRMLS_CC)\n#define Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)\n#define Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)\n\n#define Z_OBJPROP(zval)         Z_OBJ_HT((zval))->get_properties(&(zval) TSRMLS_CC)\n#define Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)\n#define Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)\n\n#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))->hf\n#define Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)\n#define Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)\n\n#define Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\\n                        Z_OBJ_HANDLER((zval),get_debug_info)(&(zval),&is_tmp TSRMLS_CC): \\\n                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) \n#define Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) \n#define Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)\n\n//操作资源的\n#define Z_RESVAL(zval)          (zval).value.lval\n#define Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)\n#define Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)\n```     \n## php的类型转换\nphp内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()\n``` c\n//将任意类型的zval转换成字符串\nvoid change_zval_to_string(zval *value)\n{\n        convert_to_string(value);\n}\n\n//其它基本的类型转换函数\nZEND_API void convert_to_long(zval *op);\nZEND_API void convert_to_double(zval *op);\nZEND_API void convert_to_null(zval *op);\nZEND_API void convert_to_boolean(zval *op);\nZEND_API void convert_to_array(zval *op);\nZEND_API void convert_to_object(zval *op);\n\nZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);\n#define convert_to_string(op) if ((op)->type != IS_STRING) { _convert_to_string((op) ZEND_FILE_LINE_CC);  }\n```\n这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。\n注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。\n\n\n\n","source":"_posts/探索php中的变量zval结构体.md","raw":"---\ntitle: 探索php中的变量zval结构体\ndate: 2017-06-18 23:03:30\ntags: php php扩展 c\ncategories: 技术\n\n---\n## 变量的类型\nphp是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.\n注意这个php的版本是5.4,最新的php7结构体已经变更\nPHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：\n``` c\n\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc;\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n\n//在Zend/zend_types.h里定义的：\ntypedef unsigned int zend_uint;\ntypedef unsigned char zend_uchar;\n\n```\n\n<!--more-->\n保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：\n``` c\ntypedef union _zvalue_value {\n        long lval;                  /* long value */\n        double dval;                /* double value */\n        struct {\n                char *val;\n                int len;\n        } str;\n        HashTable *ht;              /* hash table value */\n        zend_object_value obj;\n} zvalue_value;\n\n```\n\n> PHP中常见的变量类型有：\n1. 整型/浮点/长整型/bool值 等等\n2. 字符串\n3. 数组/关联数组\n4. 对象\n5. 资源\n\n\nPHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:\n\n``` c\n      zval.type = IS_LONG;//整形\n      zval.type = IS_BOOL;//布尔值\n```\n\n就去取zval.value.lval,对于bool值来说lval∈(0|1);\n如果是双精度，或者float则会去取zval.value的dval。\n而如果是字符串，那么:\n\n``` c\n         zval.type = IS_STRING\n```\n\n这个时候，就会取:\n\n``` c \n         zval.value.str\n```\n\n而这个也是个结构，存有C分格的字符串和字符串的长度。\n而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj\n比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:\n\n``` c\n            type = IS_RESOURCE\n```\n## 变量类型的实现\n在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：\n\n| 常量名称： |  解释 |\n| :--------  |  :---:|\n| IS_NULL    | 第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。|\n| IS_BOOL    | 布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。|\n| IS_LONG    | PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。| \n| IS_DOUBLE  | PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011....。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333.....，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0. |\n| IS_STRING  | PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。|\n| IS_ARRAY   | 数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。\n| IS_OBJECT  | 和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！\n| IS_RESOURCE| 有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。\n\n\nzval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。\n如果要我们检测一个变量的类型\n``` c\nvoid describe_zval(zval *foo)\n{\n        if ( Z_TYPE_P(foo) == IS_NULL  )\n        {\n                    php_printf(\"这个变量的数据类型是： NULL\");\n                        \n        }\n        else\n        {\n                    php_printf(\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\", Z_TYPE_P(foo));\n                        \n        }\n\n}\n```\n\n以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。\n\n``` c\n//开始定义php语言中的函数gettype\nPHP_FUNCTION(gettype)\n{\n    //arg间接指向调用gettype函数时所传递的参数。是一个zval**结构\n    //所以我们要对他使用__PP后缀的宏。\n    zval **arg;\n\n    //这个if的操作主要是让arg指向参数～\n    if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, \"Z\", &arg) == FAILURE) {\n                return;\n    }\n                    \n    //调用Z_TYPE_PP宏来获取arg指向zval的类型。\n    //然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值\n    switch (Z_TYPE_PP(arg)) {\n        case IS_NULL:\n            RETVAL_STRING(\"NULL\", 1);\n            break;\n        case IS_BOOL:\n            RETVAL_STRING(\"boolean\", 1);\n            break;\n        case IS_LONG:\n            RETVAL_STRING(\"integer\", 1);\n            break;\n        case IS_DOUBLE:\n            RETVAL_STRING(\"double\", 1);\n            break;\n        case IS_STRING:\n            RETVAL_STRING(\"string\", 1);\n            break;\n        case IS_ARRAY:\n            RETVAL_STRING(\"array\", 1);\n            break;\n        case IS_OBJECT:\n            RETVAL_STRING(\"object\", 1);\n            break;\n        case IS_RESOURCE:\n        {\n            char *type_name;\n            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);\n            if (type_name) {\n                RETVAL_STRING(\"resource\", 1);\n                break;\n            }\n        }\n        default:\n                    RETVAL_STRING(\"unknown type\", 1);\n    }\n}       \n```\n以上三个宏的定义在Zend/zend_operators.h里，定义分别是：\n\n#define Z_TYPE(zval)        (zval).type\n#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)\n#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)\n\n## 变量值的实现\nPHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.\n内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:\n``` c\nvoid display_value(zval zv,zval *zv_p,zval **zv_pp)\n{\n    if( Z_TYPE(zv) == IS_NULL)\n    {\n                php_printf(\"类型是 IS_NULL!\\n\");\n    }\n    if( Z_TYPE_P(zv_p) == IS_LONG)\n    {\n                php_printf(\"类型是 IS_LONG，值是：%ld\" , Z_LVAL_P(zv_p));\n    }\n    if(Z_TYPE_PP(zv_pp) == IS_DOUBLE)\n    {\n                php_printf(\"类型是 IS_DOUBLE,值是：%f\" , Z_DVAL_PP(zv_pp) );\n    }\n}   \n```\nstring型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。\n``` c\nvoid display_string(zval *zstr)\n{\n    if (Z_TYPE_P(zstr) != IS_STRING) {\n        php_printf(\"这个变量不是字符串!\\n\");\n        return;\n    }\n    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));\n    //这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。\n}       \n ```       \nArray型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。\n对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。\n资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。\n有关值操作的宏都定义在./Zend/zend_operators.h文件里：\n``` c\n//操作整数的\n#define Z_LVAL(zval)            (zval).value.lval\n#define Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)\n#define Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)\n\n//操作IS_BOOL布尔型的\n#define Z_BVAL(zval)            ((zend_bool)(zval).value.lval)\n#define Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)\n#define Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)\n\n//操作浮点数的\n#define Z_DVAL(zval)            (zval).value.dval\n#define Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)\n#define Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)\n\n//操作字符串的值和长度的\n#define Z_STRVAL(zval)          (zval).value.str.val\n#define Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)\n#define Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)\n\n#define Z_STRLEN(zval)          (zval).value.str.len\n#define Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)\n#define Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)\n\n#define Z_ARRVAL(zval)          (zval).value.ht\n#define Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)\n#define Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)\n\n//操作对象的\n#define Z_OBJVAL(zval)          (zval).value.obj\n#define Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)\n#define Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)\n\n#define Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle\n#define Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)\n#define Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)\n\n#define Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers\n#define Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)\n#define Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)\n\n#define Z_OBJCE(zval)           zend_get_class_entry(&(zval) TSRMLS_CC)\n#define Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)\n#define Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)\n\n#define Z_OBJPROP(zval)         Z_OBJ_HT((zval))->get_properties(&(zval) TSRMLS_CC)\n#define Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)\n#define Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)\n\n#define Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))->hf\n#define Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)\n#define Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)\n\n#define Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\\n                        Z_OBJ_HANDLER((zval),get_debug_info)(&(zval),&is_tmp TSRMLS_CC): \\\n                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) \n#define Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) \n#define Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)\n\n//操作资源的\n#define Z_RESVAL(zval)          (zval).value.lval\n#define Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)\n#define Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)\n```     \n## php的类型转换\nphp内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()\n``` c\n//将任意类型的zval转换成字符串\nvoid change_zval_to_string(zval *value)\n{\n        convert_to_string(value);\n}\n\n//其它基本的类型转换函数\nZEND_API void convert_to_long(zval *op);\nZEND_API void convert_to_double(zval *op);\nZEND_API void convert_to_null(zval *op);\nZEND_API void convert_to_boolean(zval *op);\nZEND_API void convert_to_array(zval *op);\nZEND_API void convert_to_object(zval *op);\n\nZEND_API void _convert_to_string(zval *op ZEND_FILE_LINE_DC);\n#define convert_to_string(op) if ((op)->type != IS_STRING) { _convert_to_string((op) ZEND_FILE_LINE_CC);  }\n```\n这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。\n注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。\n\n\n\n","slug":"探索php中的变量zval结构体","published":1,"updated":"2017-12-10T12:38:46.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q2z001fto7yzb1rzc0c","content":"<h2 id=\"变量的类型\"><a href=\"#变量的类型\" class=\"headerlink\" title=\"变量的类型\"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</div><div class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></div><div class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></div><div class=\"line\">        zend_uint refcount__gc;</div><div class=\"line\">        zend_uchar is_ref__gc;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在Zend/zend_types.h里定义的：</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> zend_uint;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> zend_uchar;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zvalue_value &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> lval;                  <span class=\"comment\">/* long value */</span></div><div class=\"line\">        <span class=\"keyword\">double</span> dval;                <span class=\"comment\">/* double value */</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> *val;</div><div class=\"line\">                <span class=\"keyword\">int</span> len;</div><div class=\"line\">        &#125; str;</div><div class=\"line\">        HashTable *ht;              <span class=\"comment\">/* hash table value */</span></div><div class=\"line\">        zend_object_value obj;</div><div class=\"line\">&#125; zvalue_value;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>PHP中常见的变量类型有：</p>\n<ol>\n<li>整型/浮点/长整型/bool值 等等</li>\n<li>字符串</li>\n<li>数组/关联数组</li>\n<li>对象</li>\n<li>资源</li>\n</ol>\n</blockquote>\n<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval.type = IS_LONG;<span class=\"comment\">//整形</span></div><div class=\"line\">zval.type = IS_BOOL;<span class=\"comment\">//布尔值</span></div></pre></td></tr></table></figure>\n<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval.type = IS_STRING</div></pre></td></tr></table></figure>\n<p>这个时候，就会取:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval.value.str</div></pre></td></tr></table></figure>\n<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">type = IS_RESOURCE</div></pre></td></tr></table></figure>\n<h2 id=\"变量类型的实现\"><a href=\"#变量类型的实现\" class=\"headerlink\" title=\"变量类型的实现\"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常量名称：</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IS_NULL</td>\n<td style=\"text-align:center\">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_BOOL</td>\n<td style=\"text-align:center\">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_LONG</td>\n<td style=\"text-align:center\">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_DOUBLE</td>\n<td style=\"text-align:center\">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_STRING</td>\n<td style=\"text-align:center\">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_ARRAY</td>\n<td style=\"text-align:center\">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_OBJECT</td>\n<td style=\"text-align:center\">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_RESOURCE</td>\n<td style=\"text-align:center\">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>\n</tr>\n</tbody>\n</table>\n<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">describe_zval</span><span class=\"params\">(zval *foo)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</div><div class=\"line\">        &#123;</div><div class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型是： NULL\"</span>);</div><div class=\"line\">                        </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\"</span>, Z_TYPE_P(foo));</div><div class=\"line\">                        </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以一个P结尾的宏的参数大多是<em>zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*</em>zval。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//开始定义php语言中的函数gettype</span></div><div class=\"line\">PHP_FUNCTION(gettype)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></div><div class=\"line\">    <span class=\"comment\">//所以我们要对他使用__PP后缀的宏。</span></div><div class=\"line\">    zval **arg;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//这个if的操作主要是让arg指向参数～</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class=\"string\">\"Z\"</span>, &amp;arg) == FAILURE) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">                    </div><div class=\"line\">    <span class=\"comment\">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></div><div class=\"line\">    <span class=\"comment\">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (Z_TYPE_PP(arg)) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_NULL:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"NULL\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_BOOL:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"boolean\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_LONG:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"integer\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_DOUBLE:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"double\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_STRING:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"string\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_ARRAY:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"array\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_OBJECT:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"object\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_RESOURCE:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> *type_name;</div><div class=\"line\">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</div><div class=\"line\">            <span class=\"keyword\">if</span> (type_name) &#123;</div><div class=\"line\">                RETVAL_STRING(<span class=\"string\">\"resource\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">                    RETVAL_STRING(<span class=\"string\">\"unknown type\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>\n<p>#define Z_TYPE(zval)        (zval).type</p>\n<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>\n<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>\n<h2 id=\"变量值的实现\"><a href=\"#变量值的实现\" class=\"headerlink\" title=\"变量值的实现\"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_value</span><span class=\"params\">(zval zv,zval *zv_p,zval **zv_pp)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE(zv) == IS_NULL)</div><div class=\"line\">    &#123;</div><div class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_NULL!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</div><div class=\"line\">    &#123;</div><div class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_LONG，值是：%ld\"</span> , Z_LVAL_P(zv_p));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</div><div class=\"line\">    &#123;</div><div class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_DOUBLE,值是：%f\"</span> , Z_DVAL_PP(zv_pp) );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_string</span><span class=\"params\">(zval *zstr)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</div><div class=\"line\">        php_printf(<span class=\"string\">\"这个变量不是字符串!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</div><div class=\"line\">    <span class=\"comment\">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></div><div class=\"line\">&#125;       </div><div class=\"line\"> ```       </div><div class=\"line\">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</div><div class=\"line\">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</div><div class=\"line\">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</div><div class=\"line\">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</div><div class=\"line\">``` c</div><div class=\"line\"><span class=\"comment\">//操作整数的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL(zval)            (zval).value.lval</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作IS_BOOL布尔型的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作浮点数的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL(zval)            (zval).value.dval</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作字符串的值和长度的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作对象的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\</span></div><div class=\"line\">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \\</div><div class=\"line\">                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) </div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作资源的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL(zval)          (zval).value.lval</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></div><div class=\"line\">```     </div><div class=\"line\">#<span class=\"meta\"># php的类型转换</span></div><div class=\"line\">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</div><div class=\"line\">``` c</div><div class=\"line\"><span class=\"comment\">//将任意类型的zval转换成字符串</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_zval_to_string</span><span class=\"params\">(zval *value)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        convert_to_string(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//其它基本的类型转换函数</span></div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_long</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_double</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_null</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_boolean</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_array</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_object</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"></div><div class=\"line\">ZEND_API <span class=\"keyword\">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> convert_to_string(op) <span class=\"meta-keyword\">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></div></pre></td></tr></table></figure></p>\n<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"变量的类型\"><a href=\"#变量的类型\" class=\"headerlink\" title=\"变量的类型\"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</div><div class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></div><div class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></div><div class=\"line\">        zend_uint refcount__gc;</div><div class=\"line\">        zend_uchar is_ref__gc;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//在Zend/zend_types.h里定义的：</span></div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">int</span> zend_uint;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">unsigned</span> <span class=\"keyword\">char</span> zend_uchar;</div></pre></td></tr></table></figure></p>","more":"<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">union</span> _zvalue_value &#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> lval;                  <span class=\"comment\">/* long value */</span></div><div class=\"line\">        <span class=\"keyword\">double</span> dval;                <span class=\"comment\">/* double value */</span></div><div class=\"line\">        <span class=\"keyword\">struct</span> &#123;</div><div class=\"line\">                <span class=\"keyword\">char</span> *val;</div><div class=\"line\">                <span class=\"keyword\">int</span> len;</div><div class=\"line\">        &#125; str;</div><div class=\"line\">        HashTable *ht;              <span class=\"comment\">/* hash table value */</span></div><div class=\"line\">        zend_object_value obj;</div><div class=\"line\">&#125; zvalue_value;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>PHP中常见的变量类型有：</p>\n<ol>\n<li>整型/浮点/长整型/bool值 等等</li>\n<li>字符串</li>\n<li>数组/关联数组</li>\n<li>对象</li>\n<li>资源</li>\n</ol>\n</blockquote>\n<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval.type = IS_LONG;<span class=\"comment\">//整形</span></div><div class=\"line\">zval.type = IS_BOOL;<span class=\"comment\">//布尔值</span></div></pre></td></tr></table></figure>\n<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval.type = IS_STRING</div></pre></td></tr></table></figure>\n<p>这个时候，就会取:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval.value.str</div></pre></td></tr></table></figure>\n<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">type = IS_RESOURCE</div></pre></td></tr></table></figure>\n<h2 id=\"变量类型的实现\"><a href=\"#变量类型的实现\" class=\"headerlink\" title=\"变量类型的实现\"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">常量名称：</th>\n<th style=\"text-align:center\">解释</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">IS_NULL</td>\n<td style=\"text-align:center\">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_BOOL</td>\n<td style=\"text-align:center\">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_LONG</td>\n<td style=\"text-align:center\">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_DOUBLE</td>\n<td style=\"text-align:center\">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_STRING</td>\n<td style=\"text-align:center\">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_ARRAY</td>\n<td style=\"text-align:center\">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_OBJECT</td>\n<td style=\"text-align:center\">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">IS_RESOURCE</td>\n<td style=\"text-align:center\">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>\n</tr>\n</tbody>\n</table>\n<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">describe_zval</span><span class=\"params\">(zval *foo)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</div><div class=\"line\">        &#123;</div><div class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型是： NULL\"</span>);</div><div class=\"line\">                        </div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">else</span></div><div class=\"line\">        &#123;</div><div class=\"line\">                    php_printf(<span class=\"string\">\"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d\"</span>, Z_TYPE_P(foo));</div><div class=\"line\">                        </div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>以一个P结尾的宏的参数大多是<em>zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*</em>zval。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//开始定义php语言中的函数gettype</span></div><div class=\"line\">PHP_FUNCTION(gettype)</div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"comment\">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></div><div class=\"line\">    <span class=\"comment\">//所以我们要对他使用__PP后缀的宏。</span></div><div class=\"line\">    zval **arg;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//这个if的操作主要是让arg指向参数～</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class=\"string\">\"Z\"</span>, &amp;arg) == FAILURE) &#123;</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">                    </div><div class=\"line\">    <span class=\"comment\">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></div><div class=\"line\">    <span class=\"comment\">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></div><div class=\"line\">    <span class=\"keyword\">switch</span> (Z_TYPE_PP(arg)) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_NULL:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"NULL\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_BOOL:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"boolean\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_LONG:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"integer\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_DOUBLE:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"double\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_STRING:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"string\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_ARRAY:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"array\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_OBJECT:</div><div class=\"line\">            RETVAL_STRING(<span class=\"string\">\"object\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> IS_RESOURCE:</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"keyword\">char</span> *type_name;</div><div class=\"line\">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</div><div class=\"line\">            <span class=\"keyword\">if</span> (type_name) &#123;</div><div class=\"line\">                RETVAL_STRING(<span class=\"string\">\"resource\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">default</span>:</div><div class=\"line\">                    RETVAL_STRING(<span class=\"string\">\"unknown type\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>\n<p>#define Z_TYPE(zval)        (zval).type</p>\n<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>\n<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>\n<h2 id=\"变量值的实现\"><a href=\"#变量值的实现\" class=\"headerlink\" title=\"变量值的实现\"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_value</span><span class=\"params\">(zval zv,zval *zv_p,zval **zv_pp)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE(zv) == IS_NULL)</div><div class=\"line\">    &#123;</div><div class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_NULL!\\n\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</div><div class=\"line\">    &#123;</div><div class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_LONG，值是：%ld\"</span> , Z_LVAL_P(zv_p));</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</div><div class=\"line\">    &#123;</div><div class=\"line\">                php_printf(<span class=\"string\">\"类型是 IS_DOUBLE,值是：%f\"</span> , Z_DVAL_PP(zv_pp) );</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div><div class=\"line\">91</div><div class=\"line\">92</div><div class=\"line\">93</div><div class=\"line\">94</div><div class=\"line\">95</div><div class=\"line\">96</div><div class=\"line\">97</div><div class=\"line\">98</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display_string</span><span class=\"params\">(zval *zstr)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">    <span class=\"keyword\">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</div><div class=\"line\">        php_printf(<span class=\"string\">\"这个变量不是字符串!\\n\"</span>);</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</div><div class=\"line\">    <span class=\"comment\">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></div><div class=\"line\">&#125;       </div><div class=\"line\"> ```       </div><div class=\"line\">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</div><div class=\"line\">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</div><div class=\"line\">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</div><div class=\"line\">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</div><div class=\"line\">``` c</div><div class=\"line\"><span class=\"comment\">//操作整数的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL(zval)            (zval).value.lval</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作IS_BOOL布尔型的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作浮点数的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL(zval)            (zval).value.dval</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作字符串的值和长度的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作对象的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \\</span></div><div class=\"line\">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \\</div><div class=\"line\">                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) </div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//操作资源的</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL(zval)          (zval).value.lval</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></div><div class=\"line\">```     </div><div class=\"line\">#<span class=\"meta\"># php的类型转换</span></div><div class=\"line\">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</div><div class=\"line\">``` c</div><div class=\"line\"><span class=\"comment\">//将任意类型的zval转换成字符串</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">change_zval_to_string</span><span class=\"params\">(zval *value)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        convert_to_string(value);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//其它基本的类型转换函数</span></div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_long</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_double</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_null</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_boolean</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_array</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"><span class=\"function\">ZEND_API <span class=\"keyword\">void</span> <span class=\"title\">convert_to_object</span><span class=\"params\">(zval *op)</span></span>;</div><div class=\"line\"></div><div class=\"line\">ZEND_API <span class=\"keyword\">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> convert_to_string(op) <span class=\"meta-keyword\">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></div></pre></td></tr></table></figure></p>\n<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>"},{"title":"探索php中的变量zval结构体二","date":"2017-06-20T09:04:13.000Z","_content":"上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:\n       ` zend_uint refcount__gc `\n       ` zend_uchar is_ref__gc `\n``` c\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc; /*  */\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n```\nphp中的引用计数\n先看例子\n\n``` php\n<?php\n$a = 'Hello World';\n$b = $a;\nunset($a);      \n```\n\n<!--more-->\nPHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？\n这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：\n\n``` c\n    zval *helloval;\n    MAKE_STD_ZVAL(helloval);\n    ZVAL_STRING(helloval, \"Hello World\", 1);\n    zend_hash_add(EG(active_symbol_table), \"a\", sizeof(\"a\"),&helloval, sizeof(zval*), NULL);\n    ZVAL_ADDREF(helloval); //这句很特殊，我们显式的增加了helloval结构体的refcount\n    zend_hash_add(EG(active_symbol_table), \"b\", sizeof(\"b\"),&helloval, sizeof(zval*), NULL)\n```\n这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！\n引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？\n\n``` php\n    $a = 1;\n    $b = $a;\n    $b += 5;\n```\n从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。\n\n``` c\nzval *get_var_and_separate(char *varname, int varname_len TSRMLS_DC)\n{\n        zval **varval, *varcopy;\n        if (zend_hash_find(EG(active_symbol_table),varname, varname_len + 1, (void**)&varval) == FAILURE)\n        {\n            /* 如果在符号表里找不到这个变量则直接return */\n            return NULL;\n        }\n\n        if ((*varval)->refcount < 2)\n        {   \n        //如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return\n        return *varval;\n        }\n            \n        /* 否则，复制一份zval*的值 */\n        MAKE_STD_ZVAL(varcopy);\n        varcopy = *varval;\n            \n        /* 复制任何在zval*内已分配的结构*/\n        zval_copy_ctor(varcopy);\n\n        /* 从符号表中删除原来的变量\n         * 这将减少该过程中varval的refcount的值\n         */\n        zend_hash_del(EG(active_symbol_table), varname, varname_len + 1);\n\n        /* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/\n        varcopy->refcount = 1;\n        varcopy->is_ref = 0;\n        zend_hash_add(EG(active_symbol_table), varname, varname_len + 1,&varcopy, sizeof(zval*), NULL);\n            \n        /* 返回新zval的地址 */\n        return varcopy;\n}  \n```\n\n现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。\nChange on Write\n\n如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？\n\n``` php\n    $a = 1;\n    $b = &$a;\n    $b += 5;        \n```\n\n作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：\n``` c\n    /* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/\n    if ((*varval)->is_ref || (*varval)->refcount < 2) {\n            return *varval;\n    }       \n\n```\n\n这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。\nSeparation Anxiety\n\n我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：\n\n``` php\n    $a = 1;\n    $b = $a;\n    $c = &$a;       \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref1.jpg)\n这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】\n\n\n\n同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！\n``` php\n    //上图对应的代码\n    $a = 1;\n    $b = &$a;\n    $c = $a;        \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref2.jpg)\n\n需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/探索php中的变量zval结构体二.md","raw":"---\ntitle: 探索php中的变量zval结构体二\ndate: 2017-06-20 17:04:13\ntags: php php扩展 c\ncategories: 技术\n\n---\n上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:\n       ` zend_uint refcount__gc `\n       ` zend_uchar is_ref__gc `\n``` c\nstruct _zval_struct {\n        zvalue_value value; /* 变量的值 */\n        zend_uchar type;    /* 变量当前的数据类型 */\n        zend_uint refcount__gc; /*  */\n        zend_uchar is_ref__gc;\n};\ntypedef struct _zval_struct zval;\n```\nphp中的引用计数\n先看例子\n\n``` php\n<?php\n$a = 'Hello World';\n$b = $a;\nunset($a);      \n```\n\n<!--more-->\nPHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？\n这里我们主要讲解refcount__gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount__gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：\n\n``` c\n    zval *helloval;\n    MAKE_STD_ZVAL(helloval);\n    ZVAL_STRING(helloval, \"Hello World\", 1);\n    zend_hash_add(EG(active_symbol_table), \"a\", sizeof(\"a\"),&helloval, sizeof(zval*), NULL);\n    ZVAL_ADDREF(helloval); //这句很特殊，我们显式的增加了helloval结构体的refcount\n    zend_hash_add(EG(active_symbol_table), \"b\", sizeof(\"b\"),&helloval, sizeof(zval*), NULL)\n```\n这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！\n引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？\n\n``` php\n    $a = 1;\n    $b = $a;\n    $b += 5;\n```\n从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。\n\n``` c\nzval *get_var_and_separate(char *varname, int varname_len TSRMLS_DC)\n{\n        zval **varval, *varcopy;\n        if (zend_hash_find(EG(active_symbol_table),varname, varname_len + 1, (void**)&varval) == FAILURE)\n        {\n            /* 如果在符号表里找不到这个变量则直接return */\n            return NULL;\n        }\n\n        if ((*varval)->refcount < 2)\n        {   \n        //如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return\n        return *varval;\n        }\n            \n        /* 否则，复制一份zval*的值 */\n        MAKE_STD_ZVAL(varcopy);\n        varcopy = *varval;\n            \n        /* 复制任何在zval*内已分配的结构*/\n        zval_copy_ctor(varcopy);\n\n        /* 从符号表中删除原来的变量\n         * 这将减少该过程中varval的refcount的值\n         */\n        zend_hash_del(EG(active_symbol_table), varname, varname_len + 1);\n\n        /* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/\n        varcopy->refcount = 1;\n        varcopy->is_ref = 0;\n        zend_hash_add(EG(active_symbol_table), varname, varname_len + 1,&varcopy, sizeof(zval*), NULL);\n            \n        /* 返回新zval的地址 */\n        return varcopy;\n}  \n```\n\n现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。\nChange on Write\n\n如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？\n\n``` php\n    $a = 1;\n    $b = &$a;\n    $b += 5;        \n```\n\n作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref__gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount__gc等于1，is_ref__gc等于0;。 当第二条语句执行后($b = &$a;)，refcount__gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：\n``` c\n    /* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/\n    if ((*varval)->is_ref || (*varval)->refcount < 2) {\n            return *varval;\n    }       \n\n```\n\n这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。\nSeparation Anxiety\n\n我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：\n\n``` php\n    $a = 1;\n    $b = $a;\n    $c = &$a;       \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref1.jpg)\n这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref__gc和refcount__gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】\n\n\n\n同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！\n``` php\n    //上图对应的代码\n    $a = 1;\n    $b = &$a;\n    $c = $a;        \n```\n ![\"我是傲娇的效果图\"](/assets/blogImg/is_ref2.jpg)\n\n需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。\n\n\n\n\n\n\n\n\n\n\n\n","slug":"探索php中的变量zval结构体二","published":1,"updated":"2017-12-10T12:38:46.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q35001jto7yj7rflc2d","content":"<p>上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:<br>       <code>zend_uint refcount__gc</code><br>       <code>zend_uchar is_ref__gc</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</div><div class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></div><div class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></div><div class=\"line\">        zend_uint refcount__gc; <span class=\"comment\">/*  */</span></div><div class=\"line\">        zend_uchar is_ref__gc;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</div></pre></td></tr></table></figure></p>\n<p>php中的引用计数<br>先看例子</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$a = <span class=\"string\">'Hello World'</span>;</div><div class=\"line\">$b = $a;</div><div class=\"line\"><span class=\"keyword\">unset</span>($a);</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<p>PHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br>这里我们主要讲解refcount<strong>gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount</strong>gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval *helloval;</div><div class=\"line\">MAKE_STD_ZVAL(helloval);</div><div class=\"line\">ZVAL_STRING(helloval, <span class=\"string\">\"Hello World\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"a\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"a\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</div><div class=\"line\">ZVAL_ADDREF(helloval); <span class=\"comment\">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></div><div class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"b\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"b\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>)</div></pre></td></tr></table></figure>\n<p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！<br>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = $a;</div><div class=\"line\">$b += <span class=\"number\">5</span>;</div></pre></td></tr></table></figure>\n<p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">zval *<span class=\"title\">get_var_and_separate</span><span class=\"params\">(<span class=\"keyword\">char</span> *varname, <span class=\"keyword\">int</span> varname_len TSRMLS_DC)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        zval **varval, *varcopy;</div><div class=\"line\">        <span class=\"keyword\">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class=\"number\">1</span>, (<span class=\"keyword\">void</span>**)&amp;varval) == FAILURE)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">/* 如果在符号表里找不到这个变量则直接return */</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((*varval)-&gt;refcount &lt; <span class=\"number\">2</span>)</div><div class=\"line\">        &#123;   </div><div class=\"line\">        <span class=\"comment\">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></div><div class=\"line\">        <span class=\"keyword\">return</span> *varval;</div><div class=\"line\">        &#125;</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">/* 否则，复制一份zval*的值 */</span></div><div class=\"line\">        MAKE_STD_ZVAL(varcopy);</div><div class=\"line\">        varcopy = *varval;</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">/* 复制任何在zval*内已分配的结构*/</span></div><div class=\"line\">        zval_copy_ctor(varcopy);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/* 从符号表中删除原来的变量</span></div><div class=\"line\">         * 这将减少该过程中varval的refcount的值</div><div class=\"line\">         */</div><div class=\"line\">        zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></div><div class=\"line\">        varcopy-&gt;refcount = <span class=\"number\">1</span>;</div><div class=\"line\">        varcopy-&gt;is_ref = <span class=\"number\">0</span>;</div><div class=\"line\">        zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>,&amp;varcopy, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">/* 返回新zval的地址 */</span></div><div class=\"line\">        <span class=\"keyword\">return</span> varcopy;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。<br>Change on Write</p>\n<p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = &amp;$a;</div><div class=\"line\">$b += <span class=\"number\">5</span>;</div></pre></td></tr></table></figure>\n<p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref<strong>gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount</strong>gc等于1，is_ref<strong>gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount</strong>gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> *varval;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。<br>Separation Anxiety</p>\n<p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = $a;</div><div class=\"line\">$c = &amp;$a;</div></pre></td></tr></table></figure>\n<p> <img src=\"/assets/blogImg/is_ref1.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref<strong>gc和refcount</strong>gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】</p>\n<p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//上图对应的代码</span></div><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = &amp;$a;</div><div class=\"line\">$c = $a;</div></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/is_ref2.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>\n","site":{"data":{}},"excerpt":"<p>上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:<br>       <code>zend_uint refcount__gc</code><br>       <code>zend_uchar is_ref__gc</code><br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">struct</span> _zval_struct &#123;</div><div class=\"line\">        zvalue_value value; <span class=\"comment\">/* 变量的值 */</span></div><div class=\"line\">        zend_uchar type;    <span class=\"comment\">/* 变量当前的数据类型 */</span></div><div class=\"line\">        zend_uint refcount__gc; <span class=\"comment\">/*  */</span></div><div class=\"line\">        zend_uchar is_ref__gc;</div><div class=\"line\">&#125;;</div><div class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">struct</span> _zval_struct zval;</div></pre></td></tr></table></figure></p>\n<p>php中的引用计数<br>先看例子</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">$a = <span class=\"string\">'Hello World'</span>;</div><div class=\"line\">$b = $a;</div><div class=\"line\"><span class=\"keyword\">unset</span>($a);</div></pre></td></tr></table></figure>","more":"<p>PHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br>这里我们主要讲解refcount<strong>gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount</strong>gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">zval *helloval;</div><div class=\"line\">MAKE_STD_ZVAL(helloval);</div><div class=\"line\">ZVAL_STRING(helloval, <span class=\"string\">\"Hello World\"</span>, <span class=\"number\">1</span>);</div><div class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"a\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"a\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</div><div class=\"line\">ZVAL_ADDREF(helloval); <span class=\"comment\">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></div><div class=\"line\">zend_hash_add(EG(active_symbol_table), <span class=\"string\">\"b\"</span>, <span class=\"keyword\">sizeof</span>(<span class=\"string\">\"b\"</span>),&amp;helloval, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>)</div></pre></td></tr></table></figure>\n<p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！<br>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = $a;</div><div class=\"line\">$b += <span class=\"number\">5</span>;</div></pre></td></tr></table></figure>\n<p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">zval *<span class=\"title\">get_var_and_separate</span><span class=\"params\">(<span class=\"keyword\">char</span> *varname, <span class=\"keyword\">int</span> varname_len TSRMLS_DC)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        zval **varval, *varcopy;</div><div class=\"line\">        <span class=\"keyword\">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class=\"number\">1</span>, (<span class=\"keyword\">void</span>**)&amp;varval) == FAILURE)</div><div class=\"line\">        &#123;</div><div class=\"line\">            <span class=\"comment\">/* 如果在符号表里找不到这个变量则直接return */</span></div><div class=\"line\">            <span class=\"keyword\">return</span> <span class=\"literal\">NULL</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> ((*varval)-&gt;refcount &lt; <span class=\"number\">2</span>)</div><div class=\"line\">        &#123;   </div><div class=\"line\">        <span class=\"comment\">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></div><div class=\"line\">        <span class=\"keyword\">return</span> *varval;</div><div class=\"line\">        &#125;</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">/* 否则，复制一份zval*的值 */</span></div><div class=\"line\">        MAKE_STD_ZVAL(varcopy);</div><div class=\"line\">        varcopy = *varval;</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">/* 复制任何在zval*内已分配的结构*/</span></div><div class=\"line\">        zval_copy_ctor(varcopy);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/* 从符号表中删除原来的变量</span></div><div class=\"line\">         * 这将减少该过程中varval的refcount的值</div><div class=\"line\">         */</div><div class=\"line\">        zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"comment\">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></div><div class=\"line\">        varcopy-&gt;refcount = <span class=\"number\">1</span>;</div><div class=\"line\">        varcopy-&gt;is_ref = <span class=\"number\">0</span>;</div><div class=\"line\">        zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class=\"number\">1</span>,&amp;varcopy, <span class=\"keyword\">sizeof</span>(zval*), <span class=\"literal\">NULL</span>);</div><div class=\"line\">            </div><div class=\"line\">        <span class=\"comment\">/* 返回新zval的地址 */</span></div><div class=\"line\">        <span class=\"keyword\">return</span> varcopy;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。<br>Change on Write</p>\n<p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = &amp;$a;</div><div class=\"line\">$b += <span class=\"number\">5</span>;</div></pre></td></tr></table></figure>\n<p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref<strong>gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount</strong>gc等于1，is_ref<strong>gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount</strong>gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></div><div class=\"line\"><span class=\"keyword\">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class=\"number\">2</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> *varval;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。<br>Separation Anxiety</p>\n<p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = $a;</div><div class=\"line\">$c = &amp;$a;</div></pre></td></tr></table></figure>\n<p> <img src=\"/assets/blogImg/is_ref1.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref<strong>gc和refcount</strong>gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】</p>\n<p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//上图对应的代码</span></div><div class=\"line\">$a = <span class=\"number\">1</span>;</div><div class=\"line\">$b = &amp;$a;</div><div class=\"line\">$c = $a;</div></pre></td></tr></table></figure></p>\n<p> <img src=\"/assets/blogImg/is_ref2.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>"},{"title":"深入解析php的容器模式","date":"2016-10-19T03:20:43.000Z","_content":"先说结论，**容器**在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。\n### 我是傲娇的代码块:\n\n``` php\n\n<?php\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n  private $_binContainerngs = [];//服务列表\n  private $_instances= [];//已经实例化的服务\n\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n  //检测是否已经绑定\n  public function has($name){\n  return isset($this->_binContainerngs[$name]) or isset($this->_instances[$name]);\n  }\n\n  //卸载服务\n  public function remove($name){\n  unset($this->_binContainerngs[$name],$this->_instances[$name]);\n  }\n  //设置服务\n  public function set($name,$class){\n  $this->_registerService($name,$class);\n  }\n  //设置共享服务\n  public function setShared($name,$class){\n  $this->_registerService($name,$class,true);\n  }\n  //注册服务\n  private function _registerService($name,$class,$shared=false){\n  $this->remove($name);\n  if(!($class instanceof \\Closure) && is_object($class)){\n  $this->_instances[$name]=$class;\n  }else{\n  $this->_binContainerngs[$name]=array(\"class\"=>$class,\"shared\"=>$shared);\n  }\n  }\n  //ArrayAccess接口，检测服务是否存在\n  public function offsetExists($offset){\n  return $this->has($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetGet($offset){\n  return $this->get($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetSet($offset,$value){\n  return $this->set($offset,$value);\n  }\n  //卸载服务\n  public function offsetUnset($offset){\n  return $this->remove($offset);\n  }\n}\n\n```\n\n<!--more-->\n### 使用方式\n\n``` php\n\n<?php\nheader(\"Content-Type:text/html;charset=utf8\");\nclass A{\n  public $name;\n  public $age;\n  public function __construct($name=\"\"){\n  $this->name = $name;\n\n  }\n\n}\n\ninclude \"Container.class.php\";\n$Container = new Container();\n\n/**\n* @brief $Container->setShared 匿名函数方式注册一个名为a1的服务\n*\n* @param 'a1'\n* @param\n*/\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n\n$a1 = $Container->get('a1',array(\"小李\"));\necho $a1->name.\"<br/>\";//小李\n/**\n* @brief $Container->set 直接以类名方式注册\n*\n* @param 'a2'\n* @param 'A'\n*/\n$Container->set('a2','A');\n\n$a2 = $Container->get('a2',array(\"小张\"));\necho $a2->name.\"<br/>\";//小张\n/**\n* @brief $Container->set 直接传入实例化的对象\n*\n* @param 'a3'\n* @param \"小唐\"\n*/\n$Container->set('a3',new A(\"小唐\"));\necho $a3->name.\"<br/>\";//小唐\n\n```\n### 分析\n通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式\n- 匿名函数方式注册\n- 类名方式注册\n- 直接传入实例化的对象的注册\n然后get方法\n``` php\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n```\n\n实际上通过分析get方法对这三种注入方式的数组都做了对应的处理\n# 匿名方式\n\n``` php\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n```\n\n``` php\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }\n```\n  \n\n  首先通过**$concrete instanceof \\Closure**来判断是否是匿名函数，然后通过**call_user_func_array($concrete,$params)**来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。\n# 类名方式注册\n\n``` php\n$Container->set('a2','A');\n\n```\n\n``` php\n\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }\n  }\n\n```\n\n 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名\n# 带参数的类实例化,使用反射(接口方式)\n\n``` php\n$Container->set('a3',new A(\"小唐\"));\n```\n``` php\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  \n```\n> **reflectionClass**: ReflectionClass 类报告了一个类的有关信息。\n> **newInstanceArgs**: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。\n","source":"_posts/深入解析php的容器模式.md","raw":"\ntitle: 深入解析php的容器模式\ndate: 2016-10-19 11:20:43\ntag: php\ncategories: 技术\n---\n先说结论，**容器**在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。\n### 我是傲娇的代码块:\n\n``` php\n\n<?php\n/**\n* @brief 服务容器\n* author Graychen\n */\nclass Container implements \\ArrayAccess{\n  private $_binContainerngs = [];//服务列表\n  private $_instances= [];//已经实例化的服务\n\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n  //检测是否已经绑定\n  public function has($name){\n  return isset($this->_binContainerngs[$name]) or isset($this->_instances[$name]);\n  }\n\n  //卸载服务\n  public function remove($name){\n  unset($this->_binContainerngs[$name],$this->_instances[$name]);\n  }\n  //设置服务\n  public function set($name,$class){\n  $this->_registerService($name,$class);\n  }\n  //设置共享服务\n  public function setShared($name,$class){\n  $this->_registerService($name,$class,true);\n  }\n  //注册服务\n  private function _registerService($name,$class,$shared=false){\n  $this->remove($name);\n  if(!($class instanceof \\Closure) && is_object($class)){\n  $this->_instances[$name]=$class;\n  }else{\n  $this->_binContainerngs[$name]=array(\"class\"=>$class,\"shared\"=>$shared);\n  }\n  }\n  //ArrayAccess接口，检测服务是否存在\n  public function offsetExists($offset){\n  return $this->has($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetGet($offset){\n  return $this->get($offset);\n  }\n  //ArrayAccess接口,以$Container[$name]方式获取服务\n  public function offsetSet($offset,$value){\n  return $this->set($offset,$value);\n  }\n  //卸载服务\n  public function offsetUnset($offset){\n  return $this->remove($offset);\n  }\n}\n\n```\n\n<!--more-->\n### 使用方式\n\n``` php\n\n<?php\nheader(\"Content-Type:text/html;charset=utf8\");\nclass A{\n  public $name;\n  public $age;\n  public function __construct($name=\"\"){\n  $this->name = $name;\n\n  }\n\n}\n\ninclude \"Container.class.php\";\n$Container = new Container();\n\n/**\n* @brief $Container->setShared 匿名函数方式注册一个名为a1的服务\n*\n* @param 'a1'\n* @param\n*/\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n\n$a1 = $Container->get('a1',array(\"小李\"));\necho $a1->name.\"<br/>\";//小李\n/**\n* @brief $Container->set 直接以类名方式注册\n*\n* @param 'a2'\n* @param 'A'\n*/\n$Container->set('a2','A');\n\n$a2 = $Container->get('a2',array(\"小张\"));\necho $a2->name.\"<br/>\";//小张\n/**\n* @brief $Container->set 直接传入实例化的对象\n*\n* @param 'a3'\n* @param \"小唐\"\n*/\n$Container->set('a3',new A(\"小唐\"));\necho $a3->name.\"<br/>\";//小唐\n\n```\n### 分析\n通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式\n- 匿名函数方式注册\n- 类名方式注册\n- 直接传入实例化的对象的注册\n然后get方法\n``` php\n  //获取服务\n  public function get($name,$params=[]){\n  //先从实例化的列表中查找\n  if(isset($this->_instances[$name])){\n  return $this->_instances[$name];\n  }\n\n  //检测有没有注册该服务\n  if(!isset($this->_binContainerngs[$name])){\n  return null;\n  }\n\n  $concrete = $this->_binContainerngs[$name]['class'];//对象具体注册内容\n\n  $obj = null;\n\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }else{\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  }\n  }\n  //如果是共享服务，则写入_instances列表，下次直接取回\n  if($this->_binContainerngs[$name]['shared']==true && $ojb){\n  $this->_instances[$name]=$obj;\n  }\n\n  return $obj;\n  }\n\n```\n\n实际上通过分析get方法对这三种注入方式的数组都做了对应的处理\n# 匿名方式\n\n``` php\n$Container->setShared('a1',function($name=\"\"){\n  return new A($name);\n  });\n```\n\n``` php\n  if($concrete instanceof \\Closure){ //匿名函数方式\n  $obj = call_user_func_array($concrete,$params);\n  }\n```\n  \n\n  首先通过**$concrete instanceof \\Closure**来判断是否是匿名函数，然后通过**call_user_func_array($concrete,$params)**来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。\n# 类名方式注册\n\n``` php\n$Container->set('a2','A');\n\n```\n\n``` php\n\n  }elseif(is_string($concrete)){ //字符串方式\n  if(empty($params)){\n  $obj = new $concrete;\n  }\n  }\n\n```\n\n 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名\n# 带参数的类实例化,使用反射(接口方式)\n\n``` php\n$Container->set('a3',new A(\"小唐\"));\n```\n``` php\n  //带参数的类实例化,使用反射\n  $class = new \\reflectionClass($concrete);\n  $obj = $class->newInstanceArgs($params);\n  \n```\n> **reflectionClass**: ReflectionClass 类报告了一个类的有关信息。\n> **newInstanceArgs**: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。\n","slug":"深入解析php的容器模式","published":1,"updated":"2017-12-10T12:38:46.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q38001mto7ya31nuhjl","content":"<p>先说结论，<strong>容器</strong>在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。</p>\n<h3 id=\"我是傲娇的代码块\"><a href=\"#我是傲娇的代码块\" class=\"headerlink\" title=\"我是傲娇的代码块:\"></a>我是傲娇的代码块:</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> 服务容器</div><div class=\"line\">* author Graychen</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> $_binContainerngs = [];<span class=\"comment\">//服务列表</span></div><div class=\"line\">  <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//获取服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</div><div class=\"line\">  <span class=\"comment\">//先从实例化的列表中查找</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//检测有没有注册该服务</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  $concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></div><div class=\"line\"></div><div class=\"line\">  $obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">  $obj = call_user_func_array($concrete,$params);</div><div class=\"line\">  &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">  $obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">  $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">  $obj = $class-&gt;newInstanceArgs($params);</div><div class=\"line\">  &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> $obj;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//检测是否已经绑定</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//卸载服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//设置服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//设置共享服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//注册服务</span></div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;remove($name);</div><div class=\"line\">  <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared);</div><div class=\"line\">  &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//卸载服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">header(<span class=\"string\">\"Content-Type:text/html;charset=utf8\"</span>);</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">public</span> $name;</div><div class=\"line\">  <span class=\"keyword\">public</span> $age;</div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;name = $name;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">\"Container.class.php\"</span>;</div><div class=\"line\">$Container = <span class=\"keyword\">new</span> Container();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> $Container-&gt;setShared 匿名函数方式注册一个名为a1的服务</div><div class=\"line\">*</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'a1'</div><div class=\"line\">* <span class=\"doctag\">@param</span></div><div class=\"line\">*/</div><div class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">$a1 = $Container-&gt;get(<span class=\"string\">'a1'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小李\"</span>));</div><div class=\"line\"><span class=\"keyword\">echo</span> $a1-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小李</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接以类名方式注册</div><div class=\"line\">*</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'a2'</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'A'</div><div class=\"line\">*/</div><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</div><div class=\"line\"></div><div class=\"line\">$a2 = $Container-&gt;get(<span class=\"string\">'a2'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小张\"</span>));</div><div class=\"line\"><span class=\"keyword\">echo</span> $a2-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小张</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接传入实例化的对象</div><div class=\"line\">*</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'a3'</div><div class=\"line\">* <span class=\"doctag\">@param</span> \"小唐\"</div><div class=\"line\">*/</div><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</div><div class=\"line\"><span class=\"keyword\">echo</span> $a3-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小唐</span></div></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式</p>\n<ul>\n<li>匿名函数方式注册</li>\n<li>类名方式注册</li>\n<li>直接传入实例化的对象的注册<br>然后get方法<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//获取服务</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</div><div class=\"line\"><span class=\"comment\">//先从实例化的列表中查找</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//检测有没有注册该服务</span></div><div class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></div><div class=\"line\"></div><div class=\"line\">$obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">$obj = call_user_func_array($concrete,$params);</div><div class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</div><div class=\"line\"><span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">return</span> $obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际上通过分析get方法对这三种注入方式的数组都做了对应的处理</p>\n<h1 id=\"匿名方式\"><a href=\"#匿名方式\" class=\"headerlink\" title=\"匿名方式\"></a>匿名方式</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">$obj = call_user_func_array($concrete,$params);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  首先通过<strong>$concrete instanceof \\Closure</strong>来判断是否是匿名函数，然后通过<strong>call_user_func_array($concrete,$params)</strong>来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。</p>\n<h1 id=\"类名方式注册\"><a href=\"#类名方式注册\" class=\"headerlink\" title=\"类名方式注册\"></a>类名方式注册</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</div></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名</p>\n<h1 id=\"带参数的类实例化-使用反射-接口方式\"><a href=\"#带参数的类实例化-使用反射-接口方式\" class=\"headerlink\" title=\"带参数的类实例化,使用反射(接口方式)\"></a>带参数的类实例化,使用反射(接口方式)</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</div></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>reflectionClass</strong>: ReflectionClass 类报告了一个类的有关信息。<br><strong>newInstanceArgs</strong>: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"<p>先说结论，<strong>容器</strong>在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。</p>\n<h3 id=\"我是傲娇的代码块\"><a href=\"#我是傲娇的代码块\" class=\"headerlink\" title=\"我是傲娇的代码块:\"></a>我是傲娇的代码块:</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> 服务容器</div><div class=\"line\">* author Graychen</div><div class=\"line\"> */</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Container</span> <span class=\"keyword\">implements</span> \\<span class=\"title\">ArrayAccess</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">private</span> $_binContainerngs = [];<span class=\"comment\">//服务列表</span></div><div class=\"line\">  <span class=\"keyword\">private</span> $_instances= [];<span class=\"comment\">//已经实例化的服务</span></div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//获取服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</div><div class=\"line\">  <span class=\"comment\">//先从实例化的列表中查找</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//检测有没有注册该服务</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  $concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></div><div class=\"line\"></div><div class=\"line\">  $obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">  $obj = call_user_func_array($concrete,$params);</div><div class=\"line\">  &#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">  $obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">  <span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">  $class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">  $obj = $class-&gt;newInstanceArgs($params);</div><div class=\"line\">  &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class=\"line\">  <span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"keyword\">return</span> $obj;</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//检测是否已经绑定</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">has</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]) <span class=\"keyword\">or</span> <span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">  <span class=\"comment\">//卸载服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">remove</span><span class=\"params\">($name)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">unset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name],<span class=\"keyword\">$this</span>-&gt;_instances[$name]);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//设置服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">set</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//设置共享服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">setShared</span><span class=\"params\">($name,$class)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_registerService($name,$class,<span class=\"keyword\">true</span>);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//注册服务</span></div><div class=\"line\">  <span class=\"keyword\">private</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">_registerService</span><span class=\"params\">($name,$class,$shared=false)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;remove($name);</div><div class=\"line\">  <span class=\"keyword\">if</span>(!($class <span class=\"keyword\">instanceof</span> \\Closure) &amp;&amp; is_object($class))&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_instances[$name]=$class;</div><div class=\"line\">  &#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]=<span class=\"keyword\">array</span>(<span class=\"string\">\"class\"</span>=&gt;$class,<span class=\"string\">\"shared\"</span>=&gt;$shared);</div><div class=\"line\">  &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//ArrayAccess接口，检测服务是否存在</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetExists</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;has($offset);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetGet</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;get($offset);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//ArrayAccess接口,以$Container[$name]方式获取服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetSet</span><span class=\"params\">($offset,$value)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;set($offset,$value);</div><div class=\"line\">  &#125;</div><div class=\"line\">  <span class=\"comment\">//卸载服务</span></div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">offsetUnset</span><span class=\"params\">($offset)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;remove($offset);</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<h3 id=\"使用方式\"><a href=\"#使用方式\" class=\"headerlink\" title=\"使用方式\"></a>使用方式</h3><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\"><span class=\"meta\">&lt;?php</span></div><div class=\"line\">header(<span class=\"string\">\"Content-Type:text/html;charset=utf8\"</span>);</div><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">public</span> $name;</div><div class=\"line\">  <span class=\"keyword\">public</span> $age;</div><div class=\"line\">  <span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">__construct</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">$this</span>-&gt;name = $name;</div><div class=\"line\"></div><div class=\"line\">  &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">include</span> <span class=\"string\">\"Container.class.php\"</span>;</div><div class=\"line\">$Container = <span class=\"keyword\">new</span> Container();</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> $Container-&gt;setShared 匿名函数方式注册一个名为a1的服务</div><div class=\"line\">*</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'a1'</div><div class=\"line\">* <span class=\"doctag\">@param</span></div><div class=\"line\">*/</div><div class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</div><div class=\"line\">  &#125;);</div><div class=\"line\"></div><div class=\"line\">$a1 = $Container-&gt;get(<span class=\"string\">'a1'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小李\"</span>));</div><div class=\"line\"><span class=\"keyword\">echo</span> $a1-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小李</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接以类名方式注册</div><div class=\"line\">*</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'a2'</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'A'</div><div class=\"line\">*/</div><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</div><div class=\"line\"></div><div class=\"line\">$a2 = $Container-&gt;get(<span class=\"string\">'a2'</span>,<span class=\"keyword\">array</span>(<span class=\"string\">\"小张\"</span>));</div><div class=\"line\"><span class=\"keyword\">echo</span> $a2-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小张</span></div><div class=\"line\"><span class=\"comment\">/**</span></div><div class=\"line\">* <span class=\"doctag\">@brief</span> $Container-&gt;set 直接传入实例化的对象</div><div class=\"line\">*</div><div class=\"line\">* <span class=\"doctag\">@param</span> 'a3'</div><div class=\"line\">* <span class=\"doctag\">@param</span> \"小唐\"</div><div class=\"line\">*/</div><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</div><div class=\"line\"><span class=\"keyword\">echo</span> $a3-&gt;name.<span class=\"string\">\"&lt;br/&gt;\"</span>;<span class=\"comment\">//小唐</span></div></pre></td></tr></table></figure>\n<h3 id=\"分析\"><a href=\"#分析\" class=\"headerlink\" title=\"分析\"></a>分析</h3><p>通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式</p>\n<ul>\n<li>匿名函数方式注册</li>\n<li>类名方式注册</li>\n<li>直接传入实例化的对象的注册<br>然后get方法<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//获取服务</span></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"function\"><span class=\"keyword\">function</span> <span class=\"title\">get</span><span class=\"params\">($name,$params=[])</span></span>&#123;</div><div class=\"line\"><span class=\"comment\">//先从实例化的列表中查找</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_instances[$name]))&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">$this</span>-&gt;_instances[$name];</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//检测有没有注册该服务</span></div><div class=\"line\"><span class=\"keyword\">if</span>(!<span class=\"keyword\">isset</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name]))&#123;</div><div class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">$concrete = <span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'class'</span>];<span class=\"comment\">//对象具体注册内容</span></div><div class=\"line\"></div><div class=\"line\">$obj = <span class=\"keyword\">null</span>;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">$obj = call_user_func_array($concrete,$params);</div><div class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">&#125;<span class=\"keyword\">else</span>&#123;</div><div class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div><div class=\"line\"><span class=\"comment\">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">$this</span>-&gt;_binContainerngs[$name][<span class=\"string\">'shared'</span>]==<span class=\"keyword\">true</span> &amp;&amp; $ojb)&#123;</div><div class=\"line\"><span class=\"keyword\">$this</span>-&gt;_instances[$name]=$obj;</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">return</span> $obj;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<p>实际上通过分析get方法对这三种注入方式的数组都做了对应的处理</p>\n<h1 id=\"匿名方式\"><a href=\"#匿名方式\" class=\"headerlink\" title=\"匿名方式\"></a>匿名方式</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">$Container-&gt;setShared(<span class=\"string\">'a1'</span>,<span class=\"function\"><span class=\"keyword\">function</span><span class=\"params\">($name=<span class=\"string\">\"\"</span>)</span></span>&#123;</div><div class=\"line\">  <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> A($name);</div><div class=\"line\">  &#125;);</div></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>($concrete <span class=\"keyword\">instanceof</span> \\Closure)&#123; <span class=\"comment\">//匿名函数方式</span></div><div class=\"line\">$obj = call_user_func_array($concrete,$params);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>  首先通过<strong>$concrete instanceof \\Closure</strong>来判断是否是匿名函数，然后通过<strong>call_user_func_array($concrete,$params)</strong>来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。</p>\n<h1 id=\"类名方式注册\"><a href=\"#类名方式注册\" class=\"headerlink\" title=\"类名方式注册\"></a>类名方式注册</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a2'</span>,<span class=\"string\">'A'</span>);</div></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"></div><div class=\"line\">&#125;<span class=\"keyword\">elseif</span>(is_string($concrete))&#123; <span class=\"comment\">//字符串方式</span></div><div class=\"line\"><span class=\"keyword\">if</span>(<span class=\"keyword\">empty</span>($params))&#123;</div><div class=\"line\">$obj = <span class=\"keyword\">new</span> $concrete;</div><div class=\"line\">&#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p> 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名</p>\n<h1 id=\"带参数的类实例化-使用反射-接口方式\"><a href=\"#带参数的类实例化-使用反射-接口方式\" class=\"headerlink\" title=\"带参数的类实例化,使用反射(接口方式)\"></a>带参数的类实例化,使用反射(接口方式)</h1><figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">$Container-&gt;set(<span class=\"string\">'a3'</span>,<span class=\"keyword\">new</span> A(<span class=\"string\">\"小唐\"</span>));</div></pre></td></tr></table></figure>\n<figure class=\"highlight php\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//带参数的类实例化,使用反射</span></div><div class=\"line\">$class = <span class=\"keyword\">new</span> \\reflectionClass($concrete);</div><div class=\"line\">$obj = $class-&gt;newInstanceArgs($params);</div></pre></td></tr></table></figure>\n<blockquote>\n<p><strong>reflectionClass</strong>: ReflectionClass 类报告了一个类的有关信息。<br><strong>newInstanceArgs</strong>: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。</p>\n</blockquote>"},{"title":"解析php的内存管理","date":"2017-06-21T05:59:12.000Z","_content":"## php的内存管理\n在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。\n> 内存泄露\n每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。\n对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。\n\n## Zend内存管理器\n使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是\"请求感知\"的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。\n![\"我是傲娇的效果图\"](/assets/blogImg/zend_manage.jpg)\n 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。 \n 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求\"跳出\"时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为\"永久性分配\"），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：\n 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。\n\n| C语言原生函数 |   PHP内核封装后的函数|\n| :-------------|  :------------------:|\n| void *malloc(size_t count);  |  void *emalloc(size_t count); void *pemalloc(size_t count, char persistent);|\n|  void *calloc(size_t count); |  void *ecalloc(size_t count); void *pecalloc(size_t count, char persistent);|\n|  void *realloc(void *ptr, size_t count); |   void *erealloc(void *ptr, size_t count); void *perealloc(void *ptr, size_t count, char persistent);|\n|  void *strdup(void *ptr); |  void *estrdup(void *ptr); void *pestrdup(void *ptr, char persistent);|\n|  void free(void *ptr); | void efree(void *ptr); void pefree(void *ptr, char persistent);|\n你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： ````c void *estrndup(void *ptr，int len);\n该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：\n\n```c\nZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n        char *p;\n\n        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n            if (UNEXPECTED(p == NULL))\n            {\n                        return p;\n                            \n            }\n        memcpy(p, s, length);\n        p[length] = 0;\n        return p;\n}\n```\n<!--more-->\n\n在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。\nvoid *safe_emalloc(size_t size, size_t count, size_t addtl);\nvoid *safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);\n这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：\"为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？\"。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一\"可能性相当小\"的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。\n","source":"_posts/解析php的内存管理.md","raw":"---\ntitle: 解析php的内存管理\ndate: 2017-06-21 13:59:12\ntags: php php扩展 c\ncategories: 技术\n\n---\n## php的内存管理\n在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。\n> 内存泄露\n每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。\n对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。\n\n## Zend内存管理器\n使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是\"请求感知\"的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。\n![\"我是傲娇的效果图\"](/assets/blogImg/zend_manage.jpg)\n 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。 \n 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求\"跳出\"时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为\"永久性分配\"），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：\n 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。\n\n| C语言原生函数 |   PHP内核封装后的函数|\n| :-------------|  :------------------:|\n| void *malloc(size_t count);  |  void *emalloc(size_t count); void *pemalloc(size_t count, char persistent);|\n|  void *calloc(size_t count); |  void *ecalloc(size_t count); void *pecalloc(size_t count, char persistent);|\n|  void *realloc(void *ptr, size_t count); |   void *erealloc(void *ptr, size_t count); void *perealloc(void *ptr, size_t count, char persistent);|\n|  void *strdup(void *ptr); |  void *estrdup(void *ptr); void *pestrdup(void *ptr, char persistent);|\n|  void free(void *ptr); | void efree(void *ptr); void pefree(void *ptr, char persistent);|\n你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： ````c void *estrndup(void *ptr，int len);\n该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：\n\n```c\nZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)\n{\n        char *p;\n\n        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);\n            if (UNEXPECTED(p == NULL))\n            {\n                        return p;\n                            \n            }\n        memcpy(p, s, length);\n        p[length] = 0;\n        return p;\n}\n```\n<!--more-->\n\n在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。\nvoid *safe_emalloc(size_t size, size_t count, size_t addtl);\nvoid *safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);\n这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：\"为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？\"。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一\"可能性相当小\"的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。\n","slug":"解析php的内存管理","published":1,"updated":"2017-12-10T12:38:46.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q3c001pto7yfsat0znc","content":"<h2 id=\"php的内存管理\"><a href=\"#php的内存管理\" class=\"headerlink\" title=\"php的内存管理\"></a>php的内存管理</h2><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p>\n<blockquote>\n<p>内存泄露<br>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。<br>对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。</p>\n</blockquote>\n<h2 id=\"Zend内存管理器\"><a href=\"#Zend内存管理器\" class=\"headerlink\" title=\"Zend内存管理器\"></a>Zend内存管理器</h2><p>使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br><img src=\"/assets/blogImg/zend_manage.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br> 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br> 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">C语言原生函数</th>\n<th style=\"text-align:center\">PHP内核封装后的函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">void *malloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>emalloc(size_t count); void </em>pemalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void *calloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>ecalloc(size_t count); void </em>pecalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>realloc(void </em>ptr, size_t count);</td>\n<td style=\"text-align:center\">void <em>erealloc(void </em>ptr, size_t count); void <em>perealloc(void </em>ptr, size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>strdup(void </em>ptr);</td>\n<td style=\"text-align:center\">void <em>estrdup(void </em>ptr); void <em>pestrdup(void </em>ptr, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void free(void *ptr);</td>\n<td style=\"text-align:center\">void efree(void <em>ptr); void pefree(void </em>ptr, char persistent);</td>\n</tr>\n</tbody>\n</table>\n<p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： <figure class=\"highlight plain\"><figcaption><span>void *estrndup(void *ptr，int len);</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</div><div class=\"line\"></div><div class=\"line\">```c</div><div class=\"line\">ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</div><div class=\"line\">&#123;</div><div class=\"line\">        char *p;</div><div class=\"line\"></div><div class=\"line\">        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</div><div class=\"line\">            if (UNEXPECTED(p == NULL))</div><div class=\"line\">            &#123;</div><div class=\"line\">                        return p;</div><div class=\"line\">                            </div><div class=\"line\">            &#125;</div><div class=\"line\">        memcpy(p, s, length);</div><div class=\"line\">        p[length] = 0;</div><div class=\"line\">        return p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<a id=\"more\"></a>\n<p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br>void <em>safe_emalloc(size_t size, size_t count, size_t addtl);<br>void </em>safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);<br>这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p>\n","site":{"data":{}},"excerpt":"<h2 id=\"php的内存管理\"><a href=\"#php的内存管理\" class=\"headerlink\" title=\"php的内存管理\"></a>php的内存管理</h2><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p>\n<blockquote>\n<p>内存泄露<br>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。<br>对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。</p>\n</blockquote>\n<h2 id=\"Zend内存管理器\"><a href=\"#Zend内存管理器\" class=\"headerlink\" title=\"Zend内存管理器\"></a>Zend内存管理器</h2><p>使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br><img src=\"/assets/blogImg/zend_manage.jpg\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br> 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br> 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">C语言原生函数</th>\n<th style=\"text-align:center\">PHP内核封装后的函数</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">void *malloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>emalloc(size_t count); void </em>pemalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void *calloc(size_t count);</td>\n<td style=\"text-align:center\">void <em>ecalloc(size_t count); void </em>pecalloc(size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>realloc(void </em>ptr, size_t count);</td>\n<td style=\"text-align:center\">void <em>erealloc(void </em>ptr, size_t count); void <em>perealloc(void </em>ptr, size_t count, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void <em>strdup(void </em>ptr);</td>\n<td style=\"text-align:center\">void <em>estrdup(void </em>ptr); void <em>pestrdup(void </em>ptr, char persistent);</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">void free(void *ptr);</td>\n<td style=\"text-align:center\">void efree(void <em>ptr); void pefree(void </em>ptr, char persistent);</td>\n</tr>\n</tbody>\n</table>\n<p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： <figure class=\"highlight plain\"><figcaption><span>void *estrndup(void *ptr，int len);</span></figcaption><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</div><div class=\"line\"></div><div class=\"line\">```c</div><div class=\"line\">ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</div><div class=\"line\">&#123;</div><div class=\"line\">        char *p;</div><div class=\"line\"></div><div class=\"line\">        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</div><div class=\"line\">            if (UNEXPECTED(p == NULL))</div><div class=\"line\">            &#123;</div><div class=\"line\">                        return p;</div><div class=\"line\">                            </div><div class=\"line\">            &#125;</div><div class=\"line\">        memcpy(p, s, length);</div><div class=\"line\">        p[length] = 0;</div><div class=\"line\">        return p;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>","more":"<p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br>void <em>safe_emalloc(size_t size, size_t count, size_t addtl);<br>void </em>safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);<br>这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p>"},{"title":"计划虽然不酷，但是很有用","date":"2017-02-04T06:26:37.000Z","_content":"\n这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！\n ![\"我是傲娇的女神\"](/assets/blogImg/女神2.jpg)\n 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。\n## 目标\n 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，\n 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是\n 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。\n## 计划\n 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上\n 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！\n## 计划详情\n 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品\n## 我是傲娇的分割线O(∩_∩)O~~\n### 第一个项目\n\n<!--more-->\n#### 代号：**OnePiece**\n![\"我是伟大的OnePiece\"](/assets/blogImg/onepiece.png)\n>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。\n\n#### 项目介绍\n这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，\n前台做完之后再开始做后台功能，我要倒过来做。\n#### 可能会用到的技术\n- 语言：php+js\n- 框架：laravel+vue.js\n- 平台：移动端\n- 类型：移动端的网站\n做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。\n#### 项目时间安排\n今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）\n","source":"_posts/计划虽然不酷，但是很有用.md","raw":"---\ntitle: 计划虽然不酷，但是很有用\ndate: 2017-02-04 14:26:37\ntag: php\ncategories: 随笔\n\n---\n\n这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！\n ![\"我是傲娇的女神\"](/assets/blogImg/女神2.jpg)\n 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。\n## 目标\n 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，\n 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是\n 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。\n## 计划\n 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上\n 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！\n## 计划详情\n 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品\n## 我是傲娇的分割线O(∩_∩)O~~\n### 第一个项目\n\n<!--more-->\n#### 代号：**OnePiece**\n![\"我是伟大的OnePiece\"](/assets/blogImg/onepiece.png)\n>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。\n\n#### 项目介绍\n这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，\n前台做完之后再开始做后台功能，我要倒过来做。\n#### 可能会用到的技术\n- 语言：php+js\n- 框架：laravel+vue.js\n- 平台：移动端\n- 类型：移动端的网站\n做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。\n#### 项目时间安排\n今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）\n","slug":"计划虽然不酷，但是很有用","published":1,"updated":"2017-12-10T12:38:46.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q3j001sto7ynqe76sni","content":"<p>这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！<br> <img src=\"/assets/blogImg/女神2.jpg\" alt=\"&quot;我是傲娇的女神&quot;\"><br> 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p> 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，<br> 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是<br> 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p> 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上<br> 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！</p>\n<h2 id=\"计划详情\"><a href=\"#计划详情\" class=\"headerlink\" title=\"计划详情\"></a>计划详情</h2><p> 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品</p>\n<h2 id=\"我是傲娇的分割线O-∩-∩-O\"><a href=\"#我是傲娇的分割线O-∩-∩-O\" class=\"headerlink\" title=\"我是傲娇的分割线O(∩_∩)O~~\"></a>我是傲娇的分割线O(∩_∩)O~~</h2><h3 id=\"第一个项目\"><a href=\"#第一个项目\" class=\"headerlink\" title=\"第一个项目\"></a>第一个项目</h3><a id=\"more\"></a>\n<h4 id=\"代号：OnePiece\"><a href=\"#代号：OnePiece\" class=\"headerlink\" title=\"代号：OnePiece\"></a>代号：<strong>OnePiece</strong></h4><p><img src=\"/assets/blogImg/onepiece.png\" alt=\"&quot;我是伟大的OnePiece&quot;\"></p>\n<blockquote>\n<p>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。</p>\n</blockquote>\n<h4 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h4><p>这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，<br>前台做完之后再开始做后台功能，我要倒过来做。</p>\n<h4 id=\"可能会用到的技术\"><a href=\"#可能会用到的技术\" class=\"headerlink\" title=\"可能会用到的技术\"></a>可能会用到的技术</h4><ul>\n<li>语言：php+js</li>\n<li>框架：laravel+vue.js</li>\n<li>平台：移动端</li>\n<li>类型：移动端的网站<br>做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。<h4 id=\"项目时间安排\"><a href=\"#项目时间安排\" class=\"headerlink\" title=\"项目时间安排\"></a>项目时间安排</h4>今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）</li>\n</ul>\n","site":{"data":{}},"excerpt":"<p>这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！<br> <img src=\"/assets/blogImg/女神2.jpg\" alt=\"&quot;我是傲娇的女神&quot;\"><br> 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。</p>\n<h2 id=\"目标\"><a href=\"#目标\" class=\"headerlink\" title=\"目标\"></a>目标</h2><p> 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，<br> 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是<br> 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。</p>\n<h2 id=\"计划\"><a href=\"#计划\" class=\"headerlink\" title=\"计划\"></a>计划</h2><p> 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上<br> 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！</p>\n<h2 id=\"计划详情\"><a href=\"#计划详情\" class=\"headerlink\" title=\"计划详情\"></a>计划详情</h2><p> 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品</p>\n<h2 id=\"我是傲娇的分割线O-∩-∩-O\"><a href=\"#我是傲娇的分割线O-∩-∩-O\" class=\"headerlink\" title=\"我是傲娇的分割线O(∩_∩)O~~\"></a>我是傲娇的分割线O(∩_∩)O~~</h2><h3 id=\"第一个项目\"><a href=\"#第一个项目\" class=\"headerlink\" title=\"第一个项目\"></a>第一个项目</h3>","more":"<h4 id=\"代号：OnePiece\"><a href=\"#代号：OnePiece\" class=\"headerlink\" title=\"代号：OnePiece\"></a>代号：<strong>OnePiece</strong></h4><p><img src=\"/assets/blogImg/onepiece.png\" alt=\"&quot;我是伟大的OnePiece&quot;\"></p>\n<blockquote>\n<p>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。</p>\n</blockquote>\n<h4 id=\"项目介绍\"><a href=\"#项目介绍\" class=\"headerlink\" title=\"项目介绍\"></a>项目介绍</h4><p>这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，<br>前台做完之后再开始做后台功能，我要倒过来做。</p>\n<h4 id=\"可能会用到的技术\"><a href=\"#可能会用到的技术\" class=\"headerlink\" title=\"可能会用到的技术\"></a>可能会用到的技术</h4><ul>\n<li>语言：php+js</li>\n<li>框架：laravel+vue.js</li>\n<li>平台：移动端</li>\n<li>类型：移动端的网站<br>做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。<h4 id=\"项目时间安排\"><a href=\"#项目时间安排\" class=\"headerlink\" title=\"项目时间安排\"></a>项目时间安排</h4>今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）</li>\n</ul>"},{"title":"谈谈进程和线程","date":"2017-06-17T15:27:02.000Z","_content":"最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下\n## 多任务\n现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。\n什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。\n现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？\n答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。\n真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。\n## 进程的概念\n对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。\n## 进程的本质\ncpu的单次运算\n## 线程的概念\n有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。\n## 线程的本质\n由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。\n## 线程的特点\n由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：\n文件描述符表\n每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）\n当前工作目录\n用户id和组id\n但有些资源是每个线程各有一份的：\n线程id\n<!--more-->\n上下文，包括各种寄存器的值、程序计数器和栈指针\n栈空间\nerrno变量\n信号屏蔽字\n调度优先级\n\n\n## 进程的通信\n每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。\n图 30.6. 进程间通信\n进程间通信\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.png)\n###  管道\n管道是一种最基本的IPC机制，由pipe函数创建：\n``` c\n#include <unistd.h>\nint pipe(int filedes[2]);\n\n\n```\n调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。\n\n开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。\n1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。\n2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。\n3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.pipe.png)\n ``` c\n#include <stdlib.h>\n#include <unistd.h>\n#define MAXLINE 80\n\n int main(void)\n{\n        int n;\n        int fd[2];\n        pid_t pid;\n        char line[MAXLINE];\n\n        if (pipe(fd) < 0) {\n                perror(\"pipe\");\n                exit(1);\n        }\n        if ((pid = fork()) < 0) {\n                perror(\"fork\");\n                exit(1);\n        }\n        if (pid > 0) { /* parent */\n                close(fd[0]);\n                write(fd[1], \"hello world\\n\", 12);\n                wait(NULL);\n         } else {       /* child */\n                close(fd[1]);\n                n = read(fd[0], line, MAXLINE);\n                write(STDOUT_FILENO, line, n);\n         }\n}\n```\n> 使用管道有一些限制：\n两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？\n管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。\n使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：\n如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。\n如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。\n如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。\n如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。\n\n 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：\n-父进程通过fork可以将打开文件的描述符传递给子进程\n-子进程结束时，父进程调用wait可以得到子进程的终止信息\n-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步\n-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能\n-管道\n-FIFO\n-mmap函数，几个进程可以映射同一内存区\n-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃\n-UNIX Domain Socket，目前最广泛使用的IPC机制\n\n\n## 线程的通信\n多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：\n1.从内存读变量值到寄存器\n2.寄存器的值加1\n3.将寄存器的值写回内存\n假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。\n ![\"我是傲娇的效果图\"](/assets/blogImg/thread.corrupt.png)\n 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。\n pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：\n``` c\n#include <pthread.h>\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n返回值：成功返回0，失败返回错误号。\n一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。\n如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。\nMutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：\nlock:\n``` c\nif(mutex > 0){\n        mutex = 0;\n        return 0;\n} else\n        //挂起等待;\n        goto lock;\nunlock:\n        mutex = 1;\n        //唤醒等待Mutex的线程;\n        return 0;\n        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。\n```\n## 死锁\n1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。\n2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。\n\n 参考文章:\n-------------------\n[线程](https://akaedu.github.io/book/ch35s04.html)\n[进程间通信](https://akaedu.github.io/book/ch30s04.html)\n[进程和线程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000)\n\n\n\n\n\n\n","source":"_posts/谈谈进程和线程.md","raw":"---\ntitle: 谈谈进程和线程\ndate: 2017-06-17 23:27:02\ntags: linux基础 \ncategories: 技术\n\n---\n最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下\n## 多任务\n现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。\n什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。\n现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？\n答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。\n真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。\n## 进程的概念\n对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。\n## 进程的本质\ncpu的单次运算\n## 线程的概念\n有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。\n## 线程的本质\n由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。\n## 线程的特点\n由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：\n文件描述符表\n每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）\n当前工作目录\n用户id和组id\n但有些资源是每个线程各有一份的：\n线程id\n<!--more-->\n上下文，包括各种寄存器的值、程序计数器和栈指针\n栈空间\nerrno变量\n信号屏蔽字\n调度优先级\n\n\n## 进程的通信\n每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。\n图 30.6. 进程间通信\n进程间通信\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.png)\n###  管道\n管道是一种最基本的IPC机制，由pipe函数创建：\n``` c\n#include <unistd.h>\nint pipe(int filedes[2]);\n\n\n```\n调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。\n\n开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。\n1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。\n2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。\n3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。\n ![\"我是傲娇的效果图\"](/assets/blogImg/process.pipe.png)\n ``` c\n#include <stdlib.h>\n#include <unistd.h>\n#define MAXLINE 80\n\n int main(void)\n{\n        int n;\n        int fd[2];\n        pid_t pid;\n        char line[MAXLINE];\n\n        if (pipe(fd) < 0) {\n                perror(\"pipe\");\n                exit(1);\n        }\n        if ((pid = fork()) < 0) {\n                perror(\"fork\");\n                exit(1);\n        }\n        if (pid > 0) { /* parent */\n                close(fd[0]);\n                write(fd[1], \"hello world\\n\", 12);\n                wait(NULL);\n         } else {       /* child */\n                close(fd[1]);\n                n = read(fd[0], line, MAXLINE);\n                write(STDOUT_FILENO, line, n);\n         }\n}\n```\n> 使用管道有一些限制：\n两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？\n管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。\n使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：\n如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。\n如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。\n如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。\n如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。\n\n 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：\n-父进程通过fork可以将打开文件的描述符传递给子进程\n-子进程结束时，父进程调用wait可以得到子进程的终止信息\n-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步\n-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能\n-管道\n-FIFO\n-mmap函数，几个进程可以映射同一内存区\n-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃\n-UNIX Domain Socket，目前最广泛使用的IPC机制\n\n\n## 线程的通信\n多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：\n1.从内存读变量值到寄存器\n2.寄存器的值加1\n3.将寄存器的值写回内存\n假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。\n ![\"我是傲娇的效果图\"](/assets/blogImg/thread.corrupt.png)\n 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。\n pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：\n``` c\n#include <pthread.h>\n\nint pthread_mutex_lock(pthread_mutex_t *mutex);\nint pthread_mutex_trylock(pthread_mutex_t *mutex);\nint pthread_mutex_unlock(pthread_mutex_t *mutex);\n```\n返回值：成功返回0，失败返回错误号。\n一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。\n如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。\nMutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：\nlock:\n``` c\nif(mutex > 0){\n        mutex = 0;\n        return 0;\n} else\n        //挂起等待;\n        goto lock;\nunlock:\n        mutex = 1;\n        //唤醒等待Mutex的线程;\n        return 0;\n        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。\n```\n## 死锁\n1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。\n2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。\n\n 参考文章:\n-------------------\n[线程](https://akaedu.github.io/book/ch35s04.html)\n[进程间通信](https://akaedu.github.io/book/ch30s04.html)\n[进程和线程](http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000)\n\n\n\n\n\n\n","slug":"谈谈进程和线程","published":1,"updated":"2018-02-10T05:53:45.434Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q3p001wto7yn672byeh","content":"<p>最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下</p>\n<h2 id=\"多任务\"><a href=\"#多任务\" class=\"headerlink\" title=\"多任务\"></a>多任务</h2><p>现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。<br>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>\n<h2 id=\"进程的概念\"><a href=\"#进程的概念\" class=\"headerlink\" title=\"进程的概念\"></a>进程的概念</h2><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>\n<h2 id=\"进程的本质\"><a href=\"#进程的本质\" class=\"headerlink\" title=\"进程的本质\"></a>进程的本质</h2><p>cpu的单次运算</p>\n<h2 id=\"线程的概念\"><a href=\"#线程的概念\" class=\"headerlink\" title=\"线程的概念\"></a>线程的概念</h2><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>\n<h2 id=\"线程的本质\"><a href=\"#线程的本质\" class=\"headerlink\" title=\"线程的本质\"></a>线程的本质</h2><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>\n<h2 id=\"线程的特点\"><a href=\"#线程的特点\" class=\"headerlink\" title=\"线程的特点\"></a>线程的特点</h2><p>由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br>文件描述符表<br>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）<br>当前工作目录<br>用户id和组id<br>但有些资源是每个线程各有一份的：<br>线程id<br><a id=\"more\"></a><br>上下文，包括各种寄存器的值、程序计数器和栈指针<br>栈空间<br>errno变量<br>信号屏蔽字<br>调度优先级</p>\n<h2 id=\"进程的通信\"><a href=\"#进程的通信\" class=\"headerlink\" title=\"进程的通信\"></a>进程的通信</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。<br>图 30.6. 进程间通信<br>进程间通信<br> <img src=\"/assets/blogImg/process.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes[<span class=\"number\">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>\n<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。</p>\n<p>开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。<br>1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。<br>2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br>3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。<br> <img src=\"/assets/blogImg/process.pipe.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 80</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>];</div><div class=\"line\">        <span class=\"keyword\">pid_t</span> pid;</div><div class=\"line\">        <span class=\"keyword\">char</span> line[MAXLINE];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (pipe(fd) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                perror(<span class=\"string\">\"pipe\"</span>);</div><div class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                perror(<span class=\"string\">\"fork\"</span>);</div><div class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">/* parent */</span></div><div class=\"line\">                close(fd[<span class=\"number\">0</span>]);</div><div class=\"line\">                write(fd[<span class=\"number\">1</span>], <span class=\"string\">\"hello world\\n\"</span>, <span class=\"number\">12</span>);</div><div class=\"line\">                wait(<span class=\"literal\">NULL</span>);</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;       <span class=\"comment\">/* child */</span></div><div class=\"line\">                close(fd[<span class=\"number\">1</span>]);</div><div class=\"line\">                n = read(fd[<span class=\"number\">0</span>], line, MAXLINE);</div><div class=\"line\">                write(STDOUT_FILENO, line, n);</div><div class=\"line\">         &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用管道有一些限制：<br>两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？<br>管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。<br>使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：<br>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<br>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。<br>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。<br>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>\n</blockquote>\n<p> 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：<br>-父进程通过fork可以将打开文件的描述符传递给子进程<br>-子进程结束时，父进程调用wait可以得到子进程的终止信息<br>-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步<br>-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能<br>-管道<br>-FIFO<br>-mmap函数，几个进程可以映射同一内存区<br>-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃<br>-UNIX Domain Socket，目前最广泛使用的IPC机制</p>\n<h2 id=\"线程的通信\"><a href=\"#线程的通信\" class=\"headerlink\" title=\"线程的通信\"></a>线程的通信</h2><p>多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：<br>1.从内存读变量值到寄存器<br>2.寄存器的值加1<br>3.将寄存器的值写回内存<br>假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。<br> <img src=\"/assets/blogImg/thread.corrupt.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br> pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>返回值：成功返回0，失败返回错误号。<br>一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br>如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。<br>Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：<br>lock:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mutex &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        mutex = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">//挂起等待;</span></div><div class=\"line\">        <span class=\"keyword\">goto</span> lock;</div><div class=\"line\">unlock:</div><div class=\"line\">        mutex = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">//唤醒等待Mutex的线程;</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。</div></pre></td></tr></table></figure></p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://akaedu.github.io/book/ch35s04.html\" target=\"_blank\" rel=\"noopener\">线程</a><br><a href=\"https://akaedu.github.io/book/ch30s04.html\" target=\"_blank\" rel=\"noopener\">进程间通信</a><br><a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000\" target=\"_blank\" rel=\"noopener\">进程和线程</a></p>\n","site":{"data":{}},"excerpt":"<p>最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下</p>\n<h2 id=\"多任务\"><a href=\"#多任务\" class=\"headerlink\" title=\"多任务\"></a>多任务</h2><p>现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。<br>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>\n<h2 id=\"进程的概念\"><a href=\"#进程的概念\" class=\"headerlink\" title=\"进程的概念\"></a>进程的概念</h2><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>\n<h2 id=\"进程的本质\"><a href=\"#进程的本质\" class=\"headerlink\" title=\"进程的本质\"></a>进程的本质</h2><p>cpu的单次运算</p>\n<h2 id=\"线程的概念\"><a href=\"#线程的概念\" class=\"headerlink\" title=\"线程的概念\"></a>线程的概念</h2><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>\n<h2 id=\"线程的本质\"><a href=\"#线程的本质\" class=\"headerlink\" title=\"线程的本质\"></a>线程的本质</h2><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>\n<h2 id=\"线程的特点\"><a href=\"#线程的特点\" class=\"headerlink\" title=\"线程的特点\"></a>线程的特点</h2><p>由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br>文件描述符表<br>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）<br>当前工作目录<br>用户id和组id<br>但有些资源是每个线程各有一份的：<br>线程id<br>","more":"<br>上下文，包括各种寄存器的值、程序计数器和栈指针<br>栈空间<br>errno变量<br>信号屏蔽字<br>调度优先级</p>\n<h2 id=\"进程的通信\"><a href=\"#进程的通信\" class=\"headerlink\" title=\"进程的通信\"></a>进程的通信</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。<br>图 30.6. 进程间通信<br>进程间通信<br> <img src=\"/assets/blogImg/process.png\" alt=\"&quot;我是傲娇的效果图&quot;\"></p>\n<h3 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pipe</span><span class=\"params\">(<span class=\"keyword\">int</span> filedes[<span class=\"number\">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>\n<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。</p>\n<p>开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。<br>1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。<br>2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br>3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。<br> <img src=\"/assets/blogImg/process.pipe.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> <figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdlib.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;unistd.h&gt;</span></span></div><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLINE 80</span></div><div class=\"line\"></div><div class=\"line\"> <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></div><div class=\"line\">&#123;</div><div class=\"line\">        <span class=\"keyword\">int</span> n;</div><div class=\"line\">        <span class=\"keyword\">int</span> fd[<span class=\"number\">2</span>];</div><div class=\"line\">        <span class=\"keyword\">pid_t</span> pid;</div><div class=\"line\">        <span class=\"keyword\">char</span> line[MAXLINE];</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">if</span> (pipe(fd) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                perror(<span class=\"string\">\"pipe\"</span>);</div><div class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> ((pid = fork()) &lt; <span class=\"number\">0</span>) &#123;</div><div class=\"line\">                perror(<span class=\"string\">\"fork\"</span>);</div><div class=\"line\">                <span class=\"built_in\">exit</span>(<span class=\"number\">1</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">        <span class=\"keyword\">if</span> (pid &gt; <span class=\"number\">0</span>) &#123; <span class=\"comment\">/* parent */</span></div><div class=\"line\">                close(fd[<span class=\"number\">0</span>]);</div><div class=\"line\">                write(fd[<span class=\"number\">1</span>], <span class=\"string\">\"hello world\\n\"</span>, <span class=\"number\">12</span>);</div><div class=\"line\">                wait(<span class=\"literal\">NULL</span>);</div><div class=\"line\">         &#125; <span class=\"keyword\">else</span> &#123;       <span class=\"comment\">/* child */</span></div><div class=\"line\">                close(fd[<span class=\"number\">1</span>]);</div><div class=\"line\">                n = read(fd[<span class=\"number\">0</span>], line, MAXLINE);</div><div class=\"line\">                write(STDOUT_FILENO, line, n);</div><div class=\"line\">         &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<blockquote>\n<p>使用管道有一些限制：<br>两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？<br>管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。<br>使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：<br>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<br>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。<br>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。<br>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>\n</blockquote>\n<p> 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：<br>-父进程通过fork可以将打开文件的描述符传递给子进程<br>-子进程结束时，父进程调用wait可以得到子进程的终止信息<br>-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步<br>-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能<br>-管道<br>-FIFO<br>-mmap函数，几个进程可以映射同一内存区<br>-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃<br>-UNIX Domain Socket，目前最广泛使用的IPC机制</p>\n<h2 id=\"线程的通信\"><a href=\"#线程的通信\" class=\"headerlink\" title=\"线程的通信\"></a>线程的通信</h2><p>多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：<br>1.从内存读变量值到寄存器<br>2.寄存器的值加1<br>3.将寄存器的值写回内存<br>假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。<br> <img src=\"/assets/blogImg/thread.corrupt.png\" alt=\"&quot;我是傲娇的效果图&quot;\"><br> 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br> pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;pthread.h&gt;</span></span></div><div class=\"line\"></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_lock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_trylock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">pthread_mutex_unlock</span><span class=\"params\">(<span class=\"keyword\">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure></p>\n<p>返回值：成功返回0，失败返回错误号。<br>一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br>如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。<br>Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：<br>lock:<br><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">if</span>(mutex &gt; <span class=\"number\">0</span>)&#123;</div><div class=\"line\">        mutex = <span class=\"number\">0</span>;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span></div><div class=\"line\">        <span class=\"comment\">//挂起等待;</span></div><div class=\"line\">        <span class=\"keyword\">goto</span> lock;</div><div class=\"line\">unlock:</div><div class=\"line\">        mutex = <span class=\"number\">1</span>;</div><div class=\"line\">        <span class=\"comment\">//唤醒等待Mutex的线程;</span></div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</div><div class=\"line\">        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。</div></pre></td></tr></table></figure></p>\n<h2 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h2><p>1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。</p>\n<h2 id=\"参考文章\"><a href=\"#参考文章\" class=\"headerlink\" title=\" 参考文章:\"></a> 参考文章:</h2><p><a href=\"https://akaedu.github.io/book/ch35s04.html\" target=\"_blank\" rel=\"noopener\">线程</a><br><a href=\"https://akaedu.github.io/book/ch30s04.html\" target=\"_blank\" rel=\"noopener\">进程间通信</a><br><a href=\"http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000\" target=\"_blank\" rel=\"noopener\">进程和线程</a></p>"},{"title":"集中式日志管理elk搭建","date":"2018-02-10T05:56:26.000Z","_content":"前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。\n> elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本\n- Elasticsearch 高可用性，实时索引，拓展简单，接口友好\n- Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表\n- Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据\n- Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据\n- X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索\n\n## elk的初始化\n其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的[docker-elk](https://github.com/deviantony/docker-elk)\n使用git clone git@github.com:deviantony/docker-elk.git后执行docker-compose up,然后我们访问http://localhost:5601,以下是它的端口\n- 5000: Logstash TCP input.\n- 9200: Elasticsearch HTTP\n- 9300: Elasticsearch TCP transport\n- 5601: Kibana\n<!--more-->\n## elk 配置\n我们先配置'elk/logstash/pipeline/logstash.conf'\n```\ninput {\n        beats { #通过这个端口接收filebeat组件发送过来的日志\n                port => 5043\n        }\n}\n## Add your filters / logstash plugins configuration here\nfilter {\n        grok { # 正则形式将无序的日志整理成有序的结构形式\n                match => { \"message\" => \"%{GREEDYDATA:health_Timestamp}\\[%{IPV4:health_IPaddress}\\]\\[-\\]\\[-\\]\\[%{LOGLEVEL:health_LogLevel}\\]\\[%{NOTSPACE:health_Category}\\]%{GREEDYDATA:health_Text}\" } \n        }    \n        geoip { #通过这个可以将ip和地理位置相关联\n                source => \"clientip\"\n        }\n}\noutput { #将日志信息交给elasticsearch处理\n        elasticsearch {\n                hosts => \"elasticsearch:9200\"\n        }\n}\n```\n## filebeat配置\n然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口\n- 现在docker-compose.yml添加filebeat组件\n```\nfilebeat:\n        image: docker.elastic.co/beats/filebeat:6.0.0\n        hostname: filebeat\n        container_name: filebeat\n        restart: always\n        volumes:\n        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml\n        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json\n        - ./api/runtime/logs:/var/logs\n        - ./api/runtime/debug:/var/debug\n        depends_on:\n        - web\n```\n- 接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml\n```\nfilebeat.prospectors:\n- type: log\n  paths:\n      - \"/var/logs/*.log\"\n     #- \"/var/debug/*.data\"\nregistry_file: /etc/registry/mark\n#============================= 将以时间的日志归并为一行 ===============================\n  multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'\n  multiline.negate: true\n  multiline.match: after\n  multiline.timeout: 10s\nenable: true\n#============================= Filebeat modules ===============================\n#\nfilebeat.config.modules:\n# Glob pattern for configuration loading\n  path: /usr/share/filebeat/modules.d/*.yml\n#\n# Set to true to enable config reloading\nreload.enabled: true\n\noutput:\nlogstash:\nhosts: [\"刚刚配置的elk的ip地址:5043\"]\n\nlogging:\nfiles:\nrotateeverybytes: 10485760 # = 10MB\n```\n\n 参考文章:\n-------------------\n[官网](https://www.elastic.co/cn/products)\n[使用Docker搭建ELK日志系统](http://blog.csdn.net/sysushui/article/details/78461498)\n[ELK---合并多行日志（php.log）](https://www.jianshu.com/p/a980cd121212)\n[docker容器日志集中ELK](https://jicki.me/2016/10/11/docker-elk-filebeat/)\n[filebeat+logstash配置搭建](https://my.oschina.net/openplus/blog/1584861)\n[关于Logstash中grok插件的正则表达式例子](https://www.cnblogs.com/stozen/p/5638369.html)\n[使用Logstash收集PHP相关日志-Linux SA John-51CTO博客](http://blog.51cto.com/john88wang/1641723)\n[Logstash整合Kafka](https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/)\n","source":"_posts/集中式日志管理elk搭建.md","raw":"---\ntitle: 集中式日志管理elk搭建\ndate: 2018-02-10 13:56:26\ntags: linux基础 \ncategories: 技术\n---\n前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。\n> elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本\n- Elasticsearch 高可用性，实时索引，拓展简单，接口友好\n- Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表\n- Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据\n- Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据\n- X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索\n\n## elk的初始化\n其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的[docker-elk](https://github.com/deviantony/docker-elk)\n使用git clone git@github.com:deviantony/docker-elk.git后执行docker-compose up,然后我们访问http://localhost:5601,以下是它的端口\n- 5000: Logstash TCP input.\n- 9200: Elasticsearch HTTP\n- 9300: Elasticsearch TCP transport\n- 5601: Kibana\n<!--more-->\n## elk 配置\n我们先配置'elk/logstash/pipeline/logstash.conf'\n```\ninput {\n        beats { #通过这个端口接收filebeat组件发送过来的日志\n                port => 5043\n        }\n}\n## Add your filters / logstash plugins configuration here\nfilter {\n        grok { # 正则形式将无序的日志整理成有序的结构形式\n                match => { \"message\" => \"%{GREEDYDATA:health_Timestamp}\\[%{IPV4:health_IPaddress}\\]\\[-\\]\\[-\\]\\[%{LOGLEVEL:health_LogLevel}\\]\\[%{NOTSPACE:health_Category}\\]%{GREEDYDATA:health_Text}\" } \n        }    \n        geoip { #通过这个可以将ip和地理位置相关联\n                source => \"clientip\"\n        }\n}\noutput { #将日志信息交给elasticsearch处理\n        elasticsearch {\n                hosts => \"elasticsearch:9200\"\n        }\n}\n```\n## filebeat配置\n然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口\n- 现在docker-compose.yml添加filebeat组件\n```\nfilebeat:\n        image: docker.elastic.co/beats/filebeat:6.0.0\n        hostname: filebeat\n        container_name: filebeat\n        restart: always\n        volumes:\n        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml\n        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json\n        - ./api/runtime/logs:/var/logs\n        - ./api/runtime/debug:/var/debug\n        depends_on:\n        - web\n```\n- 接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml\n```\nfilebeat.prospectors:\n- type: log\n  paths:\n      - \"/var/logs/*.log\"\n     #- \"/var/debug/*.data\"\nregistry_file: /etc/registry/mark\n#============================= 将以时间的日志归并为一行 ===============================\n  multiline.pattern: '^[0-9]{4}-[0-9]{2}-[0-9]{2}'\n  multiline.negate: true\n  multiline.match: after\n  multiline.timeout: 10s\nenable: true\n#============================= Filebeat modules ===============================\n#\nfilebeat.config.modules:\n# Glob pattern for configuration loading\n  path: /usr/share/filebeat/modules.d/*.yml\n#\n# Set to true to enable config reloading\nreload.enabled: true\n\noutput:\nlogstash:\nhosts: [\"刚刚配置的elk的ip地址:5043\"]\n\nlogging:\nfiles:\nrotateeverybytes: 10485760 # = 10MB\n```\n\n 参考文章:\n-------------------\n[官网](https://www.elastic.co/cn/products)\n[使用Docker搭建ELK日志系统](http://blog.csdn.net/sysushui/article/details/78461498)\n[ELK---合并多行日志（php.log）](https://www.jianshu.com/p/a980cd121212)\n[docker容器日志集中ELK](https://jicki.me/2016/10/11/docker-elk-filebeat/)\n[filebeat+logstash配置搭建](https://my.oschina.net/openplus/blog/1584861)\n[关于Logstash中grok插件的正则表达式例子](https://www.cnblogs.com/stozen/p/5638369.html)\n[使用Logstash收集PHP相关日志-Linux SA John-51CTO博客](http://blog.51cto.com/john88wang/1641723)\n[Logstash整合Kafka](https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/)\n","slug":"集中式日志管理elk搭建","published":1,"updated":"2018-02-10T09:39:43.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q3t0020to7yd4btvmyj","content":"<p>前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。</p>\n<blockquote>\n<p>elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本</p>\n<ul>\n<li>Elasticsearch 高可用性，实时索引，拓展简单，接口友好</li>\n<li>Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表</li>\n<li>Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据</li>\n<li>Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据</li>\n<li>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索</li>\n</ul>\n</blockquote>\n<h2 id=\"elk的初始化\"><a href=\"#elk的初始化\" class=\"headerlink\" title=\"elk的初始化\"></a>elk的初始化</h2><p>其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的<a href=\"https://github.com/deviantony/docker-elk\" target=\"_blank\" rel=\"noopener\">docker-elk</a><br>使用git clone git@github.com:deviantony/docker-elk.git后执行docker-compose up,然后我们访问<a href=\"http://localhost:5601,以下是它的端口\" target=\"_blank\" rel=\"noopener\">http://localhost:5601,以下是它的端口</a></p>\n<ul>\n<li>5000: Logstash TCP input.</li>\n<li>9200: Elasticsearch HTTP</li>\n<li>9300: Elasticsearch TCP transport</li>\n<li>5601: Kibana<a id=\"more\"></a>\n<h2 id=\"elk-配置\"><a href=\"#elk-配置\" class=\"headerlink\" title=\"elk 配置\"></a>elk 配置</h2>我们先配置’elk/logstash/pipeline/logstash.conf’<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">input &#123;</div><div class=\"line\">        beats &#123; #通过这个端口接收filebeat组件发送过来的日志</div><div class=\"line\">                port =&gt; 5043</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">## Add your filters / logstash plugins configuration here</div><div class=\"line\">filter &#123;</div><div class=\"line\">        grok &#123; # 正则形式将无序的日志整理成有序的结构形式</div><div class=\"line\">                match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;GREEDYDATA:health_Timestamp&#125;\\[%&#123;IPV4:health_IPaddress&#125;\\]\\[-\\]\\[-\\]\\[%&#123;LOGLEVEL:health_LogLevel&#125;\\]\\[%&#123;NOTSPACE:health_Category&#125;\\]%&#123;GREEDYDATA:health_Text&#125;&quot; &#125; </div><div class=\"line\">        &#125;    </div><div class=\"line\">        geoip &#123; #通过这个可以将ip和地理位置相关联</div><div class=\"line\">                source =&gt; &quot;clientip&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">output &#123; #将日志信息交给elasticsearch处理</div><div class=\"line\">        elasticsearch &#123;</div><div class=\"line\">                hosts =&gt; &quot;elasticsearch:9200&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"filebeat配置\"><a href=\"#filebeat配置\" class=\"headerlink\" title=\"filebeat配置\"></a>filebeat配置</h2><p>然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口</p>\n<ul>\n<li><p>现在docker-compose.yml添加filebeat组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">filebeat:</div><div class=\"line\">        image: docker.elastic.co/beats/filebeat:6.0.0</div><div class=\"line\">        hostname: filebeat</div><div class=\"line\">        container_name: filebeat</div><div class=\"line\">        restart: always</div><div class=\"line\">        volumes:</div><div class=\"line\">        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml</div><div class=\"line\">        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json</div><div class=\"line\">        - ./api/runtime/logs:/var/logs</div><div class=\"line\">        - ./api/runtime/debug:/var/debug</div><div class=\"line\">        depends_on:</div><div class=\"line\">        - web</div></pre></td></tr></table></figure>\n</li>\n<li><p>接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">filebeat.prospectors:</div><div class=\"line\">- type: log</div><div class=\"line\">  paths:</div><div class=\"line\">      - &quot;/var/logs/*.log&quot;</div><div class=\"line\">     #- &quot;/var/debug/*.data&quot;</div><div class=\"line\">registry_file: /etc/registry/mark</div><div class=\"line\">#============================= 将以时间的日志归并为一行 ===============================</div><div class=\"line\">  multiline.pattern: &apos;^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&apos;</div><div class=\"line\">  multiline.negate: true</div><div class=\"line\">  multiline.match: after</div><div class=\"line\">  multiline.timeout: 10s</div><div class=\"line\">enable: true</div><div class=\"line\">#============================= Filebeat modules ===============================</div><div class=\"line\">#</div><div class=\"line\">filebeat.config.modules:</div><div class=\"line\"># Glob pattern for configuration loading</div><div class=\"line\">  path: /usr/share/filebeat/modules.d/*.yml</div><div class=\"line\">#</div><div class=\"line\"># Set to true to enable config reloading</div><div class=\"line\">reload.enabled: true</div><div class=\"line\"></div><div class=\"line\">output:</div><div class=\"line\">logstash:</div><div class=\"line\">hosts: [&quot;刚刚配置的elk的ip地址:5043&quot;]</div><div class=\"line\"></div><div class=\"line\">logging:</div><div class=\"line\">files:</div><div class=\"line\">rotateeverybytes: 10485760 # = 10MB</div></pre></td></tr></table></figure>\n<p>参考文章:</p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://www.elastic.co/cn/products\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"http://blog.csdn.net/sysushui/article/details/78461498\" target=\"_blank\" rel=\"noopener\">使用Docker搭建ELK日志系统</a><br><a href=\"https://www.jianshu.com/p/a980cd121212\" target=\"_blank\" rel=\"noopener\">ELK—合并多行日志（php.log）</a><br><a href=\"https://jicki.me/2016/10/11/docker-elk-filebeat/\" target=\"_blank\" rel=\"noopener\">docker容器日志集中ELK</a><br><a href=\"https://my.oschina.net/openplus/blog/1584861\" target=\"_blank\" rel=\"noopener\">filebeat+logstash配置搭建</a><br><a href=\"https://www.cnblogs.com/stozen/p/5638369.html\" target=\"_blank\" rel=\"noopener\">关于Logstash中grok插件的正则表达式例子</a><br><a href=\"http://blog.51cto.com/john88wang/1641723\" target=\"_blank\" rel=\"noopener\">使用Logstash收集PHP相关日志-Linux SA John-51CTO博客</a><br><a href=\"https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/\" target=\"_blank\" rel=\"noopener\">Logstash整合Kafka</a></p>\n","site":{"data":{}},"excerpt":"<p>前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。</p>\n<blockquote>\n<p>elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本</p>\n<ul>\n<li>Elasticsearch 高可用性，实时索引，拓展简单，接口友好</li>\n<li>Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表</li>\n<li>Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据</li>\n<li>Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据</li>\n<li>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索</li>\n</ul>\n</blockquote>\n<h2 id=\"elk的初始化\"><a href=\"#elk的初始化\" class=\"headerlink\" title=\"elk的初始化\"></a>elk的初始化</h2><p>其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的<a href=\"https://github.com/deviantony/docker-elk\" target=\"_blank\" rel=\"noopener\">docker-elk</a><br>使用git clone git@github.com:deviantony/docker-elk.git后执行docker-compose up,然后我们访问<a href=\"http://localhost:5601,以下是它的端口\" target=\"_blank\" rel=\"noopener\">http://localhost:5601,以下是它的端口</a></p>\n<ul>\n<li>5000: Logstash TCP input.</li>\n<li>9200: Elasticsearch HTTP</li>\n<li>9300: Elasticsearch TCP transport</li>\n<li>5601: Kibana","more":"<h2 id=\"elk-配置\"><a href=\"#elk-配置\" class=\"headerlink\" title=\"elk 配置\"></a>elk 配置</h2>我们先配置’elk/logstash/pipeline/logstash.conf’<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">input &#123;</div><div class=\"line\">        beats &#123; #通过这个端口接收filebeat组件发送过来的日志</div><div class=\"line\">                port =&gt; 5043</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">## Add your filters / logstash plugins configuration here</div><div class=\"line\">filter &#123;</div><div class=\"line\">        grok &#123; # 正则形式将无序的日志整理成有序的结构形式</div><div class=\"line\">                match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;GREEDYDATA:health_Timestamp&#125;\\[%&#123;IPV4:health_IPaddress&#125;\\]\\[-\\]\\[-\\]\\[%&#123;LOGLEVEL:health_LogLevel&#125;\\]\\[%&#123;NOTSPACE:health_Category&#125;\\]%&#123;GREEDYDATA:health_Text&#125;&quot; &#125; </div><div class=\"line\">        &#125;    </div><div class=\"line\">        geoip &#123; #通过这个可以将ip和地理位置相关联</div><div class=\"line\">                source =&gt; &quot;clientip&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">output &#123; #将日志信息交给elasticsearch处理</div><div class=\"line\">        elasticsearch &#123;</div><div class=\"line\">                hosts =&gt; &quot;elasticsearch:9200&quot;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n</li>\n</ul>\n<h2 id=\"filebeat配置\"><a href=\"#filebeat配置\" class=\"headerlink\" title=\"filebeat配置\"></a>filebeat配置</h2><p>然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口</p>\n<ul>\n<li><p>现在docker-compose.yml添加filebeat组件</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">filebeat:</div><div class=\"line\">        image: docker.elastic.co/beats/filebeat:6.0.0</div><div class=\"line\">        hostname: filebeat</div><div class=\"line\">        container_name: filebeat</div><div class=\"line\">        restart: always</div><div class=\"line\">        volumes:</div><div class=\"line\">        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml</div><div class=\"line\">        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json</div><div class=\"line\">        - ./api/runtime/logs:/var/logs</div><div class=\"line\">        - ./api/runtime/debug:/var/debug</div><div class=\"line\">        depends_on:</div><div class=\"line\">        - web</div></pre></td></tr></table></figure>\n</li>\n<li><p>接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">filebeat.prospectors:</div><div class=\"line\">- type: log</div><div class=\"line\">  paths:</div><div class=\"line\">      - &quot;/var/logs/*.log&quot;</div><div class=\"line\">     #- &quot;/var/debug/*.data&quot;</div><div class=\"line\">registry_file: /etc/registry/mark</div><div class=\"line\">#============================= 将以时间的日志归并为一行 ===============================</div><div class=\"line\">  multiline.pattern: &apos;^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&apos;</div><div class=\"line\">  multiline.negate: true</div><div class=\"line\">  multiline.match: after</div><div class=\"line\">  multiline.timeout: 10s</div><div class=\"line\">enable: true</div><div class=\"line\">#============================= Filebeat modules ===============================</div><div class=\"line\">#</div><div class=\"line\">filebeat.config.modules:</div><div class=\"line\"># Glob pattern for configuration loading</div><div class=\"line\">  path: /usr/share/filebeat/modules.d/*.yml</div><div class=\"line\">#</div><div class=\"line\"># Set to true to enable config reloading</div><div class=\"line\">reload.enabled: true</div><div class=\"line\"></div><div class=\"line\">output:</div><div class=\"line\">logstash:</div><div class=\"line\">hosts: [&quot;刚刚配置的elk的ip地址:5043&quot;]</div><div class=\"line\"></div><div class=\"line\">logging:</div><div class=\"line\">files:</div><div class=\"line\">rotateeverybytes: 10485760 # = 10MB</div></pre></td></tr></table></figure>\n<p>参考文章:</p>\n</li>\n</ul>\n<hr>\n<p><a href=\"https://www.elastic.co/cn/products\" target=\"_blank\" rel=\"noopener\">官网</a><br><a href=\"http://blog.csdn.net/sysushui/article/details/78461498\" target=\"_blank\" rel=\"noopener\">使用Docker搭建ELK日志系统</a><br><a href=\"https://www.jianshu.com/p/a980cd121212\" target=\"_blank\" rel=\"noopener\">ELK—合并多行日志（php.log）</a><br><a href=\"https://jicki.me/2016/10/11/docker-elk-filebeat/\" target=\"_blank\" rel=\"noopener\">docker容器日志集中ELK</a><br><a href=\"https://my.oschina.net/openplus/blog/1584861\" target=\"_blank\" rel=\"noopener\">filebeat+logstash配置搭建</a><br><a href=\"https://www.cnblogs.com/stozen/p/5638369.html\" target=\"_blank\" rel=\"noopener\">关于Logstash中grok插件的正则表达式例子</a><br><a href=\"http://blog.51cto.com/john88wang/1641723\" target=\"_blank\" rel=\"noopener\">使用Logstash收集PHP相关日志-Linux SA John-51CTO博客</a><br><a href=\"https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/\" target=\"_blank\" rel=\"noopener\">Logstash整合Kafka</a></p>"},{"title":"集群的nginx配置","date":"2018-01-14T16:01:54.000Z","_content":"\n这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。\n按照上篇的惯例，我们先亮出集群nginx配置文件\n## 实例\n``` shell\nuser nobody nobody;\nworker_process 2;\nerror_log /usr/local/webserver/nginx/logs/nginx_error.log crit;\npid /usr/local/webserver/nginx/nginx/pid;\nworker_rlimit_nofile 65535;\nevents\n{\n        use epoll;\n        woreker_connections 65535;\n}\nhttp\n{\n        include mime.types;\n        default_type application/octet-stream;\n        charset utf-8;\n        sendfile on;\n        tcp_nopush on;\n        keepalive_timeout 60;\n        tcp_nodelay on;\n        client_body_buffer_size 512k;\n        proxy_connect_timeout 5;\n        proxy_read_timeout 60;\n        proxy_send_timeout 5;\n        proxy_buffer_size 16k;\n        proxy_buffers 4 16k;\n        proxy_busy_buffers_size 128k;\n        proxy_temp_file_write_size 128k;\n        gzip on;\n        gzip_min_length 1k;\n        gzip_buffers 4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types text/plain application/x-javascript text/css application/xml;\n        gzip_vary on;\n#设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB\n        proxy_temp_file_path /data0/proxy_temp_dir;\n        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m\n        inactive=1d max_size=30g;\n        upstream backend {\n                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;\n        }\n        server\n        {\n                listen 80;\n                server_name myweb;\n                index index.html index.htm;\n                root /data0/htdocs/www;\n                location /\n                {\n                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。\n                        proxy_next_upstream http_502 http_504 error timeout invalid_header;\n                        proxy_cache cache_one;\n                        #针对不同HTTP状态设置不同的缓存时间\n                        proxy_cache_key $host$uri$is_args$args;\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend_server;\n                        expires 1d;\n                }\n                #配置缓存清楚功能\n                location ~ /purge(/.*)\n                {\n                        allow 127.0.0.1;\n                        allow 192.168.0.0/16;\n                        deny all;                \n                        proxy_cache_purge cache_one $host$1$is_args$args;\n                }\n                #配置数据不缓存\n                location ~ .*\\.(php|jpg|cgi)?$\n                {\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend;\n                }\n        }\n}\n```\n<!--more-->\n## 后端服务器组\n### upstream \nupstream backend\n{\n        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高\n        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态\n        server 127.0.0.1:8081 backup; #备用服务器 \n        server 127.0.0.1:8082 down; #永久无效状态 \n        server unix:/tmp/backend3; \n}\nupstream backend2\n{\n        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用\n        server myback1.proxy.com;\n        server myback2.proxy.com;\n        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量\n        last_conn;#选择当前网络连接最少的服务器\n}\n## rewrite功能配置\n### ngx_http_rewrite_module模块\n> 用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求\n\nlast：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行\nlocation / {\n     rewrite ^(/myweb/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last;\n     rewrite ^(/myweb/.*)/audio/(.*)\\.*$ $1/mp3/$2.ra last;\n}\n### 域名跳转\n```\nserver\n{\n        listen 80;\n        server_name jump.myweb.name;\n        rewrite ^ http://www.myweb.info/;#域名跳转\n}\nserver\n{\n        listen 80;\n        server_name jump.myweb.name jump.myweb.info\n        if($host ^ myweb.\\info) #.用\\转义\n        {\n                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转\n        }\n}\nserver\n{\n        listen 80;       \n        server_name jump1.myweb.name jump2.myweb.name;\n        if($http_host ~* ^(.*)\\.myweb\\.name$)\n        {\n                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转\n                break;\n        }\n}\n```\n### 域名镜像\n```\nserver\n{\n        listen 80;\n        server_name mirror1.myweb.name;\n        rewrite ^(.*) http://jump1.myweb.name$1 last;\n}\nserver\n{\n        listen 81;\n        server_name mirror2.myweb.name;\n        rewrite ^(.*) http://jump2.myweb.name$1 last;\n}\n\n```\n### 独立域名\n当一个网站包含多个板块时，可以为某些板块设置独立域名\n```\nserver\n{\n        listen 80;\n        server_name bbs.myweb.name;\n        rewrite ^(.*) http://www.myweb.com/bbs$1 last;\n}\n\n```\n### 防盗链\n```\nlocation ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*\n{\n        valid_referers none blocked server_name *. myweb.name;\n        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片\n        {\n                rewrite ^/ http://www.myweb.com/images/forbidden.png;\n        }\n}\n```\n## 反向代理\n> 局域网向Internet提供局域网内的资源，设置一个代理服务器\n\nproxy_pass URL 设置被代理的服务器\n```\nupstream proxy_svrs\n{\n        ...\n}\nserver\n{\n...\n        location /\n        {\n                proxy_pass proxy_svrs;\n        }\n}\n```\n- proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息\n- proxy_pass_header field;#设置需要发送的头域信息\n- proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器\n- proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器\n- proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器\n- proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器\n- proxy_bind; #强制将代理主机的连接绑定到指定的IP地址\n- proxy_connect_timeout time;#与被代理服务器的连接超时时间\n- proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间\n- proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 \n- proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本\n- proxy_method;#nginx 和代理服务器组的请求方法\n- proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求\n- proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域\n- proxy_redirect; #修改被代理服务器组的Location域和Refresh域\n- proxy_intercept_errors off; #直接返回代理服务器的http状态码\n- proxy_hash_max_size 512; #http报头文的容量上限\n- proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小\n- proxy_next_upstream status;#遵循upstream指令的轮询规则\n- proxy_ssl_session_reuse on;#开启ssl代理间协议\n#### Proxy Buffer\n- proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)\n- proxy_buffers 8 4k; #buffer个数 每个大小\n- proxy_busy_buffers_size 16kb; #busy状态下buffer总大小\n- proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录\n- proxy_max_temp_file_size 1024MB #临时文件总体积上限值\n- proxy_temp_file_write_size 8kb; #数据量总大小限值\n#### Proxy Cache(对已有数据在内存中建立缓存数据)\n- proxy_cache zone | off #设置存放缓存内存区域名字\n- proxy_cache_bypass #向客户端发送数据时不从缓存中获取\n- proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字\n- proxy_cache_lock on#缓存中的数据同时只能被一条请求读取\n- proxy_cache_lock_timeout 5s; #缓存锁的超时时间\n- proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存\n- proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小\n- proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存\n- proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟\n- proxy_store on;#开启本地磁盘缓存数据\n- proxy_store_access user:rw group:rw all:r #配置缓存权限\n### 负载均衡\n> 将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间\n\nupstream backend\n{\n  server 192.168.1.2:80 weight=5 #权限最高\n  server 192.168.1.3:80 weight=2\n  server 192.168.1.4:80          #默认1\n}\n\n\n\n\n\n","source":"_posts/集群的nginx配置.md","raw":"---\ntitle: 集群的nginx配置\ndate: 2018-01-15 00:01:54\ntag: php\ncategories: 技术\n\n---\n\n这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。\n按照上篇的惯例，我们先亮出集群nginx配置文件\n## 实例\n``` shell\nuser nobody nobody;\nworker_process 2;\nerror_log /usr/local/webserver/nginx/logs/nginx_error.log crit;\npid /usr/local/webserver/nginx/nginx/pid;\nworker_rlimit_nofile 65535;\nevents\n{\n        use epoll;\n        woreker_connections 65535;\n}\nhttp\n{\n        include mime.types;\n        default_type application/octet-stream;\n        charset utf-8;\n        sendfile on;\n        tcp_nopush on;\n        keepalive_timeout 60;\n        tcp_nodelay on;\n        client_body_buffer_size 512k;\n        proxy_connect_timeout 5;\n        proxy_read_timeout 60;\n        proxy_send_timeout 5;\n        proxy_buffer_size 16k;\n        proxy_buffers 4 16k;\n        proxy_busy_buffers_size 128k;\n        proxy_temp_file_write_size 128k;\n        gzip on;\n        gzip_min_length 1k;\n        gzip_buffers 4 16k;\n        gzip_http_version 1.1;\n        gzip_comp_level 2;\n        gzip_types text/plain application/x-javascript text/css application/xml;\n        gzip_vary on;\n#设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB\n        proxy_temp_file_path /data0/proxy_temp_dir;\n        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m\n        inactive=1d max_size=30g;\n        upstream backend {\n                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;\n                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;\n        }\n        server\n        {\n                listen 80;\n                server_name myweb;\n                index index.html index.htm;\n                root /data0/htdocs/www;\n                location /\n                {\n                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。\n                        proxy_next_upstream http_502 http_504 error timeout invalid_header;\n                        proxy_cache cache_one;\n                        #针对不同HTTP状态设置不同的缓存时间\n                        proxy_cache_key $host$uri$is_args$args;\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend_server;\n                        expires 1d;\n                }\n                #配置缓存清楚功能\n                location ~ /purge(/.*)\n                {\n                        allow 127.0.0.1;\n                        allow 192.168.0.0/16;\n                        deny all;                \n                        proxy_cache_purge cache_one $host$1$is_args$args;\n                }\n                #配置数据不缓存\n                location ~ .*\\.(php|jpg|cgi)?$\n                {\n                        proxy_set_header Host $host;\n                        proxy_set_header X-Forwarded-For $remote_addr;\n                        proxy_pass http://backend;\n                }\n        }\n}\n```\n<!--more-->\n## 后端服务器组\n### upstream \nupstream backend\n{\n        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高\n        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态\n        server 127.0.0.1:8081 backup; #备用服务器 \n        server 127.0.0.1:8082 down; #永久无效状态 \n        server unix:/tmp/backend3; \n}\nupstream backend2\n{\n        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用\n        server myback1.proxy.com;\n        server myback2.proxy.com;\n        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量\n        last_conn;#选择当前网络连接最少的服务器\n}\n## rewrite功能配置\n### ngx_http_rewrite_module模块\n> 用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求\n\nlast：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行\nlocation / {\n     rewrite ^(/myweb/.*)/media/(.*)\\..*$ $1/mp3/$2.mp3 last;\n     rewrite ^(/myweb/.*)/audio/(.*)\\.*$ $1/mp3/$2.ra last;\n}\n### 域名跳转\n```\nserver\n{\n        listen 80;\n        server_name jump.myweb.name;\n        rewrite ^ http://www.myweb.info/;#域名跳转\n}\nserver\n{\n        listen 80;\n        server_name jump.myweb.name jump.myweb.info\n        if($host ^ myweb.\\info) #.用\\转义\n        {\n                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转\n        }\n}\nserver\n{\n        listen 80;       \n        server_name jump1.myweb.name jump2.myweb.name;\n        if($http_host ~* ^(.*)\\.myweb\\.name$)\n        {\n                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转\n                break;\n        }\n}\n```\n### 域名镜像\n```\nserver\n{\n        listen 80;\n        server_name mirror1.myweb.name;\n        rewrite ^(.*) http://jump1.myweb.name$1 last;\n}\nserver\n{\n        listen 81;\n        server_name mirror2.myweb.name;\n        rewrite ^(.*) http://jump2.myweb.name$1 last;\n}\n\n```\n### 独立域名\n当一个网站包含多个板块时，可以为某些板块设置独立域名\n```\nserver\n{\n        listen 80;\n        server_name bbs.myweb.name;\n        rewrite ^(.*) http://www.myweb.com/bbs$1 last;\n}\n\n```\n### 防盗链\n```\nlocation ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*\n{\n        valid_referers none blocked server_name *. myweb.name;\n        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片\n        {\n                rewrite ^/ http://www.myweb.com/images/forbidden.png;\n        }\n}\n```\n## 反向代理\n> 局域网向Internet提供局域网内的资源，设置一个代理服务器\n\nproxy_pass URL 设置被代理的服务器\n```\nupstream proxy_svrs\n{\n        ...\n}\nserver\n{\n...\n        location /\n        {\n                proxy_pass proxy_svrs;\n        }\n}\n```\n- proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息\n- proxy_pass_header field;#设置需要发送的头域信息\n- proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器\n- proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器\n- proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器\n- proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器\n- proxy_bind; #强制将代理主机的连接绑定到指定的IP地址\n- proxy_connect_timeout time;#与被代理服务器的连接超时时间\n- proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间\n- proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 \n- proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本\n- proxy_method;#nginx 和代理服务器组的请求方法\n- proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求\n- proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域\n- proxy_redirect; #修改被代理服务器组的Location域和Refresh域\n- proxy_intercept_errors off; #直接返回代理服务器的http状态码\n- proxy_hash_max_size 512; #http报头文的容量上限\n- proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小\n- proxy_next_upstream status;#遵循upstream指令的轮询规则\n- proxy_ssl_session_reuse on;#开启ssl代理间协议\n#### Proxy Buffer\n- proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)\n- proxy_buffers 8 4k; #buffer个数 每个大小\n- proxy_busy_buffers_size 16kb; #busy状态下buffer总大小\n- proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录\n- proxy_max_temp_file_size 1024MB #临时文件总体积上限值\n- proxy_temp_file_write_size 8kb; #数据量总大小限值\n#### Proxy Cache(对已有数据在内存中建立缓存数据)\n- proxy_cache zone | off #设置存放缓存内存区域名字\n- proxy_cache_bypass #向客户端发送数据时不从缓存中获取\n- proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字\n- proxy_cache_lock on#缓存中的数据同时只能被一条请求读取\n- proxy_cache_lock_timeout 5s; #缓存锁的超时时间\n- proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存\n- proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小\n- proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存\n- proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟\n- proxy_store on;#开启本地磁盘缓存数据\n- proxy_store_access user:rw group:rw all:r #配置缓存权限\n### 负载均衡\n> 将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间\n\nupstream backend\n{\n  server 192.168.1.2:80 weight=5 #权限最高\n  server 192.168.1.3:80 weight=2\n  server 192.168.1.4:80          #默认1\n}\n\n\n\n\n\n","slug":"集群的nginx配置","published":1,"updated":"2018-02-10T10:15:37.607Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjdkg6q3w0024to7ybh56o3ew","content":"<p>这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。<br>按照上篇的惯例，我们先亮出集群nginx配置文件</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">user nobody nobody;</div><div class=\"line\">worker_process 2;</div><div class=\"line\">error_log /usr/local/webserver/nginx/logs/nginx_error.log crit;</div><div class=\"line\">pid /usr/local/webserver/nginx/nginx/pid;</div><div class=\"line\">worker_rlimit_nofile 65535;</div><div class=\"line\">events</div><div class=\"line\">&#123;</div><div class=\"line\">        use epoll;</div><div class=\"line\">        woreker_connections 65535;</div><div class=\"line\">&#125;</div><div class=\"line\">http</div><div class=\"line\">&#123;</div><div class=\"line\">        include mime.types;</div><div class=\"line\">        default_type application/octet-stream;</div><div class=\"line\">        charset utf-8;</div><div class=\"line\">        sendfile on;</div><div class=\"line\">        tcp_nopush on;</div><div class=\"line\">        keepalive_timeout 60;</div><div class=\"line\">        tcp_nodelay on;</div><div class=\"line\">        client_body_buffer_size 512k;</div><div class=\"line\">        proxy_connect_timeout 5;</div><div class=\"line\">        proxy_read_timeout 60;</div><div class=\"line\">        proxy_send_timeout 5;</div><div class=\"line\">        proxy_buffer_size 16k;</div><div class=\"line\">        proxy_buffers 4 16k;</div><div class=\"line\">        proxy_busy_buffers_size 128k;</div><div class=\"line\">        proxy_temp_file_write_size 128k;</div><div class=\"line\">        gzip on;</div><div class=\"line\">        gzip_min_length 1k;</div><div class=\"line\">        gzip_buffers 4 16k;</div><div class=\"line\">        gzip_http_version 1.1;</div><div class=\"line\">        gzip_comp_level 2;</div><div class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml;</div><div class=\"line\">        gzip_vary on;</div><div class=\"line\">#设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB</div><div class=\"line\">        proxy_temp_file_path /data0/proxy_temp_dir;</div><div class=\"line\">        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m</div><div class=\"line\">        inactive=1d max_size=30g;</div><div class=\"line\">        upstream backend &#123;</div><div class=\"line\">                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;</div><div class=\"line\">                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;</div><div class=\"line\">                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;</div><div class=\"line\">        &#125;</div><div class=\"line\">        server</div><div class=\"line\">        &#123;</div><div class=\"line\">                listen 80;</div><div class=\"line\">                server_name myweb;</div><div class=\"line\">                index index.html index.htm;</div><div class=\"line\">                root /data0/htdocs/www;</div><div class=\"line\">                location /</div><div class=\"line\">                &#123;</div><div class=\"line\">                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。</div><div class=\"line\">                        proxy_next_upstream http_502 http_504 error timeout invalid_header;</div><div class=\"line\">                        proxy_cache cache_one;</div><div class=\"line\">                        #针对不同HTTP状态设置不同的缓存时间</div><div class=\"line\">                        proxy_cache_key $host$uri$is_args$args;</div><div class=\"line\">                        proxy_set_header Host $host;</div><div class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">                        proxy_pass http://backend_server;</div><div class=\"line\">                        expires 1d;</div><div class=\"line\">                &#125;</div><div class=\"line\">                #配置缓存清楚功能</div><div class=\"line\">                location ~ /purge(/.*)</div><div class=\"line\">                &#123;</div><div class=\"line\">                        allow 127.0.0.1;</div><div class=\"line\">                        allow 192.168.0.0/16;</div><div class=\"line\">                        deny all;                </div><div class=\"line\">                        proxy_cache_purge cache_one $host$1$is_args$args;</div><div class=\"line\">                &#125;</div><div class=\"line\">                #配置数据不缓存</div><div class=\"line\">                location ~ .*\\.(php|jpg|cgi)?$</div><div class=\"line\">                &#123;</div><div class=\"line\">                        proxy_set_header Host $host;</div><div class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">                        proxy_pass http://backend;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<a id=\"more\"></a>\n<h2 id=\"后端服务器组\"><a href=\"#后端服务器组\" class=\"headerlink\" title=\"后端服务器组\"></a>后端服务器组</h2><h3 id=\"upstream\"><a href=\"#upstream\" class=\"headerlink\" title=\"upstream\"></a>upstream</h3><p>upstream backend<br>{<br>        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高<br>        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态<br>        server 127.0.0.1:8081 backup; #备用服务器<br>        server 127.0.0.1:8082 down; #永久无效状态<br>        server unix:/tmp/backend3;<br>}<br>upstream backend2<br>{<br>        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用<br>        server myback1.proxy.com;<br>        server myback2.proxy.com;<br>        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量<br>        last_conn;#选择当前网络连接最少的服务器<br>}</p>\n<h2 id=\"rewrite功能配置\"><a href=\"#rewrite功能配置\" class=\"headerlink\" title=\"rewrite功能配置\"></a>rewrite功能配置</h2><h3 id=\"ngx-http-rewrite-module模块\"><a href=\"#ngx-http-rewrite-module模块\" class=\"headerlink\" title=\"ngx_http_rewrite_module模块\"></a>ngx_http_rewrite_module模块</h3><blockquote>\n<p>用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求</p>\n</blockquote>\n<p>last：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行<br>location / {<br>     rewrite ^(/myweb/.<em>)/media/(.</em>)..<em>$ $1/mp3/$2.mp3 last;<br>     rewrite ^(/myweb/.</em>)/audio/(.<em>).</em>$ $1/mp3/$2.ra last;<br>}</p>\n<h3 id=\"域名跳转\"><a href=\"#域名跳转\" class=\"headerlink\" title=\"域名跳转\"></a>域名跳转</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name jump.myweb.name;</div><div class=\"line\">        rewrite ^ http://www.myweb.info/;#域名跳转</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name jump.myweb.name jump.myweb.info</div><div class=\"line\">        if($host ^ myweb.\\info) #.用\\转义</div><div class=\"line\">        &#123;</div><div class=\"line\">                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;       </div><div class=\"line\">        server_name jump1.myweb.name jump2.myweb.name;</div><div class=\"line\">        if($http_host ~* ^(.*)\\.myweb\\.name$)</div><div class=\"line\">        &#123;</div><div class=\"line\">                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"域名镜像\"><a href=\"#域名镜像\" class=\"headerlink\" title=\"域名镜像\"></a>域名镜像</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name mirror1.myweb.name;</div><div class=\"line\">        rewrite ^(.*) http://jump1.myweb.name$1 last;</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 81;</div><div class=\"line\">        server_name mirror2.myweb.name;</div><div class=\"line\">        rewrite ^(.*) http://jump2.myweb.name$1 last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"独立域名\"><a href=\"#独立域名\" class=\"headerlink\" title=\"独立域名\"></a>独立域名</h3><p>当一个网站包含多个板块时，可以为某些板块设置独立域名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name bbs.myweb.name;</div><div class=\"line\">        rewrite ^(.*) http://www.myweb.com/bbs$1 last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*</div><div class=\"line\">&#123;</div><div class=\"line\">        valid_referers none blocked server_name *. myweb.name;</div><div class=\"line\">        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片</div><div class=\"line\">        &#123;</div><div class=\"line\">                rewrite ^/ http://www.myweb.com/images/forbidden.png;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><blockquote>\n<p>局域网向Internet提供局域网内的资源，设置一个代理服务器</p>\n</blockquote>\n<p>proxy_pass URL 设置被代理的服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream proxy_svrs</div><div class=\"line\">&#123;</div><div class=\"line\">        ...</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">...</div><div class=\"line\">        location /</div><div class=\"line\">        &#123;</div><div class=\"line\">                proxy_pass proxy_svrs;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息</li>\n<li>proxy_pass_header field;#设置需要发送的头域信息</li>\n<li>proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器</li>\n<li>proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器</li>\n<li>proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器</li>\n<li>proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器</li>\n<li>proxy_bind; #强制将代理主机的连接绑定到指定的IP地址</li>\n<li>proxy_connect_timeout time;#与被代理服务器的连接超时时间</li>\n<li>proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间</li>\n<li>proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 </li>\n<li>proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本</li>\n<li>proxy_method;#nginx 和代理服务器组的请求方法</li>\n<li>proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求</li>\n<li>proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域</li>\n<li>proxy_redirect; #修改被代理服务器组的Location域和Refresh域</li>\n<li>proxy_intercept_errors off; #直接返回代理服务器的http状态码</li>\n<li>proxy_hash_max_size 512; #http报头文的容量上限</li>\n<li>proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小</li>\n<li>proxy_next_upstream status;#遵循upstream指令的轮询规则</li>\n<li>proxy_ssl_session_reuse on;#开启ssl代理间协议<h4 id=\"Proxy-Buffer\"><a href=\"#Proxy-Buffer\" class=\"headerlink\" title=\"Proxy Buffer\"></a>Proxy Buffer</h4></li>\n<li>proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)</li>\n<li>proxy_buffers 8 4k; #buffer个数 每个大小</li>\n<li>proxy_busy_buffers_size 16kb; #busy状态下buffer总大小</li>\n<li>proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录</li>\n<li>proxy_max_temp_file_size 1024MB #临时文件总体积上限值</li>\n<li>proxy_temp_file_write_size 8kb; #数据量总大小限值<h4 id=\"Proxy-Cache-对已有数据在内存中建立缓存数据\"><a href=\"#Proxy-Cache-对已有数据在内存中建立缓存数据\" class=\"headerlink\" title=\"Proxy Cache(对已有数据在内存中建立缓存数据)\"></a>Proxy Cache(对已有数据在内存中建立缓存数据)</h4></li>\n<li>proxy_cache zone | off #设置存放缓存内存区域名字</li>\n<li>proxy_cache_bypass #向客户端发送数据时不从缓存中获取</li>\n<li>proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字</li>\n<li>proxy_cache_lock on#缓存中的数据同时只能被一条请求读取</li>\n<li>proxy_cache_lock_timeout 5s; #缓存锁的超时时间</li>\n<li>proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存</li>\n<li>proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小</li>\n<li>proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存</li>\n<li>proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟</li>\n<li>proxy_store on;#开启本地磁盘缓存数据</li>\n<li>proxy_store_access user:rw group:rw all:r #配置缓存权限<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><blockquote>\n<p>将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间</p>\n</blockquote>\n</li>\n</ul>\n<p>upstream backend<br>{<br>  server 192.168.1.2:80 weight=5 #权限最高<br>  server 192.168.1.3:80 weight=2<br>  server 192.168.1.4:80          #默认1<br>}</p>\n","site":{"data":{}},"excerpt":"<p>这篇文章是nginx的进阶篇，我会详细梳理集群的nginx配置,包括nginx服务器的反向代理，负载均衡,不过这些都是要先建立后端服务器组。<br>按照上篇的惯例，我们先亮出集群nginx配置文件</p>\n<h2 id=\"实例\"><a href=\"#实例\" class=\"headerlink\" title=\"实例\"></a>实例</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div></pre></td><td class=\"code\"><pre><div class=\"line\">user nobody nobody;</div><div class=\"line\">worker_process 2;</div><div class=\"line\">error_log /usr/local/webserver/nginx/logs/nginx_error.log crit;</div><div class=\"line\">pid /usr/local/webserver/nginx/nginx/pid;</div><div class=\"line\">worker_rlimit_nofile 65535;</div><div class=\"line\">events</div><div class=\"line\">&#123;</div><div class=\"line\">        use epoll;</div><div class=\"line\">        woreker_connections 65535;</div><div class=\"line\">&#125;</div><div class=\"line\">http</div><div class=\"line\">&#123;</div><div class=\"line\">        include mime.types;</div><div class=\"line\">        default_type application/octet-stream;</div><div class=\"line\">        charset utf-8;</div><div class=\"line\">        sendfile on;</div><div class=\"line\">        tcp_nopush on;</div><div class=\"line\">        keepalive_timeout 60;</div><div class=\"line\">        tcp_nodelay on;</div><div class=\"line\">        client_body_buffer_size 512k;</div><div class=\"line\">        proxy_connect_timeout 5;</div><div class=\"line\">        proxy_read_timeout 60;</div><div class=\"line\">        proxy_send_timeout 5;</div><div class=\"line\">        proxy_buffer_size 16k;</div><div class=\"line\">        proxy_buffers 4 16k;</div><div class=\"line\">        proxy_busy_buffers_size 128k;</div><div class=\"line\">        proxy_temp_file_write_size 128k;</div><div class=\"line\">        gzip on;</div><div class=\"line\">        gzip_min_length 1k;</div><div class=\"line\">        gzip_buffers 4 16k;</div><div class=\"line\">        gzip_http_version 1.1;</div><div class=\"line\">        gzip_comp_level 2;</div><div class=\"line\">        gzip_types text/plain application/x-javascript text/css application/xml;</div><div class=\"line\">        gzip_vary on;</div><div class=\"line\">#设置Web缓存区名称为cache_one,内存缓存空间大小为200M,1天清理一次缓存，硬盘缓存空间大小为30GB</div><div class=\"line\">        proxy_temp_file_path /data0/proxy_temp_dir;</div><div class=\"line\">        proxy_cache_path /data0/proxy_cache_dir levels=1:2 keys_zone=cache_one:200m</div><div class=\"line\">        inactive=1d max_size=30g;</div><div class=\"line\">        upstream backend &#123;</div><div class=\"line\">                server 192.168.1.3:80 weight=1 max_fails=2 fail_timeout=30s;</div><div class=\"line\">                server 192.168.1.4:80 weight=1 max_fails=2 fail_timeout=30s;</div><div class=\"line\">                server 192.168.1.5:80 weight=1 max_fails=2 fail_timeout=30s;</div><div class=\"line\">        &#125;</div><div class=\"line\">        server</div><div class=\"line\">        &#123;</div><div class=\"line\">                listen 80;</div><div class=\"line\">                server_name myweb;</div><div class=\"line\">                index index.html index.htm;</div><div class=\"line\">                root /data0/htdocs/www;</div><div class=\"line\">                location /</div><div class=\"line\">                &#123;</div><div class=\"line\">                        #如果后端的服务器返回502,504执行超时等错误，将请求转发到另一台服务器。</div><div class=\"line\">                        proxy_next_upstream http_502 http_504 error timeout invalid_header;</div><div class=\"line\">                        proxy_cache cache_one;</div><div class=\"line\">                        #针对不同HTTP状态设置不同的缓存时间</div><div class=\"line\">                        proxy_cache_key $host$uri$is_args$args;</div><div class=\"line\">                        proxy_set_header Host $host;</div><div class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">                        proxy_pass http://backend_server;</div><div class=\"line\">                        expires 1d;</div><div class=\"line\">                &#125;</div><div class=\"line\">                #配置缓存清楚功能</div><div class=\"line\">                location ~ /purge(/.*)</div><div class=\"line\">                &#123;</div><div class=\"line\">                        allow 127.0.0.1;</div><div class=\"line\">                        allow 192.168.0.0/16;</div><div class=\"line\">                        deny all;                </div><div class=\"line\">                        proxy_cache_purge cache_one $host$1$is_args$args;</div><div class=\"line\">                &#125;</div><div class=\"line\">                #配置数据不缓存</div><div class=\"line\">                location ~ .*\\.(php|jpg|cgi)?$</div><div class=\"line\">                &#123;</div><div class=\"line\">                        proxy_set_header Host $host;</div><div class=\"line\">                        proxy_set_header X-Forwarded-For $remote_addr;</div><div class=\"line\">                        proxy_pass http://backend;</div><div class=\"line\">                &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>","more":"<h2 id=\"后端服务器组\"><a href=\"#后端服务器组\" class=\"headerlink\" title=\"后端服务器组\"></a>后端服务器组</h2><h3 id=\"upstream\"><a href=\"#upstream\" class=\"headerlink\" title=\"upstream\"></a>upstream</h3><p>upstream backend<br>{<br>        server backend1.example weight=5; #组内服务器设置权重，数字越大有限级越高<br>        server 127.0.0.1:8080 max_fails=3 fail_timeout=30s; #1请求失败的次数 2请求组内服务器的时间 #30秒内失败3次该服务器是无效状态<br>        server 127.0.0.1:8081 backup; #备用服务器<br>        server 127.0.0.1:8082 down; #永久无效状态<br>        server unix:/tmp/backend3;<br>}<br>upstream backend2<br>{<br>        ip_hash #实现会话保持功能，将某个客户端定向到同一服务器，保证session,不能和weight一起用<br>        server myback1.proxy.com;<br>        server myback2.proxy.com;<br>        keeyalive 10 #控制网络连接保持功能,保证工作进程为服务器组打开一部分连接，控制数量<br>        last_conn;#选择当前网络连接最少的服务器<br>}</p>\n<h2 id=\"rewrite功能配置\"><a href=\"#rewrite功能配置\" class=\"headerlink\" title=\"rewrite功能配置\"></a>rewrite功能配置</h2><h3 id=\"ngx-http-rewrite-module模块\"><a href=\"#ngx-http-rewrite-module模块\" class=\"headerlink\" title=\"ngx_http_rewrite_module模块\"></a>ngx_http_rewrite_module模块</h3><blockquote>\n<p>用于实现url的重写，依赖PCRE库，是一种地址重写，会产生两次请求</p>\n</blockquote>\n<p>last：终止继续在本location块中处理接收到的URI，并将此处重写的URI作为一个新的URI，使用各location块进行<br>location / {<br>     rewrite ^(/myweb/.<em>)/media/(.</em>)..<em>$ $1/mp3/$2.mp3 last;<br>     rewrite ^(/myweb/.</em>)/audio/(.<em>).</em>$ $1/mp3/$2.ra last;<br>}</p>\n<h3 id=\"域名跳转\"><a href=\"#域名跳转\" class=\"headerlink\" title=\"域名跳转\"></a>域名跳转</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name jump.myweb.name;</div><div class=\"line\">        rewrite ^ http://www.myweb.info/;#域名跳转</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name jump.myweb.name jump.myweb.info</div><div class=\"line\">        if($host ^ myweb.\\info) #.用\\转义</div><div class=\"line\">        &#123;</div><div class=\"line\">                rewrite *(.*) http://jump.myweb.name$1 permanent; #多域名跳转</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;       </div><div class=\"line\">        server_name jump1.myweb.name jump2.myweb.name;</div><div class=\"line\">        if($http_host ~* ^(.*)\\.myweb\\.name$)</div><div class=\"line\">        &#123;</div><div class=\"line\">                rewrite ^(.*) http://jump.myweb.name$1; #三级域名跳转</div><div class=\"line\">                break;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"域名镜像\"><a href=\"#域名镜像\" class=\"headerlink\" title=\"域名镜像\"></a>域名镜像</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name mirror1.myweb.name;</div><div class=\"line\">        rewrite ^(.*) http://jump1.myweb.name$1 last;</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 81;</div><div class=\"line\">        server_name mirror2.myweb.name;</div><div class=\"line\">        rewrite ^(.*) http://jump2.myweb.name$1 last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h3 id=\"独立域名\"><a href=\"#独立域名\" class=\"headerlink\" title=\"独立域名\"></a>独立域名</h3><p>当一个网站包含多个板块时，可以为某些板块设置独立域名<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">        listen 80;</div><div class=\"line\">        server_name bbs.myweb.name;</div><div class=\"line\">        rewrite ^(.*) http://www.myweb.com/bbs$1 last;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<h3 id=\"防盗链\"><a href=\"#防盗链\" class=\"headerlink\" title=\"防盗链\"></a>防盗链</h3><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">location ~* ^.+\\.(gif|jpg|png|swf|flv|rar|zip)*</div><div class=\"line\">&#123;</div><div class=\"line\">        valid_referers none blocked server_name *. myweb.name;</div><div class=\"line\">        if($invalid_referer) #检查请求头部Referer头域是不是自己的站点，如果不是，返回固定图片</div><div class=\"line\">        &#123;</div><div class=\"line\">                rewrite ^/ http://www.myweb.com/images/forbidden.png;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><blockquote>\n<p>局域网向Internet提供局域网内的资源，设置一个代理服务器</p>\n</blockquote>\n<p>proxy_pass URL 设置被代理的服务器<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">upstream proxy_svrs</div><div class=\"line\">&#123;</div><div class=\"line\">        ...</div><div class=\"line\">&#125;</div><div class=\"line\">server</div><div class=\"line\">&#123;</div><div class=\"line\">...</div><div class=\"line\">        location /</div><div class=\"line\">        &#123;</div><div class=\"line\">                proxy_pass proxy_svrs;</div><div class=\"line\">        &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure></p>\n<ul>\n<li>proxy_hide_header field;#用于设置Nginx发送响应时，隐藏头域名信息</li>\n<li>proxy_pass_header field;#设置需要发送的头域信息</li>\n<li>proxy_pass_request_body on | false;# 是否将客户端的请求体发送给代理服务器</li>\n<li>proxy_pass_request_headers on | off; # 是否将客户端的请求头发送给代理服务器</li>\n<li>proxy_set_header field value; #更改接收的客户端请求的请求头信息，将新的请求头发送给被代理服务器</li>\n<li>proxy_set_body value; #更改客户端接收的请求体，将新的请求体发送给服务器</li>\n<li>proxy_bind; #强制将代理主机的连接绑定到指定的IP地址</li>\n<li>proxy_connect_timeout time;#与被代理服务器的连接超时时间</li>\n<li>proxy_read_timeout time;#被代理服务器组read后，等待响应超时时间</li>\n<li>proxy_send_timeout time; #被代理服务器组write后，等待响应超时时间 </li>\n<li>proxy_http_version 1.0|1.1#设置nginx和代理服务器的http协议版本</li>\n<li>proxy_method;#nginx 和代理服务器组的请求方法</li>\n<li>proxy_ignore_client_abort on; #客户端请求中断时，是否中断对被代理服务器的请求</li>\n<li>proxy_ignore_headers field;#nginx收到代理服务器的响应请求后，不会处理被设置的头域</li>\n<li>proxy_redirect; #修改被代理服务器组的Location域和Refresh域</li>\n<li>proxy_intercept_errors off; #直接返回代理服务器的http状态码</li>\n<li>proxy_hash_max_size 512; #http报头文的容量上限</li>\n<li>proxy_headers_hash_bucket_size 64; #http报头文的哈希表容量的单位大小</li>\n<li>proxy_next_upstream status;#遵循upstream指令的轮询规则</li>\n<li>proxy_ssl_session_reuse on;#开启ssl代理间协议<h4 id=\"Proxy-Buffer\"><a href=\"#Proxy-Buffer\" class=\"headerlink\" title=\"Proxy Buffer\"></a>Proxy Buffer</h4></li>\n<li>proxy_buffering on; #开启proxy buffer(存放从代理服务器接收的一次响应数据的临时存放文件,接收完整的一次响应后才发送到客户端)</li>\n<li>proxy_buffers 8 4k; #buffer个数 每个大小</li>\n<li>proxy_busy_buffers_size 16kb; #busy状态下buffer总大小</li>\n<li>proxy_temp_path /nginx/proxy_web/spool/proxy_temp 1 2; #临时文件路径 第几级目录</li>\n<li>proxy_max_temp_file_size 1024MB #临时文件总体积上限值</li>\n<li>proxy_temp_file_write_size 8kb; #数据量总大小限值<h4 id=\"Proxy-Cache-对已有数据在内存中建立缓存数据\"><a href=\"#Proxy-Cache-对已有数据在内存中建立缓存数据\" class=\"headerlink\" title=\"Proxy Cache(对已有数据在内存中建立缓存数据)\"></a>Proxy Cache(对已有数据在内存中建立缓存数据)</h4></li>\n<li>proxy_cache zone | off #设置存放缓存内存区域名字</li>\n<li>proxy_cache_bypass #向客户端发送数据时不从缓存中获取</li>\n<li>proxy_cache_key $scheme$proxy_host$is_args$args #缓存数据建立索引的关键字</li>\n<li>proxy_cache_lock on#缓存中的数据同时只能被一条请求读取</li>\n<li>proxy_cache_lock_timeout 5s; #缓存锁的超时时间</li>\n<li>proxy_cache_min_use 1; #向代理发送相同请求超过几次才缓存</li>\n<li>proxy_cache_path /nginx/cache/a levels=1 keys_zone=a:10m;# 缓存路径 一级目录 缓存内存区域的名称和大小</li>\n<li>proxy_cache_use_stale error | timeout |invalid_header|updating|http_500|http_502#代理服务器出错时访问历史缓存</li>\n<li>proxy_cache_valid 200 302 10m #对返回200和302状态缓存10分钟</li>\n<li>proxy_store on;#开启本地磁盘缓存数据</li>\n<li>proxy_store_access user:rw group:rw all:r #配置缓存权限<h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><blockquote>\n<p>将网络访问平衡地分摊到网络集群的各个操作单元上,减少用户的等待时间</p>\n</blockquote>\n</li>\n</ul>\n<p>upstream backend<br>{<br>  server 192.168.1.2:80 weight=5 #权限最高<br>  server 192.168.1.3:80 weight=2<br>  server 192.168.1.4:80          #默认1<br>}</p>"}],"PostAsset":[],"PostCategory":[{"post_id":"cjdkg6pzt0000to7yt33k4pji","category_id":"cjdkg6q0h0002to7y463n4y0p","_id":"cjdkg6q19000cto7yiy60bjtn"},{"post_id":"cjdkg6q060001to7yshqg0xs8","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q1l000ito7y43hwvcf1"},{"post_id":"cjdkg6q16000bto7yjfxyplbx","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q1p000mto7yixggbd5e"},{"post_id":"cjdkg6q1b000fto7y0ton6svd","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q1s000pto7yfjp0f03d"},{"post_id":"cjdkg6q0n0004to7yl2c0wbj4","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q1w000tto7yk7zits8f"},{"post_id":"cjdkg6q1f000hto7yzn2q7auw","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q21000wto7yvx4wrtjd"},{"post_id":"cjdkg6q1m000lto7y86xrcdmf","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q2a000zto7y1n34ttq2"},{"post_id":"cjdkg6q1q000oto7yz5eab2qx","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q2d0012to7yznrtw4so"},{"post_id":"cjdkg6q1t000sto7yzwrcxt40","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q2h0015to7yrhwtkpdm"},{"post_id":"cjdkg6q27000yto7y2fxs7gwq","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q2k0018to7ycnpj1nj0"},{"post_id":"cjdkg6q2e0014to7yun0kcgfj","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q2y001dto7y3drxxo1r"},{"post_id":"cjdkg6q2i0017to7ysmeczsu1","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q34001gto7ya1mk1glt"},{"post_id":"cjdkg6q2m0019to7y71rkatr0","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q37001kto7ydj4m3eom"},{"post_id":"cjdkg6q2v001cto7ylxmg61nw","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q3a001nto7y0h4uheie"},{"post_id":"cjdkg6q2z001fto7yzb1rzc0c","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q3i001qto7yvnz5cbzq"},{"post_id":"cjdkg6q35001jto7yj7rflc2d","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q3n001tto7yn2qh4g0e"},{"post_id":"cjdkg6q38001mto7ya31nuhjl","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q3r001xto7ysu2pr4xn"},{"post_id":"cjdkg6q3c001pto7yfsat0znc","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q3v0021to7y4nifh2bz"},{"post_id":"cjdkg6q3p001wto7yn672byeh","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q420026to7yaxslhc9f"},{"post_id":"cjdkg6q3t0020to7yd4btvmyj","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q430029to7y49ta14bv"},{"post_id":"cjdkg6q3w0024to7ybh56o3ew","category_id":"cjdkg6q100007to7ycetl75yh","_id":"cjdkg6q43002bto7yrao90er8"},{"post_id":"cjdkg6q3j001sto7ynqe76sni","category_id":"cjdkg6q3s001zto7yewtd16q8","_id":"cjdkg6q44002cto7yg0vreso2"}],"PostTag":[{"post_id":"cjdkg6pzt0000to7yt33k4pji","tag_id":"cjdkg6q0l0003to7ymj1i3dl8","_id":"cjdkg6q120009to7yap094qew"},{"post_id":"cjdkg6q060001to7yshqg0xs8","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q1e000gto7yhpwqgu60"},{"post_id":"cjdkg6q1b000fto7y0ton6svd","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q1l000kto7yd7mvyl4k"},{"post_id":"cjdkg6q0n0004to7yl2c0wbj4","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q1p000nto7y0ohoohu9"},{"post_id":"cjdkg6q1f000hto7yzn2q7auw","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q1t000rto7ybxa17lxr"},{"post_id":"cjdkg6q0q0005to7y5q7evq0s","tag_id":"cjdkg6q1l000jto7yf8u1j6q7","_id":"cjdkg6q1w000uto7yxx5fww42"},{"post_id":"cjdkg6q0y0006to7yprl5ty7z","tag_id":"cjdkg6q1l000jto7yf8u1j6q7","_id":"cjdkg6q2a0010to7yfmec9166"},{"post_id":"cjdkg6q1m000lto7y86xrcdmf","tag_id":"cjdkg6q22000xto7yhpq85hdr","_id":"cjdkg6q2h0016to7yvpzha2tx"},{"post_id":"cjdkg6q1q000oto7yz5eab2qx","tag_id":"cjdkg6q2d0013to7ygf4hqj2d","_id":"cjdkg6q2u001bto7yhcao86h3"},{"post_id":"cjdkg6q2m0019to7y71rkatr0","tag_id":"cjdkg6q22000xto7yhpq85hdr","_id":"cjdkg6q2y001eto7yvsyan9r4"},{"post_id":"cjdkg6q2v001cto7ylxmg61nw","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q35001ito7yl1rj4q6a"},{"post_id":"cjdkg6q1t000sto7yzwrcxt40","tag_id":"cjdkg6q2t001ato7y1ezebxvu","_id":"cjdkg6q38001lto7ynbhyz288"},{"post_id":"cjdkg6q1x000vto7yniem7qb7","tag_id":"cjdkg6q34001hto7yvv9qv3pf","_id":"cjdkg6q3j001rto7yvc90aa0h"},{"post_id":"cjdkg6q38001mto7ya31nuhjl","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q3o001uto7y50z6mbrk"},{"post_id":"cjdkg6q27000yto7y2fxs7gwq","tag_id":"cjdkg6q2t001ato7y1ezebxvu","_id":"cjdkg6q3s001yto7y82lv1bbv"},{"post_id":"cjdkg6q3j001sto7ynqe76sni","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q3w0022to7yigxqmo1z"},{"post_id":"cjdkg6q2a0011to7yun73os3m","tag_id":"cjdkg6q3o001vto7yunvzf30z","_id":"cjdkg6q410025to7yhz5pcqyz"},{"post_id":"cjdkg6q3w0024to7ybh56o3ew","tag_id":"cjdkg6q110008to7ypgydmqy8","_id":"cjdkg6q420027to7yo3fjthse"},{"post_id":"cjdkg6q2e0014to7yun0kcgfj","tag_id":"cjdkg6q3o001vto7yunvzf30z","_id":"cjdkg6q43002ato7yzsdetanz"},{"post_id":"cjdkg6q2i0017to7ysmeczsu1","tag_id":"cjdkg6q430028to7ypkynnfsu","_id":"cjdkg6q45002eto7y8osdnuvb"},{"post_id":"cjdkg6q2z001fto7yzb1rzc0c","tag_id":"cjdkg6q430028to7ypkynnfsu","_id":"cjdkg6q47002gto7yjqrz857q"},{"post_id":"cjdkg6q35001jto7yj7rflc2d","tag_id":"cjdkg6q430028to7ypkynnfsu","_id":"cjdkg6q48002ito7yp35eq60c"},{"post_id":"cjdkg6q3c001pto7yfsat0znc","tag_id":"cjdkg6q430028to7ypkynnfsu","_id":"cjdkg6q4a002kto7yqdc6e5jh"},{"post_id":"cjdkg6q3p001wto7yn672byeh","tag_id":"cjdkg6q48002jto7yc9nzn1es","_id":"cjdkg6q4b002mto7y7c4sn84m"},{"post_id":"cjdkg6q3t0020to7yd4btvmyj","tag_id":"cjdkg6q48002jto7yc9nzn1es","_id":"cjdkg6q4d002nto7y8flgra51"}],"Tag":[{"name":"错误日志","_id":"cjdkg6q0l0003to7ymj1i3dl8"},{"name":"php","_id":"cjdkg6q110008to7ypgydmqy8"},{"name":"技术 php","_id":"cjdkg6q1l000jto7yf8u1j6q7"},{"name":"linux","_id":"cjdkg6q22000xto7yhpq85hdr"},{"name":"工具","_id":"cjdkg6q2d0013to7ygf4hqj2d"},{"name":"编辑器","_id":"cjdkg6q2t001ato7y1ezebxvu"},{"name":"技术","_id":"cjdkg6q34001hto7yvv9qv3pf"},{"name":"devops","_id":"cjdkg6q3o001vto7yunvzf30z"},{"name":"php php扩展 c","_id":"cjdkg6q430028to7ypkynnfsu"},{"name":"linux基础","_id":"cjdkg6q48002jto7yc9nzn1es"}]}}