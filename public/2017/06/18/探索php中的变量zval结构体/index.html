<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Graychen,13780185250@sina.cn"><title>探索php中的变量zval结构体 · Hexo</title><meta name="description" content="变量的类型php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.注意这个php的版本是5.4,最新的php7结构体已经变更"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Hexo</a></h3><div class="description"><p>这个世界需要更多的英雄</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/huashendung"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/1763295797/home?wvr=5"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/Graychen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="assets/blogImg/avatar.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>探索php中的变量zval结构体</a></h3></div><div class="post-content"><h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">struct</span> _zval_struct &#123;</span><br><span class="line">        zvalue_value value; <span class="comment">/* 变量的值 */</span></span><br><span class="line">        zend_uchar type;    <span class="comment">/* 变量当前的数据类型 */</span></span><br><span class="line">        zend_uint refcount__gc;</span><br><span class="line">        zend_uchar is_ref__gc;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> _zval_struct zval;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在Zend/zend_types.h里定义的：</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> zend_uint;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> zend_uchar;</span><br></pre></td></tr></table></figure></p>
<a id="more"></a>
<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> _zvalue_value &#123;</span><br><span class="line">        <span class="keyword">long</span> lval;                  <span class="comment">/* long value */</span></span><br><span class="line">        <span class="keyword">double</span> dval;                <span class="comment">/* double value */</span></span><br><span class="line">        <span class="keyword">struct</span> &#123;</span><br><span class="line">                <span class="keyword">char</span> *val;</span><br><span class="line">                <span class="keyword">int</span> len;</span><br><span class="line">        &#125; str;</span><br><span class="line">        HashTable *ht;              <span class="comment">/* hash table value */</span></span><br><span class="line">        zend_object_value obj;</span><br><span class="line">&#125; zvalue_value;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>PHP中常见的变量类型有：</p>
<ol>
<li>整型/浮点/长整型/bool值 等等</li>
<li>字符串</li>
<li>数组/关联数组</li>
<li>对象</li>
<li>资源</li>
</ol>
</blockquote>
<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">zval.type = IS_LONG;<span class="comment">//整形</span></span><br><span class="line">zval.type = IS_BOOL;<span class="comment">//布尔值</span></span><br></pre></td></tr></table></figure>
<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zval.type = IS_STRING</span><br></pre></td></tr></table></figure>
<p>这个时候，就会取:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zval.value.str</span><br></pre></td></tr></table></figure>
<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">type = IS_RESOURCE</span><br></pre></td></tr></table></figure>
<h2 id="变量类型的实现"><a href="#变量类型的实现" class="headerlink" title="变量类型的实现"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量名称：</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IS_NULL</td>
<td style="text-align:center">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>
</tr>
<tr>
<td style="text-align:left">IS_BOOL</td>
<td style="text-align:center">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>
</tr>
<tr>
<td style="text-align:left">IS_LONG</td>
<td style="text-align:center">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>
</tr>
<tr>
<td style="text-align:left">IS_DOUBLE</td>
<td style="text-align:center">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>
</tr>
<tr>
<td style="text-align:left">IS_STRING</td>
<td style="text-align:center">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>
</tr>
<tr>
<td style="text-align:left">IS_ARRAY</td>
<td style="text-align:center">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>
</tr>
<tr>
<td style="text-align:left">IS_OBJECT</td>
<td style="text-align:center">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>
</tr>
<tr>
<td style="text-align:left">IS_RESOURCE</td>
<td style="text-align:center">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>
</tr>
</tbody>
</table>
<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</span><br><span class="line">        &#123;</span><br><span class="line">                    php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">                    php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, Z_TYPE_P(foo));</span><br><span class="line">                        </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以一个P结尾的宏的参数大多是*zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是**zval。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始定义php语言中的函数gettype</span></span><br><span class="line">PHP_FUNCTION(gettype)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></span><br><span class="line">    <span class="comment">//所以我们要对他使用__PP后缀的宏。</span></span><br><span class="line">    zval **arg;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个if的操作主要是让arg指向参数～</span></span><br><span class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"Z"</span>, &amp;arg) == FAILURE) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">                    </span><br><span class="line">    <span class="comment">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></span><br><span class="line">    <span class="comment">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></span><br><span class="line">    <span class="keyword">switch</span> (Z_TYPE_PP(arg)) &#123;</span><br><span class="line">        <span class="keyword">case</span> IS_NULL:</span><br><span class="line">            RETVAL_STRING(<span class="string">"NULL"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_BOOL:</span><br><span class="line">            RETVAL_STRING(<span class="string">"boolean"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_LONG:</span><br><span class="line">            RETVAL_STRING(<span class="string">"integer"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_DOUBLE:</span><br><span class="line">            RETVAL_STRING(<span class="string">"double"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_STRING:</span><br><span class="line">            RETVAL_STRING(<span class="string">"string"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_ARRAY:</span><br><span class="line">            RETVAL_STRING(<span class="string">"array"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_OBJECT:</span><br><span class="line">            RETVAL_STRING(<span class="string">"object"</span>, <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> IS_RESOURCE:</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> *type_name;</span><br><span class="line">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</span><br><span class="line">            <span class="keyword">if</span> (type_name) &#123;</span><br><span class="line">                RETVAL_STRING(<span class="string">"resource"</span>, <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">                    RETVAL_STRING(<span class="string">"unknown type"</span>, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>
<p>#define Z_TYPE(zval)        (zval).type</p>
<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>
<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>
<h2 id="变量值的实现"><a href="#变量值的实现" class="headerlink" title="变量值的实现"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_value</span><span class="params">(zval zv,zval *zv_p,zval **zv_pp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Z_TYPE(zv) == IS_NULL)</span><br><span class="line">    &#123;</span><br><span class="line">                php_printf(<span class="string">"类型是 IS_NULL!\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</span><br><span class="line">    &#123;</span><br><span class="line">                php_printf(<span class="string">"类型是 IS_LONG，值是：%ld"</span> , Z_LVAL_P(zv_p));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</span><br><span class="line">    &#123;</span><br><span class="line">                php_printf(<span class="string">"类型是 IS_DOUBLE,值是：%f"</span> , Z_DVAL_PP(zv_pp) );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(zval *zstr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</span><br><span class="line">        php_printf(<span class="string">"这个变量不是字符串!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</span><br><span class="line">    <span class="comment">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></span><br><span class="line">&#125;       </span><br><span class="line"> ```       </span><br><span class="line">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</span><br><span class="line">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</span><br><span class="line">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</span><br><span class="line">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</span><br><span class="line">``` c</span><br><span class="line"><span class="comment">//操作整数的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL(zval)            (zval).value.lval</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作IS_BOOL布尔型的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作浮点数的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL(zval)            (zval).value.dval</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作字符串的值和长度的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作对象的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \</span></span><br><span class="line">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \</span><br><span class="line">                                                (is_tmp=<span class="number">0</span>,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):<span class="literal">NULL</span>)) </span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//操作资源的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL(zval)          (zval).value.lval</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></span><br><span class="line">```     </span><br><span class="line">#<span class="meta"># php的类型转换</span></span><br><span class="line">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</span><br><span class="line">``` c</span><br><span class="line"><span class="comment">//将任意类型的zval转换成字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_zval_to_string</span><span class="params">(zval *value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">        convert_to_string(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其它基本的类型转换函数</span></span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_long</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_double</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_null</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_boolean</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_array</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_object</span><span class="params">(zval *op)</span></span>;</span><br><span class="line"></span><br><span class="line">ZEND_API <span class="keyword">void</span> _convert_to_string(zval *op ZEND_FILE_LINE_DC);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> convert_to_string(op) <span class="meta-keyword">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-06-18</span><i class="fa fa-tag"></i><a class="tag" href="/categories/技术/" title="技术">技术 </a><a class="tag" href="/tags/php-php扩展-c/" title="php php扩展 c">php php扩展 c </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2017/06/18/探索php中的变量zval结构体/,Hexo,探索php中的变量zval结构体,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a class="btn" role="navigation" href="/2017/06/20/探索php中的变量zval结构体二/" title="探索php中的变量zval结构体二">上一篇</a></li><li class="next pagbuttons"><a class="btn" role="navigation" href="/2017/06/18/如何编写测试/" title="Codeception测试框架如何编写测试">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>