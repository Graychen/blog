<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <title>Graychen的博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="这片海域最自由的人才是海贼王,我是要成为海贼王的男人。">
<meta property="og:type" content="website">
<meta property="og:title" content="Graychen的博客">
<meta property="og:url" content="http://graychen.git.io/index.html">
<meta property="og:site_name" content="Graychen的博客">
<meta property="og:description" content="这片海域最自由的人才是海贼王,我是要成为海贼王的男人。">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Graychen的博客">
<meta name="twitter:description" content="这片海域最自由的人才是海贼王,我是要成为海贼王的男人。">
  
    <link rel="alternative" href="/atom.xml" title="Graychen的博客" type="application/atom+xml">
  
  
    <link rel="icon" href="//favicon.png">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="/assets/blogImg/avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Graychen</a></h1>
		</hgroup>

		
		<p class="header-subtitle">这个世界需要更多的英雄</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
						<div class="icon-wrap icon-me hide" data-idx="3">
							<div class="user"></div>
							<div class="shoulder"></div>
						</div>
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>Menu</li>
						<li>Tags</li>
						
						
						<li>Über</li>
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/categories/随笔">随笔</a></li>
				        
							<li><a href="/categories/技术">技术文章</a></li>
				        
							<li><a href="/categories/错误日志">错误日志</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/Graychen" title="github">github</a>
					        
								<a class="weibo" target="_blank" href="http://weibo.com/u/5508881293/home?topnav=1&wvr=6" title="weibo">weibo</a>
					        
								<a class="twitter" target="_blank" href="https://twitter.com/huashendung" title="twitter">twitter</a>
					        
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/linux/" style="font-size: 13.33px;">linux</a> <a href="/tags/linux基础/" style="font-size: 10px;">linux基础</a> <a href="/tags/php/" style="font-size: 20px;">php</a> <a href="/tags/php-php扩展-c/" style="font-size: 16.67px;">php php扩展 c</a> <a href="/tags/工具/" style="font-size: 10px;">工具</a> <a href="/tags/编辑器/" style="font-size: 13.33px;">编辑器</a> <a href="/tags/错误日志/" style="font-size: 10px;">错误日志</a>
					</div>
				</section>
				
				
				

				
				
				<section class="switch-part switch-part3">
				
					<div id="js-aboutme">我是谁，我从哪里来，我到哪里去？我就是我，是颜色不一样的吃货…</div>
				</section>
				
			</div>
		</div>
	</header>				
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Graychen</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="/assets/blogImg/avatar.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
				
			</div>
			<hgroup>
			  <h1 class="header-author">Graychen</h1>
			</hgroup>
			
			<p class="header-subtitle">这个世界需要更多的英雄</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/categories/随笔">随笔</a></li>
		        
					<li><a href="/categories/技术">技术文章</a></li>
		        
					<li><a href="/categories/错误日志">错误日志</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/Graychen" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="http://weibo.com/u/5508881293/home?topnav=1&wvr=6" title="weibo">weibo</a>
			        
						<a class="twitter" target="_blank" href="https://twitter.com/huashendung" title="twitter">twitter</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
  
    <article id="post-yii2-queue队列的使用说明" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/28/yii2-queue队列的使用说明/" class="article-date">
  	<time datetime="2017-07-28T04:15:36.000Z" itemprop="datePublished">2017-07-28</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/28/yii2-queue队列的使用说明/">yii2-queue队列的使用说明</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>yii2-queue是一个yii官方推出的队列扩展库，主要通过队列异步运行任务，它支持基于DB，Redis，RabbitMQ，Beanstalk和Gearman的队列。</p>
<h2 id="来源"><a href="#来源" class="headerlink" title="来源"></a>来源</h2><ul>
<li><a href="https://github.com/yiisoft/yii2-queue" target="_blank" rel="external">github</a></li>
<li><a href="https://packagist.org/packages/yiisoft/yii2-queue" target="_blank" rel="external">packaglist</a></li>
</ul>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer <span class="keyword">require</span> yiisoft/yii2-queue</div></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">在composer中添加<span class="string">"yiisoft/yii2-queue"</span>: <span class="string">"~2.0.0"</span>,然后持续composer install</div></pre></td></tr></table></figure>
<h2 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h2><p>发送到队列的每个任务应该被定义为一个单独的类。例如，如果您需要下载并保存文件，则该类可能如下所示：<br>下面的例子以redis作为驱动，<a href="https://github.com/yiisoft/yii2-queue/blob/master/docs/guide/README.md" target="_blank" rel="external">其它驱动</a><br>首先我们配置redis的驱动，注意如果没有yiisoft/yii2-redis包的话要先执行composer require yiisoft/yii2-redis,再在/common/config/<br>注意要为queue配置一个queue的redis配置<br><figure class="highlight plain"><figcaption><span>[</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">&apos;bootstrap&apos; =&gt; [</div><div class="line">        &apos;queue&apos;, // The component registers own console commands</div><div class="line">],</div><div class="line">&apos;compoents&apos; =&gt; [</div><div class="line">    ...//其它的配置</div><div class="line">    &apos;redis_queue&apos; =&gt; [</div><div class="line">        &apos;class&apos; =&gt; &apos;yii\redis\Connection&apos;,</div><div class="line">        &apos;hostname&apos; =&gt; &apos;redis&apos;,</div><div class="line">        &apos;port&apos; =&gt; &apos;6379&apos;,</div><div class="line">        &apos;database&apos; =&gt; 0,</div><div class="line">    ],</div><div class="line">    &apos;queue&apos; =&gt; [</div><div class="line">        &apos;class&apos; =&gt; \yii\queue\redis\Queue::class,</div><div class="line">        &apos;redis&apos; =&gt; &apos;redis2&apos;, // Redis connection component or its config</div><div class="line">        &apos;channel&apos; =&gt; &apos;queue&apos;, // Queue channel key</div><div class="line">        &apos;as log&apos; =&gt; \yii\queue\LogBehavior::class</div><div class="line">    ],</div><div class="line">]</div></pre></td></tr></table></figure></p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">DownloadJob</span> <span class="keyword">extends</span> <span class="title">Object</span> <span class="keyword">implements</span> \<span class="title">yii</span>\<span class="title">queue</span>\<span class="title">Job</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">public</span> $url;</div><div class="line">    <span class="keyword">public</span> $file;</div><div class="line">                </div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">execute</span><span class="params">($queue)</span></span></div><div class="line">    &#123;</div><div class="line">        file_put_contents(<span class="keyword">$this</span>-&gt;file, file_get_contents(<span class="keyword">$this</span>-&gt;url));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以下是将任务发送到队列中的方法：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Yii::$app-&gt;queue-&gt;push(<span class="keyword">new</span> DownloadJob([</div><div class="line">    <span class="string">'url'</span> =&gt; <span class="string">'http://example.com/image.jpg'</span>,</div><div class="line">    <span class="string">'file'</span> =&gt; <span class="string">'/tmp/image.jpg'</span>,</div><div class="line">]));</div></pre></td></tr></table></figure>
<p>将作业推入5分钟后运行的队列：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Yii::$app-&gt;queue-&gt;delay(<span class="number">5</span> * <span class="number">60</span>)-&gt;push(<span class="keyword">new</span> DownloadJob([</div><div class="line">    <span class="string">'url'</span> =&gt; <span class="string">'http://example.com/image.jpg'</span>,</div><div class="line">    <span class="string">'file'</span> =&gt; <span class="string">'/tmp/image.jpg'</span>,</div><div class="line">]));</div></pre></td></tr></table></figure>
<p>执行任务的方式取决于所使用的驱动程序。大部分的驱动程序可以使用控制台命令运行，组件应该在应用程序中注册。<br>在循环中获取并执行任务的命令，直到队列为空：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yii queue/run</div></pre></td></tr></table></figure>
<p>命令启动一个无限查询队列的守护程序：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">yii queue/listen</div></pre></td></tr></table></figure>
<p>该组件具有跟踪被推入队列的作业的状态的能力。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">//将作业推入队列并获取按摩ID。</span></div><div class="line">$id = Yii::$app-&gt;queue-&gt;push(<span class="keyword">new</span> SomeJob());</div><div class="line"></div><div class="line"><span class="comment">//工作正在等待执行。</span></div><div class="line">Yii::$app-&gt;queue-&gt;isWaiting($id);</div><div class="line"></div><div class="line"><span class="comment">// Worker从队列中获取作业并执行它。</span></div><div class="line">Yii::$app-&gt;queue-&gt;isReserved($id);</div><div class="line"></div><div class="line"><span class="comment">// Worker已经执行了这个工作。</span></div><div class="line">Yii::$app-&gt;queue-&gt;isDone($id);</div></pre></td></tr></table></figure>
<h2 id="使用Supervisor管理php-yii-queue-listen"><a href="#使用Supervisor管理php-yii-queue-listen" class="headerlink" title="使用Supervisor管理php yii queue/listen"></a>使用Supervisor管理php yii queue/listen</h2><p>Supervisor是Linux的进程监视器。它会自动启动您的控制台进程。要在Ubuntu上安装，您需要运行命令：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install supervisor</div></pre></td></tr></table></figure></p>
<p>主管配置文件通常可用/etc/supervisor/conf.d。您可以创建任意数量的配置文件。<br>配置示例:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">[program:yii-queue-worker]</div><div class="line">process_name=%(program_name)s_%(process_num)<span class="number">02</span>d</div><div class="line">command=/usr/bin/php /<span class="keyword">var</span>/www/my_project/yii queue/listen --verbose=<span class="number">1</span> --color=<span class="number">0</span></div><div class="line">autostart=<span class="keyword">true</span></div><div class="line">autorestart=<span class="keyword">true</span></div><div class="line">user=www-data</div><div class="line">numprocs=<span class="number">4</span></div><div class="line">redirect_stderr=<span class="keyword">true</span></div><div class="line">stdout_logfile=/<span class="keyword">var</span>/www/my_project/log/yii-queue-worker.log</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/编辑器/">编辑器</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-docker中使用supervisor" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/07/25/docker中使用supervisor/" class="article-date">
  	<time datetime="2017-07-25T15:04:46.000Z" itemprop="datePublished">2017-07-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/07/25/docker中使用supervisor/">docker中使用supervisor管理队列</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Supervisor<a href="http://supervisord.org" target="_blank" rel="external">链接</a> 是一个用 Python 写的进程管理工具，可以很方便的用来启动、重启、关闭进程（不仅仅是 Python 进程）。除了对单个进程的控制，还可以同时启动、关闭多个进程，比如很不幸的服务器出问题导致所有应用程序都被杀死，此时可以用 supervisor 同时启动所有应用程序而不是一个一个地敲命令启动。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Supervisor 可以运行在 Linux、Mac OS X 上。如前所述，supervisor 是 Python 编写的，所以安装起来也很方便，可以直接用 pip : sudo pip install supervisor<br> 如果是 Ubuntu 系统，还可以使用 apt-get install supervisor 安装,由于我们的容器是alpine系统,所以可以在Dockerfile里添加<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RUN apk add supervisor</div></pre></td></tr></table></figure></p>
<p>这样容器就可以安装superviosr</p>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>然后在docker的服务目录services里创建supervisor目录，创建supervisor.conf文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">[supervisord]</div><div class="line">nodaemon=true</div><div class="line">[program:mqtt-server]</div><div class="line">directory = /var/www/html ;</div><div class="line">command = php yii queue/listen</div><div class="line">autostart = true</div><div class="line">startsecs = 5</div><div class="line">autorestart = true</div><div class="line">startretries = 10</div><div class="line">redirect_stderr=true</div><div class="line">stdout_logfile = /var/www/html/yii-queue-worker.log</div></pre></td></tr></table></figure>
<p>然后在Dockerfile-web-volumes里面添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- ./services/supervisor:/etc/supervisor/conf.d</div></pre></td></tr></table></figure>
<p>以此将本地的配置文件映射到docker容器里面的supervisor的默认配置文件</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><blockquote>
<p>本来我的想法是在Dockerfile里面直接添加<code>ENTRYPOINT [&#39;/usr/bin/supervisord&#39;,&#39;-c&#39;,&#39;/etc/supervisor/conf.d&#39;]</code>,想在docker build的时候直接启动supervisor管理队列，但是我的队列是其余redis的，运行到这一步的时候redis的docker还没有启动，导致我的页面一直502，虽然supervisor启动了，但是队列的redis驱动还没有启动，所以选择了折中的方法。<code>注意，如果队列基于其它driver的可以这样直接运行的</code></p>
</blockquote>
<p>折中的方案是在.gitlab-ci.yml文件中的<strong>testing-server:</strong>-&gt; <strong>script:</strong>和<strong>staging-server:</strong>-&gt;<strong>script:</strong>下分别添加<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">- ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME /usr/bin/supervisord -c /etc/supervisor/conf.d/supervisord.conf &amp;&gt;/dev/null&amp;&quot;</div></pre></td></tr></table></figure></p>
<p>这样的方式是在部署的时候在启动supervisord,想当于在docker启动后在启动supervisord这个软件，这样就可以实现监听队列了<br>然后将docker-compose.yml和目录supervisor复制到deploy目录里的production,staging,testing三个目录里面</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-php的并发io" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/25/php的并发io/" class="article-date">
  	<time datetime="2017-06-25T15:04:46.000Z" itemprop="datePublished">2017-06-25</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/25/php的并发io/">php的并发io</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>计算领域一直是分为计算密集和IO密集型，web程序一直是io密集型，从最早的同步阻塞直接Fork进程，到Worker进程池，到现在的异步IO协程，io一直是服务器的难点，下面文章，将详细解析php的并发io问题。</p>
<h2 id="多进程-多线程同步阻塞"><a href="#多进程-多线程同步阻塞" class="headerlink" title="多进程/多线程同步阻塞"></a>多进程/多线程同步阻塞</h2><p>最早的服务器端都是通过多进程来解决IO的问题,通过Accept一个客户端连接就创建一个进程，然后子进程进入循环同步阻塞与客户端进行交互，收发数据。<br> <img src="/assets/blogImg/manyporcess.png" alt="&quot;我是傲娇的效果图&quot;"><br>因为线程之间是共享内存堆栈,所以不同的线程之间进行交互比较容易实现。比如聊天室这样的程序，客户端连接之间可以交互，比聊天室中的玩家可以任意的其他人发消息。用多线程模式实现非常简单，线程中可以直接向某一个客户端连接发送数据。而多进程模式就要用到管道、消息队列、共享内存，统称进程间通信（IPC）复杂的技术才能实现。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$serv = stream_socket_server(<span class="string">"tcp://0.0.0.0.8000"</span>,$errno,$errstr) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"create server failed"</span>);</div><div class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">        $conn = stream_socket_accept($serv);</div><div class="line">        <span class="keyword">if</span>(pcntl_fork() ==<span class="number">0</span>) &#123;</div><div class="line">                $request = fread($conn);</div><div class="line">                fwite($repose);</div><div class="line">                fclose($conn);</div><div class="line">                <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="多进程-线程模型的流程"><a href="#多进程-线程模型的流程" class="headerlink" title="多进程/线程模型的流程"></a>多进程/线程模型的流程</h2><p>1创建一个 socket，绑定服务器端口（bind），监听端口（listen），在PHP中用stream_socket_server一个函数就能完成上面3个步骤，当然也可以使用更底层的sockets扩展分别实现<br>2进入while循环，阻塞在accept操作上，等待客户端连接进入。此时程序会进入随眠状态，直到有新的客户端发起connect到服务器，操作系统会唤醒此进程。accept函数返回客户端连接的socket<br>3主进程在多进程模型下通过fork（php: pcntl_fork）创建子进程，多线程模型下使用pthread_create（php: new Thread）创建子线程。下文如无特殊声明将使用进程同时表示进程/线程。<br>4子进程创建成功后进入while循环，阻塞在recv（php: fread）调用上，等待客户端向服务器发送数据。收到数据后服务器程序进行处理然后使用send（php: fwrite）向客户端发送响应。长连接的服务会持续与客户端交互，而短连接服务一般收到响应就会close。<br>5当客户端连接关闭时，子进程退出并销毁所有资源。主进程会回收掉此子进程。<br><strong>这种模式最大的问题是，进程/线程创建和销毁的开销很大。所以上面的模式没办法应用于非常繁忙的服务器程序。对应的改进版解决了此问题，这就是经典的Leader-Follower模型。</strong><br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$serv = stream_socket_server(<span class="string">"tcp://0.0.0.0:8000"</span>,$error,$errstr) <span class="keyword">or</span> <span class="keyword">die</span>(<span class="string">"create server failed"</span>);</div><div class="line"><span class="keyword">for</span>($i=<span class="number">0</span>; $i&lt; <span class="number">32</span>;$i++)&#123;</div><div class="line">        <span class="keyword">if</span> (pcntl_fork() == <span class="number">0</span> )&#123;</div><div class="line">                <span class="keyword">while</span>(<span class="number">1</span>) &#123;</div><div class="line">                        $conn = stream_socket_accept($serv);</div><div class="line">                        <span class="keyword">if</span>($conn == <span class="keyword">false</span>) <span class="keyword">continue</span>;</div><div class="line">                        $request = fread($conn);</div><div class="line">                        fwrite($reponse);</div><div class="line">                        fclose($conn);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">exit</span>(<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>他的特点是程序启动后就会创建N个进程。每个子进程就会进入Accept,等待新的连接进入。当客户端连接到服务器时，其中一个子进程就会被唤醒，开始处理客户端请求，并且不再接受新的TCP连接。当连接关闭，子进程才会释放，重新进入Accept,参与处理新的连接。<br>优点:复用进程，没有额外消耗，性能好。应用案例：Apache.PHP-FPM<br>缺点：严重依赖初始创建的进程数，操作系统可以创建的进程数有限。进程带来额外的进程调度，如果启动数千甚至数万个进程，消耗就会直线上升。调度消耗可能占到CPU的百分之几十甚至100%。<br>还有一种场景也是多进程模型的软肋。通常Web服务器启动100个进程，如果一个请求消耗100ms，100个进程可以提供1000qps，这样的处理能力还是不错的。但是如果请求内要调用外网Http接口，像QQ、微博登录，耗时会很长，一个请求需要10s。那一个进程1秒只能处理0.1个请求，100个进程只能达到10qps，这样的处理能力就太差了。</p>
<p>有没有一种技术可以在一个进程内处理所有并发IO呢？答案是有，这就是IO复用技术。</p>
<h2 id="IO复用-事件循环-异步非阻塞"><a href="#IO复用-事件循环-异步非阻塞" class="headerlink" title="IO复用/事件循环/异步非阻塞"></a>IO复用/事件循环/异步非阻塞</h2><p>其实IO复用的历史和多进程一样长，Linux很早就提供了select系统调用，可以在一个进程内维持1024个连接。后来又加入了poll系统调用，poll做了一些改进，解决了1024限制的问题，可以维持任意数量的连接。但select/poll还有一个问题就是，它需要循环检测连接是否有事件。这样问题就来了，如果服务器有100万个连接，在某一时间只有一个连接向服务器发送了数据，select/poll需要做循环100万次，其中只有1次是命中的，剩下的99万9999次都是无效的，白白浪费了CPU资源。<br>直到Linux 2.6内核提供了新的epoll系统调用，可以维持无限数量的连接，而且无需轮询，这才真正解决了C10K问题。现在各种高并发异步IO的服务器程序都是基于epoll实现的，比如Nginx、Node.js、Erlang、Golang。像Node.js这样单进程单线程的程序，都可以维持超过1百万TCP连接，全部归功于epoll技术。<br>IO复用异步非阻塞程序使用经典的Reactor模型，Reactor顾名思义就是反应堆的意思，它本身不处理任何数据收发。只是可以监视一个socket句柄的事件变化。<br> <img src="/assets/blogImg/reactor.png" alt="&quot;我是傲娇的效果图&quot;"><br> Reactor有4个核心的操作：<br> add添加socket监听到reactor，可以是listen socket也可以使客户端socket，也可以是管道、eventfd、信号等<br> set修改事件监听，可以设置监听的类型，如可读、可写。可读很好理解，对于listen socket就是有新客户端连接到来了需要accept。对于客户端连接就是收到数据，需要recv。可写事件比较难理解一些。一个SOCKET是有缓存区的，如果要向客户端连接发送2M的数据，一次性是发不出去的，操作系统默认TCP缓存区只有256K。一次性只能发256K，缓存区满了之后send就会返回EAGAIN错误。这时候就要监听可写事件，在纯异步的编程中，必须去监听可写才能保证send操作是完全非阻塞的。<br> del从reactor中移除，不再监听事件<br> callback就是事件发生后对应的处理逻辑，一般在add/set时制定。C语言用函数指针实现，JS可以用匿名函数，PHP可以用匿名函数、对象方法数组、字符串函数名。<br> Reactor只是一个事件发生器，实际对socket句柄的操作，如connect/accept、send/recv、close是在callback中完成的。具体编码可参考下面的伪代码：<br> <figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"> <span class="meta">&lt;?php</span></div><div class="line"> $reactor=<span class="keyword">new</span> Reactor();</div><div class="line"> $svr_sock=stream_socket_server(<span class="string">'tcp://127.0.0.1:9501'</span>);</div><div class="line"> $reactor-&gt;add($svr_sock,EV_READ,<span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($svr_sock,$reactor)</span></span>&#123;</div><div class="line">         $cli_sock = stream_socket_accept($svr_sock);</div><div class="line">         $reactor-&gt;add($cli_sock,EV_READ,<span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($cli_sock,$reactor)</span></span>&#123;</div><div class="line">                 $request = fread($cli_sock,<span class="number">8192</span>);</div><div class="line">                 $reactor-&gt;add($cli_sock,EV_WRITE,<span class="function"><span class="keyword">function</span><span class="params">()</span> <span class="title">use</span> <span class="params">($cli_sock,$request,$reactor)</span></span>&#123;</div><div class="line">                         fwrite($cli_sock,<span class="string">"hello world\n"</span>);</div><div class="line">                         $reactor-&gt;del($cli_sock);</div><div class="line">                         fclose($cli_sock);</div><div class="line">                 &#125;);</div><div class="line">         &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<blockquote>
<p>Reactor模型还可以与多进程、多线程结合起来用，既实现异步非阻塞IO，又利用到多核。目前流行的异步服务器程序都是这样的方式：如<br> Nginx：多进程Reactor<br> Nginx+Lua：多进程Reactor+协程<br> Golang：单线程Reactor+多线程协程<br> Swoole：多线程Reactor+多进程Worker</p>
</blockquote>
<p> 协程是什么<br> 协程从底层技术角度看实际上还是异步IO Reactor模型，应用层自行实现了任务调度，借助Reactor切换各个当前执行的用户态线程，但用户代码中完全感知不到Reactor的存在</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title=" 参考文章:"></a> 参考文章:</h2><p><a href="http://rango.swoole.com/archives/508" target="_blank" rel="external">PHP并发IO编程之路</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-压力测试，压力山大" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/21/压力测试，压力山大/" class="article-date">
  	<time datetime="2017-06-21T12:09:31.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/压力测试，压力山大/">压力测试，压力山大</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>压力测试的基本概念</p>
<h3 id="吞吐率（Requests-per-second）"><a href="#吞吐率（Requests-per-second）" class="headerlink" title="吞吐率（Requests per second）"></a>吞吐率（Requests per second）</h3><p>概念：服务器并发处理能力的量化描述，单位是reqs/s，指的是某个并发用户数下单位时间内处理的请求数。某个并发用户数下单位时间内能处理的最大请求数，称之为最大吞吐率。<br>计算公式：总请求数 / 处理完成这些请求数所花费的时间，即<br>Request per second = Complete requests / Time taken for tests</p>
<h3 id="并发连接数（The-number-of-concurrent-connections）"><a href="#并发连接数（The-number-of-concurrent-connections）" class="headerlink" title="并发连接数（The number of concurrent connections）"></a>并发连接数（The number of concurrent connections）</h3><p>概念：某个时刻服务器所接受的请求数目，简单的讲，就是一个会话。</p>
<h3 id="并发用户数（The-number-of-concurrent-users，Concurrency-Level）"><a href="#并发用户数（The-number-of-concurrent-users，Concurrency-Level）" class="headerlink" title="并发用户数（The number of concurrent users，Concurrency Level）"></a>并发用户数（The number of concurrent users，Concurrency Level）</h3><p>概念：要注意区分这个概念和并发连接数之间的区别，一个用户可能同时会产生多个会话，也即连接数。</p>
<h3 id="用户平均请求等待时间（Time-per-request）"><a href="#用户平均请求等待时间（Time-per-request）" class="headerlink" title="用户平均请求等待时间（Time per request）"></a>用户平均请求等待时间（Time per request）</h3><p>计算公式：处理完成所有请求数所花费的时间/ （总请求数 / 并发用户数），即<br>Time per request = Time taken for tests /（ Complete requests / Concurrency Level）</p>
<h3 id="服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）"><a href="#服务器平均请求等待时间（Time-per-request-across-all-concurrent-requests）" class="headerlink" title="服务器平均请求等待时间（Time per request: across all concurrent requests）"></a>服务器平均请求等待时间（Time per request: across all concurrent requests）</h3><p>计算公式：处理完成所有请求数所花费的时间 / 总请求数，即<br>Time taken for / testsComplete requests<br>可以看到，它是吞吐率的倒数。<br>同时，它也=用户平均请求等待时间/并发用户数，即<br>Time per request / Concurrency Level</p>
<h3 id="压力测试工具"><a href="#压力测试工具" class="headerlink" title="压力测试工具"></a>压力测试工具</h3><h2 id="ab"><a href="#ab" class="headerlink" title="ab"></a>ab</h2><p>ab工具简介<br>ab全称为：apache bench<br>在官网上的解释如下：<br>ab是Apache超文本传输协议(HTTP)的性能测试工具。其设计意图是描绘当前所安装的Apache的执行性能，主要是显示你安装的Apache每秒可以处理多少个请求。<br>开始测试:<br>输入命令<br><code>ab -n 100 -c 10 https://www.baidu.com/</code></p>
<blockquote>
<p>其中－n表示请求数，－c表示并发数</p>
</blockquote>
<p>测试结果分析<br>上面的命令运行完毕后就出来测试报告了<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">graychen@graychen-VPCEG27YC:/blog$ ab -n 100 -c 10 https://www.baidu.com/</div><div class="line">This is ApacheBench, Version 2.3 &lt;<span class="variable">$Revision</span>: 1706008 $&gt;</div><div class="line">Copyright 1996 Adam Twiss, Zeus Technology Ltd, http://www.zeustech.net/</div><div class="line">Licensed to The Apache Software Foundation, http://www.apache.org/</div><div class="line"></div><div class="line">Benchmarking www.baidu.com (be patient).....done</div><div class="line"></div><div class="line"></div><div class="line">Server Software:        bfe/1.0.8.18</div><div class="line">Server Hostname:        www.baidu.com</div><div class="line">Server Port:            443</div><div class="line">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</div><div class="line"></div><div class="line">Document Path:          /</div><div class="line">Document Length:        227 bytes</div><div class="line"></div><div class="line">Concurrency Level:      10</div><div class="line">Time taken <span class="keyword">for</span> tests:   1.765 seconds</div><div class="line">Complete requests:      100</div><div class="line">Failed requests:        0</div><div class="line">Total transferred:      103255 bytes</div><div class="line">HTML transferred:       22700 bytes</div><div class="line">Requests per second:    56.65 [<span class="comment">#/sec] (mean)</span></div><div class="line">Time per request:       176.522 [ms] (mean)</div><div class="line">Time per request:       17.652 [ms] (mean, across all concurrent requests)</div><div class="line">Transfer rate:          57.12 [Kbytes/sec] received</div><div class="line"></div><div class="line">Connection Times (ms)</div><div class="line">min  mean[+/-sd] median   max</div><div class="line">Connect:      104  126  12.3    125     162</div><div class="line">Processing:    32   39   5.7     38      68</div><div class="line">Waiting:       32   38   5.0     37      60</div><div class="line">Total:        138  165  14.1    164     220</div><div class="line"></div><div class="line">Percentage of the requests served within a certain time (ms)</div><div class="line">        50%    164</div><div class="line">        66%    170</div><div class="line">        75%    173</div><div class="line">        80%    177</div><div class="line">        90%    184</div></pre></td></tr></table></figure></p>
<p>这段展示的是web服务器的信息，可以看到服务器采用的是bfe/1.0.8.18,这是类似与nginx的软件，域名是www.baidu.com，端口是80<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Server Software:        bfe/1.0.8.18</div><div class="line">Server Hostname:        www.baidu.com</div><div class="line">Server Port:            443</div><div class="line">SSL/TLS Protocol:       TLSv1.2,ECDHE-RSA-AES128-GCM-SHA256,2048,128</div></pre></td></tr></table></figure></p>
<p>这段是关于请求的文档的相关信息，所在位置“/”，文档的大小为 227bytes（此为http响应的正文长度）<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Document Path:          /</div><div class="line">Document Length:        227 bytes</div><div class="line">这段展示了压力测试的几个重要指标</div><div class="line">Concurrency Level:      10</div><div class="line">Time taken <span class="keyword">for</span> tests:   1.765 seconds</div><div class="line">Complete requests:      100</div><div class="line">Failed requests:        0</div><div class="line">Total transferred:      103255 bytes</div><div class="line">HTML transferred:       22700 bytes</div><div class="line">Requests per second:    56.65 [<span class="comment">#/sec] (mean)</span></div><div class="line">Time per request:       176.522 [ms] (mean)</div><div class="line">Time per request:       17.652 [ms] (mean, across all concurrent requests)</div><div class="line">Transfer rate:          57.12 [Kbytes/sec] received</div></pre></td></tr></table></figure></p>
<p><code>Concurrency Level: 10</code><br>//并发请求数<br><code>Time taken for tests: 1.765 seconds</code><br>//整个测试持续的时间<br><code>Complete requests: 100</code><br>//完成的请求数<br><code>Failed requests: 0</code><br>//失败的请求数</p>
<p><code>Total transferred:      103255 bytes</code><br>//整个场景中的网络传输量<br><code>HTML transferred:       22700 bytes</code><br>//整个场景中的HTML内容传输量<br><strong>//吞吐率，大家最关心的指标之一，相当于 LR 中的每秒事务数，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       176.522 [ms] (mean)</code><br><strong>//用户平均请求等待时间，大家最关心的指标之二，相当于 LR 中的平均事务响应时间，后面括号中的 mean 表示这是一个平均值</strong><br><code>Time per request:       17.652 [ms] (mean, across all concurrent requests)</code><br><strong>//服务器平均请求处理时间，大家最关心的指标之三</strong></p>
<p><code>Transfer rate:          57.12 [Kbytes/sec] received</code><br>//平均每秒网络上的流量，可以帮助排除是否存在网络流量过大导致响应时间延长的问题</p>
<p>这段表示网络上消耗的时间的分解<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Connection Times (ms)</div><div class="line">min  mean[+/-sd] median   max</div><div class="line">Connect:      104  126  12.3    125     162</div><div class="line">Processing:    32   39   5.7     38      68</div><div class="line">Waiting:       32   38   5.0     37      60</div><div class="line">Total:        138  165  14.1    164     220</div></pre></td></tr></table></figure></p>
<p>这段是每个请求处理时间的分布情况，50%的处理时间在4930ms内，66%的处理时间在5008ms内…，重要的是看90%的处理时间。<br><figure class="highlight zsh"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Percentage of the requests served within a certain time (ms)</div><div class="line">        50%    164</div><div class="line">        66%    170</div><div class="line">        75%    173</div><div class="line">        80%    177</div><div class="line">        90%    184</div></pre></td></tr></table></figure></p>
<h2 id="登陆的测试"><a href="#登陆的测试" class="headerlink" title="登陆的测试"></a>登陆的测试</h2><p>有时候进行压力测试需要用户登录，怎么办？<br>请参考以下步骤：</p>
<p>先用账户和密码登录后，用开发者工具找到标识这个会话的Cookie值（Session ID）记下来<br>如果只用到一个Cookie，那么只需键入命令：<br>ab －n 100 －C key＝value <a href="http://test.com/" target="_blank" rel="external">http://test.com/</a></p>
<p>如果需要多个Cookie，就直接设Header：<br>ab -n 100 -H “Cookie: Key1=Value1; Key2=Value2” <a href="http://test.com/" target="_blank" rel="external">http://test.com/</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php-php扩展-c/">php php扩展 c</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-解析php的内存管理" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/21/解析php的内存管理/" class="article-date">
  	<time datetime="2017-06-21T05:59:12.000Z" itemprop="datePublished">2017-06-21</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/21/解析php的内存管理/">解析php的内存管理</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="php的内存管理"><a href="#php的内存管理" class="headerlink" title="php的内存管理"></a>php的内存管理</h2><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p>
<blockquote>
<p>内存泄露<br>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。<br>对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。</p>
</blockquote>
<h2 id="Zend内存管理器"><a href="#Zend内存管理器" class="headerlink" title="Zend内存管理器"></a>Zend内存管理器</h2><p>使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br><img src="/assets/blogImg/zend_manage.jpg" alt="&quot;我是傲娇的效果图&quot;"><br> 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br> 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br> 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">C语言原生函数</th>
<th style="text-align:center">PHP内核封装后的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">void *malloc(size_t count);</td>
<td style="text-align:center">void <em>emalloc(size_t count); void </em>pemalloc(size_t count, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void *calloc(size_t count);</td>
<td style="text-align:center">void <em>ecalloc(size_t count); void </em>pecalloc(size_t count, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void <em>realloc(void </em>ptr, size_t count);</td>
<td style="text-align:center">void <em>erealloc(void </em>ptr, size_t count); void <em>perealloc(void </em>ptr, size_t count, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void <em>strdup(void </em>ptr);</td>
<td style="text-align:center">void <em>estrdup(void </em>ptr); void <em>pestrdup(void </em>ptr, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void free(void *ptr);</td>
<td style="text-align:center">void efree(void <em>ptr); void pefree(void </em>ptr, char persistent);</td>
</tr>
</tbody>
</table>
<p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： <figure class="highlight plain"><figcaption><span>void *estrndup(void *ptr，int len);</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</div><div class="line"></div><div class="line">```c</div><div class="line">ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</div><div class="line">&#123;</div><div class="line">        char *p;</div><div class="line"></div><div class="line">        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</div><div class="line">            if (UNEXPECTED(p == NULL))</div><div class="line">            &#123;</div><div class="line">                        return p;</div><div class="line">                            </div><div class="line">            &#125;</div><div class="line">        memcpy(p, s, length);</div><div class="line">        p[length] = 0;</div><div class="line">        return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br>void <em>safe_emalloc(size_t size, size_t count, size_t addtl);<br>void </em>safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);<br>这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php-php扩展-c/">php php扩展 c</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-探索php中的变量zval结构体二" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/20/探索php中的变量zval结构体二/" class="article-date">
  	<time datetime="2017-06-20T09:04:13.000Z" itemprop="datePublished">2017-06-20</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/20/探索php中的变量zval结构体二/">探索php中的变量zval结构体二</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:<br>       <code>zend_uint refcount__gc</code><br>       <code>zend_uchar is_ref__gc</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">_</span>zval_struct &#123;</div><div class="line">        zvalue_value value; <span class="comment">/* 变量的值 */</span></div><div class="line">        zend_uchar type;    <span class="comment">/* 变量当前的数据类型 */</span></div><div class="line">        zend_uint refcount__gc; <span class="comment">/*  */</span></div><div class="line">        zend_uchar is_ref__gc;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="number">_</span>zval_struct zval;</div></pre></td></tr></table></figure></p>
<p>php中的引用计数<br>先看例子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$a = <span class="string">'Hello World'</span>;</div><div class="line">$b = $a;</div><div class="line"><span class="keyword">unset</span>($a);</div></pre></td></tr></table></figure>
<p>PHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br>这里我们主要讲解refcount<strong>gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount</strong>gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zval *helloval;</div><div class="line">MAKE_STD_ZVAL(helloval);</div><div class="line">ZVAL_STRING(helloval, <span class="string">"Hello World"</span>, <span class="number">1</span>);</div><div class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</div><div class="line">ZVAL_ADDREF(helloval); <span class="comment">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></div><div class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"b"</span>, <span class="keyword">sizeof</span>(<span class="string">"b"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>)</div></pre></td></tr></table></figure>
<p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！<br>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = $a;</div><div class="line">$b += <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function">zval *<span class="title">get_var_and_separate</span><span class="params">(<span class="keyword">char</span> *varname, <span class="keyword">int</span> varname_len TSRMLS_DC)</span></span></div><div class="line">&#123;</div><div class="line">        zval **varval, *varcopy;</div><div class="line">        <span class="keyword">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;varval) == FAILURE)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 如果在符号表里找不到这个变量则直接return */</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((*varval)-&gt;refcount &lt; <span class="number">2</span>)</div><div class="line">        &#123;   </div><div class="line">        <span class="comment">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></div><div class="line">        <span class="keyword">return</span> *varval;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="comment">/* 否则，复制一份zval*的值 */</span></div><div class="line">        MAKE_STD_ZVAL(varcopy);</div><div class="line">        varcopy = *varval;</div><div class="line">            </div><div class="line">        <span class="comment">/* 复制任何在zval*内已分配的结构*/</span></div><div class="line">        zval_copy_ctor(varcopy);</div><div class="line"></div><div class="line">        <span class="comment">/* 从符号表中删除原来的变量</span></div><div class="line">         * 这将减少该过程中varval的refcount的值</div><div class="line">         */</div><div class="line">        zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></div><div class="line">        varcopy-&gt;refcount = <span class="number">1</span>;</div><div class="line">        varcopy-&gt;is_ref = <span class="number">0</span>;</div><div class="line">        zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>,&amp;varcopy, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</div><div class="line">            </div><div class="line">        <span class="comment">/* 返回新zval的地址 */</span></div><div class="line">        <span class="keyword">return</span> varcopy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。<br>Change on Write</p>
<p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = &amp;$a;</div><div class="line">$b += <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref<strong>gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount</strong>gc等于1，is_ref<strong>gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount</strong>gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></div><div class="line"><span class="keyword">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> *varval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。<br>Separation Anxiety</p>
<p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = $a;</div><div class="line">$c = &amp;$a;</div></pre></td></tr></table></figure>
<p> <img src="/assets/blogImg/is_ref1.jpg" alt="&quot;我是傲娇的效果图&quot;"><br>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref<strong>gc和refcount</strong>gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】</p>
<p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上图对应的代码</span></div><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = &amp;$a;</div><div class="line">$c = $a;</div></pre></td></tr></table></figure></p>
<p> <img src="/assets/blogImg/is_ref2.jpg" alt="&quot;我是傲娇的效果图&quot;"></p>
<p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php-php扩展-c/">php php扩展 c</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-探索php中的变量zval结构体" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/18/探索php中的变量zval结构体/" class="article-date">
  	<time datetime="2017-06-18T15:03:30.000Z" itemprop="datePublished">2017-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/18/探索php中的变量zval结构体/">探索php中的变量zval结构体</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> <span class="number">_</span>zval_struct &#123;</div><div class="line">        zvalue_value value; <span class="comment">/* 变量的值 */</span></div><div class="line">        zend_uchar type;    <span class="comment">/* 变量当前的数据类型 */</span></div><div class="line">        zend_uint refcount__gc;</div><div class="line">        zend_uchar is_ref__gc;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="number">_</span>zval_struct zval;</div><div class="line"></div><div class="line"><span class="comment">//在Zend/zend_types.h里定义的：</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> zend_uint;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> zend_uchar;</div></pre></td></tr></table></figure></p>
<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="number">_</span>zvalue_value &#123;</div><div class="line">        <span class="keyword">long</span> lval;                  <span class="comment">/* long value */</span></div><div class="line">        <span class="keyword">double</span> dval;                <span class="comment">/* double value */</span></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">                <span class="keyword">char</span> *val;</div><div class="line">                <span class="keyword">int</span> len;</div><div class="line">        &#125; str;</div><div class="line">        HashTable *ht;              <span class="comment">/* hash table value */</span></div><div class="line">        zend_object_value obj;</div><div class="line">&#125; zvalue_value;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>PHP中常见的变量类型有：</p>
<ol>
<li>整型/浮点/长整型/bool值 等等</li>
<li>字符串</li>
<li>数组/关联数组</li>
<li>对象</li>
<li>资源</li>
</ol>
</blockquote>
<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zval.type = IS_LONG;<span class="comment">//整形</span></div><div class="line">zval.type = IS_BOOL;<span class="comment">//布尔值</span></div></pre></td></tr></table></figure>
<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zval.type = IS_STRING</div></pre></td></tr></table></figure>
<p>这个时候，就会取:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zval.value.str</div></pre></td></tr></table></figure>
<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type = IS_RESOURCE</div></pre></td></tr></table></figure>
<h2 id="变量类型的实现"><a href="#变量类型的实现" class="headerlink" title="变量类型的实现"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量名称：</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IS_NULL</td>
<td style="text-align:center">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>
</tr>
<tr>
<td style="text-align:left">IS_BOOL</td>
<td style="text-align:center">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>
</tr>
<tr>
<td style="text-align:left">IS_LONG</td>
<td style="text-align:center">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>
</tr>
<tr>
<td style="text-align:left">IS_DOUBLE</td>
<td style="text-align:center">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>
</tr>
<tr>
<td style="text-align:left">IS_STRING</td>
<td style="text-align:center">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>
</tr>
<tr>
<td style="text-align:left">IS_ARRAY</td>
<td style="text-align:center">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>
</tr>
<tr>
<td style="text-align:left">IS_OBJECT</td>
<td style="text-align:center">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>
</tr>
<tr>
<td style="text-align:left">IS_RESOURCE</td>
<td style="text-align:center">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>
</tr>
</tbody>
</table>
<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</div><div class="line">        &#123;</div><div class="line">                    php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</div><div class="line">                        </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">                    php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, Z_TYPE_P(foo));</div><div class="line">                        </div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以一个P结尾的宏的参数大多是<em>zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*</em>zval。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始定义php语言中的函数gettype</span></div><div class="line">PHP_FUNCTION(gettype)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></div><div class="line">    <span class="comment">//所以我们要对他使用__PP后缀的宏。</span></div><div class="line">    zval **arg;</div><div class="line"></div><div class="line">    <span class="comment">//这个if的操作主要是让arg指向参数～</span></div><div class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"Z"</span>, &amp;arg) == FAILURE) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">                    </div><div class="line">    <span class="comment">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></div><div class="line">    <span class="comment">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></div><div class="line">    <span class="keyword">switch</span> (Z_TYPE_PP(arg)) &#123;</div><div class="line">        <span class="keyword">case</span> IS_NULL:</div><div class="line">            RETVAL_STRING(<span class="string">"NULL"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_BOOL:</div><div class="line">            RETVAL_STRING(<span class="string">"boolean"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_LONG:</div><div class="line">            RETVAL_STRING(<span class="string">"integer"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_DOUBLE:</div><div class="line">            RETVAL_STRING(<span class="string">"double"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_STRING:</div><div class="line">            RETVAL_STRING(<span class="string">"string"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_ARRAY:</div><div class="line">            RETVAL_STRING(<span class="string">"array"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_OBJECT:</div><div class="line">            RETVAL_STRING(<span class="string">"object"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_RESOURCE:</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">char</span> *type_name;</div><div class="line">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</div><div class="line">            <span class="keyword">if</span> (type_name) &#123;</div><div class="line">                RETVAL_STRING(<span class="string">"resource"</span>, <span class="number">1</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">                    RETVAL_STRING(<span class="string">"unknown type"</span>, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>
<p>#define Z_TYPE(zval)        (zval).type</p>
<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>
<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>
<h2 id="变量值的实现"><a href="#变量值的实现" class="headerlink" title="变量值的实现"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_value</span><span class="params">(zval zv,zval *zv_p,zval **zv_pp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( Z_TYPE(zv) == IS_NULL)</div><div class="line">    &#123;</div><div class="line">                php_printf(<span class="string">"类型是 IS_NULL!\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</div><div class="line">    &#123;</div><div class="line">                php_printf(<span class="string">"类型是 IS_LONG，值是：%ld"</span> , Z_LVAL_P(zv_p));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</div><div class="line">    &#123;</div><div class="line">                php_printf(<span class="string">"类型是 IS_DOUBLE,值是：%f"</span> , Z_DVAL_PP(zv_pp) );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(zval *zstr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</div><div class="line">        php_printf(<span class="string">"这个变量不是字符串!\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</div><div class="line">    <span class="comment">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></div><div class="line">&#125;       </div><div class="line"> ```       </div><div class="line">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</div><div class="line">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</div><div class="line">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</div><div class="line">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</div><div class="line">``` c</div><div class="line"><span class="comment">//操作整数的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL(zval)            (zval).value.lval</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作IS_BOOL布尔型的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作浮点数的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL(zval)            (zval).value.dval</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作字符串的值和长度的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作对象的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \</span></div><div class="line">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \</div><div class="line">                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作资源的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL(zval)          (zval).value.lval</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></div><div class="line">```     </div><div class="line">#<span class="meta"># php的类型转换</span></div><div class="line">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</div><div class="line">``` c</div><div class="line"><span class="comment">//将任意类型的zval转换成字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_zval_to_string</span><span class="params">(zval *value)</span></span></div><div class="line">&#123;</div><div class="line">        convert_to_string(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其它基本的类型转换函数</span></div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_long</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_double</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_null</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_boolean</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_array</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_object</span><span class="params">(zval *op)</span></span>;</div><div class="line"></div><div class="line">ZEND_API <span class="keyword">void</span> <span class="number">_</span>convert_to_string(zval *op ZEND_FILE_LINE_DC);</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> convert_to_string(op) <span class="meta-keyword">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></div></pre></td></tr></table></figure></p>
<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php-php扩展-c/">php php扩展 c</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-如何编写测试" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/18/如何编写测试/" class="article-date">
  	<time datetime="2017-06-18T05:38:51.000Z" itemprop="datePublished">2017-06-18</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/18/如何编写测试/">Codeception测试框架如何编写测试</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="如何编写测试"><a href="#如何编写测试" class="headerlink" title="如何编写测试"></a>如何编写测试</h2><p>Yii2高级应用程序使用Codeception作为其主要测试框架。</p>
<h3 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h3><p>为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer <span class="keyword">global</span> <span class="keyword">require</span> <span class="string">"codeception/codeception=2.1.*"</span></div><div class="line">composer <span class="keyword">global</span> <span class="keyword">require</span> <span class="string">"codeception/specify=*"</span></div><div class="line">composer <span class="keyword">global</span> <span class="keyword">require</span> <span class="string">"codeception/verify=*"</span></div></pre></td></tr></table></figure></p>
<p>创建测试目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codecept bootstrap</div></pre></td></tr></table></figure></p>
<p>构建测试套件：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codecept build</div></pre></td></tr></table></figure></p>
<p>如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./yii_test migrate</div></pre></td></tr></table></figure></p>
<p>然后所有的样例测试可以通过运行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codecept run</div></pre></td></tr></table></figure></p>
<p>docker环境下运行搭建并运行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker exec -it health_web_1 ./vendor/bin/codecept boostrap</div><div class="line">docker exec -it health_web_1 ./vendor/bin/./yii_test migrate</div><div class="line">docker exec -it health_web_1 ./vendor/bin/codecept build</div><div class="line">docker exec -it health_web_1 ./vendor/bin/codecept run</div></pre></td></tr></table></figure></p>
<p>测试套件描述：</p>
<ul>
<li>unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。</li>
<li>api ⇒ api接口测试(主要)。</li>
<li>functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。</li>
<li>acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。</li>
</ul>
<h2 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> docker <span class="built_in">exec</span> -it usercenter_web_1 bash</div><div class="line">//或者</div><div class="line"> docker <span class="built_in">exec</span> -it health_web_1 /bin/sh</div><div class="line">./vendor/bin/codecept run -c tests</div></pre></td></tr></table></figure>
<p>-c 指定目录<br>api测试需要启动一个web服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S localhost:80 --docroot api/tests &amp;&gt;/dev/null&amp;</div></pre></td></tr></table></figure></p>
<h2 id="搭建测试环境-1"><a href="#搭建测试环境-1" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><p>目录结构</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">├── codeception</div><div class="line">│   ├── api  //api测试</div><div class="line">│   ├── api.suite.yml  //api测试配置</div><div class="line">│   ├── _bootstrap.php</div><div class="line">│   ├── _data</div><div class="line">│   │   └── dump.sql  //初始化sql</div><div class="line">│   ├── _output  //日志</div><div class="line">│   ├── _support                                                    </div><div class="line">│   ├── unit</div><div class="line">│   │   ├── _bootstrap.php   //依赖文件</div><div class="line">│   │   ├── models</div><div class="line">│   │   │   ├── ActivityConfigTest.php  //单元测试</div><div class="line">│   │   └── UnitTester.php</div><div class="line">│   └── unit.suite.yml  //单元测试配置文件</div><div class="line">├── codeception.yml</div><div class="line">├── _envs</div><div class="line">├── _output</div><div class="line">└── _support</div><div class="line">    └── _generated</div></pre></td></tr></table></figure>
<p>在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件</p>
<h3 id="api测试详解"><a href="#api测试详解" class="headerlink" title="api测试详解"></a>api测试详解</h3><p>API测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./vendor/bin/codecept g:suite api</div></pre></td></tr></table></figure></p>
<p>您将需要启用REST，Yii2模块tests/api.suite.yml：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class_name: ApiTester</div><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">        - REST:</div><div class="line">            url: /api/v1</div><div class="line">            depends: Yii2</div><div class="line">        - \ApiBundle\Helper\Api</div><div class="line">    config:</div><div class="line">        - Yii2</div></pre></td></tr></table></figure></p>
<p>Yii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。</p>
<p><a href="http://codeception.com/docs/10-WebServices#REST" target="_blank" rel="external">继续执行REST API测试指南»</a></p>
<h3 id="单位测试详解"><a href="#单位测试详解" class="headerlink" title="单位测试详解"></a>单位测试详解</h3><p>单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。</p>
<p>每个测试用例扩展Codeception\Test\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">      - Yii2:</div><div class="line">            part: [orm, email]</div></pre></td></tr></table></figure></p>
<p>该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。</p>
<p>通过访问测试用例中的$this-&gt;tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// insert records in database</div><div class="line">$this-&gt;tester-&gt;haveRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class="line">// check records in database</div><div class="line">$this-&gt;tester-&gt;seeRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class="line">// test email was sent</div><div class="line">$this-&gt;tester-&gt;seeEmailIsSent();</div><div class="line">// get a last sent emails</div><div class="line">$this-&gt;tester-&gt;grabLastSentEmail();</div></pre></td></tr></table></figure></p>
<p>如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// load fixtures</div><div class="line">$this-&gt;tester-&gt;haveFixtures([</div><div class="line">    &apos;user&apos; =&gt; [</div><div class="line">        &apos;class&apos; =&gt; UserFixture::className(),</div><div class="line">        // fixture data located in tests/_data/user.php</div><div class="line">        &apos;dataFile&apos; =&gt; codecept_data_dir() . &apos;user.php&apos;</div><div class="line">    ]</div><div class="line">]);</div><div class="line">// get first user from fixtures</div><div class="line">$this-&gt;tester-&gt;grabFixture(&apos;user&apos;, 0);</div></pre></td></tr></table></figure></p>
<p>如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\Test\Unit而是写出你自己的单独的Helper类。</p>
<p><a href="http://codeception.com/docs/05-UnitTests" target="_blank" rel="external">继续进行单元测试指南»</a></p>
<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$I-&gt;amOnPage([&apos;site/contact&apos;]);</div><div class="line">$I-&gt;submitForm(&apos;#contact-form&apos;, []);</div><div class="line">$I-&gt;expectTo(&apos;see validations errors&apos;);</div><div class="line">$I-&gt;see(&apos;Contact&apos;, &apos;h1&apos;);</div><div class="line">$I-&gt;see(&apos;Name cannot be blank&apos;);</div><div class="line">$I-&gt;see(&apos;Email cannot be blank&apos;);</div><div class="line">$I-&gt;see(&apos;Subject cannot be blank&apos;);</div><div class="line">$I-&gt;see(&apos;Body cannot be blank&apos;);</div></pre></td></tr></table></figure></p>
<p>这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。</p>
<p>功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：</p>
<p>./vendor/bin/codecept g:cest functional MyNewScenarioCest<br> 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。</p>
<p><a href="http://codeception.com/docs/04-FunctionalTests" target="_blank" rel="external">继续进行功能测试指南»</a></p>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><p>从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。</p>
<p>默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv tests/acceptance.suite.yml.example tests/acceptance.suite.yml</div><div class="line">基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。</div></pre></td></tr></table></figure></p>
<p>那么您将需要在测试模式下启动应用服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./tests/bin/yii serve</div></pre></td></tr></table></figure></p>
<p>并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># config at tests/acceptance.yml</div><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">        - WebDriver:</div><div class="line">            url: http://127.0.0.1:8080/</div><div class="line">            browser: firefox</div><div class="line">        - Yii2:</div><div class="line">            part: [orm, fixtures] # allow to use AR methods</div><div class="line">            cleanup: false # don&apos;t wrap test in transaction</div><div class="line">            entryScript: index-test.php</div></pre></td></tr></table></figure></p>
<p>正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。</p>
<p>与功能测试类似，建议使用Cest格式进行验收测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./vendor/bin/codecept g:cest acceptance MyNewScenarioCest</div></pre></td></tr></table></figure></p>
<p><a href="http://codeception.com/docs/03-AcceptanceTests" target="_blank" rel="external">继续验收测试指南»</a></p>
<h3 id="手动设置-amp-amp-配置"><a href="#手动设置-amp-amp-配置" class="headerlink" title="手动设置&amp;&amp;配置"></a>手动设置&amp;&amp;配置</h3><p>要开始，您需要通过Composer安装Codeception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require &quot;codeception/codeception&quot; --dev</div></pre></td></tr></table></figure></p>
<p>创建基本的测试套件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./vendor/bin/codecept bootstrap</div></pre></td></tr></table></figure></p>
<p>启用模块Yii2进行功能测试functional.suite.yml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># functional.suite.yml</div><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">        - Yii2:</div><div class="line">            configFile: #insert path to config file</div></pre></td></tr></table></figure></p>
<p>Yii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// config/test.php</div><div class="line">$config =  yii\helpers\ArrayHelper::merge(</div><div class="line">    require(__DIR__ . &apos;/main.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/main-local.php&apos;),</div><div class="line">    [</div><div class="line">        &apos;id&apos; =&gt; &apos;app-tests&apos;,</div><div class="line">        &apos;components&apos; =&gt; [</div><div class="line">            &apos;db&apos; =&gt; [</div><div class="line">                &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yii_app_test&apos;,</div><div class="line">            ]</div><div class="line">        ]        </div><div class="line">    ]</div><div class="line">);</div><div class="line">return $config;</div></pre></td></tr></table></figure></p>
<p>测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。</p>
<p>还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。</p>
<p>一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。</p>
<p>在基础和高级应用程序模板configFile中定义了全局配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># inside codeception.yml</div><div class="line">modules:</div><div class="line">    config:</div><div class="line">        Yii2:</div><div class="line">            configFile: &apos;config/test.php&apos;</div></pre></td></tr></table></figure></p>
<p>这样我们不需要为每个定义的套件提供测试配置。</p>
<h3 id="伪数据生成器"><a href="#伪数据生成器" class="headerlink" title="伪数据生成器"></a>伪数据生成器</h3><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require fzaninotto/faker</div></pre></td></tr></table></figure></p>
<p>使用Faker\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// require the Faker autoloader</div><div class="line">require_once &apos;/path/to/Faker/src/autoload.php&apos;;</div><div class="line">// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)</div><div class="line"></div><div class="line">// use the factory to create a Faker\Generator instance</div><div class="line">$faker = Faker\Factory::create();</div><div class="line"></div><div class="line">// generate data by accessing properties</div><div class="line">echo $faker-&gt;name;</div><div class="line">  // &apos;Lucy Cechtelar&apos;;</div><div class="line">echo $faker-&gt;address;</div><div class="line">  // &quot;426 Jordy Lodge</div><div class="line">  // Cartwrightshire, SC 88120-6700&quot;</div><div class="line">echo $faker-&gt;text;</div><div class="line">  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit</div><div class="line">  // et sit et mollitia sed.</div><div class="line">  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium</div><div class="line">  // sit minima sint.</div></pre></td></tr></table></figure></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/php/">php</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-谈谈进程和线程" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/06/17/谈谈进程和线程/" class="article-date">
  	<time datetime="2017-06-17T15:27:02.000Z" itemprop="datePublished">2017-06-17</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/06/17/谈谈进程和线程/">谈谈进程和线程</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。<br>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<h2 id="进程的本质"><a href="#进程的本质" class="headerlink" title="进程的本质"></a>进程的本质</h2><p>cpu的单次运算</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<h2 id="线程的本质"><a href="#线程的本质" class="headerlink" title="线程的本质"></a>线程的本质</h2><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>
<h2 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h2><p>由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br>文件描述符表<br>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）<br>当前工作目录<br>用户id和组id<br>但有些资源是每个线程各有一份的：<br>线程id<br>上下文，包括各种寄存器的值、程序计数器和栈指针<br>栈空间<br>errno变量<br>信号屏蔽字<br>调度优先级</p>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。<br>图 30.6. 进程间通信<br>进程间通信<br> <img src="/assets/blogImg/process.png" alt="&quot;我是傲娇的效果图&quot;"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。</p>
<p>开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。<br>1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。<br>2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br>3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。<br> <img src="/assets/blogImg/process.pipe.png" alt="&quot;我是傲娇的效果图&quot;"><br> <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];</div><div class="line">        <span class="keyword">pid_t</span> pid;</div><div class="line">        <span class="keyword">char</span> line[MAXLINE];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</div><div class="line">                perror(<span class="string">"pipe"</span>);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">                perror(<span class="string">"fork"</span>);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">/* parent */</span></div><div class="line">                close(fd[<span class="number">0</span>]);</div><div class="line">                write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</div><div class="line">                wait(<span class="literal">NULL</span>);</div><div class="line">         &#125; <span class="keyword">else</span> &#123;       <span class="comment">/* child */</span></div><div class="line">                close(fd[<span class="number">1</span>]);</div><div class="line">                n = read(fd[<span class="number">0</span>], line, MAXLINE);</div><div class="line">                write(STDOUT_FILENO, line, n);</div><div class="line">         &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用管道有一些限制：<br>两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？<br>管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。<br>使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：<br>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<br>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。<br>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。<br>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
</blockquote>
<p> 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：<br>-父进程通过fork可以将打开文件的描述符传递给子进程<br>-子进程结束时，父进程调用wait可以得到子进程的终止信息<br>-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步<br>-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能<br>-管道<br>-FIFO<br>-mmap函数，几个进程可以映射同一内存区<br>-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃<br>-UNIX Domain Socket，目前最广泛使用的IPC机制</p>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><p>多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：<br>1.从内存读变量值到寄存器<br>2.寄存器的值加1<br>3.将寄存器的值写回内存<br>假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。<br> <img src="/assets/blogImg/thread.corrupt.png" alt="&quot;我是傲娇的效果图&quot;"><br> 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br> pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure></p>
<p>返回值：成功返回0，失败返回错误号。<br>一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br>如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。<br>Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：<br>lock:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(mutex &gt; <span class="number">0</span>)&#123;</div><div class="line">        mutex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">        <span class="comment">//挂起等待;</span></div><div class="line">        <span class="keyword">goto</span> lock;</div><div class="line">unlock:</div><div class="line">        mutex = <span class="number">1</span>;</div><div class="line">        <span class="comment">//唤醒等待Mutex的线程;</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。</div></pre></td></tr></table></figure></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title=" 参考文章:"></a> 参考文章:</h2><p><a href="https://akaedu.github.io/book/ch35s04.html" target="_blank" rel="external">线程</a><br><a href="https://akaedu.github.io/book/ch30s04.html" target="_blank" rel="external">进程间通信</a><br><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000" target="_blank" rel="external">进程和线程</a></p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/linux基础/">linux基础</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/技术/">技术</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
    <article id="post-Webpack595错误" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2017/05/13/Webpack595错误/" class="article-date">
  	<time datetime="2017-05-13T15:39:40.000Z" itemprop="datePublished">2017-05-13</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2017/05/13/Webpack595错误/">Webpack595错误</a>
    </h1>
  

      </header>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="错误情况"><a href="#错误情况" class="headerlink" title="错误情况"></a>错误情况</h2><p>Mix incompatible with Webpack 2.3.0? #595</p>
<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>这是laravel5.4的错误webpack依赖包兼容问题</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在package,json 修改”aravel-mix”: “^0.10.0” 修复这个错误</p>

      
    </div>
    
    <div class="article-info article-info-index">
      
      
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/错误日志/">错误日志</a></li></ul>
	</div>

      
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/错误日志/">错误日志</a>
	</div>


      
      <div class="clearfix"></div>
    </div>
    
  </div>
  
</article>









  
  
    <nav id="page-nav">
      <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">Next &raquo;</a>
    </nav>
  
</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2017 Graychen
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: undefined,
		isHome: true,
		isPost: false,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: undefined,
		root: /
	}
</script>
<script src="http://7.url.cn/edu/jslib/comb/require-2.1.6,jquery-1.9.1.min.js"></script>
<script src="/js/main.js"></script>






<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>


  </div>
</body>
</html>