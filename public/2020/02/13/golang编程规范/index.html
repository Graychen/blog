<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Graychen,13780185250@sina.cn"><title>golang编程规范 · Hexo</title><meta name="description" content="go fmt大部分的格式问题可以通过 gofmt 解决，gofmt 自动格式化代码，保证所有的Go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。代码提交前，必须执行gofmt进行格式化。
go vetvet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的"><meta name="keywords" content="Hexo,HTML,CSS,android,Linux"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title><a href="/">Hexo</a></h3><div class="description"><p>这个世界需要更多的英雄</p></div></div></div><ul class="social-links"><li><a href="https://twitter.com/huashendung"><i class="fa fa-twitter"></i></a></li><li><a href="http://weibo.com/1763295797/home?wvr=5"><i class="fa fa-weibo"></i></a></li><li><a href="http://github.com/Graychen"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="assets/blogImg/avatar.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>golang编程规范</a></h3></div><div class="post-content"><h1 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h1><p>大部分的格式问题可以通过 gofmt 解决，gofmt 自动格式化代码，保证所有的Go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。<br>代码提交前，必须执行gofmt进行格式化。</p>
<h1 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h1><p>vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。<br>代码提交前，必须执行go vet进行静态检查。</p>
<h1 id="长度约定"><a href="#长度约定" class="headerlink" title="长度约定"></a>长度约定</h1><p>代码块长度，代码块不能超过10行，否则就需要进行分块。<br>行代码长度控制，每行代码不能超过100个字符，超过100字符需换行，提高代码可读性。</p>
<h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>结构体、函数和包必须进行注释<br>结构体注释格式：<br>// ObjectMeta is metadata that all persisted resources must have, which includes all objects<br>// users must create.<br>type ObjectMeta struct {<br>}</p>
<ul>
<li><p>函数注释格式：<br>// Compile parses a regular expression and returns, if successful,<br>// a Regexp that can be used to match against text.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Compile(str string) (*Regexp, error) &#123;</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>包注释格式：<br>// Package path implements utility routines for<br>// manipulating slash-separated filename paths.<br>path</p>
</li>
</ul>
<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><ul>
<li>关键或者复杂的代码需要进行注释：</li>
<li>注释内容必须是可读的完整句子，简要并且突出重点。</li>
<li>需要注释来补充的命名就不算是好命名。</li>
<li>使用可搜索的名称：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。</li>
<li>做有意义的区分：Product 和 ProductInfo 和 ProductData 没有区别，NameString 和 Name 没有区别，要区分名称，就要以读者能鉴别不同之处的方式来区分 。</li>
<li>函数命名规则：驼峰式命名，名字可以长但是得把功能，必要的参数描述清楚，函数名应当是动词或动词短语，不可导出的函数以小写开头。</li>
<li>如 postPayment、deletePage、save。并依 Javabean 标准加上 get、set、is 前缀。例如：xxx + With + 需要的参数名 + And + 需要的参数名 + …..</li>
<li>结构体命名规则：结构体名应该是名词或名词短语，如 Customer、WikiPage、Account、AddressParser<h2 id="接口命名规则："><a href="#接口命名规则：" class="headerlink" title="接口命名规则："></a>接口命名规则：</h2>单个函数的接口名以”er”作为后缀，如Reader,Writer</li>
</ul>
<h2 id="接口的实现则去掉“er”"><a href="#接口的实现则去掉“er”" class="headerlink" title="接口的实现则去掉“er”"></a>接口的实现则去掉“er”</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="两个函数的接口名综合两个函数名"><a href="#两个函数的接口名综合两个函数名" class="headerlink" title="两个函数的接口名综合两个函数名"></a>两个函数的接口名综合两个函数名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三个以上函数的接口名，类似于结构体名"><a href="#三个以上函数的接口名，类似于结构体名" class="headerlink" title="三个以上函数的接口名，类似于结构体名"></a>三个以上函数的接口名，类似于结构体名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start([]<span class="keyword">byte</span>)</span><br><span class="line">    Stop() error</span><br><span class="line">    Recover()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包名命名规则：包名应该为小写单词，不要使用下划线或者混合大小写。<br>文件夹命名规则：小写单词，使用横杠连接<br>文件命名 规则：小写单词，使用下划线连接，测试文件_test.go结束<br>一般情况下包名和文件夹命名是一致的，不过也可以不一样<br>常量<br>常量均需使用全部大写字母组成，并使用下划线分词：</p>
<p>const APP_VER = “1.0”</p>
<p>如果是枚举类型的常量，需要先创建相应类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">"http"</span></span><br><span class="line">    HTTPS Scheme = <span class="string">"https"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PullRequestStatus <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PULL_REQUEST_STATUS_CONFLICT PullRequestStatus = <span class="literal">iota</span></span><br><span class="line">    PULL_REQUEST_STATUS_CHECKING</span><br><span class="line">    PULL_REQUEST_STATUS_MERGEABLE</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则："><a href="#变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：" class="headerlink" title="变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则："></a>变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：</h2><ul>
<li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li>
<li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li>
<li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray<br>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist boolvar hasConflict <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="keyword">bool</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>多个变量声明放在一起<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    isExist <span class="keyword">bool</span></span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>在函数外部声明使用var,不要采用:=<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p>
<p>声明和初始化采用多行，初始化结构体使用带有标签的语法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="keyword">string</span></span><br><span class="line">    Email     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := User&#123;</span><br><span class="line">    Username: <span class="string">"yourname"</span>,</span><br><span class="line">    Email:    <span class="string">"yourname@gmail.com"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>修改对象属性不能直接使用赋值，要写成方法且必须加锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">map</span></span><br></pre></td></tr></table></figure></p>
<p>非线程安全，并发读写map的情况下必须加锁，不然会产生panic</p>
<blockquote>
<blockquote>
<p>go 1.9以下版本可参考 beego的safemap，1.9以上版本使用sync.Map</p>
</blockquote>
</blockquote>
<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数采用命名的多值返回，传入变量和返回变量以小写字母开头<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数返回值可能为空或零值时，加一个逻辑判断的返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<p>函数返回用显式，不要用隐式，避免返回值被重复定义，导致返回值错误，特别是error返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span> <span class="params">(bar *Bar,err error)</span></span>&#123;</span><br><span class="line">  a,err:=A()</span><br><span class="line">  <span class="keyword">if</span> err !=  <span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>约定下面的写法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span> <span class="params">(bar *Bar,err error)</span></span>&#123;</span><br><span class="line">  a,err:=A()</span><br><span class="line">  <span class="keyword">if</span> err !=  <span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> bar,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><ul>
<li>在同一个文件中，可以重复定义init方法</li>
<li>在同一个文件中，多个init方法按照在代码中编写的顺序依次执行</li>
<li>在同一个package中，可以多个文件中定义init方法</li>
<li>在同一个package中，不同文件中的init方法的执行按照文件名先后执行各个文件中的init方法<br>建议同一个文件中只定义一个init方法，同一个package中init尽量合并</li>
</ul>
<h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ul>
<li>error作为函数的值返回,必须对error进行处理</li>
<li>错误描述如果是英文必须为小写，不需要标点结尾</li>
<li>采用独立的错误流进行处理<br>不要采用下面的处理错误写法:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>采用下面的写法</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure>
<p>使用函数的返回值时，则采用下面的方式</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, err := f()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br></pre></td></tr></table></figure>
<p>控制结构<br>if接受初始化语句，约定如下方式建立局部变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>for 采用短声明建立局部变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>range<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果只需要第一项（key），就丢弃第二个：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果只需要第二项，则把第一项置为下划线<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>return 尽早 return：一旦有错误发生，马上返回<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  f.Close()</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br><span class="line"></span><br><span class="line"># <span class="built_in">panic</span></span><br></pre></td></tr></table></figure></p>
<p>在逻辑处理中不要使用panic，且业务逻辑中要有recover机制<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">import</span></span><br></pre></td></tr></table></figure></p>
<p>对 import 的包进行分组管理，用换行符分割，而且标准库作为分组的第一组。如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"kmg/a"</span></span><br><span class="line">    <span class="string">"kmg/b"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"code.google.com/a"</span></span><br><span class="line">    <span class="string">"github.com/b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>在项目中不要使用相对路径引入包：</p>
<p>// 错误示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"../net"</span></span><br></pre></td></tr></table></figure></p>
<p>// 正确的做法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/repo/proj/src/net"</span></span><br></pre></td></tr></table></figure></p>
<h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>对于少量数据，不要传递指针<br>对于大量数据的 struct 可以考虑使用指针<br>传入的参数是 map，slice，chan 不要传递指针，因为 map，slice，chan 是引用类型，不需要传递指针的指针</p>
<h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试文件名命名规范：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　　　 example_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></p>
<p>测试用例的函数名称必须以 Test 开头，例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExample</span><span class="params">(t * testing.T)</span></span></span><br></pre></td></tr></table></figure></p>
<h1 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h1><p>函数名以Benchmark开头</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkExample</span><span class="params">(b *testing.B)</span></span></span><br></pre></td></tr></table></figure>
<h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>为了方便日志分析，记录日志统一使用glog详细用法请看 这里<br>记录有意义的日志，日志里记录一些比较有意义的状态数据：程序启动，退出的时间点；程序运行消耗时间；耗时程序的执行进度；重要变量的状态变化。<br>日志内容必须是可读的英文语句，第一个单词首字母大写，合理标点符号<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glog.V(<span class="number">2</span>).Infof(<span class="string">"Skipping nil field: %s"</span>, key)</span><br><span class="line">glog.Errorf(<span class="string">"Failed to changes docker version to docker apiverson: %v"</span>, err)</span><br><span class="line">glog.Fatalf(<span class="string">"Error compiling: %v"</span>, err)</span><br></pre></td></tr></table></figure></p>
<p>错误日志必须日志打印：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err := serverFailureDetector.Detect()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   glog.Errorf(<span class="string">"Failed to detect server failure, %v"</span>, err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>日志等级<br>等级    方法    说明<br>Fatal    glog.Fatal    致命的异常，造成服务中断的错误, 一般只在程序初始化校验阶段使用<br>Error    glog.Error    异常，其他错误运行期错误；<br>Warning    glog.Warning    警告，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；<br>Info    glog.Info    有意义的信息，如程序启动，关闭事件，收到请求事件等；<br>Debug    glog.V(2).Info    调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；<br>Trace    glog.V(5).Info    更详细的跟踪信息；<br>依赖包</p>
<p>依赖包统一用gomodule管理</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2020-02-13</span><i class="fa fa-tag"></i><a class="tag" href="/tags/技术/" title="技术">技术 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2020/02/13/golang编程规范/,Hexo,golang编程规范,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2020/02/02/将mysql和github的action一起使用/" title="将mysql和github的action一起使用">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>