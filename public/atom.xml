<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-12T02:33:02.185Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Graychen,13780185250@sina.cn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Flutter卡在package获取的解决办法</title>
    <link href="http://yoursite.com/2020/03/12/Flutter%E5%8D%A1%E5%9C%A8package%E8%8E%B7%E5%8F%96%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yoursite.com/2020/03/12/Flutter卡在package获取的解决办法/</id>
    <published>2020-03-12T02:30:32.000Z</published>
    <updated>2020-03-12T02:33:02.185Z</updated>
    
    <content type="html"><![CDATA[<p>flutter一直卡在了Running “flutter packages get” in project_name…，试了几次，还是会卡住。<br>上网查找解决方法，原来是 storage.googleapis.com 撞墙了，而且 flutter 对此已经有对策了。</p><p>具体方法<br>Linux 或 Mac<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure></p><p>Windows<br>新增两个环境变量即可：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">PUB_HOSTED_URL ===== https://pub.flutter-io.cn</span><br><span class="line">FLUTTER_STORAGE_BASE_URL ===== https://storage.flutter-io.cn</span><br></pre></td></tr></table></figure></p><p>执行一下 flutter doctor -v 命令。</p><p>然后再执行 flutter packages get 即可</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;flutter一直卡在了Running “flutter packages get” in project_name…，试了几次，还是会卡住。&lt;br&gt;上网查找解决方法，原来是 storage.googleapis.com 撞墙了，而且 flutter 对此已经有对策了。&lt;/
      
    
    </summary>
    
    
      <category term="flutter" scheme="http://yoursite.com/tags/flutter/"/>
    
  </entry>
  
  <entry>
    <title>golang编程规范</title>
    <link href="http://yoursite.com/2020/02/13/golang%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2020/02/13/golang编程规范/</id>
    <published>2020-02-13T02:26:33.000Z</published>
    <updated>2020-02-13T02:51:42.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="go-fmt"><a href="#go-fmt" class="headerlink" title="go fmt"></a>go fmt</h1><p>大部分的格式问题可以通过 gofmt 解决，gofmt 自动格式化代码，保证所有的Go代码与官方推荐的格式保持一致，于是所有格式有关问题，都以 gofmt 的结果为准。<br>代码提交前，必须执行gofmt进行格式化。</p><h1 id="go-vet"><a href="#go-vet" class="headerlink" title="go vet"></a>go vet</h1><p>vet工具可以帮我们静态分析我们的源码存在的各种问题，例如多余的代码，提前return的逻辑，struct的tag是否符合标准等。<br>代码提交前，必须执行go vet进行静态检查。</p><h1 id="长度约定"><a href="#长度约定" class="headerlink" title="长度约定"></a>长度约定</h1><p>代码块长度，代码块不能超过10行，否则就需要进行分块。<br>行代码长度控制，每行代码不能超过100个字符，超过100字符需换行，提高代码可读性。</p><h1 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h1><p>结构体、函数和包必须进行注释<br>结构体注释格式：<br>// ObjectMeta is metadata that all persisted resources must have, which includes all objects<br>// users must create.<br>type ObjectMeta struct {<br>}</p><ul><li><p>函数注释格式：<br>// Compile parses a regular expression and returns, if successful,<br>// a Regexp that can be used to match against text.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func Compile(str string) (*Regexp, error) &#123;</span><br><span class="line">  。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>包注释格式：<br>// Package path implements utility routines for<br>// manipulating slash-separated filename paths.<br>path</p></li></ul><h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><ul><li>关键或者复杂的代码需要进行注释：</li><li>注释内容必须是可读的完整句子，简要并且突出重点。</li><li>需要注释来补充的命名就不算是好命名。</li><li>使用可搜索的名称：单字母名称和数字常量很难从一大堆文字中搜索出来。单字母名称仅适用于短方法中的本地变量，名称长短应与其作用域相对应。若变量或常量可能在代码中多处使用，则应赋其以便于搜索的名称。</li><li>做有意义的区分：Product 和 ProductInfo 和 ProductData 没有区别，NameString 和 Name 没有区别，要区分名称，就要以读者能鉴别不同之处的方式来区分 。</li><li>函数命名规则：驼峰式命名，名字可以长但是得把功能，必要的参数描述清楚，函数名应当是动词或动词短语，不可导出的函数以小写开头。</li><li>如 postPayment、deletePage、save。并依 Javabean 标准加上 get、set、is 前缀。例如：xxx + With + 需要的参数名 + And + 需要的参数名 + …..</li><li>结构体命名规则：结构体名应该是名词或名词短语，如 Customer、WikiPage、Account、AddressParser<h2 id="接口命名规则："><a href="#接口命名规则：" class="headerlink" title="接口命名规则："></a>接口命名规则：</h2>单个函数的接口名以”er”作为后缀，如Reader,Writer</li></ul><h2 id="接口的实现则去掉“er”"><a href="#接口的实现则去掉“er”" class="headerlink" title="接口的实现则去掉“er”"></a>接口的实现则去掉“er”</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Reader <span class="keyword">interface</span> &#123;</span><br><span class="line">        Read(p []<span class="keyword">byte</span>) (n <span class="keyword">int</span>, err error)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个函数的接口名综合两个函数名"><a href="#两个函数的接口名综合两个函数名" class="headerlink" title="两个函数的接口名综合两个函数名"></a>两个函数的接口名综合两个函数名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> WriteFlusher <span class="keyword">interface</span> &#123;</span><br><span class="line">    Write([]<span class="keyword">byte</span>) (<span class="keyword">int</span>, error)</span><br><span class="line">    Flush() error</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三个以上函数的接口名，类似于结构体名"><a href="#三个以上函数的接口名，类似于结构体名" class="headerlink" title="三个以上函数的接口名，类似于结构体名"></a>三个以上函数的接口名，类似于结构体名</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Car <span class="keyword">interface</span> &#123;</span><br><span class="line">    Start([]<span class="keyword">byte</span>)</span><br><span class="line">    Stop() error</span><br><span class="line">    Recover()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="包"><a href="#包" class="headerlink" title="包"></a>包</h1><p>包名命名规则：包名应该为小写单词，不要使用下划线或者混合大小写。<br>文件夹命名规则：小写单词，使用横杠连接<br>文件命名 规则：小写单词，使用下划线连接，测试文件_test.go结束<br>一般情况下包名和文件夹命名是一致的，不过也可以不一样<br>常量<br>常量均需使用全部大写字母组成，并使用下划线分词：</p><p>const APP_VER = “1.0”</p><p>如果是枚举类型的常量，需要先创建相应类型：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Scheme <span class="keyword">string</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    HTTP  Scheme = <span class="string">"http"</span></span><br><span class="line">    HTTPS Scheme = <span class="string">"https"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>如果模块的功能较为复杂、常量名称容易混淆的情况下，为了更好地区分枚举类型，可以使用完整的前缀：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> PullRequestStatus <span class="keyword">int</span></span><br><span class="line"><span class="keyword">const</span> (</span><br><span class="line">    PULL_REQUEST_STATUS_CONFLICT PullRequestStatus = <span class="literal">iota</span></span><br><span class="line">    PULL_REQUEST_STATUS_CHECKING</span><br><span class="line">    PULL_REQUEST_STATUS_MERGEABLE</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则："><a href="#变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：" class="headerlink" title="变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则："></a>变量名称一般遵循驼峰法，但遇到特有名词时，需要遵循以下规则：</h2><ul><li>如果变量为私有，且特有名词为首个单词，则使用小写，如 apiClient</li><li>其它情况都应当使用该名词原有的写法，如 APIClient、repoID、UserID</li><li>错误示例：UrlArray，应该写成 urlArray 或者 URLArray<br>若变量类型为 bool 类型，则名称应以 Has, Is, Can 或 Allow 开头：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isExist boolvar hasConflict <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> canManage <span class="keyword">bool</span></span><br><span class="line"><span class="keyword">var</span> allowGitHook <span class="keyword">bool</span></span><br></pre></td></tr></table></figure></li></ul><p>多个变量声明放在一起<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">    isExist <span class="keyword">bool</span></span><br><span class="line">    count <span class="keyword">int</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>在函数外部声明使用var,不要采用:=<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span></span><br></pre></td></tr></table></figure></p><p>声明和初始化采用多行，初始化结构体使用带有标签的语法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> User <span class="keyword">struct</span>&#123;</span><br><span class="line">    Username  <span class="keyword">string</span></span><br><span class="line">    Email     <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">u := User&#123;</span><br><span class="line">    Username: <span class="string">"yourname"</span>,</span><br><span class="line">    Email:    <span class="string">"yourname@gmail.com"</span>,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改对象属性不能直接使用赋值，要写成方法且必须加锁<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">map</span></span><br></pre></td></tr></table></figure></p><p>非线程安全，并发读写map的情况下必须加锁，不然会产生panic</p><blockquote><blockquote><p>go 1.9以下版本可参考 beego的safemap，1.9以上版本使用sync.Map</p></blockquote></blockquote><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>函数采用命名的多值返回，传入变量和返回变量以小写字母开头<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">nextInt</span><span class="params">(b []<span class="keyword">byte</span>, pos <span class="keyword">int</span>)</span> <span class="params">(value, nextPos <span class="keyword">int</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>函数返回值可能为空或零值时，加一个逻辑判断的返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">(a <span class="keyword">int</span>, b <span class="keyword">int</span>)</span> <span class="params">(<span class="keyword">string</span>, <span class="keyword">bool</span>)</span></span></span><br></pre></td></tr></table></figure></p><p>函数返回用显式，不要用隐式，避免返回值被重复定义，导致返回值错误，特别是error返回值<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span> <span class="params">(bar *Bar,err error)</span></span>&#123;</span><br><span class="line">  a,err:=A()</span><br><span class="line">  <span class="keyword">if</span> err !=  <span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>约定下面的写法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Foo</span><span class="params">()</span> <span class="params">(bar *Bar,err error)</span></span>&#123;</span><br><span class="line">  a,err:=A()</span><br><span class="line">  <span class="keyword">if</span> err !=  <span class="literal">nil</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>,err</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> bar,<span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="init"><a href="#init" class="headerlink" title="init"></a>init</h1><ul><li>在同一个文件中，可以重复定义init方法</li><li>在同一个文件中，多个init方法按照在代码中编写的顺序依次执行</li><li>在同一个package中，可以多个文件中定义init方法</li><li>在同一个package中，不同文件中的init方法的执行按照文件名先后执行各个文件中的init方法<br>建议同一个文件中只定义一个init方法，同一个package中init尽量合并</li></ul><h1 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h1><ul><li>error作为函数的值返回,必须对error进行处理</li><li>错误描述如果是英文必须为小写，不需要标点结尾</li><li>采用独立的错误流进行处理<br>不要采用下面的处理错误写法:<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// normal code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>采用下面的写法</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span> <span class="comment">// or continue, etc.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// normal code</span></span><br></pre></td></tr></table></figure><p>使用函数的返回值时，则采用下面的方式</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x, err := f()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="comment">// error handling</span></span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// use x</span></span><br></pre></td></tr></table></figure><p>控制结构<br>if接受初始化语句，约定如下方式建立局部变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> err := file.Chmod(<span class="number">0664</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>for 采用短声明建立局部变量<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">10</span>; i++ &#123;</span><br><span class="line">  sum += i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>range<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">如果只需要第一项（key），就丢弃第二个：</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> key := <span class="keyword">range</span> m &#123;</span><br><span class="line">    <span class="keyword">if</span> key.expired() &#123;</span><br><span class="line">        <span class="built_in">delete</span>(m, key)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如果只需要第二项，则把第一项置为下划线<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sum := <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> _, value := <span class="keyword">range</span> array &#123;</span><br><span class="line">    sum += value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>return 尽早 return：一旦有错误发生，马上返回<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">f, err := os.Open(name)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">d, err := f.Stat()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">  f.Close()</span><br><span class="line">  <span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line">codeUsing(f, d)</span><br><span class="line"></span><br><span class="line"># <span class="built_in">panic</span></span><br></pre></td></tr></table></figure></p><p>在逻辑处理中不要使用panic，且业务逻辑中要有recover机制<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># <span class="keyword">import</span></span><br></pre></td></tr></table></figure></p><p>对 import 的包进行分组管理，用换行符分割，而且标准库作为分组的第一组。如果你的包引入了三种类型的包，标准库包，程序内部包，第三方包，建议采用如下方式进行组织你的包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">"fmt"</span></span><br><span class="line">    <span class="string">"os"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"kmg/a"</span></span><br><span class="line">    <span class="string">"kmg/b"</span></span><br><span class="line"></span><br><span class="line">    <span class="string">"code.google.com/a"</span></span><br><span class="line">    <span class="string">"github.com/b"</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>在项目中不要使用相对路径引入包：</p><p>// 错误示例<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"../net"</span></span><br></pre></td></tr></table></figure></p><p>// 正确的做法<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"github.com/repo/proj/src/net"</span></span><br></pre></td></tr></table></figure></p><h1 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h1><p>对于少量数据，不要传递指针<br>对于大量数据的 struct 可以考虑使用指针<br>传入的参数是 map，slice，chan 不要传递指针，因为 map，slice，chan 是引用类型，不需要传递指针的指针</p><h1 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h1><p>单元测试文件名命名规范：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">　　　　 example_test.<span class="keyword">go</span></span><br></pre></td></tr></table></figure></p><p>测试用例的函数名称必须以 Test 开头，例如：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TestExample</span><span class="params">(t * testing.T)</span></span></span><br></pre></td></tr></table></figure></p><h1 id="性能测试："><a href="#性能测试：" class="headerlink" title="性能测试："></a>性能测试：</h1><p>函数名以Benchmark开头</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">BenchmarkExample</span><span class="params">(b *testing.B)</span></span></span><br></pre></td></tr></table></figure><h1 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h1><p>为了方便日志分析，记录日志统一使用glog详细用法请看 这里<br>记录有意义的日志，日志里记录一些比较有意义的状态数据：程序启动，退出的时间点；程序运行消耗时间；耗时程序的执行进度；重要变量的状态变化。<br>日志内容必须是可读的英文语句，第一个单词首字母大写，合理标点符号<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glog.V(<span class="number">2</span>).Infof(<span class="string">"Skipping nil field: %s"</span>, key)</span><br><span class="line">glog.Errorf(<span class="string">"Failed to changes docker version to docker apiverson: %v"</span>, err)</span><br><span class="line">glog.Fatalf(<span class="string">"Error compiling: %v"</span>, err)</span><br></pre></td></tr></table></figure></p><p>错误日志必须日志打印：<br><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_, err := serverFailureDetector.Detect()</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">   glog.Errorf(<span class="string">"Failed to detect server failure, %v"</span>, err)</span><br><span class="line">   <span class="keyword">return</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>日志等级<br>等级    方法    说明<br>Fatal    glog.Fatal    致命的异常，造成服务中断的错误, 一般只在程序初始化校验阶段使用<br>Error    glog.Error    异常，其他错误运行期错误；<br>Warning    glog.Warning    警告，如程序调用了一个即将作废的接口，接口的不当使用，运行状态不是期望的但仍可继续处理等；<br>Info    glog.Info    有意义的信息，如程序启动，关闭事件，收到请求事件等；<br>Debug    glog.V(2).Info    调试信息，可记录详细的业务处理到哪一步了，以及当前的变量状态；<br>Trace    glog.V(5).Info    更详细的跟踪信息；<br>依赖包</p><p>依赖包统一用gomodule管理</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://github.com/golang/go/wiki/CodeReviewComments" target="_blank" rel="noopener">https://github.com/golang/go/wiki/CodeReviewComments</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;go-fmt&quot;&gt;&lt;a href=&quot;#go-fmt&quot; class=&quot;headerlink&quot; title=&quot;go fmt&quot;&gt;&lt;/a&gt;go fmt&lt;/h1&gt;&lt;p&gt;大部分的格式问题可以通过 gofmt 解决，gofmt 自动格式化代码，保证所有的Go代码与官方推荐的格式保
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>将mysql和github的action一起使用</title>
    <link href="http://yoursite.com/2020/02/02/%E5%B0%86mysql%E5%92%8Cgithub%E7%9A%84action%E4%B8%80%E8%B5%B7%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/02/02/将mysql和github的action一起使用/</id>
    <published>2020-02-02T13:43:28.000Z</published>
    <updated>2020-02-02T13:44:40.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="将MySQL服务与Github操作一起使用"><a href="#将MySQL服务与Github操作一起使用" class="headerlink" title="将MySQL服务与Github操作一起使用"></a>将MySQL服务与Github操作一起使用</h1><p>借助新推出的Github Actions，现在可以基于事件在Githubs基础架构上自动运行单元测试和其他自动化任务。这是一篇简短的博客文章，描述了如何在Github Actions中使用MySQL / MariaDB服务。</p><p>Ubuntu映像已经包含一个预先配置的MySQL服务器，但是如果您要使用特定或更新的版本，甚至是MariaDB服务器，则需要使用服务。Github Actions中的服务只是一个运行特定映像并将其端口公开给localhost的Docker容器。您也可以通过安装所需的服务，apt-get但是在这种情况下使用Docker可能会更容易。</p><p>您需要谨慎使用此设置，因为如果使用默认端口，则您的应用或测试将连接到本地mysql服务器，而不是docker服务器。为确保应用使用正确的数据库，请确保使用$变量并将其传递给您的配置。由于启动脚本正在运行，由于Docker中的MySQL可能需要几分钟才能使用，因此您需要等待服务器准备就绪，否则它将无法接受连接，并且由于缺少数据库连接，以下步骤可能会失败。</p><p>以下YML代码可以用作此类操作的示例。</p><p>在本services节中，我们定义要启动的数据库docker映像（mariadb:latest在这种情况下）以及公开的端口。docker镜像使用传递给它的Environment变量来创建初始数据库并指定用户。有关更多详细信息，请参见<a href="https://hub.docker.com/_/mariadb/或https://hub.docker.com/_/mysql。该options规定被传递到码头工人为它的内部状况检查。此命令可确保在测试期间数据库可访问，并且如果指定的命令health-retries多次失败，则docker将自动重启容器。在本Verify" target="_blank" rel="noopener">https://hub.docker.com/_/mariadb/或https://hub.docker.com/_/mysql。该options规定被传递到码头工人为它的内部状况检查。此命令可确保在测试期间数据库可访问，并且如果指定的命令health-retries多次失败，则docker将自动重启容器。在本Verify</a> MariaDB connection节中，简单mysqladmin ping在继续测试之前，请执行以确保数据库已完全启动并运行。当容器中的端口映射到主机上的随机端口时，我们还需要通过暴露变量来捕获它$，并将其通过环境变量传递给命令。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">name: Tests</span><br><span class="line"></span><br><span class="line">on: [push]</span><br><span class="line"></span><br><span class="line">jobs:</span><br><span class="line">  build:</span><br><span class="line">    runs-on: ubuntu-latest</span><br><span class="line"></span><br><span class="line">    services:</span><br><span class="line">      mariadb:</span><br><span class="line">        image: mariadb:latest</span><br><span class="line">        ports:</span><br><span class="line">          - 3306</span><br><span class="line">        env:</span><br><span class="line">          MYSQL_USER: user</span><br><span class="line">          MYSQL_PASSWORD: password</span><br><span class="line">          MYSQL_DATABASE: test</span><br><span class="line">          MYSQL_ROOT_PASSWORD: password</span><br><span class="line">        options: --health-cmd=&quot;mysqladmin ping&quot; --health-interval=5s --health-timeout=2s --health-retries=3</span><br><span class="line"></span><br><span class="line">    steps:</span><br><span class="line">    - uses: actions/checkout@v1</span><br><span class="line"></span><br><span class="line">    - name: Verify MariaDB connection</span><br><span class="line">      env:</span><br><span class="line">        PORT: $&#123;&#123; job.services.mariadb.ports[3306] &#125;&#125;</span><br><span class="line">      run: |</span><br><span class="line">        while ! mysqladmin ping -h&quot;127.0.0.1&quot; -P&quot;$PORT&quot; --silent; do</span><br><span class="line">          sleep 1</span><br><span class="line">        done</span><br><span class="line"></span><br><span class="line">    - name: Test</span><br><span class="line">      run: |</span><br><span class="line">        your tests</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;将MySQL服务与Github操作一起使用&quot;&gt;&lt;a href=&quot;#将MySQL服务与Github操作一起使用&quot; class=&quot;headerlink&quot; title=&quot;将MySQL服务与Github操作一起使用&quot;&gt;&lt;/a&gt;将MySQL服务与Github操作一起使用&lt;/
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>flutter环境搭建</title>
    <link href="http://yoursite.com/2020/01/16/flutter%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2020/01/16/flutter环境搭建/</id>
    <published>2020-01-16T15:48:48.000Z</published>
    <updated>2020-01-16T16:29:05.454Z</updated>
    
    <content type="html"><![CDATA[<p>最近开始接触flutter,今天配置了flutter的开发环境，现在把这个过程记录下来.</p><h1 id="系统环境要求"><a href="#系统环境要求" class="headerlink" title="系统环境要求"></a>系统环境要求</h1><p>macOS (64-bit)<br>硬盘空间: 700 MB (不包含android studio等编辑器工具).<br>命令行工具:bash, mkdir, rm, git, curl, unzip, which,brew需要保证上述命令在命令行下能使用，</p><h1 id="下载flutter"><a href="#下载flutter" class="headerlink" title="下载flutter"></a>下载flutter</h1><p><a href="https://flutter.dev/docs/get-started/install/macos" target="_blank" rel="noopener">https://flutter.dev/docs/get-started/install/macos</a></p><ul><li>解压安装包到你想安装的目录，如：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ~/development</span><br><span class="line">unzip ~/Downloads/flutter_macos_v0.5.1-beta.zip</span><br></pre></td></tr></table></figure></li></ul><p>添加flutter相关工具到path中：<br>export PATH=<code>pwd</code>/flutter/bin:$PATH</p><blockquote><p>这个目前只能暂时配置flutter，要永久的话可以vi ~/.bash_profile,<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PATH=~/Documents/flutter/bin:$PATH</span><br></pre></td></tr></table></figure></p></blockquote><h1 id="运行-flutter-doctor"><a href="#运行-flutter-doctor" class="headerlink" title="运行 flutter doctor"></a>运行 flutter doctor</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>这是我的结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">➜  Documents flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, v1.12.13+hotfix.5, on Mac OS X 10.15.2 19C57, locale zh-Hans-CN)</span><br><span class="line"></span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 11.3)</span><br><span class="line">[!] Android Studio (version 3.5)</span><br><span class="line">    ✗ Flutter plugin not installed; this adds Flutter specific functionality.</span><br><span class="line">    ✗ Dart plugin not installed; this adds Dart specific functionality.</span><br><span class="line">[✓] VS Code (version 1.41.1)</span><br><span class="line">[!] Connected device</span><br><span class="line">    ! No devices available</span><br></pre></td></tr></table></figure></p><p>解决步骤:<br>打开Android Studio &gt; Preferences &gt; Plugins &gt; flutter 下载过来</p><h2 id="iOS-设置"><a href="#iOS-设置" class="headerlink" title="iOS 设置"></a>iOS 设置</h2><p>安装 Xcode</p><ul><li>要为iOS开发Flutter应用程序，您需要Xcode 7.2或更高版本:</li><li>安装Xcode 7.2或更新版本(通过链接下载或苹果应用商店).</li><li>配置Xcode命令行工具以使用新安装的Xcode版本 sudo xcode-select –switch /Applications/Xcode.app/Contents/Developer 对于大多数情况，当您想要使用最新版本的Xcode时，这是正确的路径。如果您需要使用不同的版本，请指定相应路径。</li><li>确保Xcode许可协议是通过打开一次Xcode或通过命令sudo xcodebuild -license同意过了.<br>使用Xcode，您可以在iOS设备或模拟器上运行Flutter应用程序。<br>设置iOS模拟器<br>要准备在iOS模拟器上运行并测试您的Flutter应用，请按以下步骤操作：<br>在Mac上，通过Spotlight或使用以下命令找到模拟器:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">open -a Simulator</span><br></pre></td></tr></table></figure></li></ul><p>通过检查模拟器 硬件&gt;设备 菜单中的设置，确保您的模拟器正在使用64位设备（iPhone 5s或更高版本）.<br>根据您的开发机器的屏幕大小，模拟的高清屏iOS设备可能会使您的屏幕溢出。在模拟器的 Window&gt; Scale 菜单下设置设备比例<br>运行 flutter run启动您的应用.<br>安装到iOS设备<br>要将您的Flutter应用安装到iOS真机设备，您需要一些额外的工具和一个Apple帐户，您还需要在Xcode中进行设置。<br>安装 homebrew （如果已经安装了brew,跳过此步骤）.<br>打开终端并运行这些命令来安装用于将Flutter应用安装到iOS设备的工具<br>brew update<br>然后我们在执行flutter doctor<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">➜  Documents flutter doctor</span><br><span class="line">Doctor summary (to see all details, run flutter doctor -v):</span><br><span class="line">[✓] Flutter (Channel stable, v1.12.13+hotfix.5, on Mac OS X 10.15.2 19C57, locale zh-Hans-CN)</span><br><span class="line"></span><br><span class="line">[✓] Android toolchain - develop for Android devices (Android SDK version 29.0.2)</span><br><span class="line">[✓] Xcode - develop for iOS and macOS (Xcode 11.3)</span><br><span class="line">[✓] Android Studio (version 3.5)</span><br><span class="line">[✓] VS Code (version 1.41.1)</span><br><span class="line">[✓] Connected device (1 available)</span><br><span class="line"></span><br><span class="line">• No issues found!</span><br></pre></td></tr></table></figure></p><p>然后我们创建第一个app项目<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter create my_app</span><br></pre></td></tr></table></figure></p><p>然后运行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd my_app</span><br><span class="line">flutter run</span><br></pre></td></tr></table></figure></p><p>这样就可以运行第一个flutter的app了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://flutter.dev/docs/get-started/install/macos" target="_blank" rel="noopener">flutter macOS install</a></li><li><a href="https://flutterchina.club/setup-macos/" target="_blank" rel="noopener">入门: 在macOS上搭建Flutter开发环境</a></li><li><a href="https://segmentfault.com/a/1190000014845833" target="_blank" rel="noopener">flutter环境搭建mac版</a></li><li><a href="https://stackoverflow.com/questions/49045393/flutter-run-no-connected-devices" target="_blank" rel="noopener">flutter run: No connected devices</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近开始接触flutter,今天配置了flutter的开发环境，现在把这个过程记录下来.&lt;/p&gt;
&lt;h1 id=&quot;系统环境要求&quot;&gt;&lt;a href=&quot;#系统环境要求&quot; class=&quot;headerlink&quot; title=&quot;系统环境要求&quot;&gt;&lt;/a&gt;系统环境要求&lt;/h1&gt;&lt;p&gt;ma
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>阿里云linux系统挂载磁盘</title>
    <link href="http://yoursite.com/2020/01/05/%E9%98%BF%E9%87%8C%E4%BA%91linux%E7%B3%BB%E7%BB%9F%E6%8C%82%E8%BD%BD%E7%A3%81%E7%9B%98/"/>
    <id>http://yoursite.com/2020/01/05/阿里云linux系统挂载磁盘/</id>
    <published>2020-01-05T03:11:32.000Z</published>
    <updated>2020-01-05T03:26:20.892Z</updated>
    
    <content type="html"><![CDATA[<p>一、打开控制台-服务器-磁盘-创建磁盘<br>创建磁盘, 完成之后在返回刚刚的地方, 执行挂载<br>二、然后登录linux服务器 进程分区挂载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z data]# fdisk -l</span><br><span class="line"></span><br><span class="line">磁盘 /dev/vda：42.9 GB, 42949672960 字节，83886080 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x000b2d99</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vda1   *        2048    83875364    41936658+  83  Linux</span><br><span class="line"></span><br><span class="line">磁盘 /dev/vdb：107.4 GB, 107374182400 字节，209715200 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br></pre></td></tr></table></figure></p><p>然后我们将挂载的设置更改写入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z data]# fdisk /dev/vdb</span><br><span class="line">欢迎使用 fdisk (util-linux 2.23.2)。</span><br><span class="line"></span><br><span class="line">更改将停留在内存中，直到您决定将更改写入磁盘。</span><br><span class="line">使用写入命令前请三思。</span><br><span class="line"></span><br><span class="line">Device does not contain a recognized partition table</span><br><span class="line">使用磁盘标识符 0x677825d5 创建新的 DOS 磁盘标签。</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (0 primary, 0 extended, 4 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): p</span><br><span class="line">分区号 (1-4，默认 1)：</span><br><span class="line">起始 扇区 (2048-209715199，默认为 2048)：</span><br><span class="line">将使用默认值 2048</span><br><span class="line">Last 扇区, +扇区 or +size&#123;K,M,G&#125; (2048-209715199，默认为 209715199)：</span><br><span class="line">将使用默认值 209715199</span><br><span class="line">分区 1 已设置为 Linux 类型，大小设为 100 GiB</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/vdb：107.4 GB, 107374182400 字节，209715200 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x677825d5</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vdb1            2048   209715199   104856576   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/vdb：107.4 GB, 107374182400 字节，209715200 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x677825d5</span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vdb1            2048   209715199   104856576   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：p</span><br><span class="line"></span><br><span class="line">磁盘 /dev/vdb：107.4 GB, 107374182400 字节，209715200 个扇区</span><br><span class="line">Units = 扇区 of 1 * 512 = 512 bytes</span><br><span class="line">扇区大小(逻辑/物理)：512 字节 / 512 字节</span><br><span class="line">I/O 大小(最小/最佳)：512 字节 / 512 字节</span><br><span class="line">磁盘标签类型：dos</span><br><span class="line">磁盘标识符：0x677825d5</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   设备 Boot      Start         End      Blocks   Id  System</span><br><span class="line">/dev/vdb1            2048   209715199   104856576   83  Linux</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助)：m</span><br><span class="line">命令操作</span><br><span class="line">   a   toggle a bootable flag</span><br><span class="line">   b   edit bsd disklabel</span><br><span class="line">   c   toggle the dos compatibility flag</span><br><span class="line">   d   delete a partition</span><br><span class="line">   g   create a new empty GPT partition table</span><br><span class="line">   G   create an IRIX (SGI) partition table</span><br><span class="line">   l   list known partition types</span><br><span class="line">   m   print this menu</span><br><span class="line">   n   add a new partition</span><br><span class="line">   o   create a new empty DOS partition table</span><br><span class="line">   p   print the partition table</span><br><span class="line">   q   quit without saving changes</span><br><span class="line">   s   create a new empty Sun disklabel</span><br><span class="line">   t   change a partition's system id</span><br><span class="line">   u   change display/entry units</span><br><span class="line">   v   verify the partition table</span><br><span class="line">   w   write table to disk and exit</span><br><span class="line">   x   extra functionality (experts only)</span><br><span class="line"></span><br><span class="line">命令(输入 m 获取帮助) q</span><br></pre></td></tr></table></figure></p><p>然后写入<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z data]# mkfs.ext3 /dev/vdb</span><br><span class="line">mke2fs 1.42.9 (28-Dec-2013)</span><br><span class="line">文件系统标签=</span><br><span class="line">OS type: Linux</span><br><span class="line">块大小=4096 (log=2)</span><br><span class="line">分块大小=4096 (log=2)</span><br><span class="line">Stride=0 blocks, Stripe width=0 blocks</span><br><span class="line">6553600 inodes, 26214400 blocks</span><br><span class="line">1310720 blocks (5.00%) reserved for the super user</span><br><span class="line">第一个数据块=0</span><br><span class="line">Maximum filesystem blocks=4294967296</span><br><span class="line">800 block groups</span><br><span class="line">32768 blocks per group, 32768 fragments per group</span><br><span class="line">8192 inodes per group</span><br><span class="line">Superblock backups stored on blocks:</span><br><span class="line">32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208,</span><br><span class="line">4096000, 7962624, 11239424, 20480000, 23887872</span><br><span class="line"></span><br><span class="line">Allocating group tables: 完成</span><br><span class="line">正在写入inode表: 完成</span><br><span class="line">Creating journal (32768 blocks): 完成</span><br><span class="line">Writing superblocks and filesystem accounting information: 完成</span><br></pre></td></tr></table></figure></p><p>格式化 挂载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z data]# vi /etc/fstab</span><br></pre></td></tr></table></figure></p><p>写入挂载的磁盘<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/vdb /mnt ext3 defaults 0 0</span><br></pre></td></tr></table></figure></p><p>然后我们进行挂载<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z data]# mount -a</span><br></pre></td></tr></table></figure></p><p>最后我们看到了我们刚挂载的磁盘<br>[root@iZ8vbcuptq5g86qk6lk4x1Z data]# df -h<br>文件系统        容量  已用  可用 已用% 挂载点<br>devtmpfs        1.9G     0  1.9G    0% /dev<br>tmpfs           1.9G     0  1.9G    0% /dev/shm<br>tmpfs           1.9G  828K  1.9G    1% /run<br>tmpfs           1.9G     0  1.9G    0% /sys/fs/cgroup<br>/dev/vda1        40G   31G  7.3G   81% /<br>tmpfs           1.9G   12K  1.9G    1% /var/lib/kubelet/pods/0de38241-1a67-420e-9be1-a134d074ef9a/volumes/kubernetes.io~secret/kube-proxy-token-vb2tf<br>tmpfs           1.9G   12K  1.9G    1% /var/lib/kubelet/pods/c43b28d3-3327-49aa-a495-ae852a62836b/volumes/kubernetes.io~secret/flannel-token-6wvm6<br>overlay          40G   31G  7.3G   81% /var/lib/docker/overlay2/a5427d390e807abd425386d6672b92a51a5254467d91085853ae38b99307e9f0/merged<br>overlay          40G   31G  7.3G   81% /var/lib/docker/overlay2/32ff2942f925963dbe545801c058e1c18c7b8fd647973f0ca02b52a2426c8b82/merged<br>shm              64M     0   64M    0% /var/lib/docker/containers/496f71ea4b9b2167a4902fb6a4724790378f1fe271d92bd384cdb901f440225f/mounts/shm<br>shm              64M     0   64M    0% /var/lib/docker/containers/61b7684e36a60c4096a512d7cd6f82ce3a8e9d930d85ad2d974b4705658a3c95/mounts/shm<br>overlay          40G   31G  7.3G   81% /var/lib/docker/overlay2/983dadfacba33b05d6ba40913ff78a8ac5ce53802d2b892ec675b0bc47e676a2/merged<br>overlay          40G   31G  7.3G   81% /var/lib/docker/overlay2/0775175ff240ea5b3370fc9cd08909cb0c9218b30e3d6e9545b42e8eb9e9017d/merged<br>tmpfs           379M     0  379M    0% /run/user/0<br>overlay          40G   31G  7.3G   81% /var/lib/docker/overlay2/30a79b628c071c1b624c3108abadeb2e159d4c76e28d8e0c6af9ad6ae262ad01/merged<br>overlay          40G   31G  7.3G   81% /var/lib/docker/overlay2/3fb2ddcf55f7ab7536c3f04567ea6d4452fca1dcbae1ccd6f868a997155e5130/merged</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title=" 参考文章:"></a> 参考文章:</h2><p><a href="https://yq.aliyun.com/articles/656289" target="_blank" rel="noopener">阿里云Linux系统挂载磁盘</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;一、打开控制台-服务器-磁盘-创建磁盘&lt;br&gt;创建磁盘, 完成之后在返回刚刚的地方, 执行挂载&lt;br&gt;二、然后登录linux服务器 进程分区挂载&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>helm在k8s上的部署</title>
    <link href="http://yoursite.com/2019/12/21/helm%E5%9C%A8k8s%E4%B8%8A%E7%9A%84%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2019/12/21/helm在k8s上的部署/</id>
    <published>2019-12-21T01:57:06.000Z</published>
    <updated>2019-12-21T03:01:53.533Z</updated>
    
    <content type="html"><![CDATA[<p>helm是k8s集群上的包管理工具，类似centos上的yum，ubuntu上的apt-get。<br>在安装了k8s后我今天打算安装helm,来部署ingress暴露我的服务</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><blockquote><p>对于应用发布者而言，可以通过helm打包应用，管理应用依赖关系，管理应用版本并发布应用到软件仓库。<br>对于使用者而言，使用helm后不用需要了解kubernetes的yaml语法并编写应用部署文件，可以通过helm下载并在kubernetes上安装需要的应用。<br>除此以外，helm还提供了kubernetes上的软件部署，删除，升级，回滚应用的强大功能。</p></blockquote><h2 id="组件说明"><a href="#组件说明" class="headerlink" title="组件说明"></a>组件说明</h2><ul><li>helm: kubernetes的应用打包工具，也是命令行工具的名称。</li><li>tiller: helm的服务端，部署在kubernetes集群中，用于处理helm的相关命令。</li><li>chart: helm的打包格式，内部包含了一组相关的kubernetes资源。</li><li>repoistory: helm的软件仓库，repository本质上是一个web服务器，该服务器保存了chart软件包以供下载，并有提供一个该repository的chart包的清单文件以供查询。在使用时，helm可以对接多个不同的Repository。</li><li>release: 使用helm install命令在kubernetes集群中安装的Chart称为Release。<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2>Helm由客户端命helm令行工具和服务端tiller组成，Helm的安装十分简单。 下载helm命令行工具到master节点node1的/usr/local/bin下，这里下载的2.13.1版本：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget https://storage.googleapis.com/kubernetes-helm/helm-v2.13.1-linux-amd64.tar.gz</span><br><span class="line">tar -zxvf helm-v2.13.1-linux-amd64.tar.gz</span><br><span class="line">cd linux-amd64/</span><br><span class="line">cp helm /usr/local/bin/</span><br></pre></td></tr></table></figure></li></ul><p>因为Kubernetes APIServer开启了RBAC访问控制，所以需要创建tiller使用的service account: tiller并分配合适的角色给它。 详细内容可以查看helm文档中的Role-based Access Control。 这里简单起见直接分配cluster-admin这个集群内置的ClusterRole给它。创建rbac-config.yaml文件：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">  namespace: kube-system</span><br><span class="line">---</span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1beta1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: tiller</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">  - kind: ServiceAccount</span><br><span class="line">    name: tiller</span><br><span class="line">    namespace: kube-system</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl create -f rbac-config.yaml</span><br><span class="line">serviceaccount/tiller created</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/tiller created</span><br></pre></td></tr></table></figure><p>接下来使用helm部署tiller:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">helm init --service-account tiller --skip-refresh</span><br></pre></td></tr></table></figure></p><p>但是没有启动，查看了原因是镜像被强了，只能去阿里云下载对应的镜像,然后更名<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1</span><br><span class="line">docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/tiller:v2.13.1 gcr.io/kubernetes-helm/tiller:v2.13.1</span><br></pre></td></tr></table></figure></p><p>然后再执行一遍<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">helm init --service-account tiller --skip-refresh</span><br><span class="line">Creating /root/.helm</span><br><span class="line">Creating /root/.helm/repository</span><br><span class="line">Creating /root/.helm/repository/cache</span><br><span class="line">Creating /root/.helm/repository/local</span><br><span class="line">Creating /root/.helm/plugins</span><br><span class="line">Creating /root/.helm/starters</span><br><span class="line">Creating /root/.helm/cache/archive</span><br><span class="line">Creating /root/.helm/repository/repositories.yaml</span><br><span class="line">Adding stable repo with URL: https://kubernetes-charts.storage.googleapis.com</span><br><span class="line">Adding local repo with URL: http://127.0.0.1:8879/charts</span><br><span class="line"><span class="meta">$</span><span class="bash">HELM_HOME has been configured at /root/.helm.</span></span><br><span class="line"></span><br><span class="line">Tiller (the Helm server-side component) has been installed into your Kubernetes Cluster.</span><br><span class="line"></span><br><span class="line">Please note: by default, Tiller is deployed with an insecure 'allow unauthenticated users' policy.</span><br><span class="line">To prevent this, run `helm init` with the --tiller-tls-verify flag.</span><br><span class="line">For more information on securing your installation see: https://docs.helm.sh/using_helm/#securing-your-helm-installation</span><br><span class="line">Happy Helming!</span><br></pre></td></tr></table></figure></p><p>tiller默认被部署在k8s集群中的kube-system这个namespace下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pod -n kube-system -l app=helm</span><br><span class="line">NAME                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">tiller-deploy-6966cf57d8-kfxlg   1/1     Running   0          83s</span><br></pre></td></tr></table></figure></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# helm version</span><br><span class="line">Client: &amp;version.Version&#123;SemVer:"v2.13.1", GitCommit:"618447cbf203d147601b4b9bd7f8c37a5d39fbb4", GitTreeState:"clean"&#125;</span><br><span class="line">Server: &amp;version.Version&#123;SemVer:"v2.13.1", GitCommit:"618447cbf203d147601b4b9bd7f8c37a5d39fbb4", GitTreeState:"clean"&#125;</span><br></pre></td></tr></table></figure><h2 id="使用Helm部署Nginx-Ingress"><a href="#使用Helm部署Nginx-Ingress" class="headerlink" title="使用Helm部署Nginx Ingress"></a>使用Helm部署Nginx Ingress</h2><p>为了便于将集群中的服务暴露到集群外部，从集群外部访问，接下来使用Helm将Nginx Ingress部署到Kubernetes上。 Nginx Ingress Controller被部署在Kubernetes的边缘节点上<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl label node node1 node-role.kubernetes.io/edge=</span><br><span class="line">node/node1 labeled</span><br></pre></td></tr></table></figure></p><p>我们将node1做为边缘节点，打上Label：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get node</span><br><span class="line">NAME    STATUS   ROLES         AGE   VERSION</span><br><span class="line">node1   Ready    edge,master   24m   v1.14.0</span><br><span class="line">node2   Ready    &lt;none&gt;        11m   v1.14.0</span><br></pre></td></tr></table></figure></p><p>stable/nginx-ingress chart的值文件ingress-nginx.yaml：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">controller:</span><br><span class="line">  replicaCount: 1</span><br><span class="line">  hostNetwork: true</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node-role.kubernetes.io/edge: ''</span><br><span class="line">  affinity:</span><br><span class="line">    podAntiAffinity:</span><br><span class="line">        requiredDuringSchedulingIgnoredDuringExecution:</span><br><span class="line">        - labelSelector:</span><br><span class="line">            matchExpressions:</span><br><span class="line">            - key: app</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - nginx-ingress</span><br><span class="line">            - key: component</span><br><span class="line">              operator: In</span><br><span class="line">              values:</span><br><span class="line">              - controller</span><br><span class="line">          topologyKey: kubernetes.io/hostname</span><br><span class="line">  tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        operator: Exists</span><br><span class="line">        effect: NoSchedule</span><br><span class="line"></span><br><span class="line">defaultBackend:</span><br><span class="line">  nodeSelector:</span><br><span class="line">    node-role.kubernetes.io/edge: ''</span><br><span class="line">  tolerations:</span><br><span class="line">      - key: node-role.kubernetes.io/master</span><br><span class="line">        operator: Exists</span><br><span class="line">        effect: NoSchedule</span><br></pre></td></tr></table></figure></p><p>nginx ingress controller的副本数replicaCount为1，将被调度到node1这个边缘节点上。这里并没有指定nginx ingress controller service的externalIPs，而是通过hostNetwork: true设置nginx ingress controller使用宿主机网络。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">helm repo update</span><br><span class="line"></span><br><span class="line">helm install stable/nginx-ingress \</span><br><span class="line">-n nginx-ingress \</span><br><span class="line">--namespace ingress-nginx  \</span><br><span class="line">-f ingress-nginx.yaml</span><br></pre></td></tr></table></figure></p><p>当然意料之中的没有这么一番丰顺<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n ingress-nginx</span><br><span class="line">NAME                                            READY   STATUS             RESTARTS   AGE</span><br><span class="line">nginx-ingress-controller-5f94977665-xx5dh       1/1     Running            0          4h43m</span><br><span class="line">nginx-ingress-default-backend-774bd49bf-mm56k   0/1     ImagePullBackOff   0          4h43m</span><br></pre></td></tr></table></figure></p><h2 id="然后我们通过kubectl-describe这个命令查看这个pod没有启动的原因"><a href="#然后我们通过kubectl-describe这个命令查看这个pod没有启动的原因" class="headerlink" title="然后我们通过kubectl describe这个命令查看这个pod没有启动的原因"></a>然后我们通过kubectl describe这个命令查看这个pod没有启动的原因</h2><p>[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl –namespace=ingress-nginx describe pod nginx-ingress-default-backend-774bd49bf-mm56k<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Name:         nginx-ingress-default-backend-774bd49bf-mm56k</span><br><span class="line">Namespace:    ingress-nginx</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         iz8vbbld8tet39uo7wyi2jz/172.26.139.97</span><br><span class="line">Start Time:   Fri, 20 Dec 2019 19:49:53 +0800</span><br><span class="line">Labels:       app=nginx-ingress</span><br><span class="line">              component=default-backend</span><br><span class="line">              pod-template-hash=774bd49bf</span><br><span class="line">              release=nginx-ingress</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Pending</span><br><span class="line">IP:           10.244.0.6</span><br><span class="line">IPs:</span><br><span class="line">  IP:           10.244.0.6</span><br><span class="line">Controlled By:  ReplicaSet/nginx-ingress-default-backend-774bd49bf</span><br><span class="line">Containers:</span><br><span class="line">  nginx-ingress-default-backend:</span><br><span class="line">    Container ID:</span><br><span class="line">    Image:          k8s.gcr.io/defaultbackend-amd64:1.5</span><br><span class="line">    Image ID:</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Waiting</span><br><span class="line">      Reason:       ImagePullBackOff</span><br><span class="line">    Ready:          False</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Liveness:       http-get http://:8080/healthz delay=30s timeout=5s period=10s #success=1 #failure=3</span><br><span class="line">    Readiness:      http-get http://:8080/healthz delay=0s timeout=5s period=5s #success=1 #failure=6</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from nginx-ingress-backend-token-ftx8j (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             False</span><br><span class="line">  ContainersReady   False</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  nginx-ingress-backend-token-ftx8j:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  nginx-ingress-backend-token-ftx8j</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  node-role.kubernetes.io/edge=</span><br><span class="line">Tolerations:     node-role.kubernetes.io/master:NoSchedule</span><br><span class="line">                 node.kubernetes.io/not-ready:NoExecute for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type     Reason  Age                     From                              Message</span><br><span class="line">  ----     ------  ----                    ----                              -------</span><br><span class="line">  Warning  Failed  58m (x17 over 3h58m)    kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ErrImagePull</span><br><span class="line">  Warning  Failed  3m7s (x264 over 3h58m)  kubelet, iz8vbbld8tet39uo7wyi2jz  Error: ImagePullBackOff</span><br></pre></td></tr></table></figure></p><p>原来还是对应的image没有下载过来<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5</span><br><span class="line">docker tag googlecontainer/defaultbackend-amd64:1.1 k8s.gcr.io/defaultbackend-amd64:1.5</span><br><span class="line">docker rmi registry.cn-qingdao.aliyuncs.com/kubernetes_xingej/defaultbackend-amd64:1.5</span><br></pre></td></tr></table></figure></p><p>然后我们确认下对应的pod和service是否启动成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get pods -n ingress-nginx</span><br><span class="line">NAME                                            READY   STATUS    RESTARTS   AGE</span><br><span class="line">nginx-ingress-controller-5f94977665-xx5dh       1/1     Running   0          5h9m</span><br><span class="line">nginx-ingress-default-backend-774bd49bf-mm56k   1/1     Running   0          5h9m</span><br><span class="line">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# kubectl get service -n ingress-nginx</span><br><span class="line">NAME                            TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)                      AGE</span><br><span class="line">nginx-ingress-controller        LoadBalancer   10.96.96.226    &lt;pending&gt;     80:32074/TCP,443:32522/TCP   5h13m</span><br><span class="line">nginx-ingress-default-backend   ClusterIP      10.96.228.114   &lt;none&gt;        80/TCP                       5h13m</span><br></pre></td></tr></table></figure></p><p>然后访问下链接，测试是否链接成功<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbbld8tet39uo7wyi2jZ ~]# curl 172.26.139.97</span><br><span class="line">default backend - 404</span><br></pre></td></tr></table></figure></p><p>这样就可以了</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://blog.frognew.com/2019/04/kubeadm-install-kubernetes-1.14.html#31-helm" target="_blank" rel="noopener">使用kubeadm安装Kubernetes 1.14</a></li><li><a href="https://www.jianshu.com/p/e30b06906b77" target="_blank" rel="noopener">kubernetes 1.12.1 Ingress-nginx 部署使用</a></li><li><a href="https://juejin.im/post/5d54f87ff265da03b1204581" target="_blank" rel="noopener">Helm入门</a></li><li><a href="https://blog.bwcxtech.com/posts/5c50d041/" target="_blank" rel="noopener">K8s安装Ingress</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;helm是k8s集群上的包管理工具，类似centos上的yum，ubuntu上的apt-get。&lt;br&gt;在安装了k8s后我今天打算安装helm,来部署ingress暴露我的服务&lt;/p&gt;
&lt;h2 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerl
      
    
    </summary>
    
    
      <category term="devops" scheme="http://yoursite.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>在k8s上部署dashboard后台管理界面</title>
    <link href="http://yoursite.com/2019/12/20/%E5%9C%A8k8s%E4%B8%8A%E9%83%A8%E7%BD%B2dashboard%E5%90%8E%E5%8F%B0%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/"/>
    <id>http://yoursite.com/2019/12/20/在k8s上部署dashboard后台管理界面/</id>
    <published>2019-12-20T08:30:34.000Z</published>
    <updated>2019-12-21T01:52:51.800Z</updated>
    
    <content type="html"><![CDATA[<p>在昨天成功部署了k8s后，我今天尝试着部署它的后台web界面</p><h1 id="下载官方的yaml"><a href="#下载官方的yaml" class="headerlink" title="下载官方的yaml"></a>下载官方的yaml</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget https://raw.githubusercontent.com/kubernetes/dashboard/v1.10.1/src/deploy/recommended/kubernetes-dashboard.yaml</span><br></pre></td></tr></table></figure><p>由于官方的yaml不直接对外开放，需要在本地直接进行<code>kubectl proxy</code>进行代理,所以我们通过修改yaml来直接暴露端口和服务。有两个地方要修改：</p><h2 id="第一个是修改镜像-kubernetes-dashboard-yaml配置文件112行"><a href="#第一个是修改镜像-kubernetes-dashboard-yaml配置文件112行" class="headerlink" title="第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行"></a>第一个是修改镜像,kubernetes-dashboard.yaml配置文件112行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> 90 # ------------------- Dashboard Deployment ------------------- #</span><br><span class="line"> 91 </span><br><span class="line"> 92 kind: Deployment</span><br><span class="line"> 93 apiVersion: apps/v1</span><br><span class="line"> 94 metadata:</span><br><span class="line"> 95 labels:</span><br><span class="line"> 96 k8s-app: kubernetes-dashboard</span><br><span class="line"> 97 name: kubernetes-dashboard</span><br><span class="line"> 98 namespace: kube-system</span><br><span class="line"> 99 spec:</span><br><span class="line">100 replicas: 1</span><br><span class="line">101 revisionHistoryLimit: 10</span><br><span class="line">102 selector:</span><br><span class="line">103 matchLabels:</span><br><span class="line">104 k8s-app: kubernetes-dashboard</span><br><span class="line">105 template:</span><br><span class="line">106 metadata:</span><br><span class="line">107 labels:</span><br><span class="line">108 k8s-app: kubernetes-dashboard</span><br><span class="line">109 spec:</span><br><span class="line">110 containers:</span><br><span class="line">111 - name: kubernetes-dashboard</span><br><span class="line">112 #image: k8s.gcr.io/kubernetes-dashboard-amd64:v1.10.1</span><br><span class="line">113 image: mirrorgooglecontainers/kubernetes-dashboard-amd64:v1.10.0</span><br><span class="line">114 ports:</span><br><span class="line">115 - containerPort: 8443</span><br><span class="line">116 protocol: TCP</span><br></pre></td></tr></table></figure><h2 id="第二个是添加一个type-指定端口类型为-NodePort，这样外界可以通过地址-nodeIP-nodePort-访问-dashboard-kubernetes-dashboard-yaml配置文件158行"><a href="#第二个是添加一个type-指定端口类型为-NodePort，这样外界可以通过地址-nodeIP-nodePort-访问-dashboard-kubernetes-dashboard-yaml配置文件158行" class="headerlink" title="第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:"></a>第二个是添加一个type,指定端口类型为 NodePort，这样外界可以通过地址 nodeIP:nodePort 访问 dashboard,kubernetes-dashboard.yaml配置文件158行:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">148 # ------------------- Dashboard Service ------------------- #</span><br><span class="line">149 </span><br><span class="line">150 kind: Service</span><br><span class="line">151 apiVersion: v1</span><br><span class="line">152 metadata:</span><br><span class="line">153 labels:</span><br><span class="line">154 k8s-app: kubernetes-dashboard</span><br><span class="line">155 name: kubernetes-dashboard</span><br><span class="line">156 namespace: kube-system</span><br><span class="line">157 spec:</span><br><span class="line">158 type: NodePort</span><br><span class="line">159 ports:</span><br><span class="line">160 - port: 443</span><br><span class="line">161 targetPort: 8443</span><br><span class="line">162 selector:</span><br><span class="line">163 k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure><h2 id="部署到k8s集群"><a href="#部署到k8s集群" class="headerlink" title="部署到k8s集群"></a>部署到k8s集群</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl apply <span class="_">-f</span> kubernetes-dashboard.yaml </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get pods -n kube-system |grep dashboard</span></span><br><span class="line">kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 98s</span><br><span class="line"><span class="meta">#</span><span class="bash"> kubectl get pods,svc -n kube-system</span></span><br><span class="line">NAME READY STATUS RESTARTS AGE</span><br><span class="line">pod/coredns-78d4cf999f-5hcjm 1/1 Running 0 3h21m</span><br><span class="line">pod/coredns-78d4cf999f-6mlql 1/1 Running 0 3h21m</span><br><span class="line">pod/etcd-k8sm-218 1/1 Running 0 3h20m</span><br><span class="line">pod/kube-apiserver-k8sm-218 1/1 Running 0 3h19m</span><br><span class="line">pod/kube-controller-manager-k8sm-218 1/1 Running 0 3h20m</span><br><span class="line">pod/kube-flannel-ds-amd64-6kfhg 1/1 Running 0 3h13m</span><br><span class="line">pod/kube-flannel-ds-amd64-c4fr4 1/1 Running 0 152m</span><br><span class="line">pod/kube-flannel-ds-amd64-qhc2w 1/1 Running 0 151m</span><br><span class="line">pod/kube-proxy-7hntq 1/1 Running 0 151m</span><br><span class="line">pod/kube-proxy-b4txb 1/1 Running 0 3h21m</span><br><span class="line">pod/kube-proxy-bz529 1/1 Running 0 152m</span><br><span class="line">pod/kube-scheduler-k8sm-218 1/1 Running 0 3h20m</span><br><span class="line">pod/kubernetes-dashboard-6685cb584f-xlk2h 1/1 Running 0 3m5s</span><br><span class="line"></span><br><span class="line">NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE</span><br><span class="line">service/kube-dns ClusterIP 10.96.0.10 &lt;none&gt; 53/UDP,53/TCP 3h21m</span><br><span class="line">service/kubernetes-dashboard NodePort 10.104.4.26 &lt;none&gt; 443:30023/TCP 3m5s</span><br></pre></td></tr></table></figure><blockquote><p>因为我是阿里云的ecs，还要在安全组添加30023进入的端口才能在外部访问<br><img src="https://ws1.sinaimg.cn/large/6919c235gy1ga4315f1moj227u15mtg2.jpg" alt="截屏2019-12-21上午9.22.32.png"></p></blockquote><h2 id="Token-（令牌）-认证方式登录"><a href="#Token-（令牌）-认证方式登录" class="headerlink" title="Token （令牌） 认证方式登录"></a>Token （令牌） 认证方式登录</h2><p>1）授权 (所有 namespace )</p><p>// 创建serviceaccount<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl create serviceaccount dashboard-serviceaccount -n kube-system</span></span><br></pre></td></tr></table></figure></p><p>// 创建clusterrolebinding<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl create clusterrolebinding dashboard-cluster-admin --clusterrole=cluster-admin --serviceaccount=kube-system:dashboard-serviceaccount</span></span><br></pre></td></tr></table></figure></p><p>2）获取令牌（用于网页登录）</p><p>// 查看口令列表<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl get secret -n kube-system |grep dashboard-serviceaccount-token</span></span><br><span class="line">dashboard-serviceaccount-token-f45wg kubernetes.io/service-account-token 3 22s</span><br></pre></td></tr></table></figure></p><p>// 获取口令<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> kubectl describe secret dashboard-serviceaccount-token<span class="_">-f</span>45wg -n kube-system</span></span><br></pre></td></tr></table></figure></p><p>3）将获取到的token放在令牌里<br><img src="https://ws1.sinaimg.cn/large/6919c235gy1ga434bjbalj227k13sgsr.jpg" alt="截屏2019-12-21上午9.25.38.png"><br>4) 登录成功<br><img src="https://ws1.sinaimg.cn/large/6919c235gy1ga43c9j0ywj228011oq93.jpg" alt="截屏2019-12-21上午9.33.33.png"><br>5) 但是我还是遇到了<br><img src="https://ws1.sinaimg.cn/large/6919c235gy1ga43f7ljwhj227o108n06.jpg" alt="截屏2019-12-21上午9.36.05.png"><br>这个问题暂时还没有解决</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title=" 参考文章:"></a> 参考文章:</h2><p><a href="https://zhuanlan.zhihu.com/p/92923128" target="_blank" rel="noopener">30分钟带你搭建一套Dashboard的kubernetes（K8S）集群</a><br><a href="https://www.kubernetes.org.cn/2906.html" target="_blank" rel="noopener">使用kubeadm安装Kubernetes 1.8版本</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在昨天成功部署了k8s后，我今天尝试着部署它的后台web界面&lt;/p&gt;
&lt;h1 id=&quot;下载官方的yaml&quot;&gt;&lt;a href=&quot;#下载官方的yaml&quot; class=&quot;headerlink&quot; title=&quot;下载官方的yaml&quot;&gt;&lt;/a&gt;下载官方的yaml&lt;/h1&gt;&lt;figure
      
    
    </summary>
    
    
      <category term="devops" scheme="http://yoursite.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>国内环境利用kubeadm进行kubernetes安装</title>
    <link href="http://yoursite.com/2019/12/18/%E5%9B%BD%E5%86%85%E7%8E%AF%E5%A2%83kubernetes%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2019/12/18/国内环境kubernetes安装/</id>
    <published>2019-12-18T12:10:10.000Z</published>
    <updated>2019-12-21T01:43:47.457Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要学习kubernetes，特地从阿里云购买了两台云主机，用的是kubeadm部署，由于被墙不能直接执行kubeadm init,比较麻烦，所以练习下kubernetes的安装。</p><blockquote><p>先介绍下两台都是centos7,需要注意的是作为主节点的云主机要有两个cpu，内存大于2gb，不然会提示cpu不够和内存限制</p></blockquote><h1 id="Kubernetes主要核心组件"><a href="#Kubernetes主要核心组件" class="headerlink" title="Kubernetes主要核心组件"></a>Kubernetes主要核心组件</h1><ul><li>etcd保存了整个集群的状态；</li><li>apiserver提供了资源操作的唯一入口，并提供认证、授权、访问控制、API注册和发现等机制；</li><li>controller manager负责维护集群的状态，比如故障检测、自动扩展、滚动更新等；</li><li>scheduler负责资源的调度，按照预定的调度策略将Pod调度到相应的机器上；</li><li>kubelet负责维护容器的生命周期，同时也负责Volume（CVI）和网络（CNI）的管理；</li><li>Container runtime负责镜像管理以及Pod和容器的真正运行（CRI）；</li><li>kube-proxy负责为Service提供cluster内部的服务发现和负载均衡；<br>除了核心组件，还有一些推荐的Add-ons：</li><li>kube-dns负责为整个集群提供DNS服务</li><li>Ingress Controller为服务提供外网入口</li><li>Heapster提供资源监控</li><li>Dashboard提供GUI</li><li>Federation提供跨可用区的集群</li><li>Fluentd-elasticsearch提供集群日志采集、存储与查询<h1 id="安装kubeadm"><a href="#安装kubeadm" class="headerlink" title="安装kubeadm"></a>安装kubeadm</h1>采用国内阿里云镜像源，安装kubelet、kubeadm、kubectl:<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">repo_gpgcheck=1</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">exclude=kube*</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Set SELinux <span class="keyword">in</span> permissive mode (effectively disabling it)</span></span><br><span class="line">setenforce 0</span><br><span class="line">sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config</span><br><span class="line"></span><br><span class="line">yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes</span><br><span class="line"></span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure></li></ul><p>centos7用户还需要设置路由：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt;  /etc/sysctl.d/k8s.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">EOF</span><br><span class="line">sysctl --system</span><br></pre></td></tr></table></figure></p><p>Kubernetes 1.8开始要求关闭系统的Swap，如果不关闭，默认配置下kubelet将无法启动，关闭系统的Swap方法如下:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br></pre></td></tr></table></figure></p><p>修改 /etc/fstab 文件，注释掉 SWAP 的自动挂载，使用free -m确认swap已经关闭。 swappiness参数调整，修改/etc/sysctl.d/k8s.conf添加下面一行：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vm.swappiness=0</span><br></pre></td></tr></table></figure></p><p>执行sysctl -p /etc/sysctl.d/k8s.conf使修改生效。</p><h1 id="获取镜像列表"><a href="#获取镜像列表" class="headerlink" title="获取镜像列表"></a>获取镜像列表</h1><p>由于官方镜像地址被墙，所以我们需要首先获取所需镜像以及它们的版本。然后从国内镜像站获取。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm config images list</span><br></pre></td></tr></table></figure></p><p>然后我们创建一个k8s.shell文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">images=(  # 下面的镜像应该去除"k8s.gcr.io/"的前缀，版本换成上面获取到的版本</span><br><span class="line">    kube-apiserver:v1.17.0</span><br><span class="line">    kube-controller-manager:v1.17.0</span><br><span class="line">    kube-scheduler:v1.17.0</span><br><span class="line">    kube-proxy:v1.17.0</span><br><span class="line">    pause:3.1</span><br><span class="line">    etcd:3.4.3-0</span><br><span class="line">    coredns:1.6.5</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for imageName in $&#123;images[@]&#125; ; do</span><br><span class="line">    docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">    docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName</span><br><span class="line">    docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p><p>然后chmod +x ./k8s.shell给这个shell文件加上执行权限，然后./k8s.shell执行它，它就会从阿里云拉取对应的组件的镜像了</p><h1 id="初始化环境"><a href="#初始化环境" class="headerlink" title="初始化环境"></a>初始化环境</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --pod-network-cidr=10.244.0.0/16 # 这一步注意，如果需要特定的网络插件，需要额外加参数，具体看网络插件的介绍</span><br></pre></td></tr></table></figure><h1 id="配置授权信息"><a href="#配置授权信息" class="headerlink" title="配置授权信息"></a>配置授权信息</h1><p>所需的命令在init成功后也会有提示，主要是为了保存相关的配置信息在用户目录下，这样不用每次都输入相关的认证信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br><span class="line">添加网络插件,以下是各个网桥，选择其中一个就可以了</span><br></pre></td></tr></table></figure></p><h2 id="CNI-bridge"><a href="#CNI-bridge" class="headerlink" title="CNI bridge"></a>CNI bridge</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /etc/cni/net.d</span><br><span class="line">cat &gt;/etc/cni/net.d/10-mynet.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    "cniVersion": "0.3.0",</span><br><span class="line">    "name": "mynet",</span><br><span class="line">    "type": "bridge",</span><br><span class="line">    "bridge": "cni0",</span><br><span class="line">    "isGateway": true,</span><br><span class="line">    "ipMasq": true,</span><br><span class="line">    "ipam": &#123;</span><br><span class="line">        "type": "host-local",</span><br><span class="line">        "subnet": "10.244.0.0/16",</span><br><span class="line">        "routes": [</span><br><span class="line">            &#123;"dst": "0.0.0.0/0"&#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">cat &gt;/etc/cni/net.d/99-loopback.conf &lt;&lt;-EOF</span><br><span class="line">&#123;</span><br><span class="line">    "cniVersion": "0.3.0",</span><br><span class="line">    "type": "loopback"</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><h2 id="flannel"><a href="#flannel" class="headerlink" title="flannel"></a>flannel</h2><p>需要在kubeadm init 时设置 –pod-network-cidr=10.244.0.0/16<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml</span><br></pre></td></tr></table></figure></p><p>weave<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.bridge.bridge-nf-call-iptables=1</span><br><span class="line">kubectl apply -f "https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\n')"</span><br><span class="line">calico</span><br></pre></td></tr></table></figure></p><p>需要 kubeadm init 时设置 –pod-network-cidr=192.168.0.0/16<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/rbac-kdd.yaml</span><br><span class="line">kubectl apply -f https://docs.projectcalico.org/v3.1/getting-started/kubernetes/installation/hosted/kub</span><br></pre></td></tr></table></figure></p><h1 id="查看是否安装成功"><a href="#查看是否安装成功" class="headerlink" title="查看是否安装成功"></a>查看是否安装成功</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods -n kube-system</span><br></pre></td></tr></table></figure><p>如果出现类似下面的情况就说明安装完成了，接下来就可以开始k8s之旅了。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NAME                              READY   STATUS              RESTARTS   AGE</span><br><span class="line">coredns-86c58d9df4-mmjls          1/1     Running             0          6h26m</span><br><span class="line">coredns-86c58d9df4-p7brk          1/1     Running             0          6h26m</span><br><span class="line">etcd-promote                      1/1     Running             1          6h26m</span><br><span class="line">kube-apiserver-promote            1/1     Running             1          6h26m</span><br><span class="line">kube-controller-manager-promote   1/1     Running             1          6h25m</span><br><span class="line">kube-proxy-6ml6w                  1/1     Running             1          6h26m</span><br><span class="line">kube-scheduler-promote            1/1     Running             1          6h25m</span><br></pre></td></tr></table></figure></p><h1 id="从节点加入主节点"><a href="#从节点加入主节点" class="headerlink" title="从节点加入主节点"></a>从节点加入主节点</h1><p>在从节点重复上面的步骤，就是<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl kubeadm join 主节点内部ip:6443 --token 你的token     --discovery-token-ca-cert-hash sha256:你的ca-cert</span><br></pre></td></tr></table></figure></p><p>但是我的从节点没有执行成功，提示不对<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# kubectl get pod</span><br><span class="line">The connection to the server localhost:8080 was refused - did you specify the right host or port?</span><br></pre></td></tr></table></figure></p><p>后面进过查找原因，发现是从节点的<br>问题原因是kubectl命令需使用kubernetes-admin来运行，解决方法如下，将主节点中的/etc/kubernetes/admin.conf文件拷贝到从节点相同目录下，然后配置环境变量：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo "export KUBECONFIG=/etc/kubernetes/admin.conf" &gt;&gt; ~/.bash_profile</span><br></pre></td></tr></table></figure></p><p>可生效<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br><span class="line">[root@master kubernetes]# scp ./admin.conf root@你的ip:/etc/kubernetes/</span><br></pre></td></tr></table></figure></p><p>然后再执行一次kubeadm reset，再kubeadm join的命令，<br>后面<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z kubernetes]# kubectl get nodes</span><br><span class="line">NAME                      STATUS   ROLES    AGE     VERSION</span><br><span class="line">iz8vbbld8tet39uo7wyi2jz   Ready    master   3h54m   v1.17.0</span><br><span class="line">iz8vbcuptq5g86qk6lk4x1z   Ready    &lt;none&gt;   86m     v1.17.0</span><br></pre></td></tr></table></figure></p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title=" 参考文章:"></a> 参考文章:</h2><p><a href="https://zhuanlan.zhihu.com/p/46341911" target="_blank" rel="noopener">kubernetes安装国内环境</a><br><a href="https://zhuanlan.zhihu.com/p/55740564" target="_blank" rel="noopener">kubernetes部署</a><br><a href="https://blog.liu-kevin.com/2019/04/22/14-shen-ru-pou-xi-k8szhi-wang-luo-mo-xing-yu-cniwang-luo-cha-jian/" target="_blank" rel="noopener">深入剖析k8s之网络模型与CNI网络插件</a><br><a href="https://www.cnblogs.com/taoweizhong/p/11545953.html" target="_blank" rel="noopener">从节点The connection to the server localhost:8080 was refused - did you specify the right host or port?</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想要学习kubernetes，特地从阿里云购买了两台云主机，用的是kubeadm部署，由于被墙不能直接执行kubeadm init,比较麻烦，所以练习下kubernetes的安装。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;先介绍下两台都是centos7,需要注意的是作为
      
    
    </summary>
    
    
      <category term="devops" scheme="http://yoursite.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>记一次mysql容器的异常退出</title>
    <link href="http://yoursite.com/2019/12/17/%E8%AE%B0%E4%B8%80%E6%AC%A1mysql%E5%AE%B9%E5%99%A8%E7%9A%84%E5%BC%82%E5%B8%B8%E9%80%80%E5%87%BA/"/>
    <id>http://yoursite.com/2019/12/17/记一次mysql容器的异常退出/</id>
    <published>2019-12-17T07:07:47.000Z</published>
    <updated>2019-12-17T07:19:26.398Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚利用docker-compose部署时mysql一直异常退出，之前mysql都是好的，知道我再docker里面添加了supervisor开启了队列以后，本来以为和队列有关，直到在登录阿里云的远程连接时发现了错误语句。<br>out of memory kill process,觉得是内存的原因，然后用free -m这个命令看了下系统的内存，才发现原来是内存不足，后面给阿里云升级了内存配置，mysql就能正常启动了。</p><blockquote><blockquote><p>OOM Killer，一个保护机制，用于避免在内存不足的时候不至于出现严重问题，把一些无关的进程优先杀掉，即在内存严重不足时，系统为了继续运转，内核会挑选一个进程，将其杀掉，以释放内存，缓解内存不足情况，不过这种保护是有限的，不能完全的保护进程的运行</p></blockquote></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚刚利用docker-compose部署时mysql一直异常退出，之前mysql都是好的，知道我再docker里面添加了supervisor开启了队列以后，本来以为和队列有关，直到在登录阿里云的远程连接时发现了错误语句。&lt;br&gt;out of memory kill proc
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>elastic语句记录</title>
    <link href="http://yoursite.com/2019/12/11/elastic%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/12/11/elastic语句记录/</id>
    <published>2019-12-11T07:14:26.000Z</published>
    <updated>2019-12-11T07:26:53.049Z</updated>
    
    <content type="html"><![CDATA[<p>最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET /student_app_request/_search</span><br><span class="line">&#123;</span><br><span class="line">   "_source":["student_no"],</span><br><span class="line">  "query": &#123;</span><br><span class="line">      "bool" : &#123;</span><br><span class="line">            "must" : &#123;</span><br><span class="line">                "exists" : &#123;</span><br><span class="line">                    "field" : "student_no"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">      "filter": [</span><br><span class="line">        &#123;"range":</span><br><span class="line">          &#123;</span><br><span class="line">            "timestamp":&#123;</span><br><span class="line">                "gte" : "now-30d/d",</span><br><span class="line">                "lt" :  "now/d"</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "size": 1000,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "student_num": &#123;</span><br><span class="line">      "cardinality": &#123;"field": "student_no"&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>_source<br>这相当于mysql语句中的字段选择</li><li>must<br>must中的bool参数表达了student_no这个字段一定要存在</li><li>filter<br>range代表了对时间的筛选，表示了日志中timestamp这个时间戳的30天内的筛选</li><li>size<br>代表了返回的数据量，如果想要单纯的拿统计数据的话，这个值可以设置为0</li><li>aggs<br>相当于mysql中的聚合函数，构造一个数值来进行统计，我构造了student_num这个数字，对student_no的数量做了统计，并且使用了cardinlity对该字段做了去重</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里云ssh登录不上的bug</title>
    <link href="http://yoursite.com/2019/12/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91ssh%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8A%E7%9A%84bug/"/>
    <id>http://yoursite.com/2019/12/11/记一次阿里云ssh登录不上的bug/</id>
    <published>2019-12-11T07:00:54.000Z</published>
    <updated>2019-12-11T07:06:18.818Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。</p><p>#问题描述#<br> ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/systemd/generator/-.mount, as it already exists.Duplicate entry in /etc/fstab?</p><p> #原因#<br> 系统盘才是挂载到根的。您数据盘也挂载到根。就有问题。我帮您注释了<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/vdb/ ext3 defaults 0 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。&lt;/p&gt;
&lt;p&gt;#问题描述#&lt;br&gt; ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/syst
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>php如何正确的统计中文</title>
    <link href="http://yoursite.com/2019/11/21/php%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2019/11/21/php如何正确的统计中文/</id>
    <published>2019-11-21T07:34:28.000Z</published>
    <updated>2019-12-11T07:36:17.564Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> strlen(<span class="string">"你好ABC"</span>) . <span class="string">""</span>;</span><br><span class="line"><span class="comment">//输出 9</span></span><br><span class="line"><span class="keyword">echo</span> mb_strlen(<span class="string">"你好ABC"</span>, <span class="string">'UTF-8'</span>) . <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 输出 5</span></span><br><span class="line"><span class="keyword">echo</span> mb_strwidth(<span class="string">"你好ABC"</span>) . <span class="string">""</span>;</span><br><span class="line"><span class="comment">//输出 7</span></span><br><span class="line">登录后复制</span><br></pre></td></tr></table></figure></p><p>从上面的测试，我们可以看出：strlen 把中文字符算成 3 个字节，mb_strlen 不管中文还是英文，都算 1 个字节，而 mb_strwidth 则把中文算成 2 个字节，所以 mb_strwidth 才是我们想要的：中文 2 个字节，英文 1 个字节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在程序开发中++i与i++的区别在哪里</title>
    <link href="http://yoursite.com/2019/11/13/%E5%9C%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD-i%E4%B8%8Ei-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://yoursite.com/2019/11/13/在程序开发中-i与i-的区别在哪里/</id>
    <published>2019-11-13T12:56:10.000Z</published>
    <updated>2019-11-13T12:59:03.291Z</updated>
    
    <content type="html"><![CDATA[<p>i++ 与 ++i 的主要区别有两个：<br>1、 i++ 返回原来的值，++i 返回加1后的值。<br>2、 i++ 不能作为左值，而++i 可以。<br>毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。<br>首先解释下什么是左值（以下两段引用自中文维基百科『右值引用』词条）。</p><blockquote><blockquote><p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。<br>一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。<br>比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<br>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。<br>比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *p1 = &amp;(++i); //正确</span><br><span class="line">int *p2 = &amp;(i++); //错误</span><br><span class="line"></span><br><span class="line">++i = 1; //正确</span><br><span class="line">i++ = 5; //错误</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><p>那么为什么『i++ 不能作为左值，而++i 可以』？看它们各自的实现就一目了然了：以下代码来自博客：为什么(i++)不能做左值，而(++i)可以// 前缀形式：<br>int&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;//函数本身无参，意味着是在自身空间内增加1的</span><br><span class="line">  *this += 1;  // 增加</span><br><span class="line">  return *this;  // 取回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后缀形式:</span><br><span class="line">const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。</span><br><span class="line">&#123;//函数带参，说明有另外的空间开辟</span><br><span class="line">  int oldValue = *this;  // 取回值</span><br><span class="line">  ++(*this);  // 增加</span><br><span class="line">  return oldValue;  // 返回被取回的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;i++ 与 ++i 的主要区别有两个：&lt;br&gt;1、 i++ 返回原来的值，++i 返回加1后的值。&lt;br&gt;2、 i++ 不能作为左值，而++i 可以。&lt;br&gt;毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。&lt;br&gt;首先解释下什么是左值（以
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>谈谈mysql的四种事务隔离级别</title>
    <link href="http://yoursite.com/2019/10/17/%E8%B0%88%E8%B0%88mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2019/10/17/谈谈mysql的四种事务隔离级别/</id>
    <published>2019-10-17T12:28:07.000Z</published>
    <updated>2019-10-19T16:07:01.859Z</updated>
    
    <content type="html"><![CDATA[<p>这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。</p><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><p>事务为什么需要隔离级别，这是因为事务有这几个问题。<br>1脏读:事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据是脏数据<br>2不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致<br>3幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入一条具体分数的记录，当系统管理员A结束后发现还有一条记录没改正，就好像发生幻觉一样。</p><blockquote><p>不可重复读侧重于修改，幻读侧重于新增火删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。</p></blockquote><h2 id="Mysql事务隔离级别"><a href="#Mysql事务隔离级别" class="headerlink" title="Mysql事务隔离级别"></a>Mysql事务隔离级别</h2><table><thead><tr><th>事务隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>不可重复读（read-committed）</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>可重复读（repeatable-read）</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td>串行化（serializable）</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr></tbody></table><blockquote><p>mysql默认的事务隔离级别为repeatable-read</p></blockquote><h2 id="用例子说明各个隔离级别的情况"><a href="#用例子说明各个隔离级别的情况" class="headerlink" title="用例子说明各个隔离级别的情况"></a>用例子说明各个隔离级别的情况</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端A</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2在客户端A的事务提交之前，打开另一个客户端B，更新表account；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端B</span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">客户端A</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line">4一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据</span><br><span class="line">``` mysql </span><br><span class="line">客户端B</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别<br>客户端A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端A</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。&lt;/p&gt;
&lt;h2 id=&quot;事务的并发问题&quot;&gt;&lt;a href=&quot;#事务的并发问题&quot; class=&quot;headerlink&quot; title=&quot;事务的并发问题&quot;&gt;&lt;/a&gt;事务的并发问题&lt;/h2&gt;&lt;p&gt;事务为什么
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于软件工程师的思考</title>
    <link href="http://yoursite.com/2019/10/16/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/10/16/关于软件工程师的思考/</id>
    <published>2019-10-16T04:40:13.000Z</published>
    <updated>2019-10-16T06:45:42.393Z</updated>
    
    <content type="html"><![CDATA[<p>最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。</p><h1 id="缺乏工程师的思维模式"><a href="#缺乏工程师的思维模式" class="headerlink" title="缺乏工程师的思维模式"></a>缺乏工程师的思维模式</h1><p>这是我目前最大的问题，我现在debug的能力还是偏弱的，遇到bug常常是靠猜测，凭借经验去假设出现bug的原因，然后就是去谷歌，去搜索之前是否有别人已经解决过这个问题。<br>这其实是非常不好的表现，软件是千变万化的东西，这两种手段是非常偶发的，随机性很高的手段，不具有高效率和普遍性。软件的debug应该是一项工程调试，应该更多的关注软件<br>本身的结构，本身的运行流程，通过错误日志来定位问题，通过错误提示或者异常来判断问题可能的原因。我在debug的过程中太过关注解决问题这件事情，往往忽视了排查问题原因<br>的过程才是最重要的。一步一步按节奏不紧不慢地排查出问题的原因这个过程才是我接下来要努力提高的目标，近期要有意识地锻炼自己解决bug的能力，按照工程师的思维方式去排查<br>问题的原因。</p><h1 id="源码重要还是文档重要"><a href="#源码重要还是文档重要" class="headerlink" title="源码重要还是文档重要"></a>源码重要还是文档重要</h1><p>我之前非常重视文档，觉得文档是开发者的字典。但其实开发者在迭代的过程中是很容易忘记同时修改文档的，所以看源码远远比看文档要更准确，更能反映一个项目的业务逻辑。<br>而且另一方面，阅读源码你会更容易了解这个项目的来龙去脉，更能知道作者一些方法实现的过程，很容易知道这个项目的筋脉在哪里。之前一直不明白为什么要去看底层，为什么<br>要去看框架的源码，因为了解框架的源码会更容易知道这些方法在项目的哪里，原来是因为那样才可以使用这个方法的，从整体的角度来看开发。</p><h1 id="知其然，知其所以然"><a href="#知其然，知其所以然" class="headerlink" title="知其然，知其所以然"></a>知其然，知其所以然</h1><p>之前只知道一个东西的使用方法，但不知道它运行背后的原理，这个也是很重要的，一个方法的使用,原理和使用是相伴随行的，光是知道使用的话其实还是很难熟练变通的，要想游刃<br>有余还是要仔细地思考背后的原理,这样才能游刃有余的知道使用过程中这些问题的答案，本质的一些东西是不会轻易改变的，大多数新东西的原理还是老的，所以掌握背后的原理其实<br>还是更能知道这些新东西的使用。我的基础还是薄弱的，接下来一段时间要努力的补充基础知识，最基础的东西往往会影响一个软件的性能。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>以上就是这段时间的感悟，希望能在接下来的一段时间努力地客服这些东西，只有这样，同样的教训才不会再次发生，才能成长的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。&lt;/p&gt;
&lt;h1 id=&quot;缺乏工程师的思维模式&quot;&gt;&lt;a href=&quot;#缺乏工程师的思维模式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="个人感悟" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>记录一次阿里云上docker启动不了的bug</title>
    <link href="http://yoursite.com/2019/10/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8Adocker%E5%90%AF%E5%8A%A8%E4%B8%8D%E4%BA%86%E7%9A%84bug/"/>
    <id>http://yoursite.com/2019/10/09/记录一次阿里云上docker启动不了的bug/</id>
    <published>2019-10-09T05:25:06.000Z</published>
    <updated>2019-10-09T05:34:15.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。"><a href="#最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。" class="headerlink" title="最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。"></a>最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker.service</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: start-limit) since 六 2019-09-28 12:05:46 CST; 5min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line">  Process: 1250 ExecStart=/usr/bin/dockerd --registry-mirror=39.98.73.138 --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 1250 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service holdoff time over, scheduling restart.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopped Docker Application Container Engine.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# journalctl -xe</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has finished shutting down.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopping Docker Socket for the API.</span><br><span class="line">-- Subject: Unit docker.socket has begun shutting down</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has begun shutting down.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Starting Docker Socket for the API.</span><br><span class="line">-- Subject: Unit docker.socket has begun start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has begun starting up.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Listening on Docker Socket for the API.</span><br><span class="line">-- Subject: Unit docker.socket has finished start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has finished starting up.</span><br><span class="line">--</span><br><span class="line">-- The start-up result is done.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">-- Subject: Unit docker.service has failed</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.service has failed.</span><br><span class="line">--</span><br><span class="line">-- The result is failed.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class="line">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 6 of user root.</span><br><span class="line">-- Subject: Unit session-6.scope has finished start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit session-6.scope has finished starting up.</span><br><span class="line">--</span><br><span class="line">-- The start-up result is done.</span><br><span class="line">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1271]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 7 of user root.</span><br><span class="line">-- Subject: Unit session-7.scope has finished start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit session-7.scope has finished starting up.</span><br><span class="line">--</span><br><span class="line">-- The start-up result is done.</span><br><span class="line">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1277]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">lines 2500-2550/2550 (END)</span><br></pre></td></tr></table></figure><h1 id="解决的步骤"><a href="#解决的步骤" class="headerlink" title="解决的步骤:"></a>解决的步骤:</h1><p>1）清除/etc/systemd/system/目录下的 docker.service.requires这个目录的生成是安装别的系统Kubernete时生成的依赖信息。<br>个人总结：对这类问题清除/etc/systemd/system目录下不用的目录和文件是首选<br>2）执行systemctl daemon-reload或重启系统</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.talkwithtrend.com/Question/415283?order=desc" target="_blank" rel="noopener">启动DOCKER时，遇到一个很奇葩的问题？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。&quot;&gt;&lt;a href=&quot;#最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。&quot; class=&quot;headerlink&quot; title=&quot;最近在阿里云
      
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>php利用puppeteer来抓取西瓜视频</title>
    <link href="http://yoursite.com/2019/08/26/php%E5%88%A9%E7%94%A8puppeteer%E6%9D%A5%E6%8A%93%E5%8F%96%E8%A5%BF%E7%93%9C%E8%A7%86%E9%A2%91/"/>
    <id>http://yoursite.com/2019/08/26/php利用puppeteer来抓取西瓜视频/</id>
    <published>2019-08-26T10:12:44.000Z</published>
    <updated>2019-08-26T10:39:16.097Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件<br>本来下载puppeteer的时候它会自动下载无头的chrome的,但是由于被墙的原因，这个方案不行，我后面是用了阿里的一个改进版的puppeteer库，但后面发现还是不行，最后我只能在我的docker里面先下chrome的组件了<br>下面是我的dockerfile<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> graychen/alpine-php7.<span class="number">1</span>:alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /var/www/html</span></span><br><span class="line"><span class="bash">COPY supervisord.conf /etc/supervisor/conf.d/</span></span><br><span class="line"><span class="bash">COPY . /var/www/html</span></span><br><span class="line"><span class="bash">ENV CHROME_BIN=<span class="string">"/usr/bin/chromium-browser"</span>\</span></span><br><span class="line"><span class="bash">    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=<span class="string">"true"</span></span></span><br><span class="line"><span class="bash">RUN <span class="built_in">set</span> -x \</span></span><br><span class="line"><span class="bash">&amp;&amp; apk update \</span></span><br><span class="line"><span class="bash">&amp;&amp; apk upgrade \</span></span><br><span class="line"><span class="bash"><span class="comment"># replacing default repositories with edge ones</span></span></span><br><span class="line"><span class="bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">"http://dl-cdn.alpinelinux.org/alpine/edge/testing"</span> &gt; /etc/apk/repositories \</span></span><br><span class="line"><span class="bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">"http://dl-cdn.alpinelinux.org/alpine/edge/community"</span> &gt;&gt; /etc/apk/repositories \</span></span><br><span class="line"><span class="bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">"http://dl-cdn.alpinelinux.org/alpine/edge/main"</span> &gt;&gt; /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash"><span class="comment"># Add the packages</span></span></span><br><span class="line"><span class="bash">apk add --no-cache dumb-init curl make gcc g++ python linux-headers binutils-gold gnupg libstdc++ nss nodejs nodejs-npm \</span></span><br><span class="line"><span class="bash">  <span class="comment">#alsa-lib \</span></span></span><br><span class="line"><span class="bash">  <span class="comment">#at-spi2-atk \</span></span></span><br><span class="line"><span class="bash">  <span class="comment">#atk \</span></span></span><br><span class="line"><span class="bash">  cairo \</span></span><br><span class="line"><span class="bash">  cups-libs \</span></span><br><span class="line"><span class="bash">  dbus-libs \</span></span><br><span class="line"><span class="bash">  eudev-libs \</span></span><br><span class="line"><span class="bash">  expat \</span></span><br><span class="line"><span class="bash">  flac \</span></span><br><span class="line"><span class="bash">  gdk-pixbuf \</span></span><br><span class="line"><span class="bash">  glib \</span></span><br><span class="line"><span class="bash">  libgcc \</span></span><br><span class="line"><span class="bash">  libjpeg-turbo \</span></span><br><span class="line"><span class="bash">  libpng \</span></span><br><span class="line"><span class="bash">  libwebp \</span></span><br><span class="line"><span class="bash">  libx11 \</span></span><br><span class="line"><span class="bash">  libxcomposite \</span></span><br><span class="line"><span class="bash">  libxdamage \</span></span><br><span class="line"><span class="bash">  libxext \</span></span><br><span class="line"><span class="bash">  libxfixes \</span></span><br><span class="line"><span class="bash">  tzdata \</span></span><br><span class="line"><span class="bash">  libexif \</span></span><br><span class="line"><span class="bash">  udev \</span></span><br><span class="line"><span class="bash">  xvfb \</span></span><br><span class="line"><span class="bash">  zlib-dev \</span></span><br><span class="line"><span class="bash">  chromium \</span></span><br><span class="line"><span class="bash">  chromium-chromedriver &amp;&amp; \</span></span><br><span class="line"><span class="bash">npm install cnpm -g --registry=https://r.npm.taobao.org &amp;&amp; \</span></span><br><span class="line"><span class="bash">cnpm install puppeteer@0.13.0  &amp;&amp; \</span></span><br><span class="line"><span class="bash">apk del --no-cache make gcc g++ python binutils-gold gnupg libstdc++ &amp;&amp; \</span></span><br><span class="line"><span class="bash">docker-php-ext-install sockets</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/usr/bin/supervisord"</span>, <span class="string">"-n"</span>, <span class="string">"-c"</span>,  <span class="string">"/etc/supervisor/conf.d/supervisord.conf"</span>]%</span></span><br></pre></td></tr></table></figure></p><p>因为我本身是用php，所以要下这个使用别人已经封装好的composer包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer <span class="keyword">require</span> jaeger/querylist-puppeteer</span><br></pre></td></tr></table></figure></p><p>然后安装Node依赖（与composer一样在项目根目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @nesk/puphpeteer</span><br></pre></td></tr></table></figure></p><p>下面是这个组件的用法<br>在QueryList中注册插件<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">QL</span>\<span class="title">QueryList</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">QL</span>\<span class="title">Ext</span>\<span class="title">Chrome</span>;</span><br><span class="line"></span><br><span class="line">$ql = QueryList::getInstance();</span><br><span class="line"><span class="comment">// 注册插件，默认注册的方法名为: chrome</span></span><br><span class="line">$ql-&gt;use(Chrome::class);</span><br><span class="line"><span class="comment">// 或者自定义注册的方法名</span></span><br><span class="line">$ql-&gt;use(Chrome::class,<span class="string">'chrome'</span>);</span><br></pre></td></tr></table></figure></p><p>基本用法<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抓取的目标页面是使用Vue.js动态渲染的页面</span></span><br><span class="line">$text = $ql-&gt;chrome(<span class="string">'https://www.iviewui.com/components/button'</span>)-&gt;find(<span class="string">'h1'</span>)-&gt;text();</span><br><span class="line">print_r($text);</span><br><span class="line"><span class="comment">// 输出: Button 按钮</span></span><br><span class="line">$rules = [</span><br><span class="line"> <span class="string">'h1'</span> =&gt; [<span class="string">'h1'</span>,<span class="string">'text'</span>]</span><br><span class="line">];</span><br><span class="line">$ql = $ql-&gt;chrome(<span class="string">'https://www.iviewui.com/components/button'</span>);</span><br><span class="line">$data = $ql-&gt;rules($rules)-&gt;queryData();</span><br></pre></td></tr></table></figure></p><p>后面我优化了一下参数,我将抓取的步骤放到了队列中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public function execute($queue)</span><br><span class="line">    &#123;</span><br><span class="line">            $ql = QueryList::getInstance();</span><br><span class="line">                // 注册插件，默认注册的方法名为: chrome</span><br><span class="line">                $ql-&gt;use(Chrome::class);</span><br><span class="line">                $ql-&gt;use(Chrome::class,&apos;chrome&apos;);</span><br><span class="line">                $url = &apos;https://www.ixigua.com/&apos;.$this-&gt;jumpUrl;</span><br><span class="line">                $text = $ql-&gt;chrome($url,[executablePath =&gt; &apos;/usr/bin/chromium-browser&apos;, args=&gt; [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;,&apos;--proxy-server=&quot;direct://&quot;&apos;,</span><br><span class="line">                &apos;--proxy-bypass-list=*&apos;,&apos;–disable-gpu&apos;,</span><br><span class="line">                &apos;–disable-dev-shm-usage&apos;,</span><br><span class="line">                &apos;–disable-setuid-sandbox&apos;,</span><br><span class="line">                &apos;–no-first-run&apos;,</span><br><span class="line">                &apos;–no-zygote&apos;,</span><br><span class="line">                &apos;–single-process&apos;]],</span><br><span class="line">                function ($page,$browser) &#123;</span><br><span class="line">                    $page-&gt;setUserAgent(&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&apos;);</span><br><span class="line">                    // 设置cookie</span><br><span class="line">                    $page-&gt;setCookie([</span><br><span class="line">                    &apos;name&apos; =&gt; &apos;foo&apos;,</span><br><span class="line">                    &apos;value&apos; =&gt; &apos;xxx&apos;,</span><br><span class="line">                    &apos;url&apos; =&gt; $url</span><br><span class="line">                    ],[</span><br><span class="line">                    &apos;name&apos; =&gt; &apos;foo2&apos;,</span><br><span class="line">                    &apos;value&apos; =&gt; &apos;yyy&apos;,</span><br><span class="line">                    &apos;url&apos; =&gt; $url</span><br><span class="line">                    ]);</span><br><span class="line">                    $page-&gt;goto($url);</span><br><span class="line">                    // 等待h1元素出现</span><br><span class="line">                    $page-&gt;waitFor(&apos;#vs&apos;);</span><br><span class="line">                    $page-&gt;waitFor(&apos;xg-poster&apos;);</span><br><span class="line">                    $page-&gt;waitForNavigation();</span><br><span class="line">                    $page-&gt;screenshot([</span><br><span class="line">                        &apos;path&apos; =&gt; &apos;page.png&apos;,</span><br><span class="line">                        &apos;fullPage&apos; =&gt; true</span><br><span class="line">                    ]);</span><br><span class="line">                    // 获取页面HTML内容</span><br><span class="line">                    $html = $page-&gt;content();</span><br><span class="line">                    // 关闭浏览器</span><br><span class="line">                    $browser-&gt;close();</span><br><span class="line">                    // 返回值一定要是页面的HTML内容</span><br><span class="line">                    return $html;</span><br><span class="line">                &#125;)-&gt;getHtml();</span><br><span class="line">                $img = &quot;#&lt;xg-poster.*&gt;([^&lt;]*)&lt;/xg-poster&gt;#&quot;;</span><br><span class="line">                preg_match($img, $text, $contentImg);</span><br><span class="line">                $str = explode(&quot;;&quot;,$contentImg[0]);</span><br><span class="line">                $strUrl = explode(&quot;&amp;&quot;,$str[1]);</span><br><span class="line">                $imgUrl=$strUrl[0];</span><br><span class="line">                $s = file_get_contents($imgUrl);</span><br><span class="line">                $moive = new Moive();</span><br><span class="line">                $dir = \Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/cover/&apos;.date(&apos;Ymd&apos;);</span><br><span class="line">                if(!is_dir($dir)) &#123;</span><br><span class="line">                    mkdir($dir);</span><br><span class="line">                &#125;</span><br><span class="line">                $imgShotPath=&apos;cover/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class="line">                $imgPath = $dir.&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class="line">                file_put_contents($imgPath, $s);</span><br><span class="line">                $head=&quot;#&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;#&quot;;</span><br><span class="line">                preg_match($head, $text, $contentHead);</span><br><span class="line">                $regex = &quot;/src=\s*[\&apos;|\&quot;]+?(.*?)[\&apos;|\&quot;]+?/&quot;;</span><br><span class="line">                $return = preg_match_all($regex, $text, $content);</span><br><span class="line">                $pathUrl = $content[1][4];</span><br><span class="line">                $s = file_get_contents($pathUrl);</span><br><span class="line">                $dir = \Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/video/&apos;.date(&apos;Ymd&apos;);</span><br><span class="line">                if(!is_dir($dir)) &#123;</span><br><span class="line">                    mkdir($dir);</span><br><span class="line">                &#125;</span><br><span class="line">                $videoShotPath = &apos;video/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class="line">                $videoPath = $dir.&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class="line">                file_put_contents($videoPath, $s);</span><br><span class="line">                $contentArray = explode(&quot;：&quot;, $contentHead[1]);</span><br><span class="line">                $describe=$contentArray[1];</span><br><span class="line">                $status = Moive::STATUS_SHOW;</span><br><span class="line">                $num = 0;</span><br><span class="line">                $this-&gt;saveData($moive, $describe, $status, $num, $imgShotPath, $videoShotPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其实我现在的代码还有个问题，就是渲染出来的页面有时候没有渲染好就打印出来了，接下来看看怎么优化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件&lt;br&gt;本来下载puppeteer的时候它会自动下
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在minikube部署个node服务</title>
    <link href="http://yoursite.com/2019/08/22/%E5%9C%A8minikube%E9%83%A8%E7%BD%B2%E4%B8%AAnode%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/08/22/在minikube部署个node服务/</id>
    <published>2019-08-22T10:51:09.000Z</published>
    <updated>2019-08-22T11:10:28.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建Node-js应用程序"><a href="#创建Node-js应用程序" class="headerlink" title="创建Node.js应用程序"></a>创建Node.js应用程序</h2><p>先编写server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handleRequest = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received request for URL: '</span> + request.url);</span><br><span class="line">  response.writeHead(<span class="number">200</span>);</span><br><span class="line">  response.end(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handleRequest);</span><br><span class="line">www.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></p><p>然后在<a href="http://localhost:8080/中看到&quot;Hello" target="_blank" rel="noopener">http://localhost:8080/中看到&quot;Hello</a> World”</p><h2 id="创建Docker容器镜像"><a href="#创建Docker容器镜像" class="headerlink" title="创建Docker容器镜像"></a>创建Docker容器镜像</h2><p>在hellonode文件夹中创建一个Dockerfile命名的文件。Dockerfile描述了build的镜像，通过现有的镜像扩展（extend）build Docker容器镜像，本教程中的镜像扩展（extend）了现有的Node.js镜像。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">6.9</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> server.js .</span></span><br><span class="line"><span class="bash">CMD node server.js</span></span><br></pre></td></tr></table></figure></p><p>确保使用Minikube Docker守护进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure></p><p>注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。<br>使用Minikube Docker守护进程build Docker镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-node:v1 .</span><br></pre></td></tr></table></figure></p><h2 id="创建Deployment"><a href="#创建Deployment" class="headerlink" title="创建Deployment"></a>创建Deployment</h2><p>使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run hello-node --image=hello-node:v1 --port=8080</span><br></pre></td></tr></table></figure></p><p>查看Deployment：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">hello-node   1         1         1            1           3m</span><br></pre></td></tr></table></figure><p>查看Pod：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                         READY     STATUS    RESTARTS   AGE</span><br><span class="line">hello-node-714049816-ztzrb   1/1       Running   0          6m</span><br></pre></td></tr></table></figure></p><p>查看群集events：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get events</span><br></pre></td></tr></table></figure><p>查看kubectl配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config view</span><br></pre></td></tr></table></figure></p><h2 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h2><p>默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。<br>我们可以使用kubectl expose命令将Pod暴露到外部环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment hello-node --type=LoadBalancer</span><br></pre></td></tr></table></figure></p><p>查看刚创建的Service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">hello-node   10.0.0.71    &lt;pending&gt;     8080/TCP   6m</span><br><span class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP    14d</span><br></pre></td></tr></table></figure><p>通过–type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service hello-node</span><br></pre></td></tr></table></figure></p><p>将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。<br>最后可以查看到一些日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;POD-NAME&gt;</span><br></pre></td></tr></table></figure></p><p>更新应用程序<br>编辑server.js文件以返回新消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.end(&apos;Hello World Again!&apos;);</span><br></pre></td></tr></table></figure></p><p>build新版本镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-node:v2 .</span><br></pre></td></tr></table></figure></p><p>Deployment更新镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/hello-node hello-node=hello-node:v2</span><br></pre></td></tr></table></figure></p><p>再次运行应用以查看新消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service hello-node</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建Node-js应用程序&quot;&gt;&lt;a href=&quot;#创建Node-js应用程序&quot; class=&quot;headerlink&quot; title=&quot;创建Node.js应用程序&quot;&gt;&lt;/a&gt;创建Node.js应用程序&lt;/h2&gt;&lt;p&gt;先编写server.js&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://yoursite.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes本地实验环境</title>
    <link href="http://yoursite.com/2019/08/22/Kubernetes%E6%9C%AC%E5%9C%B0%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/08/22/Kubernetes本地实验环境/</id>
    <published>2019-08-22T05:12:59.000Z</published>
    <updated>2019-08-22T05:25:08.802Z</updated>
    
    <content type="html"><![CDATA[<p>最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，<br>所以使用这个minikube来安装.<br>我是mac电脑，首先<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kubernetes-cli</span><br></pre></td></tr></table></figure></p><p>然后确认是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl version</span><br></pre></td></tr></table></figure></p><p>接着安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VitualBox</a><br>然后安装改版的minikube<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></p><p>接着启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --registry-mirror=https://registry.docker-cn.com</span><br></pre></td></tr></table></figure></p><p>打开Kubernetes控制台<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://yq.aliyun.com/articles/221687" target="_blank" rel="noopener">Minikube - Kubernetes本地实验环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，&lt;br&gt;所以使用这个minikube来安装.&lt;br&gt;我是mac电脑，首先&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://yoursite.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>mac终端走shadowsocks代理</title>
    <link href="http://yoursite.com/2019/08/22/mac%E7%BB%88%E7%AB%AF%E8%B5%B0shadowsocks%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/22/mac终端走shadowsocks代理/</id>
    <published>2019-08-22T03:44:23.000Z</published>
    <updated>2019-08-22T05:32:02.065Z</updated>
    
    <content type="html"><![CDATA[<p>shadowsocks设置为：</p><p>打开shadowsocks<br>自动代理模式<br>服务器（香港阿里云）<br>以zsh作为说明<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ vim ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>添加如下代理配置:</p><h1 id="proxy-list"><a href="#proxy-list" class="headerlink" title="proxy list"></a>proxy list</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">'export all_proxy=socks5://127.0.0.1:1080'</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">'unset all_proxy'</span></span><br><span class="line">:wq保存退出</span><br><span class="line">➜  ~ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>使用proxy前先查看下当前的ip地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl ip.cn</span><br><span class="line">当前 IP：112.64.xxx.xx 来自：上海市 联通</span><br><span class="line">或者</span><br><span class="line">~ curl cip.cc</span><br><span class="line">IP: 140.206.97.42</span><br><span class="line">地址: 中国  上海</span><br><span class="line"></span><br><span class="line">数据二: 上海市 | 联通</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/140.206.97.42</span><br><span class="line">执行:</span><br><span class="line"></span><br><span class="line">➜  ~ proxy</span><br><span class="line">➜  ~ curl ip.cn</span><br><span class="line">当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云</span><br><span class="line">如果ip.cn不能用，可以换个类似的站点查询</span><br><span class="line">~ curl cip.cc</span><br><span class="line">IP: 45.78.47.19</span><br><span class="line">地址: 美国  加利福尼亚</span><br><span class="line"></span><br><span class="line">数据二: 美国 | 加利福尼亚州洛杉矶市 IT7 Networks</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/45.78.47.19</span><br></pre></td></tr></table></figure><p>没问题，终端走了代理，brew update顺畅了- -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;shadowsocks设置为：&lt;/p&gt;
&lt;p&gt;打开shadowsocks&lt;br&gt;自动代理模式&lt;br&gt;服务器（香港阿里云）&lt;br&gt;以zsh作为说明&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
</feed>
