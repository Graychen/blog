<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-11T07:26:53.049Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Graychen,13780185250@sina.cn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>elastic语句记录</title>
    <link href="http://yoursite.com/2019/12/11/elastic%E8%AF%AD%E5%8F%A5%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2019/12/11/elastic语句记录/</id>
    <published>2019-12-11T07:14:26.000Z</published>
    <updated>2019-12-11T07:26:53.049Z</updated>
    
    <content type="html"><![CDATA[<p>最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">GET /student_app_request/_search</span><br><span class="line">&#123;</span><br><span class="line">   "_source":["student_no"],</span><br><span class="line">  "query": &#123;</span><br><span class="line">      "bool" : &#123;</span><br><span class="line">            "must" : &#123;</span><br><span class="line">                "exists" : &#123;</span><br><span class="line">                    "field" : "student_no"</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">      "filter": [</span><br><span class="line">        &#123;"range":</span><br><span class="line">          &#123;</span><br><span class="line">            "timestamp":&#123;</span><br><span class="line">                "gte" : "now-30d/d",</span><br><span class="line">                "lt" :  "now/d"</span><br><span class="line">          &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  "size": 1000,</span><br><span class="line">  "aggs": &#123;</span><br><span class="line">    "student_num": &#123;</span><br><span class="line">      "cardinality": &#123;"field": "student_no"&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>_source<br>这相当于mysql语句中的字段选择</li><li>must<br>must中的bool参数表达了student_no这个字段一定要存在</li><li>filter<br>range代表了对时间的筛选，表示了日志中timestamp这个时间戳的30天内的筛选</li><li>size<br>代表了返回的数据量，如果想要单纯的拿统计数据的话，这个值可以设置为0</li><li>aggs<br>相当于mysql中的聚合函数，构造一个数值来进行统计，我构造了student_num这个数字，对student_no的数量做了统计，并且使用了cardinlity对该字段做了去重</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要做数据统计，要求是求出活跃人数，分别是日活，周活，月活人数。正好我们的elk有相应的student_no可以做人员的统计，我就来研究下elastic的语句。&lt;br&gt;&lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>记一次阿里云ssh登录不上的bug</title>
    <link href="http://yoursite.com/2019/12/11/%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91ssh%E7%99%BB%E5%BD%95%E4%B8%8D%E4%B8%8A%E7%9A%84bug/"/>
    <id>http://yoursite.com/2019/12/11/记一次阿里云ssh登录不上的bug/</id>
    <published>2019-12-11T07:00:54.000Z</published>
    <updated>2019-12-11T07:06:18.818Z</updated>
    
    <content type="html"><![CDATA[<p>刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。</p><p>#问题描述#<br> ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/systemd/generator/-.mount, as it already exists.Duplicate entry in /etc/fstab?</p><p> #原因#<br> 系统盘才是挂载到根的。您数据盘也挂载到根。就有问题。我帮您注释了<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/dev/vdb/ ext3 defaults 0 0</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚刚在阿里云上由于原本的mysql镜像使用不上了，所以开始一顿操作，结果ssh登录不上去了，下面是显示的错误。&lt;/p&gt;
&lt;p&gt;#问题描述#&lt;br&gt; ssh链接不上，阿里的远程连接也连接不上，failed to create mount unit file /run/syst
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>php如何正确的统计中文</title>
    <link href="http://yoursite.com/2019/11/21/php%E5%A6%82%E4%BD%95%E6%AD%A3%E7%A1%AE%E7%9A%84%E7%BB%9F%E8%AE%A1%E4%B8%AD%E6%96%87/"/>
    <id>http://yoursite.com/2019/11/21/php如何正确的统计中文/</id>
    <published>2019-11-21T07:34:28.000Z</published>
    <updated>2019-12-11T07:36:17.564Z</updated>
    
    <content type="html"><![CDATA[<p>PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> strlen(<span class="string">"你好ABC"</span>) . <span class="string">""</span>;</span><br><span class="line"><span class="comment">//输出 9</span></span><br><span class="line"><span class="keyword">echo</span> mb_strlen(<span class="string">"你好ABC"</span>, <span class="string">'UTF-8'</span>) . <span class="string">""</span>;</span><br><span class="line"><span class="comment">// 输出 5</span></span><br><span class="line"><span class="keyword">echo</span> mb_strwidth(<span class="string">"你好ABC"</span>) . <span class="string">""</span>;</span><br><span class="line"><span class="comment">//输出 7</span></span><br><span class="line">登录后复制</span><br></pre></td></tr></table></figure></p><p>从上面的测试，我们可以看出：strlen 把中文字符算成 3 个字节，mb_strlen 不管中文还是英文，都算 1 个字节，而 mb_strwidth 则把中文算成 2 个字节，所以 mb_strwidth 才是我们想要的：中文 2 个字节，英文 1 个字节。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;PHP 中如何正确统计中文字数？这个是困扰我很久的问题，PHP 中有很多函数可以计算字符串的长度，比如下面的例子，分别使用了 strlen，mb_strlen，mb_strwidth 这个三个函数去测试统计字符串的长度，看看把中文算成几个字节：&lt;br&gt;&lt;figure cla
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在程序开发中++i与i++的区别在哪里</title>
    <link href="http://yoursite.com/2019/11/13/%E5%9C%A8%E7%A8%8B%E5%BA%8F%E5%BC%80%E5%8F%91%E4%B8%AD-i%E4%B8%8Ei-%E7%9A%84%E5%8C%BA%E5%88%AB%E5%9C%A8%E5%93%AA%E9%87%8C/"/>
    <id>http://yoursite.com/2019/11/13/在程序开发中-i与i-的区别在哪里/</id>
    <published>2019-11-13T12:56:10.000Z</published>
    <updated>2019-11-13T12:59:03.291Z</updated>
    
    <content type="html"><![CDATA[<p>i++ 与 ++i 的主要区别有两个：<br>1、 i++ 返回原来的值，++i 返回加1后的值。<br>2、 i++ 不能作为左值，而++i 可以。<br>毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。<br>首先解释下什么是左值（以下两段引用自中文维基百科『右值引用』词条）。</p><blockquote><blockquote><p>左值是对应内存中有确定存储地址的对象的表达式的值，而右值是所有不是左值的表达式的值。<br>一般来说，左值是可以放到赋值符号左边的变量。但能否被赋值不是区分左值与右值的依据。<br>比如，C++的const左值是不可赋值的；而作为临时对象的右值可能允许被赋值。<br>左值与右值的根本区别在于是否允许取地址&amp;运算符获得对应的内存地址。<br>比如，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i = 0;</span><br><span class="line">int *p1 = &amp;(++i); //正确</span><br><span class="line">int *p2 = &amp;(i++); //错误</span><br><span class="line"></span><br><span class="line">++i = 1; //正确</span><br><span class="line">i++ = 5; //错误</span><br></pre></td></tr></table></figure></p></blockquote></blockquote><p>那么为什么『i++ 不能作为左值，而++i 可以』？看它们各自的实现就一目了然了：以下代码来自博客：为什么(i++)不能做左值，而(++i)可以// 前缀形式：<br>int&amp; int::operator++() //这里返回的是一个引用形式，就是说函数返回值也可以作为一个左值使用<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;//函数本身无参，意味着是在自身空间内增加1的</span><br><span class="line">  *this += 1;  // 增加</span><br><span class="line">  return *this;  // 取回值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//后缀形式:</span><br><span class="line">const int int::operator++(int) //函数返回值是一个非左值型的，与前缀形式的差别所在。</span><br><span class="line">&#123;//函数带参，说明有另外的空间开辟</span><br><span class="line">  int oldValue = *this;  // 取回值</span><br><span class="line">  ++(*this);  // 增加</span><br><span class="line">  return oldValue;  // 返回被取回的值</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>如上所示，i++ 最后返回的是一个临时变量，而临时变量是右值。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;i++ 与 ++i 的主要区别有两个：&lt;br&gt;1、 i++ 返回原来的值，++i 返回加1后的值。&lt;br&gt;2、 i++ 不能作为左值，而++i 可以。&lt;br&gt;毫无疑问大家都知道第一点（不清楚的看下下面的实现代码就了然了），我们重点说下第二点。&lt;br&gt;首先解释下什么是左值（以
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>谈谈mysql的四种事务隔离级别</title>
    <link href="http://yoursite.com/2019/10/17/%E8%B0%88%E8%B0%88mysql%E7%9A%84%E5%9B%9B%E7%A7%8D%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
    <id>http://yoursite.com/2019/10/17/谈谈mysql的四种事务隔离级别/</id>
    <published>2019-10-17T12:28:07.000Z</published>
    <updated>2019-10-19T16:07:01.859Z</updated>
    
    <content type="html"><![CDATA[<p>这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。</p><h2 id="事务的并发问题"><a href="#事务的并发问题" class="headerlink" title="事务的并发问题"></a>事务的并发问题</h2><p>事务为什么需要隔离级别，这是因为事务有这几个问题。<br>1脏读:事务A读取了事务B更新的数据，然后B回滚，那么A读到的数据是脏数据<br>2不可重复读:事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致<br>3幻读:系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入一条具体分数的记录，当系统管理员A结束后发现还有一条记录没改正，就好像发生幻觉一样。</p><blockquote><p>不可重复读侧重于修改，幻读侧重于新增火删除。解决不可重复读的问题只需要锁住满足条件的行，解决幻读需要锁表。</p></blockquote><h2 id="Mysql事务隔离级别"><a href="#Mysql事务隔离级别" class="headerlink" title="Mysql事务隔离级别"></a>Mysql事务隔离级别</h2><table><thead><tr><th>事务隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td>读未提交（read-uncommitted）</td><td style="text-align:center">是</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>不可重复读（read-committed）</td><td style="text-align:center">否</td><td style="text-align:center">是</td><td style="text-align:center">是</td></tr><tr><td>可重复读（repeatable-read）</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">是</td></tr><tr><td>串行化（serializable）</td><td style="text-align:center">否</td><td style="text-align:center">否</td><td style="text-align:center">否</td></tr></tbody></table><blockquote><p>mysql默认的事务隔离级别为repeatable-read</p></blockquote><h2 id="用例子说明各个隔离级别的情况"><a href="#用例子说明各个隔离级别的情况" class="headerlink" title="用例子说明各个隔离级别的情况"></a>用例子说明各个隔离级别的情况</h2><h3 id="读未提交"><a href="#读未提交" class="headerlink" title="读未提交"></a>读未提交</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端A</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2在客户端A的事务提交之前，打开另一个客户端B，更新表account；<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端B</span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted;</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><p>3）这时，虽然客户端B的事务还没提交，但是客户端A就可以查询到B已经更新的数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">客户端A</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br><span class="line">4一旦客户端B的事务因为某种原因回滚，所有的操作都将会被撤销，那客户端A查询到的数据其实就是脏数据</span><br><span class="line">``` mysql </span><br><span class="line">客户端B</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; rollback; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>5）在客户端A执行更新语句update account set balance = balance - 50 where id =1，lilei的balance没有变成350，居然是400，是不是很奇怪，数据不一致啊，如果你这么想就太天真 了，在应用程序中，我们会用400-50=350，并不知道其他会话回滚了，要想解决这个问题可以采用读已提交的隔离级别<br>客户端A<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; update account set  balance=balance-50 where id = 1; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 400     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure></p><h2 id="读已提交"><a href="#读已提交" class="headerlink" title="读已提交"></a>读已提交</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">客户端A</span><br><span class="line"></span><br><span class="line">mysql&gt; set session transaction isolation level read uncommitted; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; start transaction; </span><br><span class="line">Query OK, 0 rows affected (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; select * from account; </span><br><span class="line">+------+------+---------+</span><br><span class="line">| id   | name | balance |</span><br><span class="line">+------+------+---------+</span><br><span class="line">| 1   | lilei | 450     |</span><br><span class="line">| 2   | hanmei| 16000   |</span><br><span class="line">| 3   | lucy  | 2400    |</span><br><span class="line">+------+------+---------+</span><br><span class="line">3 rows in set (0.00 sec)</span><br></pre></td></tr></table></figure><p>2）在客户端A的事务提交之前，打开另一个客户端B，更新表account：</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天遇到事务的隔离级别的问题，网上查了资料整理一下，方便自己理解和吸收。&lt;/p&gt;
&lt;h2 id=&quot;事务的并发问题&quot;&gt;&lt;a href=&quot;#事务的并发问题&quot; class=&quot;headerlink&quot; title=&quot;事务的并发问题&quot;&gt;&lt;/a&gt;事务的并发问题&lt;/h2&gt;&lt;p&gt;事务为什么
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>关于软件工程师的思考</title>
    <link href="http://yoursite.com/2019/10/16/%E5%85%B3%E4%BA%8E%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://yoursite.com/2019/10/16/关于软件工程师的思考/</id>
    <published>2019-10-16T04:40:13.000Z</published>
    <updated>2019-10-16T06:45:42.393Z</updated>
    
    <content type="html"><![CDATA[<p>最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。</p><h1 id="缺乏工程师的思维模式"><a href="#缺乏工程师的思维模式" class="headerlink" title="缺乏工程师的思维模式"></a>缺乏工程师的思维模式</h1><p>这是我目前最大的问题，我现在debug的能力还是偏弱的，遇到bug常常是靠猜测，凭借经验去假设出现bug的原因，然后就是去谷歌，去搜索之前是否有别人已经解决过这个问题。<br>这其实是非常不好的表现，软件是千变万化的东西，这两种手段是非常偶发的，随机性很高的手段，不具有高效率和普遍性。软件的debug应该是一项工程调试，应该更多的关注软件<br>本身的结构，本身的运行流程，通过错误日志来定位问题，通过错误提示或者异常来判断问题可能的原因。我在debug的过程中太过关注解决问题这件事情，往往忽视了排查问题原因<br>的过程才是最重要的。一步一步按节奏不紧不慢地排查出问题的原因这个过程才是我接下来要努力提高的目标，近期要有意识地锻炼自己解决bug的能力，按照工程师的思维方式去排查<br>问题的原因。</p><h1 id="源码重要还是文档重要"><a href="#源码重要还是文档重要" class="headerlink" title="源码重要还是文档重要"></a>源码重要还是文档重要</h1><p>我之前非常重视文档，觉得文档是开发者的字典。但其实开发者在迭代的过程中是很容易忘记同时修改文档的，所以看源码远远比看文档要更准确，更能反映一个项目的业务逻辑。<br>而且另一方面，阅读源码你会更容易了解这个项目的来龙去脉，更能知道作者一些方法实现的过程，很容易知道这个项目的筋脉在哪里。之前一直不明白为什么要去看底层，为什么<br>要去看框架的源码，因为了解框架的源码会更容易知道这些方法在项目的哪里，原来是因为那样才可以使用这个方法的，从整体的角度来看开发。</p><h1 id="知其然，知其所以然"><a href="#知其然，知其所以然" class="headerlink" title="知其然，知其所以然"></a>知其然，知其所以然</h1><p>之前只知道一个东西的使用方法，但不知道它运行背后的原理，这个也是很重要的，一个方法的使用,原理和使用是相伴随行的，光是知道使用的话其实还是很难熟练变通的，要想游刃<br>有余还是要仔细地思考背后的原理,这样才能游刃有余的知道使用过程中这些问题的答案，本质的一些东西是不会轻易改变的，大多数新东西的原理还是老的，所以掌握背后的原理其实<br>还是更能知道这些新东西的使用。我的基础还是薄弱的，接下来一段时间要努力的补充基础知识，最基础的东西往往会影响一个软件的性能。</p><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p>以上就是这段时间的感悟，希望能在接下来的一段时间努力地客服这些东西，只有这样，同样的教训才不会再次发生，才能成长的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近经历了一些事情，有人指出了我的不足，我觉得自身目前确实存在这些问题，希望通过博客来自省。问题的指出还是要尽可能的改正和克服，这样才能成长。&lt;/p&gt;
&lt;h1 id=&quot;缺乏工程师的思维模式&quot;&gt;&lt;a href=&quot;#缺乏工程师的思维模式&quot; class=&quot;headerlink&quot; 
      
    
    </summary>
    
    
      <category term="个人感悟" scheme="http://yoursite.com/tags/%E4%B8%AA%E4%BA%BA%E6%84%9F%E6%82%9F/"/>
    
  </entry>
  
  <entry>
    <title>记录一次阿里云上docker启动不了的bug</title>
    <link href="http://yoursite.com/2019/10/09/%E8%AE%B0%E5%BD%95%E4%B8%80%E6%AC%A1%E9%98%BF%E9%87%8C%E4%BA%91%E4%B8%8Adocker%E5%90%AF%E5%8A%A8%E4%B8%8D%E4%BA%86%E7%9A%84bug/"/>
    <id>http://yoursite.com/2019/10/09/记录一次阿里云上docker启动不了的bug/</id>
    <published>2019-10-09T05:25:06.000Z</published>
    <updated>2019-10-09T05:34:15.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。"><a href="#最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。" class="headerlink" title="最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。"></a>最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。</h1><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">systemctl status docker.service</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/etc/systemd/system/docker.service; enabled; vendor preset: disabled)</span><br><span class="line">   Active: failed (Result: start-limit) since 六 2019-09-28 12:05:46 CST; 5min ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line">  Process: 1250 ExecStart=/usr/bin/dockerd --registry-mirror=39.98.73.138 --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; --registry-mirror=&lt;your accelerate address&gt; -H fd:// --containerd=/run/containerd/containerd.sock (code=exited, status=1/FAILURE)</span><br><span class="line"> Main PID: 1250 (code=exited, status=1/FAILURE)</span><br><span class="line"></span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service: main process exited, code=exited, status=1/FAILURE</span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">9月 28 12:05:44 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service holdoff time over, scheduling restart.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopped Docker Application Container Engine.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class="line">[root@iZ8vbcuptq5g86qk6lk4x1Z ~]# journalctl -xe</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has finished shutting down.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Stopping Docker Socket for the API.</span><br><span class="line">-- Subject: Unit docker.socket has begun shutting down</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has begun shutting down.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Starting Docker Socket for the API.</span><br><span class="line">-- Subject: Unit docker.socket has begun start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has begun starting up.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Listening on Docker Socket for the API.</span><br><span class="line">-- Subject: Unit docker.socket has finished start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.socket has finished starting up.</span><br><span class="line">--</span><br><span class="line">-- The start-up result is done.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: start request repeated too quickly for docker.service</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Failed to start Docker Application Container Engine.</span><br><span class="line">-- Subject: Unit docker.service has failed</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit docker.service has failed.</span><br><span class="line">--</span><br><span class="line">-- The result is failed.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Unit docker.service entered failed state.</span><br><span class="line">9月 28 12:05:46 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: docker.service failed.</span><br><span class="line">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 6 of user root.</span><br><span class="line">-- Subject: Unit session-6.scope has finished start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit session-6.scope has finished starting up.</span><br><span class="line">--</span><br><span class="line">-- The start-up result is done.</span><br><span class="line">9月 28 12:10:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1271]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z systemd[1]: Started Session 7 of user root.</span><br><span class="line">-- Subject: Unit session-7.scope has finished start-up</span><br><span class="line">-- Defined-By: systemd</span><br><span class="line">-- Support: http://lists.freedesktop.org/mailman/listinfo/systemd-devel</span><br><span class="line">--</span><br><span class="line">-- Unit session-7.scope has finished starting up.</span><br><span class="line">--</span><br><span class="line">-- The start-up result is done.</span><br><span class="line">9月 28 12:20:01 iZ8vbcuptq5g86qk6lk4x1Z CROND[1277]: (root) CMD (/usr/lib64/sa/sa1 1 1)</span><br><span class="line">lines 2500-2550/2550 (END)</span><br></pre></td></tr></table></figure><h1 id="解决的步骤"><a href="#解决的步骤" class="headerlink" title="解决的步骤:"></a>解决的步骤:</h1><p>1）清除/etc/systemd/system/目录下的 docker.service.requires这个目录的生成是安装别的系统Kubernete时生成的依赖信息。<br>个人总结：对这类问题清除/etc/systemd/system目录下不用的目录和文件是首选<br>2）执行systemctl daemon-reload或重启系统</p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.talkwithtrend.com/Question/415283?order=desc" target="_blank" rel="noopener">启动DOCKER时，遇到一个很奇葩的问题？</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。&quot;&gt;&lt;a href=&quot;#最近在阿里云上遇到一个docker启动不了的bug，解决的时间蛮久的，所以想记录一下。&quot; class=&quot;headerlink&quot; title=&quot;最近在阿里云
      
    
    </summary>
    
    
      <category term="docker" scheme="http://yoursite.com/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>php利用puppeteer来抓取西瓜视频</title>
    <link href="http://yoursite.com/2019/08/26/php%E5%88%A9%E7%94%A8puppeteer%E6%9D%A5%E6%8A%93%E5%8F%96%E8%A5%BF%E7%93%9C%E8%A7%86%E9%A2%91/"/>
    <id>http://yoursite.com/2019/08/26/php利用puppeteer来抓取西瓜视频/</id>
    <published>2019-08-26T10:12:44.000Z</published>
    <updated>2019-08-26T10:39:16.097Z</updated>
    
    <content type="html"><![CDATA[<p>最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件<br>本来下载puppeteer的时候它会自动下载无头的chrome的,但是由于被墙的原因，这个方案不行，我后面是用了阿里的一个改进版的puppeteer库，但后面发现还是不行，最后我只能在我的docker里面先下chrome的组件了<br>下面是我的dockerfile<br><figure class="highlight docker"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> graychen/alpine-php7.<span class="number">1</span>:alpine</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="bash"> /var/www/html</span></span><br><span class="line"><span class="bash">COPY supervisord.conf /etc/supervisor/conf.d/</span></span><br><span class="line"><span class="bash">COPY . /var/www/html</span></span><br><span class="line"><span class="bash">ENV CHROME_BIN=<span class="string">"/usr/bin/chromium-browser"</span>\</span></span><br><span class="line"><span class="bash">    PUPPETEER_SKIP_CHROMIUM_DOWNLOAD=<span class="string">"true"</span></span></span><br><span class="line"><span class="bash">RUN <span class="built_in">set</span> -x \</span></span><br><span class="line"><span class="bash">&amp;&amp; apk update \</span></span><br><span class="line"><span class="bash">&amp;&amp; apk upgrade \</span></span><br><span class="line"><span class="bash"><span class="comment"># replacing default repositories with edge ones</span></span></span><br><span class="line"><span class="bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">"http://dl-cdn.alpinelinux.org/alpine/edge/testing"</span> &gt; /etc/apk/repositories \</span></span><br><span class="line"><span class="bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">"http://dl-cdn.alpinelinux.org/alpine/edge/community"</span> &gt;&gt; /etc/apk/repositories \</span></span><br><span class="line"><span class="bash">&amp;&amp; <span class="built_in">echo</span> <span class="string">"http://dl-cdn.alpinelinux.org/alpine/edge/main"</span> &gt;&gt; /etc/apk/repositories &amp;&amp; \</span></span><br><span class="line"><span class="bash"><span class="comment"># Add the packages</span></span></span><br><span class="line"><span class="bash">apk add --no-cache dumb-init curl make gcc g++ python linux-headers binutils-gold gnupg libstdc++ nss nodejs nodejs-npm \</span></span><br><span class="line"><span class="bash">  <span class="comment">#alsa-lib \</span></span></span><br><span class="line"><span class="bash">  <span class="comment">#at-spi2-atk \</span></span></span><br><span class="line"><span class="bash">  <span class="comment">#atk \</span></span></span><br><span class="line"><span class="bash">  cairo \</span></span><br><span class="line"><span class="bash">  cups-libs \</span></span><br><span class="line"><span class="bash">  dbus-libs \</span></span><br><span class="line"><span class="bash">  eudev-libs \</span></span><br><span class="line"><span class="bash">  expat \</span></span><br><span class="line"><span class="bash">  flac \</span></span><br><span class="line"><span class="bash">  gdk-pixbuf \</span></span><br><span class="line"><span class="bash">  glib \</span></span><br><span class="line"><span class="bash">  libgcc \</span></span><br><span class="line"><span class="bash">  libjpeg-turbo \</span></span><br><span class="line"><span class="bash">  libpng \</span></span><br><span class="line"><span class="bash">  libwebp \</span></span><br><span class="line"><span class="bash">  libx11 \</span></span><br><span class="line"><span class="bash">  libxcomposite \</span></span><br><span class="line"><span class="bash">  libxdamage \</span></span><br><span class="line"><span class="bash">  libxext \</span></span><br><span class="line"><span class="bash">  libxfixes \</span></span><br><span class="line"><span class="bash">  tzdata \</span></span><br><span class="line"><span class="bash">  libexif \</span></span><br><span class="line"><span class="bash">  udev \</span></span><br><span class="line"><span class="bash">  xvfb \</span></span><br><span class="line"><span class="bash">  zlib-dev \</span></span><br><span class="line"><span class="bash">  chromium \</span></span><br><span class="line"><span class="bash">  chromium-chromedriver &amp;&amp; \</span></span><br><span class="line"><span class="bash">npm install cnpm -g --registry=https://r.npm.taobao.org &amp;&amp; \</span></span><br><span class="line"><span class="bash">cnpm install puppeteer@0.13.0  &amp;&amp; \</span></span><br><span class="line"><span class="bash">apk del --no-cache make gcc g++ python binutils-gold gnupg libstdc++ &amp;&amp; \</span></span><br><span class="line"><span class="bash">docker-php-ext-install sockets</span></span><br><span class="line"><span class="bash">ENTRYPOINT [<span class="string">"/usr/bin/supervisord"</span>, <span class="string">"-n"</span>, <span class="string">"-c"</span>,  <span class="string">"/etc/supervisor/conf.d/supervisord.conf"</span>]%</span></span><br></pre></td></tr></table></figure></p><p>因为我本身是用php，所以要下这个使用别人已经封装好的composer包<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">composer <span class="keyword">require</span> jaeger/querylist-puppeteer</span><br></pre></td></tr></table></figure></p><p>然后安装Node依赖（与composer一样在项目根目录下执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @nesk/puphpeteer</span><br></pre></td></tr></table></figure></p><p>下面是这个组件的用法<br>在QueryList中注册插件<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">QL</span>\<span class="title">QueryList</span>;</span><br><span class="line"><span class="keyword">use</span> <span class="title">QL</span>\<span class="title">Ext</span>\<span class="title">Chrome</span>;</span><br><span class="line"></span><br><span class="line">$ql = QueryList::getInstance();</span><br><span class="line"><span class="comment">// 注册插件，默认注册的方法名为: chrome</span></span><br><span class="line">$ql-&gt;use(Chrome::class);</span><br><span class="line"><span class="comment">// 或者自定义注册的方法名</span></span><br><span class="line">$ql-&gt;use(Chrome::class,<span class="string">'chrome'</span>);</span><br></pre></td></tr></table></figure></p><p>基本用法<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抓取的目标页面是使用Vue.js动态渲染的页面</span></span><br><span class="line">$text = $ql-&gt;chrome(<span class="string">'https://www.iviewui.com/components/button'</span>)-&gt;find(<span class="string">'h1'</span>)-&gt;text();</span><br><span class="line">print_r($text);</span><br><span class="line"><span class="comment">// 输出: Button 按钮</span></span><br><span class="line">$rules = [</span><br><span class="line"> <span class="string">'h1'</span> =&gt; [<span class="string">'h1'</span>,<span class="string">'text'</span>]</span><br><span class="line">];</span><br><span class="line">$ql = $ql-&gt;chrome(<span class="string">'https://www.iviewui.com/components/button'</span>);</span><br><span class="line">$data = $ql-&gt;rules($rules)-&gt;queryData();</span><br></pre></td></tr></table></figure></p><p>后面我优化了一下参数,我将抓取的步骤放到了队列中<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">public function execute($queue)</span><br><span class="line">    &#123;</span><br><span class="line">            $ql = QueryList::getInstance();</span><br><span class="line">                // 注册插件，默认注册的方法名为: chrome</span><br><span class="line">                $ql-&gt;use(Chrome::class);</span><br><span class="line">                $ql-&gt;use(Chrome::class,&apos;chrome&apos;);</span><br><span class="line">                $url = &apos;https://www.ixigua.com/&apos;.$this-&gt;jumpUrl;</span><br><span class="line">                $text = $ql-&gt;chrome($url,[executablePath =&gt; &apos;/usr/bin/chromium-browser&apos;, args=&gt; [&apos;--no-sandbox&apos;, &apos;--disable-setuid-sandbox&apos;,&apos;--proxy-server=&quot;direct://&quot;&apos;,</span><br><span class="line">                &apos;--proxy-bypass-list=*&apos;,&apos;–disable-gpu&apos;,</span><br><span class="line">                &apos;–disable-dev-shm-usage&apos;,</span><br><span class="line">                &apos;–disable-setuid-sandbox&apos;,</span><br><span class="line">                &apos;–no-first-run&apos;,</span><br><span class="line">                &apos;–no-zygote&apos;,</span><br><span class="line">                &apos;–single-process&apos;]],</span><br><span class="line">                function ($page,$browser) &#123;</span><br><span class="line">                    $page-&gt;setUserAgent(&apos;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/71.0.3578.98 Safari/537.36&apos;);</span><br><span class="line">                    // 设置cookie</span><br><span class="line">                    $page-&gt;setCookie([</span><br><span class="line">                    &apos;name&apos; =&gt; &apos;foo&apos;,</span><br><span class="line">                    &apos;value&apos; =&gt; &apos;xxx&apos;,</span><br><span class="line">                    &apos;url&apos; =&gt; $url</span><br><span class="line">                    ],[</span><br><span class="line">                    &apos;name&apos; =&gt; &apos;foo2&apos;,</span><br><span class="line">                    &apos;value&apos; =&gt; &apos;yyy&apos;,</span><br><span class="line">                    &apos;url&apos; =&gt; $url</span><br><span class="line">                    ]);</span><br><span class="line">                    $page-&gt;goto($url);</span><br><span class="line">                    // 等待h1元素出现</span><br><span class="line">                    $page-&gt;waitFor(&apos;#vs&apos;);</span><br><span class="line">                    $page-&gt;waitFor(&apos;xg-poster&apos;);</span><br><span class="line">                    $page-&gt;waitForNavigation();</span><br><span class="line">                    $page-&gt;screenshot([</span><br><span class="line">                        &apos;path&apos; =&gt; &apos;page.png&apos;,</span><br><span class="line">                        &apos;fullPage&apos; =&gt; true</span><br><span class="line">                    ]);</span><br><span class="line">                    // 获取页面HTML内容</span><br><span class="line">                    $html = $page-&gt;content();</span><br><span class="line">                    // 关闭浏览器</span><br><span class="line">                    $browser-&gt;close();</span><br><span class="line">                    // 返回值一定要是页面的HTML内容</span><br><span class="line">                    return $html;</span><br><span class="line">                &#125;)-&gt;getHtml();</span><br><span class="line">                $img = &quot;#&lt;xg-poster.*&gt;([^&lt;]*)&lt;/xg-poster&gt;#&quot;;</span><br><span class="line">                preg_match($img, $text, $contentImg);</span><br><span class="line">                $str = explode(&quot;;&quot;,$contentImg[0]);</span><br><span class="line">                $strUrl = explode(&quot;&amp;&quot;,$str[1]);</span><br><span class="line">                $imgUrl=$strUrl[0];</span><br><span class="line">                $s = file_get_contents($imgUrl);</span><br><span class="line">                $moive = new Moive();</span><br><span class="line">                $dir = \Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/cover/&apos;.date(&apos;Ymd&apos;);</span><br><span class="line">                if(!is_dir($dir)) &#123;</span><br><span class="line">                    mkdir($dir);</span><br><span class="line">                &#125;</span><br><span class="line">                $imgShotPath=&apos;cover/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class="line">                $imgPath = $dir.&apos;/&apos;.time().&apos;.jpg&apos;;</span><br><span class="line">                file_put_contents($imgPath, $s);</span><br><span class="line">                $head=&quot;#&lt;h1&gt;([^&lt;]*)&lt;/h1&gt;#&quot;;</span><br><span class="line">                preg_match($head, $text, $contentHead);</span><br><span class="line">                $regex = &quot;/src=\s*[\&apos;|\&quot;]+?(.*?)[\&apos;|\&quot;]+?/&quot;;</span><br><span class="line">                $return = preg_match_all($regex, $text, $content);</span><br><span class="line">                $pathUrl = $content[1][4];</span><br><span class="line">                $s = file_get_contents($pathUrl);</span><br><span class="line">                $dir = \Yii::getAlias(&apos;@frontend&apos;) . &apos;/web/uploads/video/&apos;.date(&apos;Ymd&apos;);</span><br><span class="line">                if(!is_dir($dir)) &#123;</span><br><span class="line">                    mkdir($dir);</span><br><span class="line">                &#125;</span><br><span class="line">                $videoShotPath = &apos;video/&apos;.date(&apos;Ymd&apos;).&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class="line">                $videoPath = $dir.&apos;/&apos;.time().&apos;.mp4&apos;;</span><br><span class="line">                file_put_contents($videoPath, $s);</span><br><span class="line">                $contentArray = explode(&quot;：&quot;, $contentHead[1]);</span><br><span class="line">                $describe=$contentArray[1];</span><br><span class="line">                $status = Moive::STATUS_SHOW;</span><br><span class="line">                $num = 0;</span><br><span class="line">                $this-&gt;saveData($moive, $describe, $status, $num, $imgShotPath, $videoShotPath);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>其实我现在的代码还有个问题，就是渲染出来的页面有时候没有渲染好就打印出来了，接下来看看怎么优化</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近想要抓取西瓜视频，却发现它的页面是react做的，动态的js渲染，使用普通的http只能抓到静态的页面，找了好久才发现可以使用无头的浏览器来渲染它的页面,而提供puppeteer就是对无界面的chrome浏览器的js组件&lt;br&gt;本来下载puppeteer的时候它会自动下
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>在minikube部署个node服务</title>
    <link href="http://yoursite.com/2019/08/22/%E5%9C%A8minikube%E9%83%A8%E7%BD%B2%E4%B8%AAnode%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/08/22/在minikube部署个node服务/</id>
    <published>2019-08-22T10:51:09.000Z</published>
    <updated>2019-08-22T11:10:28.688Z</updated>
    
    <content type="html"><![CDATA[<h2 id="创建Node-js应用程序"><a href="#创建Node-js应用程序" class="headerlink" title="创建Node.js应用程序"></a>创建Node.js应用程序</h2><p>先编写server.js<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> handleRequest = <span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Received request for URL: '</span> + request.url);</span><br><span class="line">  response.writeHead(<span class="number">200</span>);</span><br><span class="line">  response.end(<span class="string">'Hello World!'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> www = http.createServer(handleRequest);</span><br><span class="line">www.listen(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure></p><p>然后在<a href="http://localhost:8080/中看到&quot;Hello" target="_blank" rel="noopener">http://localhost:8080/中看到&quot;Hello</a> World”</p><h2 id="创建Docker容器镜像"><a href="#创建Docker容器镜像" class="headerlink" title="创建Docker容器镜像"></a>创建Docker容器镜像</h2><p>在hellonode文件夹中创建一个Dockerfile命名的文件。Dockerfile描述了build的镜像，通过现有的镜像扩展（extend）build Docker容器镜像，本教程中的镜像扩展（extend）了现有的Node.js镜像。<br><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">FROM</span> node:<span class="number">6.9</span>.<span class="number">2</span></span><br><span class="line"><span class="keyword">EXPOSE</span> <span class="number">8080</span></span><br><span class="line"><span class="keyword">COPY</span><span class="bash"> server.js .</span></span><br><span class="line"><span class="bash">CMD node server.js</span></span><br></pre></td></tr></table></figure></p><p>确保使用Minikube Docker守护进程<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval $(minikube docker-env)</span><br></pre></td></tr></table></figure></p><p>注意：如果不在使用Minikube主机时，可以通过运行eval $(minikube docker-env -u)来撤消此更改。<br>使用Minikube Docker守护进程build Docker镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-node:v1 .</span><br></pre></td></tr></table></figure></p><h2 id="创建Deployment"><a href="#创建Deployment" class="headerlink" title="创建Deployment"></a>创建Deployment</h2><p>使用kubectl run命令创建Deployment来管理Pod。Pod根据hello-node:v1Docker运行容器镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl run hello-node --image=hello-node:v1 --port=8080</span><br></pre></td></tr></table></figure></p><p>查看Deployment：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get deployments</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME         DESIRED   CURRENT   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">hello-node   1         1         1            1           3m</span><br></pre></td></tr></table></figure><p>查看Pod：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get pods</span><br></pre></td></tr></table></figure></p><p>输出：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NAME                         READY     STATUS    RESTARTS   AGE</span><br><span class="line">hello-node-714049816-ztzrb   1/1       Running   0          6m</span><br></pre></td></tr></table></figure></p><p>查看群集events：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get events</span><br></pre></td></tr></table></figure><p>查看kubectl配置：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl config view</span><br></pre></td></tr></table></figure></p><h2 id="创建Service"><a href="#创建Service" class="headerlink" title="创建Service"></a>创建Service</h2><p>默认情况，这Pod只能通过Kubernetes群集内部IP访问。要使hello-node容器从Kubernetes虚拟网络外部访问，须要使用Kubernetes Service暴露Pod。<br>我们可以使用kubectl expose命令将Pod暴露到外部环境：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl expose deployment hello-node --type=LoadBalancer</span><br></pre></td></tr></table></figure></p><p>查看刚创建的Service：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get services</span><br></pre></td></tr></table></figure></p><p>输出：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">hello-node   10.0.0.71    &lt;pending&gt;     8080/TCP   6m</span><br><span class="line">kubernetes   10.0.0.1     &lt;none&gt;        443/TCP    14d</span><br></pre></td></tr></table></figure><p>通过–type=LoadBalancer flag来在群集外暴露Service，在支持负载均衡的云提供商上，将配置外部IP地址来访问Service。在Minikube上，该LoadBalancer type使服务可以通过minikube Service 命令访问。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service hello-node</span><br></pre></td></tr></table></figure></p><p>将打开浏览器，在本地IP地址为应用提供服务，显示“Hello World”的消息。<br>最后可以查看到一些日志<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl logs &lt;POD-NAME&gt;</span><br></pre></td></tr></table></figure></p><p>更新应用程序<br>编辑server.js文件以返回新消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">response.end(&apos;Hello World Again!&apos;);</span><br></pre></td></tr></table></figure></p><p>build新版本镜像<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t hello-node:v2 .</span><br></pre></td></tr></table></figure></p><p>Deployment更新镜像：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl set image deployment/hello-node hello-node=hello-node:v2</span><br></pre></td></tr></table></figure></p><p>再次运行应用以查看新消息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube service hello-node</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;创建Node-js应用程序&quot;&gt;&lt;a href=&quot;#创建Node-js应用程序&quot; class=&quot;headerlink&quot; title=&quot;创建Node.js应用程序&quot;&gt;&lt;/a&gt;创建Node.js应用程序&lt;/h2&gt;&lt;p&gt;先编写server.js&lt;br&gt;&lt;figure cl
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://yoursite.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes本地实验环境</title>
    <link href="http://yoursite.com/2019/08/22/Kubernetes%E6%9C%AC%E5%9C%B0%E5%AE%9E%E9%AA%8C%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2019/08/22/Kubernetes本地实验环境/</id>
    <published>2019-08-22T05:12:59.000Z</published>
    <updated>2019-08-22T05:25:08.802Z</updated>
    
    <content type="html"><![CDATA[<p>最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，<br>所以使用这个minikube来安装.<br>我是mac电脑，首先<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install kubernetes-cli</span><br></pre></td></tr></table></figure></p><p>然后确认是否安装成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl version</span><br></pre></td></tr></table></figure></p><p>接着安装<a href="https://www.virtualbox.org/wiki/Downloads" target="_blank" rel="noopener">VitualBox</a><br>然后安装改版的minikube<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -Lo minikube http://kubernetes.oss-cn-hangzhou.aliyuncs.com/minikube/releases/v1.2.0/minikube-darwin-amd64 &amp;&amp; chmod +x minikube &amp;&amp; sudo mv minikube /usr/<span class="built_in">local</span>/bin/</span><br></pre></td></tr></table></figure></p><p>接着启动<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube start --registry-mirror=https://registry.docker-cn.com</span><br></pre></td></tr></table></figure></p><p>打开Kubernetes控制台<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">minikube dashboard</span><br></pre></td></tr></table></figure></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="https://yq.aliyun.com/articles/221687" target="_blank" rel="noopener">Minikube - Kubernetes本地实验环境</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在配置本地的k8s环境，由于网络原因，老是配置不成，偶然发现了阿里改版的minikube，&lt;br&gt;所以使用这个minikube来安装.&lt;br&gt;我是mac电脑，首先&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td clas
      
    
    </summary>
    
    
      <category term="DevOps" scheme="http://yoursite.com/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>mac终端走shadowsocks代理</title>
    <link href="http://yoursite.com/2019/08/22/mac%E7%BB%88%E7%AB%AF%E8%B5%B0shadowsocks%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2019/08/22/mac终端走shadowsocks代理/</id>
    <published>2019-08-22T03:44:23.000Z</published>
    <updated>2019-08-22T05:32:02.065Z</updated>
    
    <content type="html"><![CDATA[<p>shadowsocks设置为：</p><p>打开shadowsocks<br>自动代理模式<br>服务器（香港阿里云）<br>以zsh作为说明<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ vim ~/.zshrc</span><br></pre></td></tr></table></figure></p><p>添加如下代理配置:</p><h1 id="proxy-list"><a href="#proxy-list" class="headerlink" title="proxy list"></a>proxy list</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> proxy=<span class="string">'export all_proxy=socks5://127.0.0.1:1080'</span></span><br><span class="line"><span class="built_in">alias</span> unproxy=<span class="string">'unset all_proxy'</span></span><br><span class="line">:wq保存退出</span><br><span class="line">➜  ~ <span class="built_in">source</span> ~/.zshrc</span><br></pre></td></tr></table></figure><p>使用proxy前先查看下当前的ip地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ curl ip.cn</span><br><span class="line">当前 IP：112.64.xxx.xx 来自：上海市 联通</span><br><span class="line">或者</span><br><span class="line">~ curl cip.cc</span><br><span class="line">IP: 140.206.97.42</span><br><span class="line">地址: 中国  上海</span><br><span class="line"></span><br><span class="line">数据二: 上海市 | 联通</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/140.206.97.42</span><br><span class="line">执行:</span><br><span class="line"></span><br><span class="line">➜  ~ proxy</span><br><span class="line">➜  ~ curl ip.cn</span><br><span class="line">当前 IP：47.89.xx.xxx 来自：香港特别行政区 阿里云</span><br><span class="line">如果ip.cn不能用，可以换个类似的站点查询</span><br><span class="line">~ curl cip.cc</span><br><span class="line">IP: 45.78.47.19</span><br><span class="line">地址: 美国  加利福尼亚</span><br><span class="line"></span><br><span class="line">数据二: 美国 | 加利福尼亚州洛杉矶市 IT7 Networks</span><br><span class="line"></span><br><span class="line">URL: http://www.cip.cc/45.78.47.19</span><br></pre></td></tr></table></figure><p>没问题，终端走了代理，brew update顺畅了- -</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;shadowsocks设置为：&lt;/p&gt;
&lt;p&gt;打开shadowsocks&lt;br&gt;自动代理模式&lt;br&gt;服务器（香港阿里云）&lt;br&gt;以zsh作为说明&lt;br&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>解析jwt</title>
    <link href="http://yoursite.com/2019/08/21/%E8%A7%A3%E6%9E%90jwt/"/>
    <id>http://yoursite.com/2019/08/21/解析jwt/</id>
    <published>2019-08-21T11:01:07.000Z</published>
    <updated>2019-08-21T13:09:47.393Z</updated>
    
    <content type="html"><![CDATA[<h1 id="jwt是什么"><a href="#jwt是什么" class="headerlink" title="jwt是什么"></a>jwt是什么</h1><p>jwt全称是JSON Web Token，是目前流行的跨域认证解决方案</p><h1 id="为什么使用jwt"><a href="#为什么使用jwt" class="headerlink" title="为什么使用jwt"></a>为什么使用jwt</h1><p>要知道为什么使用jwt，我们先来看看传统的认证方式<br>1、用户向服务器发送用户名和密码。<br>2、服务器验证通过后，在当前对话（session）里面保存相关数据，比如用户角色、登录时间等等。<br>3、服务器向用户返回一个 session_id，写入用户的 Cookie。<br>4、用户随后的每一次请求，都会通过 Cookie，将 session_id 传回服务器。<br>5、服务器收到 session_id，找到前期保存的数据，由此得知用户的身份。<br>这种方式的扩展性不好，如果是服务器集群，就要求session数据共享，每台服务器都能读取session<br>一种解决方案是 session 数据持久化，写入数据库或别的持久层。各种服务收到请求后，都向持久层请求数据。这种方案的优点是架构清晰，缺点是工程量比较大。另外，持久层万一挂了，就会单点失败。<br>另一种方案是服务器索性不保存 session 数据了，所有数据都保存在客户端，每次请求都发回服务器。JWT 就是这种方案的一个代表。</p><h1 id="jwt的原理"><a href="#jwt的原理" class="headerlink" title="jwt的原理"></a>jwt的原理</h1><p>jwt的原理是服务器认证后，生成一个JSON对象，发回给用户<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"姓名"</span>: <span class="string">"张三"</span>,</span><br><span class="line">  <span class="attr">"角色"</span>: <span class="string">"管理员"</span>,</span><br><span class="line">  <span class="attr">"到期时间"</span>: <span class="string">"2018年7月1日0点0分"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>以后，用户与服务端通信的时候，都要发回这个 JSON 对象。服务器完全只靠这个对象认定用户身份。为了防止用户篡改数据，服务器在生成这个对象的时候，会加上签名（详见后文）。<br>服务器就不保存任何 session 数据了，也就是说，服务器变成无状态了，从而比较容易实现扩展。</p><h1 id="jwt的数据结构"><a href="#jwt的数据结构" class="headerlink" title="jwt的数据结构"></a>jwt的数据结构</h1><p>它是一个很长的字符串，中间用点（.）分隔成三个部分。例如<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1bmlvbmlkIjoiMDdhMjIwMDE5ODI1YWY5YjYwZDVlYWI1NGI1OTNkYmYiLCJ3eF91bmlvbmlkIjpudWxsLCJwbGF0Zm9ybSI6IkhXTUNfQVBQIiwiZXhwaXJlX2F0IjoxNTY3MjIxMDY5fQ.AsdOrML1WrCBtOiCs4afi5cCPbWK5dLPO_29Vb1w0EE</span><br></pre></td></tr></table></figure></p><blockquote><blockquote><blockquote><p>jwt的三个部分如下</p><ul><li>Header(头部)</li><li>Payload(负载)</li><li>Signature(签名)<br>写成一行就是<em>Header.Payload.Signature</em><br>Header 部分是一个 JSON 对象，描述 JWT 的元数据，通常是下面的样子。<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"alg"</span>: <span class="string">"HS256"</span>,</span><br><span class="line">  <span class="string">"typ"</span>: <span class="string">"JWT"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></blockquote></blockquote></blockquote><p>上面代码中，alg属性表示签名的算法（algorithm），默认是 HMAC SHA256（写成 HS256）；typ属性表示这个令牌（token）的类型（type），JWT 令牌统一写为JWT。<br>3.2 Payload<br>Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。JWT 规定了7个官方字段，供选用。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：签发人</span><br><span class="line">exp (expiration time)：过期时间</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：受众</span><br><span class="line">nbf (Not Before)：生效时间</span><br><span class="line">iat (Issued At)：签发时间</span><br><span class="line">jti (JWT ID)：编号</span><br></pre></td></tr></table></figure></p><p>除了官方字段，你还可以在这个部分定义私有字段，下面就是一个例子。<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"sub"</span>: <span class="string">"1234567890"</span>,</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"John Doe"</span>,</span><br><span class="line">  <span class="attr">"admin"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>注意，JWT 默认是不加密的，任何人都可以读到，所以不要把秘密信息放在这个部分。<br>这个json对象使用Base64URL 算法转成字符串<br>3.3 Signature<br>Signature 部分是对前两部分的签名，防止数据篡改。<br>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(</span><br><span class="line">  base64UrlEncode(header) + <span class="string">"."</span> +</span><br><span class="line">  base64UrlEncode(payload),</span><br><span class="line">  secret)</span><br></pre></td></tr></table></figure></p><p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用”点”（.）分隔，就可以返回给用户。</p><h2 id="jwt的使用方式"><a href="#jwt的使用方式" class="headerlink" title="jwt的使用方式"></a>jwt的使用方式</h2><p>jwt可以存储在cookie里，也可以存储在localStorage<br>在header里面放 Authorization: Bearer <token><br>也可以放在post的请求数据体里<br>代码实现<br><a href="https://github.com/firebase/php-jwt" target="_blank" rel="noopener">参考这个jwt类</a><br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">function</span> <span class="title">encode</span><span class="params">($payload, $key, $alg = <span class="string">'HS256'</span>, $keyId = null, $head = null)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        $header = <span class="keyword">array</span>(<span class="string">'typ'</span> =&gt; <span class="string">'JWT'</span>, <span class="string">'alg'</span> =&gt; $alg);</span><br><span class="line">        <span class="keyword">if</span> ($keyId !== <span class="keyword">null</span>) &#123;</span><br><span class="line">            $header[<span class="string">'kid'</span>] = $keyId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="keyword">isset</span>($head) &amp;&amp; is_array($head) ) &#123;</span><br><span class="line">            $header = array_merge($head, $header);</span><br><span class="line">        &#125;</span><br><span class="line">        $segments = <span class="keyword">array</span>();</span><br><span class="line">        $segments[] = <span class="keyword">static</span>::urlsafeB64Encode(<span class="keyword">static</span>::jsonEncode($header));</span><br><span class="line">        $segments[] = <span class="keyword">static</span>::urlsafeB64Encode(<span class="keyword">static</span>::jsonEncode($payload));</span><br><span class="line">        $signing_input = implode(<span class="string">'.'</span>, $segments);</span><br><span class="line"></span><br><span class="line">        $signature = <span class="keyword">static</span>::sign($signing_input, $key, $alg);</span><br><span class="line">        $segments[] = <span class="keyword">static</span>::urlsafeB64Encode($signature);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> implode(<span class="string">'.'</span>, $segments);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></token></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul><li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">JSON Web Token 入门教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;jwt是什么&quot;&gt;&lt;a href=&quot;#jwt是什么&quot; class=&quot;headerlink&quot; title=&quot;jwt是什么&quot;&gt;&lt;/a&gt;jwt是什么&lt;/h1&gt;&lt;p&gt;jwt全称是JSON Web Token，是目前流行的跨域认证解决方案&lt;/p&gt;
&lt;h1 id=&quot;为什么使用j
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>mac下配置vscode的xdebug</title>
    <link href="http://yoursite.com/2019/08/21/mac%E4%B8%8B%E9%85%8D%E7%BD%AEvscode%E7%9A%84xdebug/"/>
    <id>http://yoursite.com/2019/08/21/mac下配置vscode的xdebug/</id>
    <published>2019-08-21T10:39:44.000Z</published>
    <updated>2019-08-22T05:26:09.383Z</updated>
    
    <content type="html"><![CDATA[<h1 id="最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路"><a href="#最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路" class="headerlink" title="最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路"></a>最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路</h1><h2 id="首先下载xdebug的扩展"><a href="#首先下载xdebug的扩展" class="headerlink" title="首先下载xdebug的扩展"></a>首先下载xdebug的扩展</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pecl install xdebug</span><br></pre></td></tr></table></figure><h3 id="配置php-ini"><a href="#配置php-ini" class="headerlink" title="配置php.ini"></a>配置php.ini</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">zend_extension=<span class="string">"xdebug.so"</span></span><br><span class="line">xdebug.profiler_enable = on</span><br><span class="line">xdebug.trace_output_dir = <span class="string">"/data/logs/xdebug"</span></span><br><span class="line">xdebug.profile_output_dir = <span class="string">"/data/logs/xdebug"</span></span><br><span class="line">xdebug.remote_enable = <span class="number">1</span></span><br><span class="line">xdebug.remote_autostart = <span class="number">1</span></span><br><span class="line">xdebug.remote_host = <span class="string">"localhost"</span></span><br><span class="line">xdebug.remote_port = <span class="number">9000</span></span><br><span class="line">xdebug.idekey = <span class="string">"phpStorm"</span></span><br></pre></td></tr></table></figure><h3 id="保存并退出，重启php-fpm"><a href="#保存并退出，重启php-fpm" class="headerlink" title="保存并退出，重启php-fpm"></a>保存并退出，重启php-fpm</h3> <figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services restart php72</span><br></pre></td></tr></table></figure><h2 id="二、VS-Code-配置"><a href="#二、VS-Code-配置" class="headerlink" title="二、VS Code 配置"></a>二、VS Code 配置</h2><p>1.安装 PHP Debug 扩展<br>2.左侧调试按钮 - 左侧顶部调试[Listen for XDebug]，设置<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 使用 IntelliSense 了解相关属性。 </span></span><br><span class="line">    <span class="comment">// 悬停以查看现有属性的描述。</span></span><br><span class="line">    <span class="comment">// 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span></span><br><span class="line">    <span class="string">"version"</span>: <span class="string">"0.2.0"</span>,</span><br><span class="line">    <span class="string">"configurations"</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Listen for Xdebug"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"php"</span>,</span><br><span class="line">        <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">        <span class="string">"port"</span>: <span class="number">9000</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"name"</span>: <span class="string">"Launch currently open script"</span>,</span><br><span class="line">        <span class="string">"type"</span>: <span class="string">"php"</span>,</span><br><span class="line">        <span class="string">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">        <span class="string">"program"</span>: <span class="string">"$&#123;file&#125;"</span>,</span><br><span class="line">        <span class="string">"cwd"</span>: <span class="string">"$&#123;fileDirname&#125;"</span>,</span><br><span class="line">        <span class="string">"port"</span>: <span class="number">9001</span></span><br><span class="line">    &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="然后就可以利用xdebug调试php了"><a href="#然后就可以利用xdebug调试php了" class="headerlink" title="然后就可以利用xdebug调试php了"></a>然后就可以利用xdebug调试php了</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路&quot;&gt;&lt;a href=&quot;#最近将mac环境下的vscode配置了xdebug，因为配置的比较曲折，所以决定记录下思路&quot; class=&quot;headerlink&quot; title=&quot;最近
      
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>秒杀防止库存超卖的思路</title>
    <link href="http://yoursite.com/2019/07/25/%E7%A7%92%E6%9D%80%E9%98%B2%E6%AD%A2%E5%BA%93%E5%AD%98%E8%B6%85%E5%8D%96%E7%9A%84%E6%80%9D%E8%B7%AF/"/>
    <id>http://yoursite.com/2019/07/25/秒杀防止库存超卖的思路/</id>
    <published>2019-07-25T08:09:11.000Z</published>
    <updated>2019-07-25T08:09:11.055Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>mysql优化总结</title>
    <link href="http://yoursite.com/2019/04/27/mysql%E4%BC%98%E5%8C%96%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/04/27/mysql优化总结/</id>
    <published>2019-04-27T09:00:21.000Z</published>
    <updated>2019-07-23T12:19:48.282Z</updated>
    
    <content type="html"><![CDATA[<p>最近总结下mysql的优化思路，希望接下来能看到这篇文章回忆和参考</p><h1 id="优化sql语句"><a href="#优化sql语句" class="headerlink" title="优化sql语句"></a>优化sql语句</h1><h2 id="通过show-status命令了解各种sql的执行效率"><a href="#通过show-status命令了解各种sql的执行效率" class="headerlink" title="通过show status命令了解各种sql的执行效率"></a>通过show status命令了解各种sql的执行效率</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mysql&gt; show status like &apos;Com_%&apos;;</span><br></pre></td></tr></table></figure><ul><li>Com_select:执行select操作的次数，一次查询只增加1</li><li>Com_insert:执行insert操作的次数，对于批量插入的insert操作，只累加一次</li><li>Com_update: 执行update操作的次数</li><li>Com_delete: 执行delete操作的次数<br>对InnoDB存储引擎<br>Innodb_rows_read: select查询返回的行数<br>Innodb_rows_inserted: 执行insert操作的行数<br>Innodb_rows_update: 执行update操作更新的行数<br>Innodb_rows_delete: 执行delete操作的行数<br>了解当前数据以插入更新为主还是以查询为主，各种类型sql的执行比例。对于更新操作的计数，是执行次数的计数。通过com_commit和Com_rollback可以了解事务提交和回滚的情况<h2 id="定位执行效率较低的sql语句"><a href="#定位执行效率较低的sql语句" class="headerlink" title="定位执行效率较低的sql语句"></a>定位执行效率较低的sql语句</h2></li><li>通过慢查询日志定位那些执行效率低的sql语句，用–log-slow-queries=[filename]</li><li>通过show processlist命令查看mysql进行的线程，包括线程的状态，是否锁表<h2 id="通过explain分析sql的执行计划"><a href="#通过explain分析sql的执行计划" class="headerlink" title="通过explain分析sql的执行计划"></a>通过explain分析sql的执行计划</h2><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> mysql&gt; explain select sum(amount) from customer a , payment b where <span class="number">1</span>=<span class="number">1</span> a.customer_id = b.customer_id <span class="keyword">and</span> email = <span class="string">'JANE.BENNETT@SAKILACUSTOMER.org'</span>\G</span><br><span class="line">***************<span class="number">1.</span> row*********************</span><br><span class="line">id:<span class="number">1</span></span><br><span class="line">select_type:SIMPLE</span><br><span class="line">table:a</span><br><span class="line">type:ALL</span><br><span class="line">possible_keys:PRIMARY</span><br><span class="line">key:<span class="keyword">NULL</span></span><br><span class="line">key_len:<span class="keyword">NULL</span></span><br><span class="line">ref:<span class="keyword">NULL</span></span><br><span class="line">ROWS:<span class="number">583</span></span><br><span class="line">***************<span class="number">2.</span> row*********************</span><br><span class="line">id:<span class="number">2</span></span><br><span class="line">select_type:SIMPLE</span><br><span class="line">table:b</span><br><span class="line">type: ref</span><br><span class="line">possible_keys:idx_fk_customer_id</span><br><span class="line">key:idx_fk_customer_id</span><br><span class="line">key_len:<span class="number">2</span></span><br><span class="line">ref:sakila.a.customer_id</span><br><span class="line">ROWS:<span class="number">12</span></span><br><span class="line">************************************</span><br></pre></td></tr></table></figure></li></ul><blockquote></blockquote><p>slect_type: select的类型</p><ul><li>SIMPLE(简单表，不使用表连接或者子查询)</li><li>PRIMARY(主查询:外层的查询)</li><li>UNION(UNION中的第二个或者后面的查询语句)</li><li>SUBQUERY(子查询中的第一个SELECT)<br>table:输出结果集的表<br>type:</li><li>ALL 全表扫描（表里全表来找到匹配的行）</li><li>index 索引全扫描 (遍历索引来查询匹配的行)</li><li>range 索引范围扫描 (常见&lt; &gt; &lt;= &gt;= between)</li><li>ref 非唯一索引扫描表</li><li>eq_ref 唯一索引扫描表 </li><li>const/system 最多有一个匹配行<br>NULL：不用访问表或者索引</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近总结下mysql的优化思路，希望接下来能看到这篇文章回忆和参考&lt;/p&gt;
&lt;h1 id=&quot;优化sql语句&quot;&gt;&lt;a href=&quot;#优化sql语句&quot; class=&quot;headerlink&quot; title=&quot;优化sql语句&quot;&gt;&lt;/a&gt;优化sql语句&lt;/h1&gt;&lt;h2 id=&quot;通过sh
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>Hprose使用说明</title>
    <link href="http://yoursite.com/2018/05/20/Hprose%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/"/>
    <id>http://yoursite.com/2018/05/20/Hprose使用说明/</id>
    <published>2018-05-20T04:37:25.000Z</published>
    <updated>2019-03-27T13:25:38.794Z</updated>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Hprose(High Performance Remote Object Service Engine)<br>是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。 你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。</p><h1 id="使用手册"><a href="#使用手册" class="headerlink" title="使用手册"></a>使用手册</h1><h1 id="案例-php"><a href="#案例-php" class="headerlink" title="案例(php)"></a>案例(php)</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><ul><li>使用<code>composer require hprose/hprose</code><br>如果你正在使用 composer 管理你的项目，那么你不需要做任何特别处理。只要在 composer.json 中的 require 段添加了对 hprose/hprose 的引用就可以了。如果你需要 swoole 支持，添加 hprose/hprose-swoole 就可以了。<br>然后在代码中这样引用</li></ul><a id="more"></a><h3 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">use Hprose\Swoole\Http\Server;</span><br><span class="line"></span><br><span class="line">//定义Hello服务</span><br><span class="line">function hello($name) &#123;</span><br><span class="line">    return &quot;Hello $name!&quot;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//发布服务器</span><br><span class="line">$server = new Server();</span><br><span class="line"></span><br><span class="line">//注册hello方法</span><br><span class="line">$server-&gt;addFunction(&apos;hello&apos;);</span><br><span class="line"></span><br><span class="line">$server-&gt;start();</span><br></pre></td></tr></table></figure><h3 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> <span class="title">Hprose</span>\<span class="title">Client</span>;</span><br><span class="line"></span><br><span class="line">$client=Client::create(<span class="string">'http://localhost/'</span>,<span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">echo</span> $client-&gt;hello(<span class="string">"World"</span>);</span><br></pre></td></tr></table></figure><h1 id="案例-go"><a href="#案例-go" class="headerlink" title="案例(go)"></a>案例(go)</h1><h2 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">go get github.com/gorilla/websocket</span><br><span class="line">go get github.com/valyala/fasthttp</span><br><span class="line">go get github.com/hprose/hprose-golang</span><br></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="服务端-1"><a href="#服务端-1" class="headerlink" title="服务端"></a>服务端</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import(</span><br><span class="line">    &quot;net/http&quot;</span><br><span class="line">    &quot;github.com/hprose/hprose-golang/rpc&quot;</span><br><span class="line">      )</span><br><span class="line"></span><br><span class="line">func hello(name string) string &#123;</span><br><span class="line">    return &quot;Hello&quot; + name + &quot;!&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">    service := rpc.NewHTTPService()</span><br><span class="line">    service.AddFunction(&quot;hello&quot;, hello, rpc.Options&#123;&#125;)</span><br><span class="line">    http.ListenAndServer(&quot;:8080&quot;,service)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="客户端-1"><a href="#客户端-1" class="headerlink" title="客户端"></a>客户端</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">        <span class="string">"fmt"</span></span><br><span class="line">        <span class="string">"github.com/hprose/hprose-golang/rpc"</span></span><br><span class="line">       )</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> Stub <span class="keyword">struct</span> &#123;</span><br><span class="line">    Hello <span class="function"><span class="keyword">func</span><span class="params">(<span class="keyword">string</span>)</span> <span class="params">(<span class="keyword">string</span>, error)</span></span></span><br><span class="line"><span class="function">    <span class="title">AsyncHello</span> <span class="title">func</span><span class="params">(<span class="keyword">func</span>(<span class="keyword">string</span>, error)</span>,<span class="title">string</span>) `<span class="title">name</span>:"<span class="title">hello</span>"`</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    client := rpc.NewClient(<span class="string">"http://127.0.0.1:8080/"</span>)</span><br><span class="line">    <span class="keyword">var</span> stub *Stub</span><br><span class="line">    client.UseService(&amp;stub)</span><br><span class="line">    stub.AsyncHello(<span class="function"><span class="keyword">func</span><span class="params">(result <span class="keyword">string</span>,err error)</span></span> &#123;</span><br><span class="line">            fmt.Println(result, error)</span><br><span class="line">            &#125;,<span class="string">"async world"</span>)</span><br><span class="line">            fmt.Println(stub.Hello(<span class="string">"world"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h1&gt;&lt;p&gt;Hprose(High Performance Remote Object Service Engine)&lt;br&gt;是一款先进的轻量级、跨语言、跨平台、无侵入式、高性能动态远程对象调用引擎库。它不仅简单易用，而且功能强大。 你无需专门学习，只需看上几眼，就能用它轻松构建分布式应用系统。&lt;/p&gt;
&lt;h1 id=&quot;使用手册&quot;&gt;&lt;a href=&quot;#使用手册&quot; class=&quot;headerlink&quot; title=&quot;使用手册&quot;&gt;&lt;/a&gt;使用手册&lt;/h1&gt;&lt;h1 id=&quot;案例-php&quot;&gt;&lt;a href=&quot;#案例-php&quot; class=&quot;headerlink&quot; title=&quot;案例(php)&quot;&gt;&lt;/a&gt;案例(php)&lt;/h1&gt;&lt;h2 id=&quot;安装&quot;&gt;&lt;a href=&quot;#安装&quot; class=&quot;headerlink&quot; title=&quot;安装&quot;&gt;&lt;/a&gt;安装&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;composer require hprose/hprose&lt;/code&gt;&lt;br&gt;如果你正在使用 composer 管理你的项目，那么你不需要做任何特别处理。只要在 composer.json 中的 require 段添加了对 hprose/hprose 的引用就可以了。如果你需要 swoole 支持，添加 hprose/hprose-swoole 就可以了。&lt;br&gt;然后在代码中这样引用&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>利用gitlab进行持续部署</title>
    <link href="http://yoursite.com/2018/02/12/%E5%88%A9%E7%94%A8gitlab%E8%BF%9B%E8%A1%8C%E6%8C%81%E7%BB%AD%E9%83%A8%E7%BD%B2/"/>
    <id>http://yoursite.com/2018/02/12/利用gitlab进行持续部署/</id>
    <published>2018-02-12T15:55:00.000Z</published>
    <updated>2018-05-27T09:59:36.027Z</updated>
    
    <content type="html"><![CDATA[<h2 id="GitLab-CI使用Docker进行持续部署"><a href="#GitLab-CI使用Docker进行持续部署" class="headerlink" title="GitLab-CI使用Docker进行持续部署"></a>GitLab-CI使用Docker进行持续部署</h2><p>Docker镜像通过私有仓库进行发布(如阿里云), 发布命令为:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker login -u username -p password registry.demo.com</span><br><span class="line">docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</span><br><span class="line">docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</span><br></pre></td></tr></table></figure></p><p>其中 <code>username</code>是用户名, <code>password</code>是密码, registry.demo.com是私有镜像库地址,<br><code>$CI_PROJECT_NAME</code> 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t registry.demo.com/repos/image-name:latest .</span><br></pre></td></tr></table></figure></p><p><code>image-name</code>, 就是要构建的镜像名称, <code>latest</code>是TAG标签, <code>repos</code>是仓库的空间名称</p><p>在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署<br><a id="more"></a><br>项目的deploy目录中, 放置一些配置文件, 如Dockerfile, docker-compose.yml等, 通过rsync同步到部署服务器上, 用于部署所需<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">image: zacksleo/docker-composer:1.1</span><br><span class="line"></span><br><span class="line">before_script:</span><br><span class="line">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class="line">    - apk add rsync</span><br><span class="line">    - eval $(ssh-agent -s)</span><br><span class="line">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</span><br><span class="line">    - chmod 0600 ~/deploy.key</span><br><span class="line">    - ssh-add ~/deploy.key</span><br><span class="line">    - mkdir -p ~/.ssh</span><br><span class="line">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class="line">    - export APP_ENV=testing</span><br><span class="line"></span><br><span class="line">stages:</span><br><span class="line">    - prepare    </span><br><span class="line">    - build</span><br><span class="line">    - deploy</span><br><span class="line"></span><br><span class="line">variables:</span><br><span class="line">    COMPOSER_CACHE_DIR: &quot;/cache/composer&quot;</span><br><span class="line">    DOCKER_DRIVER: overlay</span><br><span class="line"></span><br><span class="line">installing-dependencies:</span><br><span class="line">    stage: prepare</span><br><span class="line">    script:</span><br><span class="line">        - composer install --prefer-dist -n --no-interaction -v --no-suggest</span><br><span class="line">    artifacts:</span><br><span class="line">        name: &quot;vendor&quot;</span><br><span class="line">        untracked: true</span><br><span class="line">        expire_in: 60 mins</span><br><span class="line">        paths:</span><br><span class="line">            - $CI_PROJECT_DIR/vendor    </span><br><span class="line">test-image:</span><br><span class="line">    stage: build</span><br><span class="line">    image: docker:latest</span><br><span class="line">    services:</span><br><span class="line">        - docker:dind</span><br><span class="line">    dependencies:</span><br><span class="line">        - installing-dependencies</span><br><span class="line">    script:</span><br><span class="line">        - docker login -u username -p password registry.demo.com</span><br><span class="line">        - docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .</span><br><span class="line">        - docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest</span><br><span class="line">testing-server:</span><br><span class="line">    stage: deploy</span><br><span class="line">    image: alpine</span><br><span class="line">    variables:</span><br><span class="line">        DEPLOY_SERVER: &quot;server-host&quot;</span><br><span class="line">    script:</span><br><span class="line">        - cd deploy</span><br><span class="line">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats        </span><br><span class="line">        - ssh root@$DEPLOY_SERVER &quot;docker login -u username -p password registry.demo.com&quot;</span><br><span class="line">        - ssh root@$DEPLOY_SERVER &quot;cd /data/$CI_PROJECT_NAME &amp;&amp; docker-compose stop &amp;&amp; docker-compose rm -f &amp;&amp; docker-compose pull &amp;&amp; docker-compose up -d&quot;</span><br><span class="line">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME chown www-data:www-data web/assets&quot;</span><br><span class="line">        - ssh root@$DEPLOY_SERVER &quot;docker exec -i $CI_PROJECT_NAME ./yii migrate/up --interactive=0&quot;</span><br></pre></td></tr></table></figure></p><h2 id="GitLab-CI使用LFTP进行持续部署"><a href="#GitLab-CI使用LFTP进行持续部署" class="headerlink" title="GitLab-CI使用LFTP进行持续部署"></a>GitLab-CI使用LFTP进行持续部署</h2><p>LFTP是一款FTP客户端软件, 支持 FTP 、 FTPS 、 HTTP 、 HTTPS 、 SFTP 、 FXP 等多种文件传输协议。</p><p>本文介绍如何使用 LFTP 将文件同步到远程FTP服务器上, 从而实现自动部署</p><p>mirror 命令及主要参数</p><p>-R 反向传输, 因为是上传(put)到远程服务器, 所以使用该参数 (默认是从远程服务器下载)<br>-L 下载符号链接作为文件, 主要处理文件软链接的问题<br>-v 详细输出日志<br>-n 只传输新文件 (相同的旧文件不会传输, 大大提升了传输效率)<br>–transfer-all 传输所有文件, 不论新旧<br>–parallel 同时传输的文件数<br>–file 本地文件<br>–target-directory 目标目录</p><p>配置参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    stage: deploy</span><br><span class="line">    dependencies:</span><br><span class="line">        - installing-dependencies</span><br><span class="line">    script:</span><br><span class="line">        - apk add lftp</span><br><span class="line">        # 只上传新文件</span><br><span class="line">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST; cd /wwwroot; mirror -RLnv ./ /wwwroot --ignore-time --parallel=50 --exclude-glob .git* --exclude .git/&quot;</span><br><span class="line">        # 指定目录覆盖上传 (强制更新)</span><br><span class="line">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -RLv ./vendor/composer /wwwroot/vendor/composer --ignore-time --transfer-all --parallel=50 --exclude-glob .git* --exclude .git/&quot;</span><br><span class="line">        # 单独上传autoload文件(强制更新)</span><br><span class="line">        - lftp -c &quot;set ftp:ssl-allow no; open -u $FTP_USERNAME,$FTP_PASSWORD $FTP_HOST;mirror -Rv --file=vendor/autoload.php --target-directory=/wwwroot/vendor/ --transfer-all&quot;</span><br><span class="line">    only:</span><br><span class="line">        - master</span><br></pre></td></tr></table></figure></p><h2 id="GitLab-CI使用Rsync进行持续部署"><a href="#GitLab-CI使用Rsync进行持续部署" class="headerlink" title="GitLab-CI使用Rsync进行持续部署"></a>GitLab-CI使用Rsync进行持续部署</h2><p>rsync命令是一个远程数据同步工具<br>主要参数<br>-r 递归目录<br>-t 保留修改时间<br>-v 详细日志<br>-h 输出数字以人类可读的格式<br>-z 在传输过程中压缩文件数据<br>-e 指定要使用的远程shell, 注意该过程需要注入SSH</p><p>配置参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">before_script:</span><br><span class="line">    - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class="line">    - apk add rsync</span><br><span class="line">    - eval $(ssh-agent -s)</span><br><span class="line">    - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; ~/deploy.key</span><br><span class="line">    - chmod 0600 ~/deploy.key</span><br><span class="line">    - ssh-add ~/deploy.key</span><br><span class="line">    - mkdir -p ~/.ssh</span><br><span class="line">    - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class="line">    - export APP_ENV=testing</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">testing-server:</span><br><span class="line">    stage: deploy</span><br><span class="line">    image: alpine</span><br><span class="line">    variables:</span><br><span class="line">        DEPLOY_SERVER: &quot;server-host&quot;</span><br><span class="line">    script:</span><br><span class="line">        - cd deploy</span><br><span class="line">        - rsync -rtvhze ssh . root@$DEPLOY_SERVER:/data/$CI_PROJECT_NAME --stats</span><br></pre></td></tr></table></figure></p><blockquote><p>注意<br>远程服务器需要安装rsync, 否则会出现 bash: rsync: command not found 错误</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;GitLab-CI使用Docker进行持续部署&quot;&gt;&lt;a href=&quot;#GitLab-CI使用Docker进行持续部署&quot; class=&quot;headerlink&quot; title=&quot;GitLab-CI使用Docker进行持续部署&quot;&gt;&lt;/a&gt;GitLab-CI使用Docker进行持续部署&lt;/h2&gt;&lt;p&gt;Docker镜像通过私有仓库进行发布(如阿里云), 发布命令为:&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker login -u username -p password registry.demo.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker build -t registry.demo.com/repos/$CI_PROJECT_NAME:latest .&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker push registry.demo.com/repos/$CI_PROJECT_NAME:latest&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;其中 &lt;code&gt;username&lt;/code&gt;是用户名, &lt;code&gt;password&lt;/code&gt;是密码, registry.demo.com是私有镜像库地址,&lt;br&gt;&lt;code&gt;$CI_PROJECT_NAME&lt;/code&gt; 是GitLab-CI内置变量, 会自动替换为项目的名称, 这里也可以直接写死, 如&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker build -t registry.demo.com/repos/image-name:latest .&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;image-name&lt;/code&gt;, 就是要构建的镜像名称, &lt;code&gt;latest&lt;/code&gt;是TAG标签, &lt;code&gt;repos&lt;/code&gt;是仓库的空间名称&lt;/p&gt;
&lt;p&gt;在下面的例子中, 首先通过composer安装依赖库, 然后通过artifacts传递给构建任务, 构建完镜像将镜像发布到私有库, 部署时通过拉取最新的镜像库, 进行部署&lt;br&gt;
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="devops" scheme="http://yoursite.com/tags/devops/"/>
    
  </entry>
  
  <entry>
    <title>gitlab-ci由浅入深</title>
    <link href="http://yoursite.com/2018/02/11/gitlab-ci%E7%94%B1%E6%B5%85%E5%85%A5%E6%B7%B1/"/>
    <id>http://yoursite.com/2018/02/11/gitlab-ci由浅入深/</id>
    <published>2018-02-11T14:57:07.000Z</published>
    <updated>2018-05-27T09:59:36.026Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。</p><p>持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.</p><h1 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h1><h2 id="持续集成可以实现的功能"><a href="#持续集成可以实现的功能" class="headerlink" title="持续集成可以实现的功能:"></a>持续集成可以实现的功能:</h2><ul><li>代码审核: 自动化代码规范审查, 甚至代码质量检查</li><li>自动化测试: 单元测试, 功能测试和验收测试</li><li>编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布</li><li>构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2></li></ul><p>GitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.<br>GitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.<br>GitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.<br><a id="more"></a><br>在仓库根目录创建 .gitlab-ci.yml 文件, 内容如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">job-1:</span><br><span class="line">  script:</span><br><span class="line">      - echo &quot;Hello World&quot;</span><br></pre></td></tr></table></figure></p><pre><code>这样, 在每次提交代码后, 都会自动执行以上脚本. 其中job-1是任务名称, 可以定义多个任务,script下面是 shell 命令, 只要命令执行成功, 就代表本次构建通过(出现passed标记)</code></pre><p>  这样, 一次简单的持续集成已经搞定了.</p><p>  如何编写GitLab-CI配置文件</p><p>  见文档 如何编写GitLab-CI配置文件</p><p>  远程拉取代码</p><p>  使用ssh远程登录服务器, 然后执行git pull 拉取代码, 实现代码热更新</p><p>  由于ssh无密码登录需要用到密钥, 所以首先需要注入私钥</p><p>  如<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">release-doc:</span><br><span class="line">    stage: deploy</span><br><span class="line">        script:</span><br><span class="line">          - ssh root@$DEPLOY_SERVER &quot;cd /mnt/data/docker-gollum/wiki &amp;&amp; git pull origin master&quot;</span><br></pre></td></tr></table></figure></p><h2 id="关键词"><a href="#关键词" class="headerlink" title="关键词"></a>关键词</h2><h3 id="根主要关键词一览"><a href="#根主要关键词一览" class="headerlink" title="根主要关键词一览"></a>根主要关键词一览</h3><table><thead><tr><th>关键词</th><th>含义</th><th>可选</th><th>备注</th></tr></thead><tbody><tr><td>image</td><td>声明使用的Docker镜像</td><td>为空时使用默认镜像</td><td>该镜像应当满足脚本执行的环境依赖</td></tr><tr><td>services</td><td>Docker镜像使用的服务, 通过链接的方式来调用所需服务</td><td>可空</td><td>常用于链接数据库</td></tr><tr><td>stages</td><td>定义构建阶段</td><td>为空时, 单纯定义jobs</td><td>项目的构建分为多个阶段, 例如: 安装依赖/准备, 编译, 测试, 发布等, 同时每个阶段包含若干任务</td></tr><tr><td>before_script</td><td>定义每个job之前执行的脚本</td><td>可空</td><td>每个job启动时会先执行该脚本</td></tr><tr><td>after_script</td><td>定义每个job之后执行的脚本</td><td>可空</td><td>同上</td></tr><tr><td>variables</td><td>定义变量</td><td>可空</td><td>同上</td></tr><tr><td>cache</td><td>定义与后续job之间应缓存的文件</td><td>可空</td><td>同上</td></tr></tbody></table><h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo:"></a>Demo:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">image: aipline</span><br><span class="line">services:</span><br><span class="line">  - mysql</span><br><span class="line">  - redis</span><br><span class="line">stages:</span><br><span class="line">  - build</span><br><span class="line">  - test</span><br><span class="line">  - deploy</span><br><span class="line">before_script:</span><br><span class="line">  - bundle install  </span><br><span class="line">after_script:</span><br><span class="line">  - rm secrets</span><br><span class="line">cache:</span><br><span class="line">paths:</span><br><span class="line">  - binaries/</span><br><span class="line">  - .config</span><br></pre></td></tr></table></figure><h2 id="Jobs中的关键词"><a href="#Jobs中的关键词" class="headerlink" title="Jobs中的关键词"></a>Jobs中的关键词</h2><h3 id="jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行"><a href="#jobs中存在一些与根中相同的关键词-这些一旦定义-则会向前覆盖-即根中定义的则不会在该job执行" class="headerlink" title="jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行"></a>jobs中存在一些与根中相同的关键词, 这些一旦定义, 则会向前覆盖, 即根中定义的则不会在该job执行</h3><h4 id="job-这里译为任务"><a href="#job-这里译为任务" class="headerlink" title="job 这里译为任务"></a>job 这里译为任务</h4><table><thead><tr><th>关键词</th><th>含义</th><th>可选</th><th>备注</th></tr></thead><tbody><tr><td>image</td><td>声明任务使用的Docker镜像</td><td>为空时使用根中的定义</td><td>该镜像应当满足脚本执行的环境依赖</td></tr><tr><td>services</td><td>任务中Docker镜像使用的服务, 通过链接的方式来调用所需服务</td><td>可空</td><td>常用于链接数据库</td></tr><tr><td>stage</td><td>所属构建阶段</td><td>为空时则不使用stages</td><td>一个任务属于一个构建阶段</td></tr><tr><td>before_script</td><td>定义每个job之前执行的脚本</td><td>可选</td><td>如果在job中定义则会覆盖根中的内容</td></tr><tr><td>script</td><td>定义每个job执行的脚本</td><td>必须</td></tr><tr><td>after_script</td><td>定义每个job之后执行的脚本</td><td>可选</td><td>同上</td></tr><tr><td>variables</td><td>定义任务中使用的变量</td><td>可选</td><td>同上</td></tr><tr><td>cache</td><td>定义与后续job之间应缓存的文件</td><td>可选</td><td>同上</td></tr><tr><td>only</td><td>指定应用的Git分支</td><td>可选</td><td>可以是分支名称, 可用正则匹配分支, 也可是tags来指定打过标签的分支</td></tr><tr><td>except</td><td>排除应用的Git分支</td><td>可选</td><td>同上</td></tr><tr><td>tags</td><td>指定执行的GitLab-Runners</td><td>可选</td><td>通过匹配Runners的标签选定</td></tr><tr><td>allow_failure</td><td>允许失败</td><td>默认为false 如果允许失败, 本次任务不会影响整个构建的结果</td></tr><tr><td>when</td><td>定义合适执行任务</td><td>默认为always</td><td>有on_success, on_failure, always or manual可选</td></tr><tr><td>dependencies</td><td>定义合任务所需要的工件</td><td>可空</td><td>需要首先定义工件</td></tr><tr><td>artifacts</td><td>定义工件</td><td>可空</td><td>工件中指定的目录会在任务执行成功后压缩传到GitLab, 后面需要该工件的任务执行时, 再自行下载解压</td></tr><tr><td>environment</td><td>定义环境</td><td>可空</td><td>在部署任务中, 定义该任务所属的环境</td></tr></tbody></table><p>示例<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">installing-dependencies:</span><br><span class="line">  script:</span><br><span class="line">    - composer install --prefer-dist --optimize-autoloader -n --no-interaction -v --no-suggest</span><br><span class="line">    - composer dump-autoload --optimize</span><br><span class="line">  artifacts:</span><br><span class="line">    - name: &quot;vendor&quot;</span><br><span class="line">    - untracked: true</span><br><span class="line">    - expire_in: 60 mins</span><br><span class="line">    - paths:</span><br><span class="line">    - vendor/    </span><br><span class="line">deleteocker-build-image:    </span><br><span class="line">  stage: test</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line">  except:</span><br><span class="line">    - develop</span><br><span class="line">  tags:</span><br><span class="line">    - ruby</span><br><span class="line">    - postgres</span><br><span class="line">  allow_failure: true</span><br><span class="line">  dependencies:</span><br><span class="line">    - installing-dependencies</span><br><span class="line">  script:        </span><br><span class="line">    - docker build -t registry.com/mops/image:latest .</span><br><span class="line">    - docker push registry.com/mops/image:latest</span><br></pre></td></tr></table></figure></p><blockquote><p>注意:<br>jobs的名称不能重名<br>同一阶段中的任务, 是并行执行的<br>上一阶段所有任务执行完后, 才会进入下一阶段<br>定义工件时, 务必定义工件的过期时间, 否则工件会一直寸在GitLab上, 占用空间<br>如果需要在任务中传递文件, 优先选择使用 dependencies (结合artifacts)</p></blockquote><h3 id="验证配置文件合法性"><a href="#验证配置文件合法性" class="headerlink" title="验证配置文件合法性"></a>验证配置文件合法性</h3><p>  在GitLab中, 打开 /ci/lint网址, 将配置文件粘贴在些, 进行验证</p><h2 id="通过gitlab-ci实现文件的自动部署"><a href="#通过gitlab-ci实现文件的自动部署" class="headerlink" title="通过gitlab-ci实现文件的自动部署"></a>通过gitlab-ci实现文件的自动部署</h2><h3 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h3><p>  文档托管在gitlab上, 每次代码更新, 会自动出发gitlab-ci构建 在构建脚本中, 通过ssh 登录远程服务器执行git拉取文档的命令</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><h4 id="生成ssh证书"><a href="#生成ssh证书" class="headerlink" title="生成ssh证书"></a>生成ssh证书</h4><p>  在服务器上, 使用ssh-keygen生成root用户(或其他有权访问的用户)的公钥和私钥<br>  在用户根目录(~)中, 创建authorized_keys并设置权限: chmod 600 authorized_keys</p><h4 id="添加公钥"><a href="#添加公钥" class="headerlink" title="添加公钥"></a>添加公钥</h4><p>  添加公钥: cat id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys<br>  id_rsa.pub为第一步生成的公钥<br>  注意该证书的用户必须与ssh远程登录的用户一样, 例如我们的用户名是root<br>  将公钥添加到gitlab上, 以便于该用于可以拉取代码, 在User Settings找到 SSH Keys, 添加上面拿到的公钥</p><h4 id="设置CI-CD变量"><a href="#设置CI-CD变量" class="headerlink" title="设置CI/CD变量"></a>设置CI/CD变量</h4><p>  在 CI/CD Piplines中设置 Secret Variables, 包括 DEPLOY_SERVER 和 SSH_PRIVATE_KEY<br>  其中 SSH_PRIVATE_KEY 的内容是服务器上的私钥, DEPLOY_SERVER 是服务器地址<br>  编写 .gitlab-ci.yml 文件, 注入密钥, 通过ssh执行远程命令<br>  完整代码<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"># 使用alpine镜像, 该镜像很少,只有几兆</span><br><span class="line">image: alpine</span><br><span class="line">stages:</span><br><span class="line">  - deploy</span><br><span class="line">before_script:</span><br><span class="line">  # 预先装 ssh-agent</span><br><span class="line">  - &apos;which ssh-agent || ( apk update &amp;&amp; apk add openssh-client)&apos;</span><br><span class="line">  # 启动服务</span><br><span class="line">  - eval $(ssh-agent -s)</span><br><span class="line">  # 将私钥写入deploy.key 文件</span><br><span class="line">  - echo &quot;$SSH_PRIVATE_KEY&quot; &gt; deploy.key</span><br><span class="line">  # 配置较低权限</span><br><span class="line">  - chmod 0600 deploy.key</span><br><span class="line">  # 注入密钥</span><br><span class="line">  - ssh-add deploy.key</span><br><span class="line">  - mkdir -p ~/.ssh    </span><br><span class="line">  - &apos;[[ -f /.dockerenv ]] &amp;&amp; echo -e &quot;Host *\n\tStrictHostKeyChecking no\n\n&quot; &gt; ~/.ssh/config&apos;</span><br><span class="line"></span><br><span class="line">release-doc:</span><br><span class="line">  stage: deploy</span><br><span class="line">  variables:</span><br><span class="line">    GIT_STRATEGY: none     </span><br><span class="line">  script:</span><br><span class="line">    # 连接远程服务器并执行拉取代码的命令</span><br><span class="line">    - ssh root@$DEPLOY_SERVER &quot;cd /path/to/wiki &amp;&amp; git pull origin master&quot;</span><br><span class="line">  only:</span><br><span class="line">    - master</span><br><span class="line">  environment:</span><br><span class="line">    name: production</span><br><span class="line">    url: http://$DEPLOY_SERVER</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;持续集成（CI）和 持续交付(CD) 是一种流行的软件开发实践，每次提交都通过自动化的构建（测试、编译、发布）来验证，从而尽早的发现错误。&lt;/p&gt;
&lt;p&gt;持续集成实现了DevOps, 使开发人员和运维人员从繁琐的工作中解放出来。另外，这种形式极大地提高了开发者的开发效率和开发质量。 持续集成有多种工具，如Jenkins. GitLab内置了GitLab-CI，通过配置一段YAML脚本来实现持续集成.&lt;/p&gt;
&lt;h1 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功能&quot; class=&quot;headerlink&quot; title=&quot;功能&quot;&gt;&lt;/a&gt;功能&lt;/h1&gt;&lt;h2 id=&quot;持续集成可以实现的功能&quot;&gt;&lt;a href=&quot;#持续集成可以实现的功能&quot; class=&quot;headerlink&quot; title=&quot;持续集成可以实现的功能:&quot;&gt;&lt;/a&gt;持续集成可以实现的功能:&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;代码审核: 自动化代码规范审查, 甚至代码质量检查&lt;/li&gt;
&lt;li&gt;自动化测试: 单元测试, 功能测试和验收测试&lt;/li&gt;
&lt;li&gt;编译发布: 将源代码编译成可执行程序, 并将程序上传到托管发布平台实现自动发布&lt;/li&gt;
&lt;li&gt;构建部署: 通过构建Docker镜像, 或登录远程服务器执行相关部署命令和脚本, 实现自动化部署&lt;h2 id=&quot;原理&quot;&gt;&lt;a href=&quot;#原理&quot; class=&quot;headerlink&quot; title=&quot;原理&quot;&gt;&lt;/a&gt;原理&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;GitLab-CI 检测每次代码变动, 通过.gitlab-ci.yml脚本执行构建命令, 将命令发布到GitLab-Runners(运行机)上, 进而执行命令.&lt;br&gt;GitLab-Runners 基于Docker执行持续集成的每项任务, 这样就解决了环境依赖问题.&lt;br&gt;GitLab-Runners把实时将执行结果输出到GitLab网页上, 任务执行完后, 通过徽章标记和邮箱告知执行结果.&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>git使用规范</title>
    <link href="http://yoursite.com/2018/02/11/git%E4%BD%BF%E7%94%A8%E8%A7%84%E8%8C%83/"/>
    <id>http://yoursite.com/2018/02/11/git使用规范/</id>
    <published>2018-02-11T14:30:54.000Z</published>
    <updated>2018-05-27T09:59:36.029Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Git工作流程"><a href="#Git工作流程" class="headerlink" title="Git工作流程"></a>Git工作流程</h1><h2 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h2><ul><li>master: 用于生产环境部署, 只接受合并请求, 不直接提交</li><li>testing: 用于测试环境测试</li><li>develop: 用于日常开发主线, 其他分支只能合并到 develop 分支</li><li>feature-xxx: 用于增加一个新功能</li><li><p>hotfix-xxx: 用于修复一个紧急bug<br>每次开发新功能，都应该新建一个单独的分支</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2></li><li><p>如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码</p></li><li>Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发</li><li>开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息</li><li>开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库<h2 id="Commit-message-和-Change-log-编写指南"><a href="#Commit-message-和-Change-log-编写指南" class="headerlink" title="Commit message 和 Change log 编写指南"></a>Commit message 和 Change log 编写指南</h2></li></ul><p>Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从<a href="http://blog.cheenwe.cn/2016-04-18/git-commit-message/" target="_blank" rel="noopener"> Angular 规范</a></p><h3 id="安装-Commitizen-来格式化-commit-使其遵循以上规范"><a href="#安装-Commitizen-来格式化-commit-使其遵循以上规范" class="headerlink" title="安装 Commitizen 来格式化 commit , 使其遵循以上规范"></a>安装 Commitizen 来格式化 commit , 使其遵循以上规范</h3><p>首先注意将package.json和node_modules加入.gitignore文件<br>全局安装commitizen: <code>npm install -g commitizen</code><br>在项目根目录初始化package.json: <code>npm init --yes</code><br>项目根目录运行 <code>commitizen init cz-conventional-changelog --save --save-exact</code><br>每次提交代码时, 用 <code>git cz</code> 代替<code>git commit</code><br><a id="more"></a></p><h2 id="自动生成-Change-log"><a href="#自动生成-Change-log" class="headerlink" title="自动生成 Change log"></a>自动生成 Change log</h2><p>安装 <code>npm install -g conventional-changelog-cli</code><br>使用<code>conventional-changelog</code>生成日志: <code>conventional-changelog -p angular -i CHANGELOG.md -s -r 0</code></p><h2 id="版本号使用规范"><a href="#版本号使用规范" class="headerlink" title="版本号使用规范"></a>版本号使用规范</h2><p>版本号遵循语义化版本规范.</p><p>版本格式：主版本号.次版本号.修订号，版本号递增规则如下：</p><p>主版本号：当你做了不兼容的 API 修改，<br>次版本号：当你做了向下兼容的功能性新增，<br>修订号：当你做了向下兼容的问题修正。<br>先行版本号及版本编译信息可以加到“主版本号.次版本号.修订号”的后面，作为延伸。</p><p>更多内容参见 <a href="http://semver.org/lang/zh-CN/" target="_blank" rel="noopener">语义化版本</a></p><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://www.ruanyifeng.com/blog/2015/08/git-use-process.html" target="_blank" rel="noopener">Git 使用规范流程</a><br><a href="http://www.ruanyifeng.com/blog/2016/01/commit_message_change_log.html" target="_blank" rel="noopener">Commit message 和 Change log 编写指南</a><br><a href="http://blog.cheenwe.cn/2016-04-18/git-commit-message/" target="_blank" rel="noopener">Git commit message 规范</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Git工作流程&quot;&gt;&lt;a href=&quot;#Git工作流程&quot; class=&quot;headerlink&quot; title=&quot;Git工作流程&quot;&gt;&lt;/a&gt;Git工作流程&lt;/h1&gt;&lt;h2 id=&quot;分支&quot;&gt;&lt;a href=&quot;#分支&quot; class=&quot;headerlink&quot; title=&quot;分支&quot;&gt;&lt;/a&gt;分支&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;master: 用于生产环境部署, 只接受合并请求, 不直接提交&lt;/li&gt;
&lt;li&gt;testing: 用于测试环境测试&lt;/li&gt;
&lt;li&gt;develop: 用于日常开发主线, 其他分支只能合并到 develop 分支&lt;/li&gt;
&lt;li&gt;feature-xxx: 用于增加一个新功能&lt;/li&gt;
&lt;li&gt;&lt;p&gt;hotfix-xxx: 用于修复一个紧急bug&lt;br&gt;每次开发新功能，都应该新建一个单独的分支&lt;/p&gt;
&lt;h2 id=&quot;工作流&quot;&gt;&lt;a href=&quot;#工作流&quot; class=&quot;headerlink&quot; title=&quot;工作流&quot;&gt;&lt;/a&gt;工作流&lt;/h2&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果要贡献代码, 首先应阅读贡献指南, 确认如果贡献代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;Fork对应的项目, 然后基于develop分支, 新建一个分支, 在这个分支上进行开发&lt;/li&gt;
&lt;li&gt;开发时应遵守相应的编码规范和Git日志规范, 提交日志应当给出完整扼要的提交信息&lt;/li&gt;
&lt;li&gt;开发完毕后, 先在本项目库上合并到develop分支, 合并完成之后再PR到原项目库&lt;h2 id=&quot;Commit-message-和-Change-log-编写指南&quot;&gt;&lt;a href=&quot;#Commit-message-和-Change-log-编写指南&quot; class=&quot;headerlink&quot; title=&quot;Commit message 和 Change log 编写指南&quot;&gt;&lt;/a&gt;Commit message 和 Change log 编写指南&lt;/h2&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Git 每次提交代码，都要写 Commit message（提交说明），否则就不允许提交 +Commit message 遵从&lt;a href=&quot;http://blog.cheenwe.cn/2016-04-18/git-commit-message/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt; Angular 规范&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;安装-Commitizen-来格式化-commit-使其遵循以上规范&quot;&gt;&lt;a href=&quot;#安装-Commitizen-来格式化-commit-使其遵循以上规范&quot; class=&quot;headerlink&quot; title=&quot;安装 Commitizen 来格式化 commit , 使其遵循以上规范&quot;&gt;&lt;/a&gt;安装 Commitizen 来格式化 commit , 使其遵循以上规范&lt;/h3&gt;&lt;p&gt;首先注意将package.json和node_modules加入.gitignore文件&lt;br&gt;全局安装commitizen: &lt;code&gt;npm install -g commitizen&lt;/code&gt;&lt;br&gt;在项目根目录初始化package.json: &lt;code&gt;npm init --yes&lt;/code&gt;&lt;br&gt;项目根目录运行 &lt;code&gt;commitizen init cz-conventional-changelog --save --save-exact&lt;/code&gt;&lt;br&gt;每次提交代码时, 用 &lt;code&gt;git cz&lt;/code&gt; 代替&lt;code&gt;git commit&lt;/code&gt;&lt;br&gt;
    
    </summary>
    
    
      <category term="技术 php" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF-php/"/>
    
  </entry>
  
  <entry>
    <title>集中式日志管理elk搭建</title>
    <link href="http://yoursite.com/2018/02/10/%E9%9B%86%E4%B8%AD%E5%BC%8F%E6%97%A5%E5%BF%97%E7%AE%A1%E7%90%86elk%E6%90%AD%E5%BB%BA/"/>
    <id>http://yoursite.com/2018/02/10/集中式日志管理elk搭建/</id>
    <published>2018-02-10T05:56:26.000Z</published>
    <updated>2018-05-27T09:59:36.034Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。</p><blockquote><p>elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本</p><ul><li>Elasticsearch 高可用性，实时索引，拓展简单，接口友好</li><li>Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表</li><li>Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据</li><li>Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据</li><li>X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索</li></ul></blockquote><h2 id="elk的初始化"><a href="#elk的初始化" class="headerlink" title="elk的初始化"></a>elk的初始化</h2><p>其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的<a href="https://github.com/deviantony/docker-elk" target="_blank" rel="noopener">docker-elk</a><br>使用git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:deviantony/docker-elk.git后执行docker-compose up,然后我们访问<a href="http://localhost:5601,以下是它的端口" target="_blank" rel="noopener">http://localhost:5601,以下是它的端口</a></p><ul><li>5000: Logstash TCP input.</li><li>9200: Elasticsearch HTTP</li><li>9300: Elasticsearch TCP transport</li><li>5601: Kibana<a id="more"></a><h2 id="elk-配置"><a href="#elk-配置" class="headerlink" title="elk 配置"></a>elk 配置</h2>我们先配置’elk/logstash/pipeline/logstash.conf’<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">input &#123;</span><br><span class="line">        beats &#123; #通过这个端口接收filebeat组件发送过来的日志</span><br><span class="line">                port =&gt; 5043</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">## Add your filters / logstash plugins configuration here</span><br><span class="line">filter &#123;</span><br><span class="line">        grok &#123; # 正则形式将无序的日志整理成有序的结构形式</span><br><span class="line">                match =&gt; &#123; &quot;message&quot; =&gt; &quot;%&#123;GREEDYDATA:health_Timestamp&#125;\[%&#123;IPV4:health_IPaddress&#125;\]\[-\]\[-\]\[%&#123;LOGLEVEL:health_LogLevel&#125;\]\[%&#123;NOTSPACE:health_Category&#125;\]%&#123;GREEDYDATA:health_Text&#125;&quot; &#125; </span><br><span class="line">        &#125;    </span><br><span class="line">        geoip &#123; #通过这个可以将ip和地理位置相关联</span><br><span class="line">                source =&gt; &quot;clientip&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">output &#123; #将日志信息交给elasticsearch处理</span><br><span class="line">        elasticsearch &#123;</span><br><span class="line">                hosts =&gt; &quot;elasticsearch:9200&quot;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="filebeat配置"><a href="#filebeat配置" class="headerlink" title="filebeat配置"></a>filebeat配置</h2><p>然后我们到我们要挖掘日志的应用中添加filebeat组件，将日志的搬运方向直销刚刚留出来的elk的ip:5043端口</p><ul><li><p>现在docker-compose.yml添加filebeat组件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">filebeat:</span><br><span class="line">        image: docker.elastic.co/beats/filebeat:6.0.0</span><br><span class="line">        hostname: filebeat</span><br><span class="line">        container_name: filebeat</span><br><span class="line">        restart: always</span><br><span class="line">        volumes:</span><br><span class="line">        - ./services/filebeat/config/filebeat.yml:/usr/share/filebeat/filebeat.yml</span><br><span class="line">        - ./services/filebeat/config/filebeat.template.json:/usr/share/filebeat/filebeat.template.json</span><br><span class="line">        - ./api/runtime/logs:/var/logs</span><br><span class="line">        - ./api/runtime/debug:/var/debug</span><br><span class="line">        depends_on:</span><br><span class="line">        - web</span><br></pre></td></tr></table></figure></li><li><p>接着我们配置刚刚docker-compose配置的./services/filebeat/config/filebeat.yml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">filebeat.prospectors:</span><br><span class="line">- type: log</span><br><span class="line">  paths:</span><br><span class="line">      - &quot;/var/logs/*.log&quot;</span><br><span class="line">     #- &quot;/var/debug/*.data&quot;</span><br><span class="line">registry_file: /etc/registry/mark</span><br><span class="line">#============================= 将以时间的日志归并为一行 ===============================</span><br><span class="line">  multiline.pattern: &apos;^[0-9]&#123;4&#125;-[0-9]&#123;2&#125;-[0-9]&#123;2&#125;&apos;</span><br><span class="line">  multiline.negate: true</span><br><span class="line">  multiline.match: after</span><br><span class="line">  multiline.timeout: 10s</span><br><span class="line">enable: true</span><br><span class="line">#============================= Filebeat modules ===============================</span><br><span class="line">#</span><br><span class="line">filebeat.config.modules:</span><br><span class="line"># Glob pattern for configuration loading</span><br><span class="line">  path: /usr/share/filebeat/modules.d/*.yml</span><br><span class="line">#</span><br><span class="line"># Set to true to enable config reloading</span><br><span class="line">reload.enabled: true</span><br><span class="line"></span><br><span class="line">output:</span><br><span class="line">logstash:</span><br><span class="line">hosts: [&quot;刚刚配置的elk的ip地址:5043&quot;]</span><br><span class="line"></span><br><span class="line">logging:</span><br><span class="line">files:</span><br><span class="line">rotateeverybytes: 10485760 # = 10MB</span><br></pre></td></tr></table></figure><p>参考文章:</p></li></ul><hr><p><a href="https://www.elastic.co/cn/products" target="_blank" rel="noopener">官网</a><br><a href="http://blog.csdn.net/sysushui/article/details/78461498" target="_blank" rel="noopener">使用Docker搭建ELK日志系统</a><br><a href="https://www.jianshu.com/p/a980cd121212" target="_blank" rel="noopener">ELK—合并多行日志（php.log）</a><br><a href="https://jicki.me/2016/10/11/docker-elk-filebeat/" target="_blank" rel="noopener">docker容器日志集中ELK</a><br><a href="https://my.oschina.net/openplus/blog/1584861" target="_blank" rel="noopener">filebeat+logstash配置搭建</a><br><a href="https://www.cnblogs.com/stozen/p/5638369.html" target="_blank" rel="noopener">关于Logstash中grok插件的正则表达式例子</a><br><a href="http://blog.51cto.com/john88wang/1641723" target="_blank" rel="noopener">使用Logstash收集PHP相关日志-Linux SA John-51CTO博客</a><br><a href="https://birdben.github.io/2016/11/21/Logstash/Logstash%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%BA%8C%EF%BC%89Logstash%E6%95%B4%E5%90%88Kafka/" target="_blank" rel="noopener">Logstash整合Kafka</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间，我们组内决定将各个应用的日志都集中管理起来，所以需要一款集中式的日志管理系统，查找了市面上的系统发现elk不错，所以我就研究搭建了elk，下面是我在搭建过程中的一些心得。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;elk:这其实是一套组件的缩写，其中比较核心的是三个组件ELK(Elasticsearch, Logstash, Kibana), 经过这么多年的发展已经是6.0.0版本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Elasticsearch 高可用性，实时索引，拓展简单，接口友好&lt;/li&gt;
&lt;li&gt;Kibana 提供分析和可视化的 Web 平台，用来查询分析以及生成各种报表&lt;/li&gt;
&lt;li&gt;Logstash 是一个具有实时的数据收集引擎，几乎可以收集所有的数据&lt;/li&gt;
&lt;li&gt;Beats 轻量型采集器的平台，从边缘机器向 Logstash 和 Elasticsearch 发送数据&lt;/li&gt;
&lt;li&gt;X-Pack 是集成了多种便捷功能的单个插件 — security、alerting、monitoring、reporting、graph 探索&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;elk的初始化&quot;&gt;&lt;a href=&quot;#elk的初始化&quot; class=&quot;headerlink&quot; title=&quot;elk的初始化&quot;&gt;&lt;/a&gt;elk的初始化&lt;/h2&gt;&lt;p&gt;其实elk既可以在linux的环境安装也可以使用docker形式，我在github上找到一个已经配置好的docker环境的&lt;a href=&quot;https://github.com/deviantony/docker-elk&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker-elk&lt;/a&gt;&lt;br&gt;使用git clone &lt;a href=&quot;mailto:git@github.com&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;git@github.com&lt;/a&gt;:deviantony/docker-elk.git后执行docker-compose up,然后我们访问&lt;a href=&quot;http://localhost:5601,以下是它的端口&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://localhost:5601,以下是它的端口&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;5000: Logstash TCP input.&lt;/li&gt;
&lt;li&gt;9200: Elasticsearch HTTP&lt;/li&gt;
&lt;li&gt;9300: Elasticsearch TCP transport&lt;/li&gt;
&lt;li&gt;5601: Kibana
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux基础" scheme="http://yoursite.com/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
