<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Graychen的博客</title>
  <subtitle>这个世界需要更多的英雄</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://graychen.git.io/"/>
  <updated>2017-06-21T06:06:11.260Z</updated>
  <id>http://graychen.git.io/</id>
  
  <author>
    <name>Graychen</name>
    <email>13780185250@sina.cn</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>解析php的内存管理</title>
    <link href="http://graychen.git.io/2017/06/21/%E8%A7%A3%E6%9E%90php%E7%9A%84%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://graychen.git.io/2017/06/21/解析php的内存管理/</id>
    <published>2017-06-21T05:59:12.000Z</published>
    <updated>2017-06-21T06:06:11.260Z</updated>
    
    <content type="html"><![CDATA[<h2 id="php的内存管理"><a href="#php的内存管理" class="headerlink" title="php的内存管理"></a>php的内存管理</h2><p>在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdup、realloc、calloc等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。</p>
<blockquote>
<p>内存泄露<br>每个平台操作内存的方式都是差不多的有两个方面，一负责申请，二负责释放。如果应用程序向系统申请内存，系统便会在内存中寻找还没有被使用的地方，如果有合适的，便分配给这个程序，并标记下来，不再给其它的程序了。如果一个内存块没有释放，而所有者应用程序也永远不再使用它了。<br>对于一些需要长时间运行的程序，比如像Apache这样的web服务器以及它的php模块来说，都是伴随着操作系统长时间运行的，所以OS在很长一段时间内不能主动的回收内存，从而导致这个程序的每一个内存泄漏都会促进量变到质变的进化，最终引起严重的内存泄漏错误，使系统的资源消耗殆尽。</p>
</blockquote>
<h2 id="Zend内存管理器"><a href="#Zend内存管理器" class="headerlink" title="Zend内存管理器"></a>Zend内存管理器</h2><p>使用Zend内存管理(Zend Memory Manager,简称ZendMM、ZMM)层。内核的这一部分非常类似于操作系统的内存管理功能——分配内存给调用程序。区别在于，它处于进程空间中非常低的位置而且是”请求感知”的；这样一来，当一个请求结束时，它能够执行与OS在一个进程终止时相同的行为。也就是说，它会隐式地释放所有的为该请求所占用的内存。图1展示了ZendMM与OS以及PHP进程之间的关系。<br><img src="/assets/blogImg/zend_manage.jpg" alt="&quot;我是傲娇的效果图&quot;"><br> 除了提供隐式的内存清除功能之外，ZendMM还能够根据php.ini中memory_limit设置来控制每一次内存请求行为，如果一个脚本试图请求比系统中可用内存更多的内存，或大于它每次应该请求的最大量，那么，ZendMM将自动地发出一个E_ERROR消息并且启动相应的终止进程。这种方法的一个额外优点在于，大多数内存分配调用的返回值并不需要检查，因为如果失败的话将会导致立即跳转到引擎的退出部分。<br> 所有内部分配的内存都要使用一组特定的可选函数实现。例如，PHP内核代码不是使用malloc(16)来分配一个16字节内存块而是使用了emalloc(16)。除了实现实际的内存分配任务外，ZendMM还会使用相应的绑定请求类型来标志该内存块；这样以来，当一个请求”跳出”时，ZendMM可以隐式地释放它。 有些时候，某次申请的内存需要在一个请求结束后仍然存活一段时间，也就是持续性存在于各个请求之间。这种类型的分配（因其在一次请求结束之后仍然存在而被称为”永久性分配”），可以使用传统型内存分配器来实现，因为这些分配并不会添加ZendMM使用的那些额外的相应于每种请求的信息。然而有时，我们必须在程序运行时根据某个数据的具体值或者状态才能确定是否需要进行永久性分配，因此ZendMM定义了一组帮助宏，其行为类似于其它的内存分配函数，但是使用最后一个额外参数来指示是否为永久性分配。 如果你确实想实现一个永久性分配，那么这个参数应该被设置为1；在这种情况下，请求是通过传统型malloc()分配器家族进行传递的。然而，如果运行时刻逻辑认为这个块不需要永久性分配；那么，这个参数可以被设置为零，并且调用将会被调整到针对每种请求的内存分配器函数。 例如，pemalloc(buffer_len，1)将映射到malloc(buffer_len)，而pemalloc(buffer_len，0)将被使用下列语句映射到emalloc(buffer_len)：<br> 所有这些在ZendMM中提供的内存管理函数都能够从下表中找到其在C语言中的函数。</p>
<table>
<thead>
<tr>
<th style="text-align:left">C语言原生函数</th>
<th style="text-align:center">PHP内核封装后的函数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">void *malloc(size_t count);</td>
<td style="text-align:center">void <em>emalloc(size_t count); void </em>pemalloc(size_t count, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void *calloc(size_t count);</td>
<td style="text-align:center">void <em>ecalloc(size_t count); void </em>pecalloc(size_t count, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void <em>realloc(void </em>ptr, size_t count);</td>
<td style="text-align:center">void <em>erealloc(void </em>ptr, size_t count); void <em>perealloc(void </em>ptr, size_t count, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void <em>strdup(void </em>ptr);</td>
<td style="text-align:center">void <em>estrdup(void </em>ptr); void <em>pestrdup(void </em>ptr, char persistent);</td>
</tr>
<tr>
<td style="text-align:left">void free(void *ptr);</td>
<td style="text-align:center">void efree(void <em>ptr); void pefree(void </em>ptr, char persistent);</td>
</tr>
</tbody>
</table>
<p>你可能会注意到，即使是pefree()函数也要求使用永久性标志。这是因为在调用pefree()时，它实际上并不知道是否ptr是一种永久性分配。需要注意的是，如果针对一个ZendMM申请的非永久性内存直接调用free()能够导致双倍的空间释放，而针对一种永久性分配调用efree()有可能会导致一个段错误，因为ZendMM需要去查找并不存在的管理信息。因此，你的代码需要记住它申请的内存是否是永久性的，从而选择不同的内存函数，free()或者efree()。 除了上述内存管理函数外，还存在其它一些非常方便的ZendMM函数，例如： <figure class="highlight plain"><figcaption><span>void *estrndup(void *ptr，int len);</span></figcaption><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">该函数能够分配len+1个字节的内存并且从ptr处复制len个字节到最新分配的块。这个estrndup()函数的行为可以大致描述如下：</div><div class="line"></div><div class="line">```c</div><div class="line">ZEND_API char *_estrndup(const char *s, uint length ZEND_FILE_LINE_DC ZEND_FILE_LINE_ORIG_DC)</div><div class="line">&#123;</div><div class="line">        char *p;</div><div class="line"></div><div class="line">        p = (char *) _emalloc(length+1 ZEND_FILE_LINE_RELAY_CC ZEND_FILE_LINE_ORIG_RELAY_CC);</div><div class="line">            if (UNEXPECTED(p == NULL))</div><div class="line">            &#123;</div><div class="line">                        return p;</div><div class="line">                            </div><div class="line">            &#125;</div><div class="line">        memcpy(p, s, length);</div><div class="line">        p[length] = 0;</div><div class="line">        return p;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在此，被隐式放置在缓冲区最后的0可以确保任何使用estrndup()实现字符串复制操作的函数都不需要担心会把结果缓冲区传递给一个例如printf()这样的希望以为NULL为结束符的函数。当使用estrndup()来复制非字符串数据时，最后一个字节实质上浪费了，但其中的利明显大于弊。<br>void <em>safe_emalloc(size_t size, size_t count, size_t addtl);<br>void </em>safe_pemalloc(size_t size, size_t count, size_t addtl, char persistent);<br>这些函数分配的内存空间最终大小都是((size*count)+addtl)。 你可以会问：”为什么还要提供额外函数呢？为什么不使用一个emalloc/pemalloc呢？”。 原因很简单：为了安全，以防万一。尽管有时候可能性相当小，但是，正是这一”可能性相当小”的结果导致宿主平台的内存溢出。 这可能会导致分配负数个数的字节空间，或更有甚者，会导致分配一个小于调用程序要求大小的字节空间。 而safe_emalloc()能够避免这种类型的陷井-通过检查整数溢出并且在发生这样的溢出时显式地预以结束。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;php的内存管理&quot;&gt;&lt;a href=&quot;#php的内存管理&quot; class=&quot;headerlink&quot; title=&quot;php的内存管理&quot;&gt;&lt;/a&gt;php的内存管理&lt;/h2&gt;&lt;p&gt;在PHP内核中，大多数情况下都不应该直接使用C语言中自带着malloc、free、strdu
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php php扩展 c" scheme="http://graychen.git.io/tags/php-php%E6%89%A9%E5%B1%95-c/"/>
    
  </entry>
  
  <entry>
    <title>探索php中的变量zval结构体二</title>
    <link href="http://graychen.git.io/2017/06/20/%E6%8E%A2%E7%B4%A2php%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8Fzval%E7%BB%93%E6%9E%84%E4%BD%93%E4%BA%8C/"/>
    <id>http://graychen.git.io/2017/06/20/探索php中的变量zval结构体二/</id>
    <published>2017-06-20T09:04:13.000Z</published>
    <updated>2017-06-21T06:56:58.164Z</updated>
    
    <content type="html"><![CDATA[<p>上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:<br>       <code>zend_uint refcount__gc</code><br>       <code>zend_uchar is_ref__gc</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">struct</span> <span class="number">_</span>zval_struct &#123;</div><div class="line">        zvalue_value value; <span class="comment">/* 变量的值 */</span></div><div class="line">        zend_uchar type;    <span class="comment">/* 变量当前的数据类型 */</span></div><div class="line">        zend_uint refcount__gc; <span class="comment">/*  */</span></div><div class="line">        zend_uchar is_ref__gc;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="number">_</span>zval_struct zval;</div></pre></td></tr></table></figure></p>
<p>php中的引用计数<br>先看例子</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">$a = <span class="string">'Hello World'</span>;</div><div class="line">$b = $a;</div><div class="line"><span class="keyword">unset</span>($a);</div></pre></td></tr></table></figure>
<p>PHP变量的名称和值在php内核中是保存在两个不同的地方的，值是通过一个与名字毫无关系的zval结构来保存，而这个变量的名字a则保存在符号表里，两者之间通过指针联系着。在我们上面的例子里，$a是一个字符串，我们通过zend_hash_add把它添加到符号表里，然后又把它赋值给$b,两者拥有相同的内容！如果两者指向完全相同的内容，我们有什么优化措施吗？<br>这里我们主要讲解refcount<strong>gc这个成员。当一个变量被第一次创建的时候，它对应的zval结构体的refcount</strong>gc成员的值会被初始化为1，理由很简单，因为只有这个变量自己在用它。但是当你把这个变量赋值给别的变量时，refcount__gc属性便会加1变成2，因为现在有两个变量在用这个zval结构了！ 以上描述转为内核中的代码大体如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">zval *helloval;</div><div class="line">MAKE_STD_ZVAL(helloval);</div><div class="line">ZVAL_STRING(helloval, <span class="string">"Hello World"</span>, <span class="number">1</span>);</div><div class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"a"</span>, <span class="keyword">sizeof</span>(<span class="string">"a"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</div><div class="line">ZVAL_ADDREF(helloval); <span class="comment">//这句很特殊，我们显式的增加了helloval结构体的refcount</span></div><div class="line">zend_hash_add(EG(active_symbol_table), <span class="string">"b"</span>, <span class="keyword">sizeof</span>(<span class="string">"b"</span>),&amp;helloval, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>)</div></pre></td></tr></table></figure>
<p>这个时候当我们再用unset删除$a的时候，它删除符号表里的$a的信息，然后清理它的值部分，这时它发现$a的值对应的zval结构的refcount值是2，也就是有另外一个变量在一起用着这个zval，所以unset只需把这个zval的refcount减去1就行了！<br>引用计数绝对是节省内存的一个超棒的模式！但是当我们修改$b的值，而且还需要继续使用$a时，该怎么办呢？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = $a;</div><div class="line">$b += <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>从代码逻辑来看，我们希望语句执行后$a仍然是1，而$b则需要变成6。我们知道在第二句完成后内核通过让$a和$b共享一个zval结构来达到节省内存的目的，但是现在第三句来了，这时$b的改变应该怎样在内核中实现呢？ 答案非常简单，内核首先查看refcount__gc属性，如果它大于1则为这个变化的变量从原zval结构中复制出一份新的专属与$b的zval来，并改变其值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div></pre></td><td class="code"><pre><div class="line"><span class="function">zval *<span class="title">get_var_and_separate</span><span class="params">(<span class="keyword">char</span> *varname, <span class="keyword">int</span> varname_len TSRMLS_DC)</span></span></div><div class="line">&#123;</div><div class="line">        zval **varval, *varcopy;</div><div class="line">        <span class="keyword">if</span> (zend_hash_find(EG(active_symbol_table),varname, varname_len + <span class="number">1</span>, (<span class="keyword">void</span>**)&amp;varval) == FAILURE)</div><div class="line">        &#123;</div><div class="line">            <span class="comment">/* 如果在符号表里找不到这个变量则直接return */</span></div><div class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> ((*varval)-&gt;refcount &lt; <span class="number">2</span>)</div><div class="line">        &#123;   </div><div class="line">        <span class="comment">//如果这个变量的zval部分的refcount小于2，代表没有别的变量在用，return</span></div><div class="line">        <span class="keyword">return</span> *varval;</div><div class="line">        &#125;</div><div class="line">            </div><div class="line">        <span class="comment">/* 否则，复制一份zval*的值 */</span></div><div class="line">        MAKE_STD_ZVAL(varcopy);</div><div class="line">        varcopy = *varval;</div><div class="line">            </div><div class="line">        <span class="comment">/* 复制任何在zval*内已分配的结构*/</span></div><div class="line">        zval_copy_ctor(varcopy);</div><div class="line"></div><div class="line">        <span class="comment">/* 从符号表中删除原来的变量</span></div><div class="line">         * 这将减少该过程中varval的refcount的值</div><div class="line">         */</div><div class="line">        zend_hash_del(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>);</div><div class="line"></div><div class="line">        <span class="comment">/* 初始化新的zval的refcount，并在符号表中重新添加此变量信息，并将其值与我们的新zval相关联。*/</span></div><div class="line">        varcopy-&gt;refcount = <span class="number">1</span>;</div><div class="line">        varcopy-&gt;is_ref = <span class="number">0</span>;</div><div class="line">        zend_hash_add(EG(active_symbol_table), varname, varname_len + <span class="number">1</span>,&amp;varcopy, <span class="keyword">sizeof</span>(zval*), <span class="literal">NULL</span>);</div><div class="line">            </div><div class="line">        <span class="comment">/* 返回新zval的地址 */</span></div><div class="line">        <span class="keyword">return</span> varcopy;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>现在$b变量拥有了自己的zval，并且可以自由的修改它的值了。<br>Change on Write</p>
<p>如果用户在PHP脚本中显式的让一个变量引用另一个变量时，我们的内核是如何处理的呢？</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = &amp;$a;</div><div class="line">$b += <span class="number">5</span>;</div></pre></td></tr></table></figure>
<p>作为一个标准的PHP程序猿，我们都知道$a的值也变成6了。当我们更改$b的值时，内核发现$b是$a的一个用户端引用，也就是所它可以直接改变$b对应的zval的值，而无需再为它生成一个新的不同与$a的zval。因为他知道$a和$b都想得到这次变化！ 但是内核是怎么知道这一切的呢？简单的讲，它是通过zval的is_ref<strong>gc成员来获取这些信息的。这个成员只有两个值，就像开关的开与关一样。它的这两个状态代表着它是否是一个用户在PHP语言中定义的引用。在第一条语句($a = 1;)执行完毕后,$a对应的zval的refcount</strong>gc等于1，is_ref<strong>gc等于0;。 当第二条语句执行后($b = &amp;$a;)，refcount</strong>gc属性向往常一样增长为2，而且is_ref__gc属性也同时变为了1！ 最后，在执行第三条语句的时候，内核再次检查$b的zval以确定是否需要复制出一份新的zval结构来，这次不需要复制，因为我们刚才上面的get_var_and_separate函数其实是个简化版，并且少写了一个条件：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/* 如果这个zval在php语言中是通过引用的形式存在的，或者它的refcount小于2，则不需要复制。*/</span></div><div class="line"><span class="keyword">if</span> ((*varval)-&gt;is_ref || (*varval)-&gt;refcount &lt; <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> *varval;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这一次，尽管它的refcount等于2，但是因为它的is_ref等于1，所以也不会被复制。内核会直接的修改这个zval的值。<br>Separation Anxiety</p>
<p>我们已经了解了php语言中变量的复制和引用的一些事，但是如果复制和引用这两个事件被组合起来使用了该怎么办呢？看下面这段代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = $a;</div><div class="line">$c = &amp;$a;</div></pre></td></tr></table></figure>
<p> <img src="/assets/blogImg/is_ref1.jpg" alt="&quot;我是傲娇的效果图&quot;"><br>这里我们可以看到,$a,$b,$c这三个变量现在共用一个zval结构，有两个属于change-on-write组合($a,$c),有两个属于copy-on-write组合($a,$b),我们的is_ref<strong>gc和refcount</strong>gc该怎样工作，才能正确的处理好这段复杂的关系呢？ The answer is: 不可能！在这种情况下，变量的值必须分离成两份完全独立的存在！$a与$c共用一个zval,$b自己用一个zval，尽管他们拥有同样的值，但是必须至少通过两个zval来实现。见图3.2【在引用时强制复制！】</p>
<p>同样，下面的这段代码同样会在内核中产生歧义，所以需要强制复制！<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//上图对应的代码</span></div><div class="line">$a = <span class="number">1</span>;</div><div class="line">$b = &amp;$a;</div><div class="line">$c = $a;</div></pre></td></tr></table></figure></p>
<p> <img src="/assets/blogImg/is_ref2.jpg" alt="&quot;我是傲娇的效果图&quot;"></p>
<p>需要注意的是，在这两种情况下，$b都与原初的zval相关联，因为当复制发生时，内核还不知道第三个变量的名字。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇博文我们探索了php中的zval中的类型和值，现在我们探究下php的zval结构体中的:&lt;br&gt;       &lt;code&gt;zend_uint refcount__gc&lt;/code&gt;&lt;br&gt;       &lt;code&gt;zend_uchar is_ref__gc&lt;/code&gt;
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php php扩展 c" scheme="http://graychen.git.io/tags/php-php%E6%89%A9%E5%B1%95-c/"/>
    
  </entry>
  
  <entry>
    <title>探索php中的变量zval结构体</title>
    <link href="http://graychen.git.io/2017/06/18/%E6%8E%A2%E7%B4%A2php%E4%B8%AD%E7%9A%84%E5%8F%98%E9%87%8Fzval%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <id>http://graychen.git.io/2017/06/18/探索php中的变量zval结构体/</id>
    <published>2017-06-18T15:03:30.000Z</published>
    <updated>2017-06-21T06:08:17.290Z</updated>
    
    <content type="html"><![CDATA[<h2 id="变量的类型"><a href="#变量的类型" class="headerlink" title="变量的类型"></a>变量的类型</h2><p>php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的每个变量都是一个zval结构体，zval中的type存储真正的类型，根据type来获取zvalue_value的值.<br>注意这个php的版本是5.4,最新的php7结构体已经变更<br>PHP在内核中是通过zval这个结构体来存储变量的，它的定义在Zend/zend.h文件里，简短精炼，只有四个成员组成：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">struct</span> <span class="number">_</span>zval_struct &#123;</div><div class="line">        zvalue_value value; <span class="comment">/* 变量的值 */</span></div><div class="line">        zend_uchar type;    <span class="comment">/* 变量当前的数据类型 */</span></div><div class="line">        zend_uint refcount__gc;</div><div class="line">        zend_uchar is_ref__gc;</div><div class="line">&#125;;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="number">_</span>zval_struct zval;</div><div class="line"></div><div class="line"><span class="comment">//在Zend/zend_types.h里定义的：</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> zend_uint;</div><div class="line"><span class="keyword">typedef</span> <span class="keyword">unsigned</span> <span class="keyword">char</span> zend_uchar;</div></pre></td></tr></table></figure></p>
<p>保存变量值的value则是zvalue_value类型(PHP5)，它是一个union，同样定义在了Zend/zend.h文件里：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> <span class="number">_</span>zvalue_value &#123;</div><div class="line">        <span class="keyword">long</span> lval;                  <span class="comment">/* long value */</span></div><div class="line">        <span class="keyword">double</span> dval;                <span class="comment">/* double value */</span></div><div class="line">        <span class="keyword">struct</span> &#123;</div><div class="line">                <span class="keyword">char</span> *val;</div><div class="line">                <span class="keyword">int</span> len;</div><div class="line">        &#125; str;</div><div class="line">        HashTable *ht;              <span class="comment">/* hash table value */</span></div><div class="line">        zend_object_value obj;</div><div class="line">&#125; zvalue_value;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>PHP中常见的变量类型有：</p>
<ol>
<li>整型/浮点/长整型/bool值 等等</li>
<li>字符串</li>
<li>数组/关联数组</li>
<li>对象</li>
<li>资源</li>
</ol>
</blockquote>
<p>PHP根据zval中的type字段来储存一个变量的真正类型，然后根据type来选择如何获取zvalue_value的值，比如对于整型和bool值:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">zval.type = IS_LONG;<span class="comment">//整形</span></div><div class="line">zval.type = IS_BOOL;<span class="comment">//布尔值</span></div></pre></td></tr></table></figure>
<p>就去取zval.value.lval,对于bool值来说lval∈(0|1);<br>如果是双精度，或者float则会去取zval.value的dval。<br>而如果是字符串，那么:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zval.type = IS_STRING</div></pre></td></tr></table></figure>
<p>这个时候，就会取:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">zval.value.str</div></pre></td></tr></table></figure>
<p>而这个也是个结构，存有C分格的字符串和字符串的长度。<br>而对于数组和对象，则type分别对应IS_ARRAY, IS_OBJECT, 相对应的则分别取zval.value.ht和obj<br>比较特别的是资源，在PHP中，资源是个很特别的变量，任何不属于PHP内建的变量类型的变量，都会被看作成资源来进行保存，比如，数据库句柄，打开的文件句柄等等。 对于资源:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">type = IS_RESOURCE</div></pre></td></tr></table></figure>
<h2 id="变量类型的实现"><a href="#变量类型的实现" class="headerlink" title="变量类型的实现"></a>变量类型的实现</h2><p>在以上实现的基础上，PHP语言得以实现了8种数据类型，这些数据类型在内核中的分别对应于特定的常量，它们分别是：</p>
<table>
<thead>
<tr>
<th style="text-align:left">常量名称：</th>
<th style="text-align:center">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">IS_NULL</td>
<td style="text-align:center">第一次使用的变量如果没有初始化过，则会自动的被赋予这个常量，当然我们也可以在PHP语言中通过null这个常量来给予变量null类型的值。 这个类型的值只有一个 ，就是NULL，它和0与false是不同的。</td>
</tr>
<tr>
<td style="text-align:left">IS_BOOL</td>
<td style="text-align:center">布尔类型的变量有两个值，true或者false。在PHP语言中，while、if等语句会自动的把表达式的值转成这个类型的。</td>
</tr>
<tr>
<td style="text-align:left">IS_LONG</td>
<td style="text-align:center">PHP语言中的整型，在内核中是通过所在操作系统的signed long数据类型来表示的。 在最常见的32位操作系统中，它可以存储从-2147483648 到 +2147483647范围内的任一整数。 有一点需要注意的是，如果PHP语言中的整型变量超出最大值或者最小值，它并不会直接溢出， 而是会被内核转换成IS_DOUBLE类型的值然后再参与计算。 再者，因为使用了signed long来作为载体，所以这也就解释了为什么PHP语言中的整型数据都是带符号的了。</td>
</tr>
<tr>
<td style="text-align:left">IS_DOUBLE</td>
<td style="text-align:center">PHP中的浮点数据是通过C语言中的signed double型变量来存储的， 这最终取决与所在操作系统的浮点型实现。 我们做为程序猿，应该知道计算机是无法精准的表示浮点数的， 而是采用了科学计数法来保存某个精度的浮点数。 用科学计数法，计算机只用8位便可以保存2.225x10^(-308)~~1.798x10^308之间的浮点数。 用计算机来处理浮点数简直就是一场噩梦，十进制的0.5转成二进制是0.1， 0.8转换后是0.1100110011….。 但是当我们从二进制转换回来的时候，往往会发现并不能得到0.8。 我们用1除以3这个例子来解释这个现象：1/3=0.3333333333…..，它是一个无限循环小数， 但是计算机可能只能精确存储到0.333333，当我们再乘以三时， 其实计算机计算的数是0.333333*3=0.999999，而不是我们平时数学中所期盼的1.0.</td>
</tr>
<tr>
<td style="text-align:left">IS_STRING</td>
<td style="text-align:center">PHP中最常用的数据类型——字符串，在内存中的存储和C差不多， 就是一块能够放下这个变量所有字符的内存，并且在这个变量的zval实现里会保存着指向这块内存的指针。 与C不同的是，PHP内核还同时在zval结构里保存着这个字符串的实际长度， 这个设计使PHP可以在字符串中嵌入‘\0’字符，也使PHP的字符串是二进制安全的， 可以安全的存储二进制数据！本着艰苦朴素的作风，内核只会为字符串申请它长度+1的内存， 最后一个字节存储的是‘\0’字符，所以在不需要二进制安全操作的时候， 我们可以像通常C语言的方式那样来使用它。</td>
</tr>
<tr>
<td style="text-align:left">IS_ARRAY</td>
<td style="text-align:center">数组是一个非常特殊的数据类型，它唯一的功能就是聚集别的变量。 在C语言中，一个数组只能承载一种类型的数据，而PHP语言中的数组则灵活的多， 它可以承载任意类型的数据，这一切都是HashTable的功劳， 每个HashTable中的元素都有两部分组成：索引与值， 每个元素的值都是一个独立的zval（确切的说应该是指向某个zval的指针）。</td>
</tr>
<tr>
<td style="text-align:left">IS_OBJECT</td>
<td style="text-align:center">和数组一样，对象也是用来存储复合数据的，但是与数组不同的是， 对象还需要保存以下信息：方法、访问权限、类常量以及其它的处理逻辑。 相对与zend engine V1，V2中的对象实现已经被彻底修改， 所以我们PHP扩展开发者如果需要自己的扩展支持面向对象的工作方式， 则应该对PHP5和PHP4分别对待！</td>
</tr>
<tr>
<td style="text-align:left">IS_RESOURCE</td>
<td style="text-align:center">有一些数据的内容可能无法直接呈现给PHP用户的， 比如与某台mysql服务器的链接，或者直接呈现出来也没有什么意义。 但用户还需要这类数据，因此PHP中提供了一种名为Resource(资源)的数据类型。 有关这个数据类型的事宜将在第九章中介绍，现在我们只要知道有这么一种数据类型就行了。</td>
</tr>
</tbody>
</table>
<p>zval结构体里的type成员的值便是以上某个IS_*常量之一。php的内核通过检测变量的这个成员值来知道他是什么类型的数据并做相应的后续处理。<br>如果要我们检测一个变量的类型<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">describe_zval</span><span class="params">(zval *foo)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">if</span> ( Z_TYPE_P(foo) == IS_NULL  )</div><div class="line">        &#123;</div><div class="line">                    php_printf(<span class="string">"这个变量的数据类型是： NULL"</span>);</div><div class="line">                        </div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span></div><div class="line">        &#123;</div><div class="line">                    php_printf(<span class="string">"这个变量的数据类型不是NULL，这种数据类型对应的数字是： %d"</span>, Z_TYPE_P(foo));</div><div class="line">                        </div><div class="line">        &#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>以一个P结尾的宏的参数大多是<em>zval型变量。 此外获取变量类型的宏还有两个，分别是Z_TYPE和Z_TYPE_PP，前者的参数是zval型，而后者的参数则是*</em>zval。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//开始定义php语言中的函数gettype</span></div><div class="line">PHP_FUNCTION(gettype)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//arg间接指向调用gettype函数时所传递的参数。是一个zval**结构</span></div><div class="line">    <span class="comment">//所以我们要对他使用__PP后缀的宏。</span></div><div class="line">    zval **arg;</div><div class="line"></div><div class="line">    <span class="comment">//这个if的操作主要是让arg指向参数～</span></div><div class="line">    <span class="keyword">if</span> (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, <span class="string">"Z"</span>, &amp;arg) == FAILURE) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">                    </div><div class="line">    <span class="comment">//调用Z_TYPE_PP宏来获取arg指向zval的类型。</span></div><div class="line">    <span class="comment">//然后是一个switch结构，RETVAL_STRING宏代表这gettype函数返回的字符串类型的值</span></div><div class="line">    <span class="keyword">switch</span> (Z_TYPE_PP(arg)) &#123;</div><div class="line">        <span class="keyword">case</span> IS_NULL:</div><div class="line">            RETVAL_STRING(<span class="string">"NULL"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_BOOL:</div><div class="line">            RETVAL_STRING(<span class="string">"boolean"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_LONG:</div><div class="line">            RETVAL_STRING(<span class="string">"integer"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_DOUBLE:</div><div class="line">            RETVAL_STRING(<span class="string">"double"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_STRING:</div><div class="line">            RETVAL_STRING(<span class="string">"string"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_ARRAY:</div><div class="line">            RETVAL_STRING(<span class="string">"array"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_OBJECT:</div><div class="line">            RETVAL_STRING(<span class="string">"object"</span>, <span class="number">1</span>);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> IS_RESOURCE:</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">char</span> *type_name;</div><div class="line">            type_name = zend_rsrc_list_get_rsrc_type(Z_LVAL_PP(arg) TSRMLS_CC);</div><div class="line">            <span class="keyword">if</span> (type_name) &#123;</div><div class="line">                RETVAL_STRING(<span class="string">"resource"</span>, <span class="number">1</span>);</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">default</span>:</div><div class="line">                    RETVAL_STRING(<span class="string">"unknown type"</span>, <span class="number">1</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以上三个宏的定义在Zend/zend_operators.h里，定义分别是：</p>
<p>#define Z_TYPE(zval)        (zval).type</p>
<p>#define Z_TYPE_P(zval_p)    Z_TYPE(*zval_p)</p>
<p>#define Z_TYPE_PP(zval_pp)  Z_TYPE(**zval_pp)</p>
<h2 id="变量值的实现"><a href="#变量值的实现" class="headerlink" title="变量值的实现"></a>变量值的实现</h2><p>PHP内核提供了三个基础宏来方便我们对变量的值进行操作，这几个宏同样以Z_开头.<br>内核中针对具体的数据类型分别定义了相应的宏。 如针对IS_BOOL型的BVAL组合(Z_BVAL、Z_BVAL_P、Z_BVAL_PP)和针对IS_DOUBLE的DVAL组合(Z_DVAL、ZDVAL_P、ZDVAL_PP)等等。 我们通过下面这个例子来应用一下这几个宏:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_value</span><span class="params">(zval zv,zval *zv_p,zval **zv_pp)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span>( Z_TYPE(zv) == IS_NULL)</div><div class="line">    &#123;</div><div class="line">                php_printf(<span class="string">"类型是 IS_NULL!\n"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>( Z_TYPE_P(zv_p) == IS_LONG)</div><div class="line">    &#123;</div><div class="line">                php_printf(<span class="string">"类型是 IS_LONG，值是：%ld"</span> , Z_LVAL_P(zv_p));</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span>(Z_TYPE_PP(zv_pp) == IS_DOUBLE)</div><div class="line">    &#123;</div><div class="line">                php_printf(<span class="string">"类型是 IS_DOUBLE,值是：%f"</span> , Z_DVAL_PP(zv_pp) );</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>string型变量比较特殊，因为内核在保存String型变量时，不仅保存了字符串的值，还保存了它的长度， 所以它有对应的两种宏组合STRVAL和STRLEN，即：Z_STRVAL、Z_STRVAL_P、Z_STRVAL_PP与Z_STRLEN、Z_STRLEN_P、Z_STRLEN_PP。 前一种宏返回的是char *型，即字符串的地址；后一种返回的是int型，即字符串的长度。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">display_string</span><span class="params">(zval *zstr)</span></span></div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (Z_TYPE_P(zstr) != IS_STRING) &#123;</div><div class="line">        php_printf(<span class="string">"这个变量不是字符串!\n"</span>);</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    PHPWRITE(Z_STRVAL_P(zstr), Z_STRLEN_P(zstr));</div><div class="line">    <span class="comment">//这里用了PHPWRITE宏，只要知道它是从Z_STRVAL_P(zstr)地址开始，输出Z_STRLEN_P(zstr)长度的字符就可以了。</span></div><div class="line">&#125;       </div><div class="line"> ```       </div><div class="line">Array型变量的值其实是存储在C语言实现的HashTable中的， 我们可以用ARRVAL组合宏（Z_ARRVAL, Z_ARRVAL_P, Z_ARRVAL_PP）这三个宏来访问数组的值。 如果你看旧版本php的源码或者部分pecl扩展的源码，可能会发现一个HASH_OF()宏，这个宏等价于Z_ARRVAL_P()。 但不推荐在新代码中再使用了。</div><div class="line">对象是一个复杂的结构体（zend_object_value结构体），不仅存储属性的定义、属性的值，还存储着访问权限、方法等信息。 内核中定义了以下组合宏让我们方便的操作对象： OBJ_HANDLE：返回handle标识符， OBJ_HT：handle表， OBJCE：类定义， OBJPROP：HashTable的属性， OBJ_HANDLER：在OBJ_HT中操作一个特殊的handler方法。 现在不用担心这些宏对象的意思，后续有专门的章节介绍object。</div><div class="line">资源型变量的值其实就是一个整数，可以用RESVAL组合宏来访问它，我们把它的值传给zend_fetch_resource函数，便可以得到这个资源的操作句柄，如mysql的链接句柄等。</div><div class="line">有关值操作的宏都定义在./Zend/zend_operators.h文件里：</div><div class="line">``` c</div><div class="line"><span class="comment">//操作整数的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL(zval)            (zval).value.lval</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_P(zval_p)        Z_LVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_LVAL_PP(zval_pp)      Z_LVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作IS_BOOL布尔型的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL(zval)            ((zend_bool)(zval).value.lval)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_P(zval_p)        Z_BVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_BVAL_PP(zval_pp)      Z_BVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作浮点数的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL(zval)            (zval).value.dval</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_P(zval_p)        Z_DVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_DVAL_PP(zval_pp)      Z_DVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作字符串的值和长度的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL(zval)          (zval).value.str.val</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_P(zval_p)      Z_STRVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRVAL_PP(zval_pp)        Z_STRVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN(zval)          (zval).value.str.len</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_P(zval_p)      Z_STRLEN(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_STRLEN_PP(zval_pp)        Z_STRLEN(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL(zval)          (zval).value.ht</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_P(zval_p)      Z_ARRVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_ARRVAL_PP(zval_pp)        Z_ARRVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作对象的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL(zval)          (zval).value.obj</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_P(zval_p)      Z_OBJVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJVAL_PP(zval_pp)        Z_OBJVAL(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE(zval)      Z_OBJVAL(zval).handle</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_P(zval_p)      Z_OBJ_HANDLE(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLE_PP(zval_p)     Z_OBJ_HANDLE(**zval_p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT(zval)          Z_OBJVAL(zval).handlers</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_P(zval_p)      Z_OBJ_HT(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HT_PP(zval_p)     Z_OBJ_HT(**zval_p)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE(zval)           zend_get_class_entry(&amp;(zval) TSRMLS_CC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_P(zval_p)       Z_OBJCE(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJCE_PP(zval_pp)     Z_OBJCE(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP(zval)         Z_OBJ_HT((zval))-&gt;get_properties(&amp;(zval) TSRMLS_CC)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_P(zval_p)     Z_OBJPROP(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJPROP_PP(zval_pp)       Z_OBJPROP(**zval_pp)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER(zval, hf)     Z_OBJ_HT((zval))-&gt;hf</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_P(zval_p, h)  Z_OBJ_HANDLER(*zval_p, h)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJ_HANDLER_PP(zval_p, h)     Z_OBJ_HANDLER(**zval_p, h)</span></div><div class="line"></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG(zval,is_tmp)     (Z_OBJ_HANDLER((zval),get_debug_info)?  \</span></div><div class="line">                        Z_OBJ_HANDLER((zval),get_debug_info)(&amp;(zval),&amp;is_tmp TSRMLS_CC): \</div><div class="line">                                                (is_tmp=0,Z_OBJ_HANDLER((zval),get_properties)?Z_OBJPROP(zval):NULL)) </div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_P(zval_p,is_tmp) Z_OBJDEBUG(*zval_p,is_tmp) </span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_OBJDEBUG_PP(zval_pp,is_tmp)   Z_OBJDEBUG(**zval_pp,is_tmp)</span></div><div class="line"></div><div class="line"><span class="comment">//操作资源的</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL(zval)          (zval).value.lval</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_P(zval_p)      Z_RESVAL(*zval_p)</span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> Z_RESVAL_PP(zval_pp)        Z_RESVAL(**zval_pp)</span></div><div class="line">```     </div><div class="line">#<span class="meta"># php的类型转换</span></div><div class="line">php内核中提供了好多函数专门来帮我们实现类型转换的功能，你需要的只是调用一个函数而已。这一类函数有一个统一的形式：convert_to_*()</div><div class="line">``` c</div><div class="line"><span class="comment">//将任意类型的zval转换成字符串</span></div><div class="line"><span class="function"><span class="keyword">void</span> <span class="title">change_zval_to_string</span><span class="params">(zval *value)</span></span></div><div class="line">&#123;</div><div class="line">        convert_to_string(value);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//其它基本的类型转换函数</span></div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_long</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_double</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_null</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_boolean</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_array</span><span class="params">(zval *op)</span></span>;</div><div class="line"><span class="function">ZEND_API <span class="keyword">void</span> <span class="title">convert_to_object</span><span class="params">(zval *op)</span></span>;</div><div class="line"></div><div class="line">ZEND_API <span class="keyword">void</span> <span class="number">_</span>convert_to_string(zval *op ZEND_FILE_LINE_DC);</div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> convert_to_string(op) <span class="meta-keyword">if</span> ((op)-&gt;type != IS_STRING) &#123; _convert_to_string((op) ZEND_FILE_LINE_CC);  &#125;</span></div></pre></td></tr></table></figure></p>
<p>这里面有两个比较特殊，一个就是convert_to_string其实是一个宏函数，调用的另外一个函数；第二个便是没有convert_to_resource()的转换函数，因为资源的值在用户层面上，根本就没有意义，内核不会对它的值(不是指那个数字)进行转换。<br>注意，并不是所有的内存分配例程都有一个相应的p*对等实现。例如，不存在pestrndup()，并且在PHP 5.1版本前也不存在safe_pemalloc()。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;变量的类型&quot;&gt;&lt;a href=&quot;#变量的类型&quot; class=&quot;headerlink&quot; title=&quot;变量的类型&quot;&gt;&lt;/a&gt;变量的类型&lt;/h2&gt;&lt;p&gt;php是动态语言，c是静态语言，php是c实现的，我以前一直不明白静态的c是怎么实现动态的php的，后面发现php的
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php php扩展 c" scheme="http://graychen.git.io/tags/php-php%E6%89%A9%E5%B1%95-c/"/>
    
  </entry>
  
  <entry>
    <title>Codeception测试框架如何编写测试</title>
    <link href="http://graychen.git.io/2017/06/18/%E5%A6%82%E4%BD%95%E7%BC%96%E5%86%99%E6%B5%8B%E8%AF%95/"/>
    <id>http://graychen.git.io/2017/06/18/如何编写测试/</id>
    <published>2017-06-18T05:38:51.000Z</published>
    <updated>2017-06-20T06:30:10.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="如何编写测试"><a href="#如何编写测试" class="headerlink" title="如何编写测试"></a>如何编写测试</h2><p>Yii2高级应用程序使用Codeception作为其主要测试框架。</p>
<h3 id="搭建测试环境"><a href="#搭建测试环境" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h3><p>为了运行测试用例，你需要安装 Codeception 。 一个较好的安装方式是：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">composer <span class="keyword">global</span> <span class="keyword">require</span> <span class="string">"codeception/codeception=2.1.*"</span></div><div class="line">composer <span class="keyword">global</span> <span class="keyword">require</span> <span class="string">"codeception/specify=*"</span></div><div class="line">composer <span class="keyword">global</span> <span class="keyword">require</span> <span class="string">"codeception/verify=*"</span></div></pre></td></tr></table></figure></p>
<p>创建测试目录<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codecept bootstrap</div></pre></td></tr></table></figure></p>
<p>构建测试套件：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codecept build</div></pre></td></tr></table></figure></p>
<p>如果测试需要在 Production 环境中执行， yii_test 和 yii_test.bat 必须从 environments/dev 文件夹手动复制到项目根目录。 测试需要一个 额外的数据库 ，这将在测试之间清除。 在mysql中创建数据库 yii2advanced_test （根据 common/config/test.php 中的配置）并执行：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./yii_test migrate</div></pre></td></tr></table></figure></p>
<p>然后所有的样例测试可以通过运行如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">codecept run</div></pre></td></tr></table></figure></p>
<p>docker环境下运行搭建并运行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">docker exec -it health_web_1 ./vendor/bin/codecept boostrap</div><div class="line">docker exec -it health_web_1 ./vendor/bin/./yii_test migrate</div><div class="line">docker exec -it health_web_1 ./vendor/bin/codecept build</div><div class="line">docker exec -it health_web_1 ./vendor/bin/codecept run</div></pre></td></tr></table></figure></p>
<p>测试套件描述：</p>
<ul>
<li>unit ⇒ 单元测试,对程序模块(类中的方法)来进行正确性检验的测试工作（主要）。</li>
<li>api ⇒ api接口测试(主要)。</li>
<li>functional ⇒ 功能测试，应用程序内部请求/响应（无Web服务器）。</li>
<li>acceptance ⇒ 验收测试，web应用程序，用户界面和javascript交互。</li>
</ul>
<h2 id="启动测试"><a href="#启动测试" class="headerlink" title="启动测试"></a>启动测试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"> docker <span class="built_in">exec</span> -it usercenter_web_1 bash</div><div class="line">//或者</div><div class="line"> docker <span class="built_in">exec</span> -it health_web_1 /bin/sh</div><div class="line">./vendor/bin/codecept run -c tests</div></pre></td></tr></table></figure>
<p>-c 指定目录<br>api测试需要启动一个web服务器<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">php -S localhost:80 --docroot api/tests &amp;&gt;/dev/null&amp;</div></pre></td></tr></table></figure></p>
<h2 id="搭建测试环境-1"><a href="#搭建测试环境-1" class="headerlink" title="搭建测试环境"></a>搭建测试环境</h2><p>目录结构</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">├── codeception</div><div class="line">│   ├── api  //api测试</div><div class="line">│   ├── api.suite.yml  //api测试配置</div><div class="line">│   ├── _bootstrap.php</div><div class="line">│   ├── _data</div><div class="line">│   │   └── dump.sql  //初始化sql</div><div class="line">│   ├── _output  //日志</div><div class="line">│   ├── _support                                                    </div><div class="line">│   ├── unit</div><div class="line">│   │   ├── _bootstrap.php   //依赖文件</div><div class="line">│   │   ├── models</div><div class="line">│   │   │   ├── ActivityConfigTest.php  //单元测试</div><div class="line">│   │   └── UnitTester.php</div><div class="line">│   └── unit.suite.yml  //单元测试配置文件</div><div class="line">├── codeception.yml</div><div class="line">├── _envs</div><div class="line">├── _output</div><div class="line">└── _support</div><div class="line">    └── _generated</div></pre></td></tr></table></figure>
<p>在根目录运行codecept bootstrap 创建test目录和codeception.yml 文件</p>
<h3 id="api测试详解"><a href="#api测试详解" class="headerlink" title="api测试详解"></a>api测试详解</h3><p>API测试在功能测试级别完成，但是不是测试用户操作的HTML响应，而是通过REST或SOAP等协议来测试请求和响应。要开始写api测试，你应该为他们创建一个套件<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./vendor/bin/codecept g:suite api</div></pre></td></tr></table></figure></p>
<p>您将需要启用REST，Yii2模块tests/api.suite.yml：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">class_name: ApiTester</div><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">        - REST:</div><div class="line">            url: /api/v1</div><div class="line">            depends: Yii2</div><div class="line">        - \ApiBundle\Helper\Api</div><div class="line">    config:</div><div class="line">        - Yii2</div></pre></td></tr></table></figure></p>
<p>Yii2模块操作amOnPage或see不应该可用于测试API。这就是为什么Yii2模块没有被启用，但被声明depends为REST模块。</p>
<p><a href="http://codeception.com/docs/10-WebServices#REST" target="_blank" rel="external">继续执行REST API测试指南»</a></p>
<h3 id="单位测试详解"><a href="#单位测试详解" class="headerlink" title="单位测试详解"></a>单位测试详解</h3><p>单元测试位于tests/unit目录中，应包含所有类型的单元和集成测试。</p>
<p>每个测试用例扩展Codeception\Test\Unit类，这是单元测试的标准Codeception格式。在Yii中开发完全隔离的单元测试是非常困难的，所以在每个测试用例之前应用程序是自举的。tests/unit.suite.yml使用Yii2模块启用测试配置文件：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">      - Yii2:</div><div class="line">            part: [orm, email]</div></pre></td></tr></table></figure></p>
<p>该模块启动测试用例的Yii应用程序，并提供其他帮助方法来简化测试。它只有orm和email零件，以排除需要的只是功能性的测试方法。</p>
<p>通过访问测试用例中的$this-&gt;tester类可以使用Yii2模块的方法。因此，如果您已启用orm和电子邮件部件，以便您可以调用属于这些部分的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// insert records in database</div><div class="line">$this-&gt;tester-&gt;haveRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class="line">// check records in database</div><div class="line">$this-&gt;tester-&gt;seeRecord(&apos;app/model/User&apos;, [&apos;username&apos; =&gt; &apos;davert&apos;]);</div><div class="line">// test email was sent</div><div class="line">$this-&gt;tester-&gt;seeEmailIsSent();</div><div class="line">// get a last sent emails</div><div class="line">$this-&gt;tester-&gt;grabLastSentEmail();</div></pre></td></tr></table></figure></p>
<p>如果启用fixtures部件，您还将获得在测试中加载和使用灯具的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// load fixtures</div><div class="line">$this-&gt;tester-&gt;haveFixtures([</div><div class="line">    &apos;user&apos; =&gt; [</div><div class="line">        &apos;class&apos; =&gt; UserFixture::className(),</div><div class="line">        // fixture data located in tests/_data/user.php</div><div class="line">        &apos;dataFile&apos; =&gt; codecept_data_dir() . &apos;user.php&apos;</div><div class="line">    ]</div><div class="line">]);</div><div class="line">// get first user from fixtures</div><div class="line">$this-&gt;tester-&gt;grabFixture(&apos;user&apos;, 0);</div></pre></td></tr></table></figure></p>
<p>如果Yii2模块启用，您可以安全地调用Yii::$app测试内容，因为应用程序在测试后被初始化和清理。如果你想为你的测试用例添加你的帮助方法或者自定义的断言，你不应该扩展，Codeception\Test\Unit而是写出你自己的单独的Helper类。</p>
<p><a href="http://codeception.com/docs/05-UnitTests" target="_blank" rel="external">继续进行单元测试指南»</a></p>
<h3 id="功能测试"><a href="#功能测试" class="headerlink" title="功能测试"></a>功能测试</h3><p>当测试Web应用程序的实际功能时，您不能仅使用单元测试。你想测试应用程序如何处理请求，它提供什么响应，什么数据保存到数据库等等。要在近用户环境中测试应用程序，但不启动真正的Web服务器或浏览器，您可以使用功能测试。它们的写法远比单元测试简单得多。他们在简单的DSL中描述交互场景，所以您不需要直接处理应用程序，而是从用户的角度描述动作：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">$I-&gt;amOnPage([&apos;site/contact&apos;]);</div><div class="line">$I-&gt;submitForm(&apos;#contact-form&apos;, []);</div><div class="line">$I-&gt;expectTo(&apos;see validations errors&apos;);</div><div class="line">$I-&gt;see(&apos;Contact&apos;, &apos;h1&apos;);</div><div class="line">$I-&gt;see(&apos;Name cannot be blank&apos;);</div><div class="line">$I-&gt;see(&apos;Email cannot be blank&apos;);</div><div class="line">$I-&gt;see(&apos;Subject cannot be blank&apos;);</div><div class="line">$I-&gt;see(&apos;Body cannot be blank&apos;);</div></pre></td></tr></table></figure></p>
<p>这样，您不仅可以在站点上测试ContactForm，而且还可以实际输出用户看到的应用程序。Codeception提供了一套标准的动作一样amOnPage，submitForm，see进行测试。Yii2模块提供了特殊的方法，如amLoggedInAs（快速认证）haveRecord，seeRecord，seeEmailIsSent和其他人。它们都列在模块引用中。</p>
<p>功能测试应该写在Cest 文件中，这是一个场景驱动的Codeception测试格式。您可以通过运行以下方式轻松创建新测试：</p>
<p>./vendor/bin/codecept g:cest functional MyNewScenarioCest<br> 功能测试非常强大而简单。强烈推荐使用任何Yii应用程序。</p>
<p><a href="http://codeception.com/docs/04-FunctionalTests" target="_blank" rel="external">继续进行功能测试指南»</a></p>
<h3 id="验收测试"><a href="#验收测试" class="headerlink" title="验收测试"></a>验收测试</h3><p>从测试的角度来看，验收测试与功能测试相同。他们测试用户与应用程序的交互，但在这种情况下使用真正的浏览器和Web服务器。它们慢得多，脆弱得多。他们不应该在测试功能的问题上重复功能测试，而应该用于测试应用程序的UI。如果您不确定哪些测试应该被接受，哪些是功能性的，那么写入JavaScript丰富应用程序的接受测试，其中UI高度依赖于浏览器处理。您还可以使用快乐路径场景的验收测试，以确保使用真实浏览器的真实用户在功能测试中达到相同的结果。</p>
<p>默认情况下，基本应用验收测试被禁用（因为它们需要Web服务器，Selenium服务器和浏览器才能运行）。您可以轻松地通过重命名使他们acceptance.suite.yml.example对acceptance.suite.yml<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mv tests/acceptance.suite.yml.example tests/acceptance.suite.yml</div><div class="line">基本模板使用codeception/base不包含facebook/webdriver运行验收测试所需库的软件包。请更改codeception/base为codeception/codeceptionin composer.json并运行update命令。</div></pre></td></tr></table></figure></p>
<p>那么您将需要在测试模式下启动应用服务器：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./tests/bin/yii serve</div></pre></td></tr></table></figure></p>
<p>并启动Selenium Server或PhantomJS。对于接受使用WebDriver模块。请检查其参考资料，了解如何使用它。与Yii2模块不同，它对应用程序一无所知，因此，如果要使用Yii像夹具的功能进行验收测试，则应检查是否启用Yii2模块：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"># config at tests/acceptance.yml</div><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">        - WebDriver:</div><div class="line">            url: http://127.0.0.1:8080/</div><div class="line">            browser: firefox</div><div class="line">        - Yii2:</div><div class="line">            part: [orm, fixtures] # allow to use AR methods</div><div class="line">            cleanup: false # don&apos;t wrap test in transaction</div><div class="line">            entryScript: index-test.php</div></pre></td></tr></table></figure></p>
<p>正如所说，功能和验收测试是相似的，所以为了避免与这些模块的冲突，你应该只加载你真正需要的Yii2模块的一部分。您还必须将cleanup: falseYii2更改设置为数据库，以便在Web服务器上运行的应用程序进行保存和使用。使用entryScript和entryUrl值可以更改应用程序的默认主机和脚本配置。</p>
<p>与功能测试类似，建议使用Cest格式进行验收测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./vendor/bin/codecept g:cest acceptance MyNewScenarioCest</div></pre></td></tr></table></figure></p>
<p><a href="http://codeception.com/docs/03-AcceptanceTests" target="_blank" rel="external">继续验收测试指南»</a></p>
<h3 id="手动设置-amp-amp-配置"><a href="#手动设置-amp-amp-配置" class="headerlink" title="手动设置&amp;&amp;配置"></a>手动设置&amp;&amp;配置</h3><p>要开始，您需要通过Composer安装Codeception<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require &quot;codeception/codeception&quot; --dev</div></pre></td></tr></table></figure></p>
<p>创建基本的测试套件<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">./vendor/bin/codecept bootstrap</div></pre></td></tr></table></figure></p>
<p>启用模块Yii2进行功能测试functional.suite.yml：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># functional.suite.yml</div><div class="line">modules:</div><div class="line">    enabled:</div><div class="line">        - Yii2:</div><div class="line">            configFile: #insert path to config file</div></pre></td></tr></table></figure></p>
<p>Yii2模块唯一必需的参数是configFile。该文件配置为Yii应用程序的测试配置。它应该合并原始应用程序配置覆盖id值，并提供不同的数据库进行测试：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// config/test.php</div><div class="line">$config =  yii\helpers\ArrayHelper::merge(</div><div class="line">    require(__DIR__ . &apos;/main.php&apos;),</div><div class="line">    require(__DIR__ . &apos;/main-local.php&apos;),</div><div class="line">    [</div><div class="line">        &apos;id&apos; =&gt; &apos;app-tests&apos;,</div><div class="line">        &apos;components&apos; =&gt; [</div><div class="line">            &apos;db&apos; =&gt; [</div><div class="line">                &apos;dsn&apos; =&gt; &apos;mysql:host=localhost;dbname=yii_app_test&apos;,</div><div class="line">            ]</div><div class="line">        ]        </div><div class="line">    ]</div><div class="line">);</div><div class="line">return $config;</div></pre></td></tr></table></figure></p>
<p>测试配置建议存储在应用程序的config文件夹中。您应该提供相对于codeception.yml文件测试配置的路径。</p>
<p>还请确保YII_ENV常数设置为test，因为它是在做tests/_bootstrap.php的基本的和高级的应用程序模板文件。</p>
<p>一旦配置功能测试，就可以轻松地创建单元和验收测试的设置，如本指南中所述。</p>
<p>在基础和高级应用程序模板configFile中定义了全局配置文件：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"># inside codeception.yml</div><div class="line">modules:</div><div class="line">    config:</div><div class="line">        Yii2:</div><div class="line">            configFile: &apos;config/test.php&apos;</div></pre></td></tr></table></figure></p>
<p>这样我们不需要为每个定义的套件提供测试配置。</p>
<h3 id="伪数据生成器"><a href="#伪数据生成器" class="headerlink" title="伪数据生成器"></a>伪数据生成器</h3><p>安装<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer require fzaninotto/faker</div></pre></td></tr></table></figure></p>
<p>使用Faker\Factory::create()创建和初始化一个摊贩发生器，可通过访问你想要的数据类型来命名的属性生成的数据。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">&lt;?php</div><div class="line">// require the Faker autoloader</div><div class="line">require_once &apos;/path/to/Faker/src/autoload.php&apos;;</div><div class="line">// alternatively, use another PSR-0 compliant autoloader (like the Symfony2 ClassLoader for instance)</div><div class="line"></div><div class="line">// use the factory to create a Faker\Generator instance</div><div class="line">$faker = Faker\Factory::create();</div><div class="line"></div><div class="line">// generate data by accessing properties</div><div class="line">echo $faker-&gt;name;</div><div class="line">  // &apos;Lucy Cechtelar&apos;;</div><div class="line">echo $faker-&gt;address;</div><div class="line">  // &quot;426 Jordy Lodge</div><div class="line">  // Cartwrightshire, SC 88120-6700&quot;</div><div class="line">echo $faker-&gt;text;</div><div class="line">  // Dolores sit sint laboriosam dolorem culpa et autem. Beatae nam sunt fugit</div><div class="line">  // et sit et mollitia sed.</div><div class="line">  // Fuga deserunt tempora facere magni omnis. Omnis quia temporibus laudantium</div><div class="line">  // sit minima sint.</div></pre></td></tr></table></figure></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;如何编写测试&quot;&gt;&lt;a href=&quot;#如何编写测试&quot; class=&quot;headerlink&quot; title=&quot;如何编写测试&quot;&gt;&lt;/a&gt;如何编写测试&lt;/h2&gt;&lt;p&gt;Yii2高级应用程序使用Codeception作为其主要测试框架。&lt;/p&gt;
&lt;h3 id=&quot;搭建测试环境&quot;&gt;
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php" scheme="http://graychen.git.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>谈谈进程和线程</title>
    <link href="http://graychen.git.io/2017/06/17/%E8%B0%88%E8%B0%88%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B/"/>
    <id>http://graychen.git.io/2017/06/17/谈谈进程和线程/</id>
    <published>2017-06-17T15:27:02.000Z</published>
    <updated>2017-06-20T06:30:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下</p>
<h2 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h2><p>现代操作系统比如Mac OS X，UNIX，Linux，Windows等，都是支持“多任务”的操作系统。<br>什么叫“多任务”呢？简单地说，就是操作系统可以同时运行多个任务。打个比方，你一边在用浏览器上网，一边在听MP3，一边在用Word赶作业，这就是多任务，至少同时有3个任务正在运行。还有很多任务悄悄地在后台同时运行着，只是桌面上没有显示而已。<br>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？<br>答案就是操作系统轮流让各个任务交替执行，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是，由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样。<br>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。</p>
<h2 id="进程的概念"><a href="#进程的概念" class="headerlink" title="进程的概念"></a>进程的概念</h2><p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<h2 id="进程的本质"><a href="#进程的本质" class="headerlink" title="进程的本质"></a>进程的本质</h2><p>cpu的单次运算</p>
<h2 id="线程的概念"><a href="#线程的概念" class="headerlink" title="线程的概念"></a>线程的概念</h2><p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们把进程内的这些“子任务”称为线程（Thread）。</p>
<h2 id="线程的本质"><a href="#线程的本质" class="headerlink" title="线程的本质"></a>线程的本质</h2><p>由于每个进程至少要干一件事，所以，一个进程至少有一个线程。当然，像Word这种复杂的进程可以有多个线程，多个线程可以同时执行，多线程的执行方式和多进程是一样的，也是由操作系统在多个线程之间快速切换，让每个线程都短暂地交替运行，看起来就像同时执行一样。当然，真正地同时执行多线程需要多核CPU才可能实现。</p>
<h2 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h2><p>由于同一进程的多个线程共享同一地址空间，因此Text Segment、Data Segment都是共享的，如果定义一个函数，在各线程中都可以调用，如果定义一个全局变量，在各线程中都可以访问到，除此之外，各线程还共享以下进程资源和环境：<br>文件描述符表<br>每种信号的处理方式（SIG_IGN、SIG_DFL或者自定义的信号处理函数）<br>当前工作目录<br>用户id和组id<br>但有些资源是每个线程各有一份的：<br>线程id<br>上下文，包括各种寄存器的值、程序计数器和栈指针<br>栈空间<br>errno变量<br>信号屏蔽字<br>调度优先级</p>
<h2 id="进程的通信"><a href="#进程的通信" class="headerlink" title="进程的通信"></a>进程的通信</h2><p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为进程间通信（IPC，InterProcess Communication）。如下图所示。<br>图 30.6. 进程间通信<br>进程间通信<br> <img src="/assets/blogImg/process.png" alt="&quot;我是傲娇的效果图&quot;"></p>
<h3 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h3><p>管道是一种最基本的IPC机制，由pipe函数创建：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> filedes[<span class="number">2</span>])</span></span>;</div></pre></td></tr></table></figure></p>
<p>调用pipe函数时在内核中开辟一块缓冲区（称为管道）用于通信，它有一个读端一个写端，然后通过filedes参数传出给用户程序两个文件描述符，filedes[0]指向管道的读端，filedes[1]指向管道的写端（很好记，就像0是标准输入1是标准输出一样）。所以管道在用户程序看起来就像一个打开的文件，通过read(filedes[0]);或者write(filedes[1]);向这个文件读写数据其实是在读写内核缓冲区。pipe函数调用成功返回0，调用失败返回-1。</p>
<p>开辟了管道之后如何实现两个进程间的通信呢？比如可以按下面的步骤通信。<br>1.父进程调用pipe开辟管道，得到两个文件描述符指向管道的两端。<br>2.父进程调用fork创建子进程，那么子进程也有两个文件描述符指向同一管道。<br>3.父进程关闭管道读端，子进程关闭管道写端。父进程可以往管道里写，子进程可以从管道里读，管道是用环形队列实现的，数据从写端流入从读端流出，这样就实现了进程间通信。<br> <img src="/assets/blogImg/process.pipe.png" alt="&quot;我是傲娇的效果图&quot;"><br> <figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></div><div class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE 80</span></div><div class="line"></div><div class="line"> <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></div><div class="line">&#123;</div><div class="line">        <span class="keyword">int</span> n;</div><div class="line">        <span class="keyword">int</span> fd[<span class="number">2</span>];</div><div class="line">        <span class="keyword">pid_t</span> pid;</div><div class="line">        <span class="keyword">char</span> line[MAXLINE];</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (pipe(fd) &lt; <span class="number">0</span>) &#123;</div><div class="line">                perror(<span class="string">"pipe"</span>);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ((pid = fork()) &lt; <span class="number">0</span>) &#123;</div><div class="line">                perror(<span class="string">"fork"</span>);</div><div class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123; <span class="comment">/* parent */</span></div><div class="line">                close(fd[<span class="number">0</span>]);</div><div class="line">                write(fd[<span class="number">1</span>], <span class="string">"hello world\n"</span>, <span class="number">12</span>);</div><div class="line">                wait(<span class="literal">NULL</span>);</div><div class="line">         &#125; <span class="keyword">else</span> &#123;       <span class="comment">/* child */</span></div><div class="line">                close(fd[<span class="number">1</span>]);</div><div class="line">                n = read(fd[<span class="number">0</span>], line, MAXLINE);</div><div class="line">                write(STDOUT_FILENO, line, n);</div><div class="line">         &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<blockquote>
<p>使用管道有一些限制：<br>两个进程通过一个管道只能实现单向通信，比如上面的例子，父进程写子进程读，如果有时候也需要子进程写父进程读，就必须另开一个管道。请读者思考，如果只开一个管道，但是父进程不关闭读端，子进程也不关闭写端，双方都有读端和写端，为什么不能实现双向通信？<br>管道的读写端通过打开的文件描述符来传递，因此要通信的两个进程必须从它们的公共祖先那里继承管道文件描述符。上面的例子是父进程把文件描述符传给子进程之后父子进程之间通信，也可以父进程fork两次，把文件描述符传给两个子进程，然后两个子进程之间通信，总之需要通过fork传递文件描述符使两个进程都能访问同一管道，它们才能通信。<br>使用管道需要注意以下4种特殊情况（假设都是阻塞I/O操作，没有设置O_NONBLOCK标志）：<br>如果所有指向管道写端的文件描述符都关闭了（管道写端的引用计数等于0），而仍然有进程从管道的读端读数据，那么管道中剩余的数据都被读取后，再次read会返回0，就像读到文件末尾一样。<br>如果有指向管道写端的文件描述符没关闭（管道写端的引用计数大于0），而持有管道写端的进程也没有向管道中写数据，这时有进程从管道读端读数据，那么管道中剩余的数据都被读取后，再次read会阻塞，直到管道中有数据可读了才读取数据并返回。<br>如果所有指向管道读端的文件描述符都关闭了（管道读端的引用计数等于0），这时有进程向管道的写端write，那么该进程会收到信号SIGPIPE，通常会导致进程异常终止。在第 33 章 信号会讲到怎样使SIGPIPE信号不终止进程。<br>如果有指向管道读端的文件描述符没关闭（管道读端的引用计数大于0），而持有管道读端的进程也没有从管道中读数据，这时有进程向管道写端写数据，那么在管道被写满时再次write会阻塞，直到管道中有空位置了才写入数据并返回。</p>
</blockquote>
<p> 现在把进程之间传递信息的各种途径（包括各种IPC机制）总结如下：<br>-父进程通过fork可以将打开文件的描述符传递给子进程<br>-子进程结束时，父进程调用wait可以得到子进程的终止信息<br>-几个进程可以在文件系统中读写某个共享文件，也可以通过给文件加锁来实现进程间同步<br>-进程之间互发信号，一般使用SIGUSR1和SIGUSR2实现用户自定义功能<br>-管道<br>-FIFO<br>-mmap函数，几个进程可以映射同一内存区<br>-SYS V IPC，以前的SYS V UNIX系统实现的IPC机制，包括消息队列、信号量和共享内存，现在已经基本废弃<br>-UNIX Domain Socket，目前最广泛使用的IPC机制</p>
<h2 id="线程的通信"><a href="#线程的通信" class="headerlink" title="线程的通信"></a>线程的通信</h2><p>多个线程同时访问共享数据时可能会冲突，线程中的内存是共享的，导致所处理的变量是同一个，比如两个线程都要把某个全局变量增加1，这个操作在某平台需要三条指令完成：<br>1.从内存读变量值到寄存器<br>2.寄存器的值加1<br>3.将寄存器的值写回内存<br>假设两个线程在多处理器平台上同时执行这三条指令，则可能导致下图所示的结果，最后变量只加了一次而非两次。<br> <img src="/assets/blogImg/thread.corrupt.png" alt="&quot;我是傲娇的效果图&quot;"><br> 对于多线程的程序，访问冲突的问题是很普遍的，解决的办法是引入互斥锁（Mutex，Mutual Exclusive Lock），获得锁的线程可以完成“读-修改-写”的操作，然后释放锁给其它线程，没有获得锁的线程只能等待而不能访问共享数据，这样“读-修改-写”三步操作组成一个原子操作，要么都执行，要么都不执行，不会执行到中间被打断，也不会在其它处理器上并行做这个操作。<br> pthread_mutex_init函数对Mutex做初始化，参数attr设定Mutex的属性，如果attr为NULL则表示缺省属性，本章不详细介绍Mutex属性，感兴趣的读者可以参考[APUE2e]。用pthread_mutex_init函数初始化的Mutex可以用pthread_mutex_destroy销毁。如果Mutex变量是静态分配的（全局变量或static变量），也可以用宏定义PTHREAD_MUTEX_INITIALIZER来初始化，相当于用pthread_mutex_init初始化并且attr参数为NULL。Mutex的加锁和解锁操作可以用下列函数：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_lock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_trylock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div><div class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_mutex_unlock</span><span class="params">(<span class="keyword">pthread_mutex_t</span> *mutex)</span></span>;</div></pre></td></tr></table></figure></p>
<p>返回值：成功返回0，失败返回错误号。<br>一个线程可以调用pthread_mutex_lock获得Mutex，如果这时另一个线程已经调用pthread_mutex_lock获得了该Mutex，则当前线程需要挂起等待，直到另一个线程调用pthread_mutex_unlock释放Mutex，当前线程被唤醒，才能获得该Mutex并继续执行。<br>如果一个线程既想获得锁，又不想挂起等待，可以调用pthread_mutex_trylock，如果Mutex已经被另一个线程获得，这个函数会失败返回EBUSY，而不会使线程挂起等待。<br>Mutex的两个基本操作lock和unlock是如何实现的呢？假设Mutex变量的值为1表示互斥锁空闲，这时某个进程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被某个线程获得，其它线程再调用lock只能挂起等待。那么lock和unlock的伪代码如下：<br>lock:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(mutex &gt; <span class="number">0</span>)&#123;</div><div class="line">        mutex = <span class="number">0</span>;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">&#125; <span class="keyword">else</span></div><div class="line">        <span class="comment">//挂起等待;</span></div><div class="line">        <span class="keyword">goto</span> lock;</div><div class="line">unlock:</div><div class="line">        mutex = <span class="number">1</span>;</div><div class="line">        <span class="comment">//唤醒等待Mutex的线程;</span></div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">        unlock操作中唤醒等待线程的步骤可以有不同的实现，可以只唤醒一个等待线程，也可以唤醒所有等待该Mutex的线程，然后让被唤醒的这些线程去竞争获得这个Mutex，竞争失败的线程继续挂起等待。</div></pre></td></tr></table></figure></p>
<h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><p>1.一般情况下，如果同一个线程先后两次调用lock，在第二次调用时，由于锁已经被占用，该线程会挂起等待别的线程释放锁，然而锁正是被自己占用着的，该线程又被挂起而没有机会释放锁，因此就永远处于挂起等待状态了，这叫做死锁（Deadlock）。<br>2.另一种典型的死锁情形是这样：线程A获得了锁1，线程B获得了锁2，这时线程A调用lock试图获得锁2，结果是需要挂起等待线程B释放锁2，而这时线程B也调用lock试图获得锁1，结果是需要挂起等待线程A释放锁1，于是线程A和B都永远处于挂起状态了。不难想象，如果涉及到更多的线程和更多的锁，有没有可能死锁的问题将会变得复杂和难以判断。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title=" 参考文章:"></a> 参考文章:</h2><p><a href="https://akaedu.github.io/book/ch35s04.html" target="_blank" rel="external">线程</a><br><a href="https://akaedu.github.io/book/ch30s04.html" target="_blank" rel="external">进程间通信</a><br><a href="http://www.liaoxuefeng.com/wiki/001374738125095c955c1e6d8bb493182103fac9270762a000/0013868322563729e03f6905ea94f0195528e3647887415000" target="_blank" rel="external">进程和线程</a></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近对于进程和线程之间的关系及其本质有所疑惑，在网上查询了多个答案之后有了些感想，记录下&lt;/p&gt;
&lt;h2 id=&quot;多任务&quot;&gt;&lt;a href=&quot;#多任务&quot; class=&quot;headerlink&quot; title=&quot;多任务&quot;&gt;&lt;/a&gt;多任务&lt;/h2&gt;&lt;p&gt;现代操作系统比如Mac OS
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux基础" scheme="http://graychen.git.io/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Webpack595错误</title>
    <link href="http://graychen.git.io/2017/05/13/Webpack595%E9%94%99%E8%AF%AF/"/>
    <id>http://graychen.git.io/2017/05/13/Webpack595错误/</id>
    <published>2017-05-13T15:39:40.000Z</published>
    <updated>2017-06-20T06:30:10.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="错误情况"><a href="#错误情况" class="headerlink" title="错误情况"></a>错误情况</h2><p>Mix incompatible with Webpack 2.3.0? #595</p>
<h2 id="错误原因"><a href="#错误原因" class="headerlink" title="错误原因"></a>错误原因</h2><p>这是laravel5.4的错误webpack依赖包兼容问题</p>
<h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>在package,json 修改”aravel-mix”: “^0.10.0” 修复这个错误</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;错误情况&quot;&gt;&lt;a href=&quot;#错误情况&quot; class=&quot;headerlink&quot; title=&quot;错误情况&quot;&gt;&lt;/a&gt;错误情况&lt;/h2&gt;&lt;p&gt;Mix incompatible with Webpack 2.3.0? #595&lt;/p&gt;
&lt;h2 id=&quot;错误原因&quot;&gt;&lt;a
    
    </summary>
    
      <category term="错误日志" scheme="http://graychen.git.io/categories/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    
    
      <category term="错误日志" scheme="http://graychen.git.io/tags/%E9%94%99%E8%AF%AF%E6%97%A5%E5%BF%97/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu下lnmp快速搭建</title>
    <link href="http://graychen.git.io/2017/05/10/ubuntu%E4%B8%8Blnmp%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA/"/>
    <id>http://graychen.git.io/2017/05/10/ubuntu下lnmp快速搭建/</id>
    <published>2017-05-10T13:12:37.000Z</published>
    <updated>2017-06-20T06:30:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。</p>
<blockquote>
<p>下面的lnmp包括php7.1,mysql5.7,nginx1.2.8</p>
</blockquote>
<h2 id="安装php7-1"><a href="#安装php7-1" class="headerlink" title="安装php7.1"></a>安装php7.1</h2><p>安装 Php7.1 之前，要先安装language-pack-en-base这个包，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update  </div><div class="line">sudo apt-get install -y language-pack-en-base</div></pre></td></tr></table></figure>
<p>这个包是为了解决系统不同语言之间可能发生的冲突，安装之后可以减少许多因语言编码带来的问题。其中-y参数表明直接安装，无需确认。</p>
<p>安装完成之后，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">locale-gen en_US.UTF-8</div></pre></td></tr></table></figure>
<p>设定语言编码为<font color="red">UTF-8</font>。</p>
<p>进入正题，安装Php7.1，本教程采用ppa方式安装php7.1，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install software-properties-common</div></pre></td></tr></table></figure>
<p>software-properties-common是add-apt-repository所依赖的包，安装成功后，运行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo LC_ALL=en_US.UTF-8 add-apt-repository ppa:ondrej/php</div></pre></td></tr></table></figure>
<p>安装完成之后，运行<font color="red"><strong>sudo apt-get update</strong></font>更新安装包，把刚才添加的包拉取下来。 运行<strong><font color="red">apt-cache search php7.1</font></strong>搜索php7.1开头的包检验是否安装成功，输出如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">root@demo:~<span class="comment"># apt-cache search php7.1  </span></div><div class="line">php-yaml - YAML-1.1 parser and emitter <span class="keyword">for</span> PHP  </div><div class="line">php-apcu - APC User Cache <span class="keyword">for</span> PHP  </div><div class="line">php-ssh2 - Bindings <span class="keyword">for</span> the libssh2 library  </div><div class="line">php-igbinary - igbinary PHP serializer  </div><div class="line">php-mailparse - Email message manipulation <span class="keyword">for</span> PHP  </div><div class="line">php-libsodium - PHP wrapper <span class="keyword">for</span> the Sodium cryptographic library  </div><div class="line">php-propro - propro module <span class="keyword">for</span> PHP</div><div class="line"></div><div class="line">...</div><div class="line">...</div><div class="line">...</div></pre></td></tr></table></figure>
<p>安装php7.1</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get -y install php7.1</div></pre></td></tr></table></figure>
<p>安装完成后运行<strong><font color="red">php -v</font></strong>查看是否安装成功,成功的话显示</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">PHP 7.1.0beta2 (cli) ( NTS  )  </div><div class="line">Copyright (c) 1997-2016 The PHP Group  </div><div class="line">Zend Engine v3.1.0-dev, Copyright (c) 1998-2016 Zend Technologies  </div><div class="line">    with Zend OPcache v7.1.0beta2, Copyright (c) 1999-2016, by Zend Technologies</div></pre></td></tr></table></figure>
<p>接着安装php7.1-mysql，这是php和mysql通信的模块</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get -y install php7.1-mysql</div></pre></td></tr></table></figure>
<p>安装 fpm，这是Nginx 用来解析php文件的：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install php7.1-fpm</div></pre></td></tr></table></figure>
<p>安装其他必备模块：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">apt-get install php7.1-curl php7.1-xml php7.1-mcrypt php7.1-json php7.1-gd php7.1-mbstring</div></pre></td></tr></table></figure>
<p>至此与php相关的模块安装安装完成。</p>
<h2 id="安装Mysql"><a href="#安装Mysql" class="headerlink" title="安装Mysql"></a>安装Mysql</h2><p>直接安装Mysql5.7吧，5.7 可以说是里程碑式的版本，提高了性能，并增加了很多新的特性。特别是新增加的json字段，用过之后你会爱上她的！！</p>
<blockquote>
<p>MySQL 开发团队于 9.12 日宣布 MySQL 8.0.0 开发里程碑版本（DMR）发布！但是目前 8.0.0 还是开发版本，如果你希望体验和测试最新特性，可以从 <a href="http://dev.mysql.com/downloads/mysql/" target="_blank" rel="external">http://dev.mysql.com/downloads/mysql/</a> 下载各个平台的安装包。不过，MySQL 软件包是越来越大了，Linux 平台上的二进制打包后就将近有 1 GB。如果在产品环境中使用，在 8.0 没有进入稳定版本之前，请继续使用 5.7 系列，当前最新的版本是 5.7.15 GA 版本——这只有 600 M 多。<br>下载.deb包到你的服务器：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">wget http://dev.mysql.com/get/mysql-apt-config_0.5.3-1_all.deb</div></pre></td></tr></table></figure>
<p> 然后使用dpkg命令添加Mysql的源：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo dpkg -i mysql-apt-config_0.5.3-1_all.deb</div></pre></td></tr></table></figure></p>
<p>注意在添加源的时候，会叫你选择安装 MySQL 哪个应用，这里选择 Server 即可，再选择 MySQL 5.7 后又会回到选择应用的那个界面，此时选择 Apply 即可<br>安装</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div></pre></td><td class="code"><pre><div class="line">sudo apt-get update  </div><div class="line">sudo apt-get install mysql-server  </div><div class="line">``` </div><div class="line">安装完成之后运行mysql -V查看版本：</div><div class="line"></div><div class="line">``` bash</div><div class="line">root@demo:~<span class="comment"># mysql -V  </span></div><div class="line">``` </div><div class="line">mysql  Ver 14.14 Distrib 5.7.15, <span class="keyword">for</span> Linux (x86_64) using  EditLine wrapper  </div><div class="line">注意</div><div class="line"></div><div class="line">如果你已经通过 ppa 的方式安装了 MySQL 5.6，首先得去掉这个源</div><div class="line"></div><div class="line">``` bash</div><div class="line">sudo apt-add-repository --remove ppa:ondrej/mysql-5.6  </div><div class="line">``` </div><div class="line"> 如果没有 apt-add-repository 先安装上</div><div class="line">``` bash</div><div class="line"> sudo apt-get install software-properties-common</div><div class="line">``` </div><div class="line">然后其它和上面一样，但最后要运行sudo mysql_upgrade -u root -p升级数据库，运行sudo service mysql restart重启数据库，这样你的数据会完好无缺（不出意外的话）。</div><div class="line"><span class="comment">## 安装Nginx</span></div><div class="line">简单，运行：</div><div class="line">``` bash</div><div class="line">sudo apt-get -y install nginx  </div><div class="line">``` </div><div class="line"><span class="comment">## nginx配置php</span></div><div class="line"></div><div class="line">``` bash</div><div class="line">sudo vim /etc/php/7.1/fpm/php.ini  </div><div class="line">``` </div><div class="line">输入/fix_pathinfo搜索，将cgi.fix_pathinfo=1改为cgi.fix_pathinfo=0：</div><div class="line">编辑fpm的配置文件： 运行：</div><div class="line"></div><div class="line">``` bash</div><div class="line">sudo vim /etc/php/7.1/fpm/pool.d/www.conf  </div><div class="line">``` </div><div class="line">找到listen = /run/php/php7.1-fpm.sock修改为listen = 127.0.0.1:9000。使用9000端口。</div><div class="line"></div><div class="line">``` bash</div><div class="line">service php7.1-fpm stop</div><div class="line">service php7.1-fpm start</div><div class="line">``` </div><div class="line">配置Nginx：</div><div class="line"></div><div class="line">运行：</div><div class="line"></div><div class="line">``` bash</div><div class="line">sudo vim /etc/nginx/sites-available/default  </div><div class="line">``` </div><div class="line">下面是配置文件</div><div class="line">``` bash</div><div class="line">server &#123;  </div><div class="line">    <span class="comment">#listen 80 default_server;</span></div><div class="line">    listen 80;</div><div class="line">    <span class="comment">#listen [::]:80 default_server ipv6only=on;</span></div><div class="line">    </div><div class="line">    root /var/www;</div><div class="line">    index index.php index.html index.htm;</div><div class="line">                                        </div><div class="line">    <span class="comment"># Make site accessible from http://localhost/</span></div><div class="line">    server_name lufficc.com www.lufficc.com;</div><div class="line">    </div><div class="line">    location / &#123;</div><div class="line">        <span class="comment"># First attempt to serve request as file, then</span></div><div class="line">        <span class="comment"># as directory, then fall back to displaying a 404.</span></div><div class="line">        try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</div><div class="line">        <span class="comment"># Uncomment to enable naxsi on this location</span></div><div class="line">        <span class="comment"># include /etc/nginx/naxsi.rules</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    location ~ \.php$ &#123;</div><div class="line">        include snippets/fastcgi-php.conf;</div><div class="line">        <span class="comment"># With php7.0-cgi alone:</span></div><div class="line">        fastcgi_pass 127.0.0.1:9000;</div><div class="line">        <span class="comment"># With php7.0-fpm:</span></div><div class="line">        fastcgi_pass unix:/run/php/php7.0-fpm.sock;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line">``` </div><div class="line">&gt; </div><div class="line">  - root：是你的项目的public目录，也就是网站的入口</div><div class="line">  - index：添加了，index.php，告诉Nginx先解析index.php文件</div><div class="line">  - server_name：你的域名，没有的话填写localhost</div><div class="line">  - location / try_files修改为了try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.php?<span class="variable">$query_string</span>;</div><div class="line">  - location ~ \.php$部分告诉Nginx怎么解析Php，原封不动复制即可，但注意：fastcgi_pass unix:/var/run/php/php7.1-fpm.sock;的目录要和fpm的配置文件中的listen一致。</div><div class="line"></div><div class="line"><span class="comment">## 运行nginx服务</span></div><div class="line"></div><div class="line">``` bash</div><div class="line">sudo service nginx restart  </div><div class="line">sudo service php7.1-fpm restart</div></pre></td></tr></table></figure>
<p>如果出现下列错误<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[emerg]: <span class="built_in">bind</span>() to 0.0.0.0:80 failed (98: Address already <span class="keyword">in</span> use)</div></pre></td></tr></table></figure></p>
<p>这是80端口被占用，运行下面命令，关闭80端口</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo fuser -k 80/tcp</div><div class="line">service nginx start</div></pre></td></tr></table></figure>
<p><strong>好了，一切完成！</strong></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我所用的环境是ubuntu16.10，上篇博文是源码安装lnmp，但是大部分情况下没有这么多的精神和时间，这篇博文来介绍下利用apt-get这个工具来快速完成lnmp的搭建。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;下面的lnmp包括php7.1,mysql5.7,ngin
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://graychen.git.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>lnmp源码搭建</title>
    <link href="http://graychen.git.io/2017/05/08/lnmp%E6%BA%90%E7%A0%81%E6%90%AD%E5%BB%BA/"/>
    <id>http://graychen.git.io/2017/05/08/lnmp源码搭建/</id>
    <published>2017-05-08T14:47:02.000Z</published>
    <updated>2017-05-26T04:22:03.690Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql源码安装"><a href="#mysql源码安装" class="headerlink" title="mysql源码安装"></a>mysql源码安装</h2><p>1.安装编译源码需要的包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install make cmake gcc g++ bison libncurses5-dev</div></pre></td></tr></table></figure></p>
<p>2.下载相应源码包<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">[root@graychen ~]# wget https://sourceforge.net/projects/boost/files/boost/1.59.0/boost_1_59_0.tar.gz</div><div class="line">[root@graychen ~]# wget http://cdn.mysql.com/Downloads/MySQL-5.7/mysql-5.7.13.tar.gz</div></pre></td></tr></table></figure></p>
<p>3.新建MySQL用户和用户组<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@graychen ~]# groupadd -r mysql &amp;&amp; useradd -r -g mysql -s /sbin/nologin -M mysql</div></pre></td></tr></table></figure></p>
<p>4.预编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">[root@graychen ~]# tar -zxvf boost_1_59_0.tar.gz</div><div class="line">[root@graychen data]# md5sum mysql-5.7.13.tar.gz </div><div class="line">8fab75dbcafcd1374d07796bff88ae00  mysql-5.7.13.tar.gz</div><div class="line">[root@graychen ~]# tar -zxvf mysql-5.7.13.tar.gz</div><div class="line">[root@graychen data]# mkdir -p /data/mysql</div><div class="line">[root@graychen data]# cd mysql-5.7.13</div><div class="line">[root@graychen data]# cmake . -DCMAKE_INSTALL_PREFIX=/usr/local/mysql \</div><div class="line">-DMYSQL_DATADIR=/data/mysql \</div><div class="line">-DWITH_BOOST=../boost_1_59_0 \</div><div class="line">-DSYSCONFDIR=/etc \</div><div class="line">-DWITH_INNOBASE_STORAGE_ENGINE=1 \</div><div class="line">-DWITH_PARTITION_STORAGE_ENGINE=1 \</div><div class="line">-DWITH_FEDERATED_STORAGE_ENGINE=1 \</div><div class="line">-DWITH_BLACKHOLE_STORAGE_ENGINE=1 \</div><div class="line">-DWITH_MYISAM_STORAGE_ENGINE=1 \</div><div class="line">-DENABLED_LOCAL_INFILE=1 \</div><div class="line">-DENABLE_DTRACE=0 \</div><div class="line">-DDEFAULT_CHARSET=utf8mb4 \</div><div class="line">-DDEFAULT_COLLATION=utf8mb4_general_ci \</div><div class="line">-DWITH_EMBEDDED_SERVER=1</div></pre></td></tr></table></figure>
<p>5.编译安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# make -j `grep processor /proc/cpuinfo | wc -l`</div><div class="line">#编译很消耗系统资源，小内存可能编译通不过make install</div><div class="line">[root@graychen mysql-5.7.13]# make install</div></pre></td></tr></table></figure>
<p>6.设置启动脚本，开机自启动</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# ls -lrt /usr/local/mysql</div><div class="line">[root@graychen mysql-5.7.13]# cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld</div><div class="line">[root@graychen mysql-5.7.13]# chmod +x /etc/init.d/mysqld</div><div class="line">[root@graychen mysql-5.7.13]# systemctl enable mysqld</div><div class="line">mysqld.service is not a native service, redirecting to /sbin/chkconfig.</div><div class="line">Executing /sbin/chkconfig mysqld on</div></pre></td></tr></table></figure>
<p>7.配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div></pre></td><td class="code"><pre><div class="line">/etc/my.cnf，仅供参考 </div><div class="line">[root@graychen mysql-5.7.13]# cat &gt; /etc/my.cnf &lt;&lt; EOF</div><div class="line">[client]</div><div class="line">port = 3306</div><div class="line">socket = /dev/shm/mysql.sock</div><div class="line">[mysqld]</div><div class="line">port = 3306</div><div class="line">socket = /dev/shm/mysql.sock</div><div class="line">basedir = /usr/local/mysql</div><div class="line">datadir = /data/mysql</div><div class="line">pid-file = /data/mysql/mysql.pid</div><div class="line">user = mysql</div><div class="line">bind-address = 0.0.0.0</div><div class="line">server-id = 1</div><div class="line">init-connect = &apos;SET NAMES utf8mb4&apos;</div><div class="line">character-set-server = utf8mb4</div><div class="line">#skip-name-resolve</div><div class="line">#skip-networking</div><div class="line">back_log = 300</div><div class="line">max_connections = 1000</div><div class="line">max_connect_errors = 6000</div><div class="line">open_files_limit = 65535</div><div class="line">table_open_cache = 128</div><div class="line">max_allowed_packet = 4M</div><div class="line">binlog_cache_size = 1M</div><div class="line">max_heap_table_size = 8M</div><div class="line">tmp_table_size = 16M</div><div class="line">read_buffer_size = 2M</div><div class="line">read_rnd_buffer_size = 8M</div><div class="line">sort_buffer_size = 8M</div><div class="line">join_buffer_size = 8M</div><div class="line">key_buffer_size = 4M</div><div class="line">thread_cache_size = 8</div><div class="line">query_cache_type = 1</div><div class="line">query_cache_size = 8M</div><div class="line">query_cache_limit = 2M</div><div class="line">ft_min_word_len = 4</div><div class="line">log_bin = mysql-bin</div><div class="line">binlog_format = mixed</div><div class="line">expire_logs_days = 30</div><div class="line">log_error = /data/mysql/mysql-error.log</div><div class="line">slow_query_log = 1</div><div class="line">long_query_time = 1</div><div class="line">slow_query_log_file = /data/mysql/mysql-slow.log</div><div class="line">performance_schema = 0</div><div class="line">explicit_defaults_for_timestamp</div><div class="line">#lower_case_table_names = 1</div><div class="line">skip-external-locking</div><div class="line">default_storage_engine = InnoDB</div><div class="line">#default-storage-engine = MyISAM</div><div class="line">innodb_file_per_table = 1</div><div class="line">innodb_open_files = 500</div><div class="line">innodb_buffer_pool_size = 64M</div><div class="line">innodb_write_io_threads = 4</div><div class="line">innodb_read_io_threads = 4</div><div class="line">innodb_thread_concurrency = 0</div><div class="line">innodb_purge_threads = 1</div><div class="line">innodb_flush_log_at_trx_commit = 2</div><div class="line">innodb_log_buffer_size = 2M</div><div class="line">innodb_log_file_size = 32M</div><div class="line">innodb_log_files_in_group = 3</div><div class="line">innodb_max_dirty_pages_pct = 90</div><div class="line">innodb_lock_wait_timeout = 120</div><div class="line">bulk_insert_buffer_size = 8M</div><div class="line">myisam_sort_buffer_size = 8M</div><div class="line">myisam_max_sort_file_size = 10G</div><div class="line">myisam_repair_threads = 1</div><div class="line">interactive_timeout = 28800</div><div class="line">wait_timeout = 28800</div><div class="line">[mysqldump]</div><div class="line">quick</div><div class="line">max_allowed_packet = 16M</div><div class="line">[myisamchk]</div><div class="line">key_buffer_size = 8M</div><div class="line">sort_buffer_size = 8M</div><div class="line">read_buffer = 4M</div><div class="line">write_buffer = 4M</div><div class="line">EOF</div></pre></td></tr></table></figure>
<p>9.添加mysql的环境变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# echo -e &apos;\n\nexport PATH=/usr/local/mysql/bin:$PATH\n&apos; &gt;&gt; /etc/profile &amp;&amp; source /etc/profile</div></pre></td></tr></table></figure>
<p>10.初始化数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# mysqld --initialize-insecure --user=mysql --basedir=/usr/local/mysql --datadir=/data/mysql</div></pre></td></tr></table></figure>
<p>11.启动数据库</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# systemctl start mysqld</div><div class="line">[root@graychen mysql-5.7.13]# systemctl status mysqld</div><div class="line">● mysqld.service - LSB: start and stop MySQL</div><div class="line">Loaded: loaded (/etc/rc.d/init.d/mysqld)</div><div class="line">Active: active (running) since 一 2016-07-18 11:15:35 CST; 8s ago</div><div class="line">Docs: man:systemd-sysv-generator(8)</div><div class="line">Process: 23927 ExecStart=/etc/rc.d/init.d/mysqld start (code=exited, status=0/SUCCESS)</div><div class="line">CGroup: /system.slice/mysqld.service</div><div class="line">├─23940 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</div><div class="line">└─24776 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-err...</div><div class="line"></div><div class="line">7月 18 11:15:32 graychen systemd[1]: Starting LSB: start and stop MySQL...</div><div class="line">7月 18 11:15:35 graychen mysqld[23927]: Starting MySQL..[  OK   ]</div><div class="line">7月 18 11:15:35 graychen systemd[1]: Started LSB: start and stop MySQL.</div></pre></td></tr></table></figure>
<p>12.查看MySQL服务进程和端口<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# ps -ef | grep mysql</div><div class="line">root     23940     1  0 11:15 ?        00:00:00 /bin/sh /usr/local/mysql/bin/mysqld_safe --datadir=/data/mysql --pid-file=/data/mysql/mysql.pid</div><div class="line">mysql    24776 23940  0 11:15 ?        00:00:00 /usr/local/mysql/bin/mysqld --basedir=/usr/local/mysql --datadir=/data/mysql --plugin-dir=/usr/local/mysql/lib/plugin --user=mysql --log-error=/data/mysql/mysql-error.log --open-files-limit=65535 --pid-file=/data/mysql/mysql.pid --socket=/dev/shm/mysql.sock --port=3306</div><div class="line">[root@graychen mysql-5.7.13]# netstat -tunpl | grep 3306</div><div class="line">tcp        0      0 0.0.0.0:3306            0.0.0.0:*               LISTEN      24776/mysqld</div></pre></td></tr></table></figure></p>
<p>13.设置数据库root用户密码</p>
<p>MySQL和Oracle数据库一样，数据库也默认自带了一个 root 用户（这个和当前Linux主机上的root用户是完全不搭边的），我们在设置好MySQL数据库的安全配置后初始化root用户的密码。配制过程中，一路输入 y 就行了。这里只说明下MySQL5.7.13版本中，用户密码策略分成低级 LOW 、中等 MEDIUM 和超强 STRONG 三种，推荐使用中等 MEDIUM 级别！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[root@graychen mysql-5.7.13]# mysql_secure_installation</div></pre></td></tr></table></figure>
<h2 id="php源码安装"><a href="#php源码安装" class="headerlink" title="php源码安装"></a>php源码安装</h2><p>1.安装编译源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">wget http://am1.php.net/get/php-7.1.4.tar.bz2/from/mirror</div><div class="line">tar jxvf php-7.1.4.tar.bz2 </div><div class="line">bzip2 -d php-7.1.4.tar.bz2 </div><div class="line">cd php-7.1.4/</div><div class="line">./configure --prefix=/usr/local/php --with-config-file-path=/usr/local/php/etc --with-config-file-scan-dir=/usr/local/php/etc/php.d --with-mcrypt=/usr/include --enable-mysqlnd --with-mysqli --with-pdo-mysql --enable-fpm --with-fpm-user=nginx --with-fpm-group=nginx --with-iconv --with-zlib --enable-shmop --enable-sysvsem --enable-inline-optimization --enable-mbregex --enable-mbstring --enable-ftp --enable-gd-native-ttf --with-openssl --enable-pcntl --enable-sockets --with-xmlrpc --enable-zip --enable-soap --without-pear --with-gettext --enable-session --with-curl --with-jpeg-dir --with-freetype-dir --enable-opcache --with-libxml-dir=/usr</div><div class="line">sudo make test</div><div class="line">sudo make install</div></pre></td></tr></table></figure></p>
<p>2.配置php.ini<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cp php.ini-development /usr/local/php/etc/php.ini</div><div class="line">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</div></pre></td></tr></table></figure></p>
<p>3.配置php-fpm.conf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">cd /usr/local/php/etc/</div><div class="line">mv php-fpm.conf.default php-fpm.conf</div><div class="line">sudo mv php-fpm.conf.default php-fpm.conf</div><div class="line">sudo mv php-fpm.d/www.conf.default php-fpm.d/www.conf</div></pre></td></tr></table></figure></p>
<p>4.配置php-fpm开机启动<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">cd ~/src/php-7.1.4/sapi/fpm</div><div class="line">sudo cp init.d.php-fpm /etc/init.d/php-fpm</div><div class="line">sudo chmod +x /etc/init.d/php-fpm </div><div class="line">chkconfig --add php-fpm</div><div class="line">systemctl --add php-fpm</div><div class="line">sudo /sbin/chkconfig</div><div class="line">sudo vi /etc/init.d/php-fpm</div><div class="line">update-rc.d -f php-fpm defaults</div><div class="line">runlevel</div><div class="line">sudo service php-fpm start</div></pre></td></tr></table></figure></p>
<h2 id="nginx源码安装"><a href="#nginx源码安装" class="headerlink" title="nginx源码安装"></a>nginx源码安装</h2><p>1.下载源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">wget http://nginx.org/download/nginx-1.11.2.tar.gz</div><div class="line">tar -xzvf nginx-1.11.2.tar.gz -C /usr/src</div></pre></td></tr></table></figure></p>
<p>2.安装依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install gcc libpcre3 libpcre3-dev openssl libssl-dev libssl0.9.8 perl libperl-dev</div></pre></td></tr></table></figure></p>
<p>3.编译安装源码<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">cd /usr/src/nginx-1.11.2</div><div class="line"># 以下是一行。。用于生成makefile。如果需要添加第三方模块，使用--add-module=/path/module1的方法编译</div><div class="line">./configure --prefix=/usr/local/nginx --with-ipv6 --with-http_ssl_module --with-http_realip_module --with-http_addition_module --with-http_dav_module --with-http_flv_module --with-http_mp4_module --with-http_gzip_static_module --with-http_perl_module --with-mail --with-mail_ssl_module</div><div class="line"># make是生成在objs目录中，make install则安装到prefix所示的目录中</div><div class="line">make &amp;&amp; make install</div><div class="line"># 没有错误出现的话，就可以进入nginx安装目录(/usr/local/nginx)配置。</div></pre></td></tr></table></figure></p>
<blockquote>
<p>成功安装后，进入/usr/local/nginx，可以看到4个目录：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">root@graychen:/usr/local/nginx# ll</div><div class="line">total 44</div><div class="line">drwxr-xr-x 11 root   root 4096 Jul 26 10:06 ./</div><div class="line">drwxr-xr-x 12 root   root 4096 Jul 26 10:03 ../</div><div class="line">drwxr-xr-x  2 root   root 4096 Jul 26 10:11 conf/</div><div class="line">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 html/</div><div class="line">drwxr-xr-x  2 root   root 4096 Jul 26 10:07 logs/</div><div class="line">drwxr-xr-x  2 root   root 4096 Jul 26 10:03 sbin/</div></pre></td></tr></table></figure></p>
</blockquote>
<p>其中，</p>
<p> conf：放置nginx相关的配置文件，最核心的是nginx.conf<br> html：默认的网站根目录<br> logs：日志文件目录(访问日志，错误日志，运行时的进程id cat logs/nginx.pid)<br> sbin：主程序(nginx)目录<br>4.配置Nginx开机自启动<br>Ubuntu/Linux系统开机自启动，很简单，在/etc/init.d/目录下编写一个服务脚本(比如nginx)，然后在/etc/init.d/rc.local中添加一行启动命令。操作步骤如下</p>
<blockquote>
<ul>
<li><p>vi /etc/init.d/nginx ,其中具体的脚本展示如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div></pre></td><td class="code"><pre><div class="line">[plain] view plain copy</div><div class="line"></div><div class="line"> #!/bin/bash</div><div class="line"> # nginx Startup script for the Nginx HTTP Server</div><div class="line"> # it is v.0.0.2 version.</div><div class="line"> # chkconfig: - 85 15</div><div class="line"> # description: Nginx is a high-performance web and proxy server.</div><div class="line"> #              It has a lot of features, but it&apos;s not for everyone.</div><div class="line"> # processname: nginx</div><div class="line"> # pidfile: /var/run/nginx.pid</div><div class="line"> # config: /usr/local/nginx/conf/nginx.conf</div><div class="line"></div><div class="line"> #注意：这里的三个变量需要根据具体的环境而做修改。</div><div class="line"> nginxd=/opt/nginx/sbin/nginx</div><div class="line"> nginx_config=/opt/nginx/conf/nginx.conf</div><div class="line"> nginx_pid=/opt/nginx/logs/nginx.pid</div><div class="line"> RETVAL=0</div><div class="line"> prog=&quot;nginx&quot;</div><div class="line"></div><div class="line"> # Check that networking is up.</div><div class="line"> [ -x $nginxd  ] || exit 0</div><div class="line"> # Start nginx daemons functions.</div><div class="line"> start() &#123;</div><div class="line">     if [ -e $nginx_pid  ];then</div><div class="line">        echo &quot;nginx already running....&quot;</div><div class="line">        exit 1</div><div class="line">     fi</div><div class="line">        echo -n $&quot;Starting $prog: &quot;</div><div class="line">        $nginxd -c $&#123;nginx_config&#125;</div><div class="line">        RETVAL=$?</div><div class="line">        echo</div><div class="line">        [ $RETVAL = 0  ]</div><div class="line">        return $RETVAL</div><div class="line">     </div><div class="line">&#125;</div><div class="line"> # Stop nginx daemons functions.</div><div class="line"> stop() &#123;</div><div class="line">       echo -n $&quot;Stopping $prog: &quot;</div><div class="line">       $nginxd -s stop</div><div class="line">       RETVAL=$?</div><div class="line">       echo</div><div class="line">       [ $RETVAL = 0  ] &amp;&amp; rm -f /var/lock/subsys/nginx $nginx_pid</div><div class="line">     </div><div class="line">&#125;</div><div class="line"> # reload nginx service functions.</div><div class="line"> reload() &#123;</div><div class="line">       echo -n $&quot;Reloading $prog: &quot;</div><div class="line">       kill -HUP `cat $&#123;nginx_pid&#125;`</div><div class="line">       RETVAL=$?</div><div class="line">       echo</div><div class="line">     </div><div class="line">&#125;</div><div class="line"> # See how we were called.</div><div class="line"> case &quot;$1&quot; in</div><div class="line">   start)</div><div class="line">           start</div><div class="line">           ;;</div><div class="line">   stop)</div><div class="line">           stop</div><div class="line">           ;;</div><div class="line">   reload)</div><div class="line">           reload</div><div class="line">           ;;</div><div class="line">   restart)</div><div class="line">           stop</div><div class="line">           start</div><div class="line">           ;;</div><div class="line">   status)</div><div class="line">           status $prog</div><div class="line">           RETVAL=$?</div><div class="line">           ;;</div><div class="line">   *)</div><div class="line">           echo $&quot;Usage: $prog &#123;start|stop|restart|reload|status|help&#125;&quot;</div><div class="line">           exit 1</div><div class="line"> esac</div><div class="line"> exit $RETVAL</div></pre></td></tr></table></figure>
</li>
<li><p>sudo chmod a+x /etc/init.d/nginx</p>
</li>
<li>在rc.local文件的最后中添加如下的一行: /etc/init.d/nginx start<br>最后，nginx可以通过 /etc/init.d/nginx start或者 service nginx start进行启动。</li>
</ul>
</blockquote>
<p>到这里整个LNMP已经安装完成.</p>
<h2 id="nginx和php的关联"><a href="#nginx和php的关联" class="headerlink" title="nginx和php的关联"></a>nginx和php的关联</h2><p>下面我们就配置php和nginx能运行php网站: 首先为php创建配置文件:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cp php.ini-production /usr/local/php/php.ini # 如果是开发就复制php.ini-development</div><div class="line">cp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.conf</div><div class="line">ln -s /usr/local/php/bin/php /usr/bin/</div></pre></td></tr></table></figure></p>
<p>配置php-fpm,编辑php-fpm.conf</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /usr/local/php/etc/php-fpm.conf</div></pre></td></tr></table></figure>
<p>找到listen那一行,修改成如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">listen = /var/run/php-fpm/php-fpm.sock   # 使用unix socket</div></pre></td></tr></table></figure>
<p>启动php-fpm</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">mkdir /var/run/php-fpm</div><div class="line">/usr/local/php/sbin/php-fpm</div></pre></td></tr></table></figure>
<p>然后配置nginx,编辑nginx配置文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi /usr/local/nginx/conf/nginx.conf</div></pre></td></tr></table></figure>
<p>修改nginx配置文件支持php:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">server &#123;</div><div class="line">        listen       80;</div><div class="line">        server_name  localhost;</div><div class="line"></div><div class="line">        #charset koi8-r;</div><div class="line"></div><div class="line">        #access_log  logs/host.access.log  main;</div><div class="line"></div><div class="line">        location / &#123;</div><div class="line">            root   html;</div><div class="line">            index  index.php index.html index.htm;         # 添加index.php的首页文件</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        # 添加下面内容</div><div class="line">        location ~ \.php$ &#123;</div><div class="line">            fastcgi_pass        unix:/var/run/php-fpm/php-fpm.sock;</div><div class="line">            fastcgi_index       index.php;</div><div class="line">            fastcgi_param SCRIPT_FILENAME $document_root/$fastcgi_script_name;</div><div class="line">            include fastcgi_params;</div><div class="line">            include fastcgi.conf;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改完毕后保存退出重启nginx:</p>
<p>pkill -9 nignx<br>/usr/local/nginx/sbin/nginx<br>然后在/usr/local/nginx/html下创建index.php,</p>
<p>vi /usr/local/nginx/html/index.php<br>添加下面内容:<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line">phpinfo();</div><div class="line"><span class="meta">?&gt;</span></div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>保存退出后访问<a href="http://localhost/index.php,看到下面页面表示已经安装配置成功" target="_blank" rel="external">http://localhost/index.php,看到下面页面表示已经安装配置成功</a>:</p>
<p><img src="/assets/blogImg/php.png" alt="php页面"></p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;mysql源码安装&quot;&gt;&lt;a href=&quot;#mysql源码安装&quot; class=&quot;headerlink&quot; title=&quot;mysql源码安装&quot;&gt;&lt;/a&gt;mysql源码安装&lt;/h2&gt;&lt;p&gt;1.安装编译源码需要的包&lt;br&gt;&lt;figure class=&quot;highlight p
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
  </entry>
  
  <entry>
    <title>计划虽然不酷，但是很有用</title>
    <link href="http://graychen.git.io/2017/02/04/%E8%AE%A1%E5%88%92%E8%99%BD%E7%84%B6%E4%B8%8D%E9%85%B7%EF%BC%8C%E4%BD%86%E6%98%AF%E5%BE%88%E6%9C%89%E7%94%A8/"/>
    <id>http://graychen.git.io/2017/02/04/计划虽然不酷，但是很有用/</id>
    <published>2017-02-04T06:26:37.000Z</published>
    <updated>2017-06-20T06:30:10.856Z</updated>
    
    <content type="html"><![CDATA[<p>这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！<br> <img src="/assets/blogImg/女神2.jpg" alt="&quot;我是傲娇的女神&quot;"><br> 请收下这波安利，好了，安利结束，我们谈正事，写这篇文章的目的是自己过于散漫，做事不够坚持，然后看到有人凭着年度计划，一步步完善自己，所以我也想试试，学习优秀的人的习惯，总不至于让自己变得太差。</p>
<h2 id="目标"><a href="#目标" class="headerlink" title="目标"></a>目标</h2><p> 我的目标是什么呢？在工作之余，以三个月为限，做出上线运营的项目，也就是说我的2017要产出4个上线的项目，每个季度都要产出一个线上运营的项目，而且这都是业余时间完成的，这对我真是一个不小的挑战了，<br> 我希望自己能产出卓越的产品，但是我认为没有量的积累，这永远都不可能，千里之行，始于足下，我这几个产品可能不会优秀,不够细致，过于粗糙，但是<br> 完成比完美重要，上线就是我的目的。之前都是学习技术，今年我会转向输出,输出产品。</p>
<h2 id="计划"><a href="#计划" class="headerlink" title="计划"></a>计划</h2><p> 我的计划是什么呢？一个季度是三个月，每个月是4个星期，这是一个系列文章，我会在每个周日的晚上发博文(很可能是微博)来报告这周的完成情况和下周的计划安排,并且这个过程是透明的，我写下的所有源码我都会放到github上，从这个网站上<br> 你将会看到我的行动轨迹，我有没有食言，只要方格是绿色的，那就表示我输出了很多的代码，否则我可能就是食言了，但愿不要吧,我还是比较虚的！</p>
<h2 id="计划详情"><a href="#计划详情" class="headerlink" title="计划详情"></a>计划详情</h2><p> 事先声明，这篇博客我会持续更新的，我思考了下决定了我的第一个项目，我会给它起一个有趣的代号，因为我喜欢看一些动漫，所以我决定给他们起动漫中的物品</p>
<h2 id="我是傲娇的分割线O-∩-∩-O"><a href="#我是傲娇的分割线O-∩-∩-O" class="headerlink" title="我是傲娇的分割线O(∩_∩)O~~"></a>我是傲娇的分割线O(∩_∩)O~~</h2><h3 id="第一个项目"><a href="#第一个项目" class="headerlink" title="第一个项目"></a>第一个项目</h3><h4 id="代号：OnePiece"><a href="#代号：OnePiece" class="headerlink" title="代号：OnePiece"></a>代号：<strong>OnePiece</strong></h4><p><img src="/assets/blogImg/onepiece.png" alt="&quot;我是伟大的OnePiece&quot;"></p>
<blockquote>
<p>这是海贼王的伟大冒险的终点，当然也是所有故事的起点，是引起这个海贼世界变革的重要地点，我特别欣赏里面的对梦想的执着和对友情的重视,所以我的第一个项目以此为名。</p>
</blockquote>
<h4 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h4><p>这个项目我决定做一个租借平台,总有一些东西让我们食之无味，弃之可惜，这个项目要把那些人们不舍得的东西放到网上出租，第一个月我想把最核心的浏览列表和上传物品的功能做完，有别于寻常的项目，我这次要从前台开始做起，<br>前台做完之后再开始做后台功能，我要倒过来做。</p>
<h4 id="可能会用到的技术"><a href="#可能会用到的技术" class="headerlink" title="可能会用到的技术"></a>可能会用到的技术</h4><ul>
<li>语言：php+js</li>
<li>框架：laravel+vue.js</li>
<li>平台：移动端</li>
<li>类型：移动端的网站<br>做这些项目当然也要提要自己啦，我会尽可能尝试不同的语言，第一个项目我的技术选型相对保守，先从最熟悉的技术开始实现吧。由于我不是专业的设计，前期的页面可能相对粗糙，还请见谅。<h4 id="项目时间安排"><a href="#项目时间安排" class="headerlink" title="项目时间安排"></a>项目时间安排</h4>今天已经是二月5日了，由于我这个人懒得算数，就以二月份开始吧，那么截止时间就定在4月30号，4月30号我会做项目演示，会公布线上网址（如果我做好的话）</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是一遍迟到的年度计划了，这篇文章的名字是取自我最近看的日剧《逃避虽然可耻，但是很有用》,说到这里，女神镇楼！&lt;br&gt; &lt;img src=&quot;/assets/blogImg/女神2.jpg&quot; alt=&quot;&amp;quot;我是傲娇的女神&amp;quot;&quot;&gt;&lt;br&gt; 请收下这波安利，好了，
    
    </summary>
    
      <category term="随笔" scheme="http://graychen.git.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="php" scheme="http://graychen.git.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>Composer包是怎样炼成的</title>
    <link href="http://graychen.git.io/2016/10/19/composer%E5%8C%85%E6%98%AF%E6%80%8E%E6%A0%B7%E7%82%BC%E6%88%90%E7%9A%84/"/>
    <id>http://graychen.git.io/2016/10/19/composer包是怎样炼成的/</id>
    <published>2016-10-19T03:20:43.000Z</published>
    <updated>2017-06-20T06:30:10.856Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p><strong>Composer</strong>是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 –<a href="http://www.phpcomposer.com/" target="_blank" rel="external">Composer中文网</a></p>
</blockquote>
<p>关于Composer的安装和下载可以直接点击上方的链接查看，本篇博文主要讲解该怎样创建自己的Composer包，并把它提交到<a href="https://packagist.org/" target="_blank" rel="external">packgist</a></p>
<h2 id="创建组件"><a href="#创建组件" class="headerlink" title="创建组件"></a>创建组件</h2><h3 id="产商名称和包名"><a href="#产商名称和包名" class="headerlink" title="产商名称和包名"></a>产商名称和包名</h3><p>在设置命名空间之前，先要确定产商名称和包名，类似于<strong>laravel/framework</strong>,确保它的唯一性，在packgist中不存在.厂商名称和包名是为了让packgist识别组件，而组件的命名空间是为了在php中使用组件，这是两个概念。</p>
<h3 id="文件系统结构"><a href="#文件系统结构" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><ul>
<li><strong>src</strong>:这个目录用于存放组件的源码   </li>
<li><strong>tests</strong>:这个目录用于存放测试代码   </li>
<li><strong>composer.json</strong>:Composer配置文件，用于描述组件，声明组件依赖以及自动加载配置等   </li>
<li><strong>README.md</strong>:这个Markdown提供组件的相关信息,使用文档说明软件许可证等   </li>
<li><strong>CONTRIBUTING.md</strong>:这个Markdown文件告知别人如何为这个组件做贡献  </li>
<li><strong>LICENSE</strong>：纯文本文件，声明组件的软件许可证</li>
<li><strong>CHANGELOG.md</strong>：Markdown文件，列出组件在每个版本中引入的改动</li>
</ul>
<h3 id="文件系统结构-1"><a href="#文件系统结构-1" class="headerlink" title="文件系统结构"></a>文件系统结构</h3><p>我们新建一个组件目录（~/Packages/urlscanner），然后在urlscanner目录下通过如下命令生成composer.json文件：<br>composer init</p>
<p>然后在终端会让我们按照提示向导一步步填写composer.json内容：<br>最后回车，会生成相应的composer.json文件，我们对该文件作如下修改：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">    <span class="string">"name"</span>: <span class="string">"graychen/container"</span>,</div><div class="line">    <span class="string">"description"</span>: <span class="string">"a container for interface and container"</span>,</div><div class="line">    <span class="string">"license"</span>: <span class="string">"MIT"</span>,</div><div class="line">    <span class="string">"authors"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"name"</span>: <span class="string">"Graychen"</span>,</div><div class="line">            <span class="string">"email"</span>: <span class="string">"13780185250@sina.cn"</span></div><div class="line">        &#125;</div><div class="line">    ],</div><div class="line">    <span class="string">"minimum-stability"</span>: <span class="string">"dev"</span>,</div><div class="line">    <span class="string">"require"</span>: &#123;&#125;,</div><div class="line">    <span class="string">"require-dev"</span>: &#123;</div><div class="line">            <span class="string">"phpunit/phpunit"</span> : <span class="string">"~4.3"</span> </div><div class="line">        &#125;,</div><div class="line">    <span class="string">"autoload"</span>:&#123;</div><div class="line">        <span class="string">"psr-4"</span>:&#123;</div><div class="line">            <span class="string">"graychen\\container\\"</span> : <span class="string">"src"</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">    <span class="string">"autoload-dev"</span>:&#123;</div><div class="line">        <span class="string">"psr-4"</span>:&#123;</div><div class="line">            <span class="string">"graychen\\container\\Tests\\"</span>:<span class="string">"tests/"</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>我们来仔细研究一下这个文件，看看每个部分究竟是什么意思：</p>
<ul>
<li>name：组件的厂商名和包名，也是Packagist中的组件名</li>
<li>description：简要说明组件</li>
<li>keywords：描述属性的关键字</li>
<li>homepage：组件网站URL</li>
<li>license：PHP组件采用的软件许可证（更多软件许可证参考：<a href="http://choosealicense.com/）" target="_blank" rel="external">http://choosealicense.com/）</a></li>
<li>authors：作者信息数组</li>
<li>support：组件用户获取技术支持的方式</li>
<li>require：组件自身依赖的组件</li>
<li>require-dev：开发这个组件所需的依赖</li>
<li>suggest：建议安装的组件</li>
<li>autoload：告诉Composer自动加载器如何自动加载这个组件</li>
</ul>
<p>READEME.md</p>
<p>通常这个是用户最先阅读的文件，对托管在Github和Bitbucket中的组件来说，更是如此。标准的READEME.md文件至少提供以下信息：</p>
<ul>
<li>组件的名称和描述</li>
<li>安装说明</li>
<li>使用说明</li>
<li>测试说明</li>
<li>贡献方式</li>
<li>支持资源</li>
<li>作者信息</li>
<li>软件许可证</li>
</ul>
<p>实现组件</p>
<p>开始之前我们使用如下命令安装依赖：<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">composer install</div></pre></td></tr></table></figure></p>
<p>该命令会把依赖组件安装到vendor目录并生成自动加载器。<br>安装好以后我们来实现组件的具体功能。将所有的类，接口和Trait都放到src这个目录下。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="keyword">namespace</span> <span class="title">container</span>;</div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@brief</span> 服务容器</div><div class="line">* author Graychen</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">implements</span> \<span class="title">ArrayAccess</span></span>&#123;</div><div class="line">    <span class="keyword">private</span> $_bindings = [];<span class="comment">//服务列表</span></div><div class="line">    <span class="keyword">private</span> $_instances= [];<span class="comment">//已经实例化的服务</span></div><div class="line">    <span class="comment">//获取服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name,$params=[])</span></span>&#123;</div><div class="line">        <span class="comment">//先从实例化的列表中查找</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$_instances[$name]))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;$_instances[$name]; </div><div class="line">        &#125;</div><div class="line">        <span class="comment">//检测有没有注册该服务</span></div><div class="line">        <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;$_bindings[$name]))&#123;</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">        $concrete = <span class="keyword">$this</span>-&gt;$_bindings[$name][<span class="string">'class'</span>];<span class="comment">//对象具体注册内容</span></div><div class="line">        $obj = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span>($concrete <span class="keyword">instanceof</span> \Closure)&#123; <span class="comment">//匿名函数方式</span></div><div class="line">            $obj = call_user_func_array($concrete,$params);</div><div class="line">        &#125;<span class="keyword">elseif</span>(is_string($concrete))&#123;     <span class="comment">//字符串方式</span></div><div class="line">            <span class="keyword">if</span>(<span class="keyword">empty</span>($params))&#123;</div><div class="line">                $obj = <span class="keyword">new</span> $concrete;</div><div class="line">            &#125;<span class="keyword">else</span>&#123;</div><div class="line">                <span class="comment">//带参数的类实例化,使用反射</span></div><div class="line">                $class = <span class="keyword">new</span> \reflectionClass($concrete);</div><div class="line">                $obj = $class-&gt;newInstanceArgs($params);</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class="line">        <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_bindings[$name][<span class="string">'shared'</span>]==<span class="keyword">true</span> &amp;&amp; $ojb)&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_instances[$name]=$obj;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> $obj;</div><div class="line">    &#125; </div><div class="line">    <span class="comment">//检测是否已经绑定</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">has</span><span class="params">($name)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_bindings[$name]) <span class="keyword">or</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_instances[$name]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//卸载服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">($name)</span></span>&#123;</div><div class="line">        <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;_bindings[$name],<span class="keyword">$this</span>-&gt;_instances[$name]);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($name,$class)</span></span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;_registerService($name,$class);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//设置共享服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setShared</span><span class="params">($name,$class)</span></span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;_registerService($name,$class,<span class="keyword">true</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//注册服务</span></div><div class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">_registerService</span><span class="params">($name,$class,$shared=false)</span></span>&#123;</div><div class="line">        <span class="keyword">$this</span>-&gt;remove($name);</div><div class="line">        <span class="keyword">if</span>(!($class <span class="keyword">instanceof</span> \Closure) &amp;&amp; is_object($class))&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_instances[$name]=$class;</div><div class="line">        &#125;<span class="keyword">else</span>&#123;</div><div class="line">            <span class="keyword">$this</span>-&gt;_bindings[$name]=<span class="keyword">array</span>(<span class="string">"class"</span>=&gt;$class,<span class="string">"shared"</span>=&gt;$shared); </div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//ArrayAccess接口，检测服务是否存在</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetExists</span><span class="params">($offset)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;has($offset);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//ArrayAccess接口,以$di[$name]方式获取服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetGet</span><span class="params">($offset)</span></span>&#123;</div><div class="line">       <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;get($offset); </div><div class="line">    &#125;</div><div class="line">    <span class="comment">//ArrayAccess接口,以$di[$name]方式获取服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetSet</span><span class="params">($offset,$value)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;set($offset,$value);</div><div class="line">    &#125;</div><div class="line">    <span class="comment">//卸载服务</span></div><div class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetUnset</span><span class="params">($offset)</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;remove($offset);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="提交到packglist"><a href="#提交到packglist" class="headerlink" title="提交到packglist"></a>提交到packglist</h3><p>我们先将代码提交到GitHub,注意将vendor目录添加到.gitignore仓库,我的是graychen/container：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git remote add origin https://github.com/nonfu/urlscanner.git</div><div class="line">git add .</div><div class="line">git commit -m “urlscanner&quot;</div><div class="line">git pull origin master</div><div class="line">git push origin master</div></pre></td></tr></table></figure></p>
<p> <img src="/assets/blogImg/Graychen-Container.gif" alt="&quot;我是傲娇的效果图&quot;"><br> 然后在Packagist中通过GitHub账户登录，通过<a href="https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：" target="_blank" rel="external">https://packagist.org/packages/submit提交组件，在输入框中输入刚刚提交的GitHub仓库地址：</a><br> check成功后点击submit即可将组件提交到Packagist：<br> <img src="/assets/blogImg/Packagist.gif" alt="&quot;我是傲娇的效果图&quot;"></p>
<h2 id="使用组件"><a href="#使用组件" class="headerlink" title="使用组件"></a>使用组件</h2><p> 至此，我们已经成功将自己的组件提交到Packagist，现在任何人都可以使用Composer安装这个URL扫描器组件，然后在自己的PHP应用中使用。在终端执行如下命令安装这个组件：</p>
<p> composer require graychen/container dev-master</p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Composer&lt;/strong&gt;是php用来管理依赖关系的工具，你可以在自己的项目中声明所依赖的外部工具库，Composer会帮助你安装这些依赖的库文件 –&lt;a href=&quot;http://www.phpcomposer.com/&quot;
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php" scheme="http://graychen.git.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>深入解析php的容器模式</title>
    <link href="http://graychen.git.io/2016/10/19/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90php%E7%9A%84%E5%AE%B9%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://graychen.git.io/2016/10/19/深入解析php的容器模式/</id>
    <published>2016-10-19T03:20:43.000Z</published>
    <updated>2017-05-26T04:22:03.690Z</updated>
    
    <content type="html"><![CDATA[<p>先说结论，<strong>容器</strong>在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。</p>
<h3 id="我是傲娇的代码块"><a href="#我是傲娇的代码块" class="headerlink" title="我是傲娇的代码块:"></a>我是傲娇的代码块:</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@brief</span> 服务容器</div><div class="line">* author Graychen</div><div class="line"> */</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Container</span> <span class="keyword">implements</span> \<span class="title">ArrayAccess</span></span>&#123;</div><div class="line">  <span class="keyword">private</span> $_binContainerngs = [];<span class="comment">//服务列表</span></div><div class="line">  <span class="keyword">private</span> $_instances= [];<span class="comment">//已经实例化的服务</span></div><div class="line"></div><div class="line">  <span class="comment">//获取服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name,$params=[])</span></span>&#123;</div><div class="line">  <span class="comment">//先从实例化的列表中查找</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_instances[$name]))&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_instances[$name];</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//检测有没有注册该服务</span></div><div class="line">  <span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_binContainerngs[$name]))&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  $concrete = <span class="keyword">$this</span>-&gt;_binContainerngs[$name][<span class="string">'class'</span>];<span class="comment">//对象具体注册内容</span></div><div class="line"></div><div class="line">  $obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line">  <span class="keyword">if</span>($concrete <span class="keyword">instanceof</span> \Closure)&#123; <span class="comment">//匿名函数方式</span></div><div class="line">  $obj = call_user_func_array($concrete,$params);</div><div class="line">  &#125;<span class="keyword">elseif</span>(is_string($concrete))&#123; <span class="comment">//字符串方式</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">empty</span>($params))&#123;</div><div class="line">  $obj = <span class="keyword">new</span> $concrete;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="comment">//带参数的类实例化,使用反射</span></div><div class="line">  $class = <span class="keyword">new</span> \reflectionClass($concrete);</div><div class="line">  $obj = $class-&gt;newInstanceArgs($params);</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class="line">  <span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_binContainerngs[$name][<span class="string">'shared'</span>]==<span class="keyword">true</span> &amp;&amp; $ojb)&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;_instances[$name]=$obj;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> $obj;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//检测是否已经绑定</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">has</span><span class="params">($name)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_binContainerngs[$name]) <span class="keyword">or</span> <span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_instances[$name]);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">//卸载服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">remove</span><span class="params">($name)</span></span>&#123;</div><div class="line">  <span class="keyword">unset</span>(<span class="keyword">$this</span>-&gt;_binContainerngs[$name],<span class="keyword">$this</span>-&gt;_instances[$name]);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//设置服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">set</span><span class="params">($name,$class)</span></span>&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;_registerService($name,$class);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//设置共享服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">setShared</span><span class="params">($name,$class)</span></span>&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;_registerService($name,$class,<span class="keyword">true</span>);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//注册服务</span></div><div class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">function</span> <span class="title">_registerService</span><span class="params">($name,$class,$shared=false)</span></span>&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;remove($name);</div><div class="line">  <span class="keyword">if</span>(!($class <span class="keyword">instanceof</span> \Closure) &amp;&amp; is_object($class))&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;_instances[$name]=$class;</div><div class="line">  &#125;<span class="keyword">else</span>&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;_binContainerngs[$name]=<span class="keyword">array</span>(<span class="string">"class"</span>=&gt;$class,<span class="string">"shared"</span>=&gt;$shared);</div><div class="line">  &#125;</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//ArrayAccess接口，检测服务是否存在</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetExists</span><span class="params">($offset)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;has($offset);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//ArrayAccess接口,以$Container[$name]方式获取服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetGet</span><span class="params">($offset)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;get($offset);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//ArrayAccess接口,以$Container[$name]方式获取服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetSet</span><span class="params">($offset,$value)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;set($offset,$value);</div><div class="line">  &#125;</div><div class="line">  <span class="comment">//卸载服务</span></div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">offsetUnset</span><span class="params">($offset)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">$this</span>-&gt;remove($offset);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用方式"><a href="#使用方式" class="headerlink" title="使用方式"></a>使用方式</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&lt;?php</span></div><div class="line">header(<span class="string">"Content-Type:text/html;charset=utf8"</span>);</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</div><div class="line">  <span class="keyword">public</span> $name;</div><div class="line">  <span class="keyword">public</span> $age;</div><div class="line">  <span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">__construct</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">$this</span>-&gt;name = $name;</div><div class="line"></div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">include</span> <span class="string">"Container.class.php"</span>;</div><div class="line">$Container = <span class="keyword">new</span> Container();</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@brief</span> $Container-&gt;setShared 匿名函数方式注册一个名为a1的服务</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> 'a1'</div><div class="line">* <span class="doctag">@param</span></div><div class="line">*/</div><div class="line">$Container-&gt;setShared(<span class="string">'a1'</span>,<span class="function"><span class="keyword">function</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> A($name);</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">$a1 = $Container-&gt;get(<span class="string">'a1'</span>,<span class="keyword">array</span>(<span class="string">"小李"</span>));</div><div class="line"><span class="keyword">echo</span> $a1-&gt;name.<span class="string">"&lt;br/&gt;"</span>;<span class="comment">//小李</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@brief</span> $Container-&gt;set 直接以类名方式注册</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> 'a2'</div><div class="line">* <span class="doctag">@param</span> 'A'</div><div class="line">*/</div><div class="line">$Container-&gt;set(<span class="string">'a2'</span>,<span class="string">'A'</span>);</div><div class="line"></div><div class="line">$a2 = $Container-&gt;get(<span class="string">'a2'</span>,<span class="keyword">array</span>(<span class="string">"小张"</span>));</div><div class="line"><span class="keyword">echo</span> $a2-&gt;name.<span class="string">"&lt;br/&gt;"</span>;<span class="comment">//小张</span></div><div class="line"><span class="comment">/**</span></div><div class="line">* <span class="doctag">@brief</span> $Container-&gt;set 直接传入实例化的对象</div><div class="line">*</div><div class="line">* <span class="doctag">@param</span> 'a3'</div><div class="line">* <span class="doctag">@param</span> "小唐"</div><div class="line">*/</div><div class="line">$Container-&gt;set(<span class="string">'a3'</span>,<span class="keyword">new</span> A(<span class="string">"小唐"</span>));</div><div class="line"><span class="keyword">echo</span> $a3-&gt;name.<span class="string">"&lt;br/&gt;"</span>;<span class="comment">//小唐</span></div></pre></td></tr></table></figure>
<h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>通过上面的代码实例，我们可以看到php注入容器(数组)的三种方式</p>
<ul>
<li>匿名函数方式注册</li>
<li>类名方式注册</li>
<li>直接传入实例化的对象的注册<br>然后get方法<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取服务</span></div><div class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">get</span><span class="params">($name,$params=[])</span></span>&#123;</div><div class="line"><span class="comment">//先从实例化的列表中查找</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_instances[$name]))&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">$this</span>-&gt;_instances[$name];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">//检测有没有注册该服务</span></div><div class="line"><span class="keyword">if</span>(!<span class="keyword">isset</span>(<span class="keyword">$this</span>-&gt;_binContainerngs[$name]))&#123;</div><div class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">$concrete = <span class="keyword">$this</span>-&gt;_binContainerngs[$name][<span class="string">'class'</span>];<span class="comment">//对象具体注册内容</span></div><div class="line"></div><div class="line">$obj = <span class="keyword">null</span>;</div><div class="line"></div><div class="line"><span class="keyword">if</span>($concrete <span class="keyword">instanceof</span> \Closure)&#123; <span class="comment">//匿名函数方式</span></div><div class="line">$obj = call_user_func_array($concrete,$params);</div><div class="line">&#125;<span class="keyword">elseif</span>(is_string($concrete))&#123; <span class="comment">//字符串方式</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($params))&#123;</div><div class="line">$obj = <span class="keyword">new</span> $concrete;</div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line"><span class="comment">//带参数的类实例化,使用反射</span></div><div class="line">$class = <span class="keyword">new</span> \reflectionClass($concrete);</div><div class="line">$obj = $class-&gt;newInstanceArgs($params);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">//如果是共享服务，则写入_instances列表，下次直接取回</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">$this</span>-&gt;_binContainerngs[$name][<span class="string">'shared'</span>]==<span class="keyword">true</span> &amp;&amp; $ojb)&#123;</div><div class="line"><span class="keyword">$this</span>-&gt;_instances[$name]=$obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">return</span> $obj;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<p>实际上通过分析get方法对这三种注入方式的数组都做了对应的处理</p>
<h1 id="匿名方式"><a href="#匿名方式" class="headerlink" title="匿名方式"></a>匿名方式</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$Container-&gt;setShared(<span class="string">'a1'</span>,<span class="function"><span class="keyword">function</span><span class="params">($name=<span class="string">""</span>)</span></span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> A($name);</div><div class="line">  &#125;);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>($concrete <span class="keyword">instanceof</span> \Closure)&#123; <span class="comment">//匿名函数方式</span></div><div class="line">$obj = call_user_func_array($concrete,$params);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>  首先通过<strong>$concrete instanceof \Closure</strong>来判断是否是匿名函数，然后通过<strong>call_user_func_array($concrete,$params)</strong>来调用这个函数，匿名方式注册的本身就是一个已经new的方法，自然get的时候就成功调用了这个已经实例化的方法。换句话说，匿名方式写的时候写的就是实例化的方法，容器的数组里面就存在了这个已经new的方法，只要判断是回调函数，就调用到了这个已经实例化的方法。</p>
<h1 id="类名方式注册"><a href="#类名方式注册" class="headerlink" title="类名方式注册"></a>类名方式注册</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$Container-&gt;set(<span class="string">'a2'</span>,<span class="string">'A'</span>);</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#125;<span class="keyword">elseif</span>(is_string($concrete))&#123; <span class="comment">//字符串方式</span></div><div class="line"><span class="keyword">if</span>(<span class="keyword">empty</span>($params))&#123;</div><div class="line">$obj = <span class="keyword">new</span> $concrete;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p> 直接以类名注册的方式比较简单，只要判断是字符串并且参数为空那么对应的get方法就会直接实例化（new）这个方法名，就比如上面的例子，直接就会实例化A这个方法名</p>
<h1 id="带参数的类实例化-使用反射-接口方式"><a href="#带参数的类实例化-使用反射-接口方式" class="headerlink" title="带参数的类实例化,使用反射(接口方式)"></a>带参数的类实例化,使用反射(接口方式)</h1><figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$Container-&gt;set(<span class="string">'a3'</span>,<span class="keyword">new</span> A(<span class="string">"小唐"</span>));</div></pre></td></tr></table></figure>
<figure class="highlight php"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//带参数的类实例化,使用反射</span></div><div class="line">$class = <span class="keyword">new</span> \reflectionClass($concrete);</div><div class="line">$obj = $class-&gt;newInstanceArgs($params);</div></pre></td></tr></table></figure>
<blockquote>
<p><strong>reflectionClass</strong>: ReflectionClass 类报告了一个类的有关信息。<br><strong>newInstanceArgs</strong>: ReflectionClass::newInstanceArgs — 从给出的参数创建一个新的类实例。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;先说结论，&lt;strong&gt;容器&lt;/strong&gt;在php中是一组健值对，php容器类通过数组来控制对象的生成,资源的获取,销毁和处理对象和对象的依赖关系。&lt;/p&gt;
&lt;h3 id=&quot;我是傲娇的代码块&quot;&gt;&lt;a href=&quot;#我是傲娇的代码块&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="php" scheme="http://graychen.git.io/tags/php/"/>
    
  </entry>
  
  <entry>
    <title>变身吧！我的linux配置环境</title>
    <link href="http://graychen.git.io/2016/10/18/%E5%8F%98%E8%BA%AB%E5%90%A7%EF%BC%81%E6%88%91%E7%9A%84linux%E9%85%8D%E7%BD%AE%E7%8E%AF%E5%A2%83/"/>
    <id>http://graychen.git.io/2016/10/18/变身吧！我的linux配置环境/</id>
    <published>2016-10-18T06:35:17.000Z</published>
    <updated>2017-05-26T04:22:03.690Z</updated>
    
    <content type="html"><![CDATA[<p> 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。</p>
<h1 id="先上效果图"><a href="#先上效果图" class="headerlink" title="先上效果图"></a>先上效果图</h1><p> <img src="/assets/blogImg/桌面带终端效果图.png" alt="&quot;我是傲娇的效果图&quot;"></p>
<h2 id="终端改造-Terminator"><a href="#终端改造-Terminator" class="headerlink" title="终端改造  Terminator"></a>终端改造  Terminator</h2><p>ubuntu自带的终端原本也不错，只是缺少分屏功能和强大的复制粘贴功能，所以就用Terminator来代替，其强大的分屏功能真是我的最爱了。</p>
<h3 id="安装方式"><a href="#安装方式" class="headerlink" title="安装方式"></a>安装方式</h3><p>sudo apt-get install terminator</p>
<h3 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h3><p>垂直分割窗口 <code>Ctrl+Shift+e</code><br>水平分割窗口 <code>Ctrl+Shift+o</code><br>复制         <code>Ctrl+Shift+c</code><br>粘贴         <code>Ctrl+Shift+v</code><br>切换窗口     <code>Ctrl+Shift+n</code><br>将分割的某个窗口放大至全屏使用         <code>Ctrl+Shift+x</code><br>从放大的某一窗口回到多窗口格局         <code>Ctrl+Shift+z</code><br> <img src="/assets/blogImg/多窗终端.png" alt="&quot;我是傲娇的效果图&quot;"></p>
<h3 id="终端主题"><a href="#终端主题" class="headerlink" title="终端主题"></a>终端主题</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">apt-get install zsh</div><div class="line">wget https://github.com/robbyrussell/oh-my-zsh/raw/master/tools/install.sh -O - | zsh</div><div class="line">chsh -s `which zsh`</div><div class="line">sudo shutdown -r 0</div></pre></td></tr></table></figure>
<p> 我用的主题是<code>ys</code></p>
<h3 id="桌面主题"><a href="#桌面主题" class="headerlink" title="桌面主题"></a>桌面主题</h3><p> 首先在这里<a href="https://github.com/anmoljagetia/Flatabulous/archive/master.zip" target="_blank" rel="external">下载</a>主题包，将文件解压后移动到<code>/usr/share/themes/</code>,接着安装图标:<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sudo add-apt-repository ppa:noobslab/icons</div><div class="line">sudo apt-get update</div><div class="line">sudo apt-get install ultra-flat-icons</div></pre></td></tr></table></figure></p>
<p> 然后需要<code>unity-tweak-tool</code><br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install unity-tweak-tool</div><div class="line">sudo unity-tweak-tool</div></pre></td></tr></table></figure></p>
<p>在Themes和icons下分别选择刚刚的主题和图标，大功告成！</p>
<p> <img src="/assets/blogImg/选择主题.png" alt="&quot;我是傲娇的效果图&quot;"></p>
<p>完成后的样子<br> <img src="/assets/blogImg/桌面效果图.png" alt="&quot;我是傲娇的效果图&quot;"></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt; 我用的linux是ubuntu16长期支持版，自带的桌面太丑，自带的终端一直没有分屏功能，所以我就开始了改造工作。&lt;/p&gt;
&lt;h1 id=&quot;先上效果图&quot;&gt;&lt;a href=&quot;#先上效果图&quot; class=&quot;headerlink&quot; title=&quot;先上效果图&quot;&gt;&lt;/a&gt;先上效果图
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="linux" scheme="http://graychen.git.io/tags/linux/"/>
    
  </entry>
  
  <entry>
    <title>vichrome像vi一样操作你的chrome浏览器</title>
    <link href="http://graychen.git.io/2016/10/18/vichrome%E5%83%8Fvi%E4%B8%80%E6%A0%B7%E6%93%8D%E4%BD%9C%E4%BD%A0%E7%9A%84chrome%E6%B5%8F%E8%A7%88%E5%99%A8/"/>
    <id>http://graychen.git.io/2016/10/18/vichrome像vi一样操作你的chrome浏览器/</id>
    <published>2016-10-18T01:24:53.000Z</published>
    <updated>2017-05-26T04:22:03.690Z</updated>
    
    <content type="html"><![CDATA[<p><strong>vichrome</strong>是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。<br>下面是它的操作命令：</p>
<h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><ul>
<li>k 上移 </li>
<li>j 下移 </li>
<li>H 后退 </li>
<li>L 前进</li>
<li>gg 飞到顶部 </li>
<li>G 掉到底部 </li>
<li>gt 去下一个标签 (ctrl+l) </li>
<li>gT 去上一个标签 (ctrl+h)</li>
<li>t 新开一个标签 </li>
<li>x 关闭当前标签页 </li>
<li>X 关闭当前标签页并跳到下一个标签页  </li>
<li>u 恢复刚刚的标签页 </li>
<li>r 刷新 </li>
<li>f 进入f模式(可以点击链接) </li>
<li>F 在新标签中进入f模式 </li>
<li>i 聚焦在第一个输入框</li>
<li>esc 退出<h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2></li>
<li>ctrl+f 下一页</li>
<li>ctrl+b 上一页</li>
<li>ctrl+d 下半页</li>
<li>ctrl+u 上半页</li>
<li>/ 搜索</li>
<li>? 反向搜索</li>
<li>a 在带链接的文本中搜索</li>
<li>n 下一个搜索结果</li>
<li>N 上一个搜索结果</li>
<li>tab 下一个候补选项</li>
<li>shift+tab 上一个候补选项</li>
<li>: 进入命令模式</li>
<li>yy 复制url</li>
<li>p/P 打开刚刚复制的url</li>
<li>o/O 打开(输入url)</li>
<li>s/S 用搜索引擎搜索</li>
<li>b/B 打开收藏夹<h2 id="高级篇"><a href="#高级篇" class="headerlink" title="高级篇"></a>高级篇</h2></li>
<li>gp 新开一个窗口(对当前标签页)</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;strong&gt;vichrome&lt;/strong&gt;是一款chrome浏览器的插件,它让你可以像vi一样使用命令来操作你的浏览器，是提高效率的利器。&lt;br&gt;下面是它的操作命令：&lt;/p&gt;
&lt;h2 id=&quot;基础篇&quot;&gt;&lt;a href=&quot;#基础篇&quot; class=&quot;headerlink
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="工具" scheme="http://graychen.git.io/tags/%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>vi的使用总结</title>
    <link href="http://graychen.git.io/2016/09/21/vi%E7%9A%84%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://graychen.git.io/2016/09/21/vi的使用总结/</id>
    <published>2016-09-21T14:15:36.000Z</published>
    <updated>2017-05-26T04:22:03.690Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初级篇"><a href="#初级篇" class="headerlink" title="初级篇"></a>初级篇</h1><h2 id="移动篇"><a href="#移动篇" class="headerlink" title="移动篇"></a>移动篇</h2><ul>
<li>上 k</li>
<li>下 j</li>
<li>左 h</li>
<li><p>右 l</p>
</li>
<li><p>至顶 gg</p>
</li>
<li>至尾部 Shift+g</li>
<li><p>行跳转 行号+gg</p>
</li>
<li><p>行首 Shift+6 (^)</p>
</li>
<li><p>行尾 Shift+4 ($) </p>
</li>
<li><p>词组移动(词首) w </p>
</li>
<li>词组移动(词首) W </li>
<li>词组移动(词尾) e </li>
<li><p>词组移动(词尾) E </p>
</li>
<li><p>移动到查找的字母后 f</p>
</li>
<li>移动到查找的字母后 F</li>
</ul>
<h2 id="操作篇"><a href="#操作篇" class="headerlink" title="操作篇"></a>操作篇</h2><h3 id="增"><a href="#增" class="headerlink" title="增"></a>增</h3><ul>
<li>在单词前插入 i</li>
<li>在单词前插入 a</li>
<li>在句首前插入 I</li>
<li>在句尾插入 A</li>
<li>在下一行插入 o</li>
<li>在上一行插入 O<h3 id="删"><a href="#删" class="headerlink" title="删"></a>删</h3></li>
<li>删除光标行内容 d</li>
<li>删除光标至尾行内容 D</li>
<li>删除当前行及n-1行数 数字dd<h3 id="改"><a href="#改" class="headerlink" title="改"></a>改</h3></li>
<li>复制 yy</li>
<li>粘贴 p</li>
<li>替换插入 s</li>
<li>替换整句插入 S</li>
<li>替换单个字母 r</li>
<li>接下来的子都要替换 R</li>
<li>当前行替换第一个单词 :s/oldwords/newwords/</li>
<li>替换当前行所有单词 :s/oldwords/newwords/g</li>
<li>替换每一行的第一个单词 :%s/oldwords/newwords/</li>
<li>替换每一行的单词 :%s/oldwords/newwords/g</li>
</ul>
<h3 id="查"><a href="#查" class="headerlink" title="查"></a>查</h3><ul>
<li>向后查找 /</li>
<li>向前查找 ?</li>
</ul>
<h2 id="选中篇"><a href="#选中篇" class="headerlink" title="选中篇"></a>选中篇</h2><ul>
<li>左选择 v+h</li>
<li>右选择 v+l</li>
<li>上选择 v+k</li>
<li><p>下选择 v+j</p>
</li>
<li><p>选择当前行V(shift+v) </p>
</li>
<li>选择向上行V+k(shift+v) </li>
<li><p>选择向下行V+j(shift+v) </p>
</li>
<li><p>括号内的选择 v+i+) (不含括号)</p>
</li>
<li><p>括号内的选择 v+a+) (包含括号)</p>
</li>
<li><p>居中显示 zz </p>
</li>
<li>头部显示 zt </li>
<li>尾巴显示 zb <h2 id="退出篇"><a href="#退出篇" class="headerlink" title="退出篇"></a>退出篇</h2></li>
<li>不保存退出 :q </li>
<li>保存退出 :wq </li>
<li>保存 :w </li>
<li>强制退出 :q! </li>
<li>强制退出 ctrl+z </li>
<li>恢复 fg<h2 id="文件切换篇"><a href="#文件切换篇" class="headerlink" title="文件切换篇"></a>文件切换篇</h2></li>
<li>向右切换 tg</li>
<li>向左切换 tG</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初级篇&quot;&gt;&lt;a href=&quot;#初级篇&quot; class=&quot;headerlink&quot; title=&quot;初级篇&quot;&gt;&lt;/a&gt;初级篇&lt;/h1&gt;&lt;h2 id=&quot;移动篇&quot;&gt;&lt;a href=&quot;#移动篇&quot; class=&quot;headerlink&quot; title=&quot;移动篇&quot;&gt;&lt;/a&gt;移动篇&lt;/h
    
    </summary>
    
      <category term="技术" scheme="http://graychen.git.io/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="编辑器" scheme="http://graychen.git.io/tags/%E7%BC%96%E8%BE%91%E5%99%A8/"/>
    
  </entry>
  
</feed>
